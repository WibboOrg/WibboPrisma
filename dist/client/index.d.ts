
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Ban
 * 
 */
export type Ban = $Result.DefaultSelection<Prisma.$BanPayload>
/**
 * Model BotPet
 * 
 */
export type BotPet = $Result.DefaultSelection<Prisma.$BotPetPayload>
/**
 * Model BotUser
 * 
 */
export type BotUser = $Result.DefaultSelection<Prisma.$BotUserPayload>
/**
 * Model CatalogBotPreset
 * 
 */
export type CatalogBotPreset = $Result.DefaultSelection<Prisma.$CatalogBotPresetPayload>
/**
 * Model CatalogItem
 * 
 */
export type CatalogItem = $Result.DefaultSelection<Prisma.$CatalogItemPayload>
/**
 * Model CatalogItemLimited
 * 
 */
export type CatalogItemLimited = $Result.DefaultSelection<Prisma.$CatalogItemLimitedPayload>
/**
 * Model CatalogMarketplaceData
 * 
 */
export type CatalogMarketplaceData = $Result.DefaultSelection<Prisma.$CatalogMarketplaceDataPayload>
/**
 * Model CatalogMarketplaceOffer
 * 
 */
export type CatalogMarketplaceOffer = $Result.DefaultSelection<Prisma.$CatalogMarketplaceOfferPayload>
/**
 * Model CatalogPage
 * 
 */
export type CatalogPage = $Result.DefaultSelection<Prisma.$CatalogPagePayload>
/**
 * Model CatalogPageLangue
 * 
 */
export type CatalogPageLangue = $Result.DefaultSelection<Prisma.$CatalogPageLanguePayload>
/**
 * Model CatalogPetRace
 * 
 */
export type CatalogPetRace = $Result.DefaultSelection<Prisma.$CatalogPetRacePayload>
/**
 * Model CatalogPromotion
 * 
 */
export type CatalogPromotion = $Result.DefaultSelection<Prisma.$CatalogPromotionPayload>
/**
 * Model CatalogVoucher
 * 
 */
export type CatalogVoucher = $Result.DefaultSelection<Prisma.$CatalogVoucherPayload>
/**
 * Model CmsForumPost
 * 
 */
export type CmsForumPost = $Result.DefaultSelection<Prisma.$CmsForumPostPayload>
/**
 * Model CmsForumThread
 * 
 */
export type CmsForumThread = $Result.DefaultSelection<Prisma.$CmsForumThreadPayload>
/**
 * Model CmsFourmCategory
 * 
 */
export type CmsFourmCategory = $Result.DefaultSelection<Prisma.$CmsFourmCategoryPayload>
/**
 * Model CmsMailConfirm
 * 
 */
export type CmsMailConfirm = $Result.DefaultSelection<Prisma.$CmsMailConfirmPayload>
/**
 * Model CmsMailForgot
 * 
 */
export type CmsMailForgot = $Result.DefaultSelection<Prisma.$CmsMailForgotPayload>
/**
 * Model CmsNews
 * 
 */
export type CmsNews = $Result.DefaultSelection<Prisma.$CmsNewsPayload>
/**
 * Model CmsStaff
 * 
 */
export type CmsStaff = $Result.DefaultSelection<Prisma.$CmsStaffPayload>
/**
 * Model CmsStaffProtect
 * 
 */
export type CmsStaffProtect = $Result.DefaultSelection<Prisma.$CmsStaffProtectPayload>
/**
 * Model EmulatorAchievement
 * 
 */
export type EmulatorAchievement = $Result.DefaultSelection<Prisma.$EmulatorAchievementPayload>
/**
 * Model EmulatorBanner
 * 
 */
export type EmulatorBanner = $Result.DefaultSelection<Prisma.$EmulatorBannerPayload>
/**
 * Model EmulatorChatStyle
 * 
 */
export type EmulatorChatStyle = $Result.DefaultSelection<Prisma.$EmulatorChatStylePayload>
/**
 * Model EmulatorCommand
 * 
 */
export type EmulatorCommand = $Result.DefaultSelection<Prisma.$EmulatorCommandPayload>
/**
 * Model EmulatorCommandPet
 * 
 */
export type EmulatorCommandPet = $Result.DefaultSelection<Prisma.$EmulatorCommandPetPayload>
/**
 * Model EmulatorEffect
 * 
 */
export type EmulatorEffect = $Result.DefaultSelection<Prisma.$EmulatorEffectPayload>
/**
 * Model EmulatorLandingview
 * 
 */
export type EmulatorLandingview = $Result.DefaultSelection<Prisma.$EmulatorLandingviewPayload>
/**
 * Model EmulatorLootbox
 * 
 */
export type EmulatorLootbox = $Result.DefaultSelection<Prisma.$EmulatorLootboxPayload>
/**
 * Model EmulatorPermission
 * 
 */
export type EmulatorPermission = $Result.DefaultSelection<Prisma.$EmulatorPermissionPayload>
/**
 * Model EmulatorQuest
 * 
 */
export type EmulatorQuest = $Result.DefaultSelection<Prisma.$EmulatorQuestPayload>
/**
 * Model EmulatorSetting
 * 
 */
export type EmulatorSetting = $Result.DefaultSelection<Prisma.$EmulatorSettingPayload>
/**
 * Model EmulatorStats
 * 
 */
export type EmulatorStats = $Result.DefaultSelection<Prisma.$EmulatorStatsPayload>
/**
 * Model EmulatorStatus
 * 
 */
export type EmulatorStatus = $Result.DefaultSelection<Prisma.$EmulatorStatusPayload>
/**
 * Model EmulatorText
 * 
 */
export type EmulatorText = $Result.DefaultSelection<Prisma.$EmulatorTextPayload>
/**
 * Model Guild
 * 
 */
export type Guild = $Result.DefaultSelection<Prisma.$GuildPayload>
/**
 * Model GuildItem
 * 
 */
export type GuildItem = $Result.DefaultSelection<Prisma.$GuildItemPayload>
/**
 * Model GuildMembership
 * 
 */
export type GuildMembership = $Result.DefaultSelection<Prisma.$GuildMembershipPayload>
/**
 * Model GuildRequest
 * 
 */
export type GuildRequest = $Result.DefaultSelection<Prisma.$GuildRequestPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model ItemBase
 * 
 */
export type ItemBase = $Result.DefaultSelection<Prisma.$ItemBasePayload>
/**
 * Model ItemLimited
 * 
 */
export type ItemLimited = $Result.DefaultSelection<Prisma.$ItemLimitedPayload>
/**
 * Model ItemMoodlight
 * 
 */
export type ItemMoodlight = $Result.DefaultSelection<Prisma.$ItemMoodlightPayload>
/**
 * Model ItemPresent
 * 
 */
export type ItemPresent = $Result.DefaultSelection<Prisma.$ItemPresentPayload>
/**
 * Model ItemStat
 * 
 */
export type ItemStat = $Result.DefaultSelection<Prisma.$ItemStatPayload>
/**
 * Model ItemTeleport
 * 
 */
export type ItemTeleport = $Result.DefaultSelection<Prisma.$ItemTeleportPayload>
/**
 * Model ItemWired
 * 
 */
export type ItemWired = $Result.DefaultSelection<Prisma.$ItemWiredPayload>
/**
 * Model LogChat
 * 
 */
export type LogChat = $Result.DefaultSelection<Prisma.$LogChatPayload>
/**
 * Model LogChatPub
 * 
 */
export type LogChatPub = $Result.DefaultSelection<Prisma.$LogChatPubPayload>
/**
 * Model LogCommand
 * 
 */
export type LogCommand = $Result.DefaultSelection<Prisma.$LogCommandPayload>
/**
 * Model LogFlagme
 * 
 */
export type LogFlagme = $Result.DefaultSelection<Prisma.$LogFlagmePayload>
/**
 * Model LogLogin
 * 
 */
export type LogLogin = $Result.DefaultSelection<Prisma.$LogLoginPayload>
/**
 * Model LogLootbox
 * 
 */
export type LogLootbox = $Result.DefaultSelection<Prisma.$LogLootboxPayload>
/**
 * Model LogPayment
 * 
 */
export type LogPayment = $Result.DefaultSelection<Prisma.$LogPaymentPayload>
/**
 * Model LogShop
 * 
 */
export type LogShop = $Result.DefaultSelection<Prisma.$LogShopPayload>
/**
 * Model LogSlotmachine
 * 
 */
export type LogSlotmachine = $Result.DefaultSelection<Prisma.$LogSlotmachinePayload>
/**
 * Model LogStaff
 * 
 */
export type LogStaff = $Result.DefaultSelection<Prisma.$LogStaffPayload>
/**
 * Model LogTrade
 * 
 */
export type LogTrade = $Result.DefaultSelection<Prisma.$LogTradePayload>
/**
 * Model LogVpn
 * 
 */
export type LogVpn = $Result.DefaultSelection<Prisma.$LogVpnPayload>
/**
 * Model LogSandbox
 * 
 */
export type LogSandbox = $Result.DefaultSelection<Prisma.$LogSandboxPayload>
/**
 * Model MessengerFriendship
 * 
 */
export type MessengerFriendship = $Result.DefaultSelection<Prisma.$MessengerFriendshipPayload>
/**
 * Model MessengerOfflineMessage
 * 
 */
export type MessengerOfflineMessage = $Result.DefaultSelection<Prisma.$MessengerOfflineMessagePayload>
/**
 * Model MessengerRequest
 * 
 */
export type MessengerRequest = $Result.DefaultSelection<Prisma.$MessengerRequestPayload>
/**
 * Model ModerationPreset
 * 
 */
export type ModerationPreset = $Result.DefaultSelection<Prisma.$ModerationPresetPayload>
/**
 * Model ModerationResolution
 * 
 */
export type ModerationResolution = $Result.DefaultSelection<Prisma.$ModerationResolutionPayload>
/**
 * Model ModerationTicket
 * 
 */
export type ModerationTicket = $Result.DefaultSelection<Prisma.$ModerationTicketPayload>
/**
 * Model ModerationTopic
 * 
 */
export type ModerationTopic = $Result.DefaultSelection<Prisma.$ModerationTopicPayload>
/**
 * Model ModerationTopicAction
 * 
 */
export type ModerationTopicAction = $Result.DefaultSelection<Prisma.$ModerationTopicActionPayload>
/**
 * Model NavigatorCategory
 * 
 */
export type NavigatorCategory = $Result.DefaultSelection<Prisma.$NavigatorCategoryPayload>
/**
 * Model NavigatorPublic
 * 
 */
export type NavigatorPublic = $Result.DefaultSelection<Prisma.$NavigatorPublicPayload>
/**
 * Model Roleplay
 * 
 */
export type Roleplay = $Result.DefaultSelection<Prisma.$RoleplayPayload>
/**
 * Model RoleplayEnemy
 * 
 */
export type RoleplayEnemy = $Result.DefaultSelection<Prisma.$RoleplayEnemyPayload>
/**
 * Model RoleplayItem
 * 
 */
export type RoleplayItem = $Result.DefaultSelection<Prisma.$RoleplayItemPayload>
/**
 * Model RoleplayWeapon
 * 
 */
export type RoleplayWeapon = $Result.DefaultSelection<Prisma.$RoleplayWeaponPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomModel
 * 
 */
export type RoomModel = $Result.DefaultSelection<Prisma.$RoomModelPayload>
/**
 * Model RoomModelCustom
 * 
 */
export type RoomModelCustom = $Result.DefaultSelection<Prisma.$RoomModelCustomPayload>
/**
 * Model RoomRight
 * 
 */
export type RoomRight = $Result.DefaultSelection<Prisma.$RoomRightPayload>
/**
 * Model RoomSwearwordFilter
 * 
 */
export type RoomSwearwordFilter = $Result.DefaultSelection<Prisma.$RoomSwearwordFilterPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model UserBanner
 * 
 */
export type UserBanner = $Result.DefaultSelection<Prisma.$UserBannerPayload>
/**
 * Model UserPhoto
 * 
 */
export type UserPhoto = $Result.DefaultSelection<Prisma.$UserPhotoPayload>
/**
 * Model UserPremium
 * 
 */
export type UserPremium = $Result.DefaultSelection<Prisma.$UserPremiumPayload>
/**
 * Model UserQuest
 * 
 */
export type UserQuest = $Result.DefaultSelection<Prisma.$UserQuestPayload>
/**
 * Model UserRoleplay
 * 
 */
export type UserRoleplay = $Result.DefaultSelection<Prisma.$UserRoleplayPayload>
/**
 * Model UserRoleplayItem
 * 
 */
export type UserRoleplayItem = $Result.DefaultSelection<Prisma.$UserRoleplayItemPayload>
/**
 * Model UserStats
 * 
 */
export type UserStats = $Result.DefaultSelection<Prisma.$UserStatsPayload>
/**
 * Model UserWardrobe
 * 
 */
export type UserWardrobe = $Result.DefaultSelection<Prisma.$UserWardrobePayload>
/**
 * Model WordFilterRetro
 * 
 */
export type WordFilterRetro = $Result.DefaultSelection<Prisma.$WordFilterRetroPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BanBantype: {
  user: 'user',
  ip: 'ip',
  machine: 'machine',
  ignoreall: 'ignoreall'
};

export type BanBantype = (typeof BanBantype)[keyof typeof BanBantype]


export const BotUserAiType: {
  generic: 'generic',
  bartender: 'bartender',
  chatgpt: 'chatgpt'
};

export type BotUserAiType = (typeof BotUserAiType)[keyof typeof BotUserAiType]


export const CatalogBotPresetAiType: {
  pet: 'pet',
  generic: 'generic',
  bartender: 'bartender'
};

export type CatalogBotPresetAiType = (typeof CatalogBotPresetAiType)[keyof typeof CatalogBotPresetAiType]


export const CatalogVoucherType: {
  credits: 'credits',
  duckets: 'duckets'
};

export type CatalogVoucherType = (typeof CatalogVoucherType)[keyof typeof CatalogVoucherType]


export const EmulatorLootboxCategory: {
  furni: 'furni',
  badge: 'badge',
  winwin: 'winwin',
  credits: 'credits'
};

export type EmulatorLootboxCategory = (typeof EmulatorLootboxCategory)[keyof typeof EmulatorLootboxCategory]


export const GuildItemType: {
  base: 'base',
  symbol: 'symbol',
  color: 'color',
  color2: 'color2',
  color3: 'color3'
};

export type GuildItemType = (typeof GuildItemType)[keyof typeof GuildItemType]


export const ItemBaseType: {
  s: 's',
  i: 'i',
  r: 'r',
  b: 'b',
  p: 'p',
  c: 'c'
};

export type ItemBaseType = (typeof ItemBaseType)[keyof typeof ItemBaseType]


export const ModerationPresetType: {
  message: 'message',
  roommessage: 'roommessage'
};

export type ModerationPresetType = (typeof ModerationPresetType)[keyof typeof ModerationPresetType]


export const ModerationResolutionType: {
  Sexual: 'Sexual',
  PII: 'PII'
};

export type ModerationResolutionType = (typeof ModerationResolutionType)[keyof typeof ModerationResolutionType]


export const ModerationTicketStatus: {
  open: 'open',
  picked: 'picked',
  resolved: 'resolved',
  abusive: 'abusive',
  invalid: 'invalid',
  deleted: 'deleted'
};

export type ModerationTicketStatus = (typeof ModerationTicketStatus)[keyof typeof ModerationTicketStatus]


export const NavigatorCategoryCategory: {
  official_view: 'official_view',
  hotel_view: 'hotel_view',
  myworld_view: 'myworld_view',
  roomads_view: 'roomads_view',
  query: 'query',
  rooms_game: 'rooms_game'
};

export type NavigatorCategoryCategory = (typeof NavigatorCategoryCategory)[keyof typeof NavigatorCategoryCategory]


export const NavigatorCategoryViewMode: {
  REGULAR: 'REGULAR',
  THUMBNAIL: 'THUMBNAIL'
};

export type NavigatorCategoryViewMode = (typeof NavigatorCategoryViewMode)[keyof typeof NavigatorCategoryViewMode]


export const NavigatorCategorySearchAllowance: {
  NOTHING: 'NOTHING',
  SHOW_MORE: 'SHOW_MORE'
};

export type NavigatorCategorySearchAllowance = (typeof NavigatorCategorySearchAllowance)[keyof typeof NavigatorCategorySearchAllowance]


export const NavigatorPublicLangue: {
  fr: 'fr',
  en: 'en',
  br: 'br'
};

export type NavigatorPublicLangue = (typeof NavigatorPublicLangue)[keyof typeof NavigatorPublicLangue]


export const RoleplayEnemyType: {
  bot: 'bot',
  pet: 'pet'
};

export type RoleplayEnemyType = (typeof RoleplayEnemyType)[keyof typeof RoleplayEnemyType]


export const RoleplayItemType: {
  munition: 'munition',
  health: 'health',
  energy: 'energy',
  weapon_cac: 'weapon_cac',
  weapon_far: 'weapon_far',
  none: 'none',
  money: 'money',
  healthenergy: 'healthenergy',
  healthtired: 'healthtired',
  showtime: 'showtime',
  enable: 'enable',
  hit: 'hit',
  openguide: 'openguide',
  energytired: 'energytired',
  openpage: 'openpage'
};

export type RoleplayItemType = (typeof RoleplayItemType)[keyof typeof RoleplayItemType]


export const RoleplayItemCategory: {
  EQUIP: 'EQUIP',
  UTIL: 'UTIL',
  RESSOURCE: 'RESSOURCE',
  QUETE: 'QUETE'
};

export type RoleplayItemCategory = (typeof RoleplayItemCategory)[keyof typeof RoleplayItemCategory]


export const RoleplayWeaponType: {
  cac: 'cac',
  far: 'far'
};

export type RoleplayWeaponType = (typeof RoleplayWeaponType)[keyof typeof RoleplayWeaponType]


export const RoleplayWeaponInteraction: {
  none: 'none'
};

export type RoleplayWeaponInteraction = (typeof RoleplayWeaponInteraction)[keyof typeof RoleplayWeaponInteraction]


export const RoomState: {
  open: 'open',
  locked: 'locked',
  password: 'password',
  hide: 'hide'
};

export type RoomState = (typeof RoomState)[keyof typeof RoomState]


export const UserGender: {
  M: 'M',
  F: 'F'
};

export type UserGender = (typeof UserGender)[keyof typeof UserGender]


export const UserLangue: {
  fr: 'fr',
  en: 'en',
  br: 'br'
};

export type UserLangue = (typeof UserLangue)[keyof typeof UserLangue]


export const UserWardrobeGender: {
  F: 'F',
  M: 'M'
};

export type UserWardrobeGender = (typeof UserWardrobeGender)[keyof typeof UserWardrobeGender]

}

export type BanBantype = $Enums.BanBantype

export const BanBantype: typeof $Enums.BanBantype

export type BotUserAiType = $Enums.BotUserAiType

export const BotUserAiType: typeof $Enums.BotUserAiType

export type CatalogBotPresetAiType = $Enums.CatalogBotPresetAiType

export const CatalogBotPresetAiType: typeof $Enums.CatalogBotPresetAiType

export type CatalogVoucherType = $Enums.CatalogVoucherType

export const CatalogVoucherType: typeof $Enums.CatalogVoucherType

export type EmulatorLootboxCategory = $Enums.EmulatorLootboxCategory

export const EmulatorLootboxCategory: typeof $Enums.EmulatorLootboxCategory

export type GuildItemType = $Enums.GuildItemType

export const GuildItemType: typeof $Enums.GuildItemType

export type ItemBaseType = $Enums.ItemBaseType

export const ItemBaseType: typeof $Enums.ItemBaseType

export type ModerationPresetType = $Enums.ModerationPresetType

export const ModerationPresetType: typeof $Enums.ModerationPresetType

export type ModerationResolutionType = $Enums.ModerationResolutionType

export const ModerationResolutionType: typeof $Enums.ModerationResolutionType

export type ModerationTicketStatus = $Enums.ModerationTicketStatus

export const ModerationTicketStatus: typeof $Enums.ModerationTicketStatus

export type NavigatorCategoryCategory = $Enums.NavigatorCategoryCategory

export const NavigatorCategoryCategory: typeof $Enums.NavigatorCategoryCategory

export type NavigatorCategoryViewMode = $Enums.NavigatorCategoryViewMode

export const NavigatorCategoryViewMode: typeof $Enums.NavigatorCategoryViewMode

export type NavigatorCategorySearchAllowance = $Enums.NavigatorCategorySearchAllowance

export const NavigatorCategorySearchAllowance: typeof $Enums.NavigatorCategorySearchAllowance

export type NavigatorPublicLangue = $Enums.NavigatorPublicLangue

export const NavigatorPublicLangue: typeof $Enums.NavigatorPublicLangue

export type RoleplayEnemyType = $Enums.RoleplayEnemyType

export const RoleplayEnemyType: typeof $Enums.RoleplayEnemyType

export type RoleplayItemType = $Enums.RoleplayItemType

export const RoleplayItemType: typeof $Enums.RoleplayItemType

export type RoleplayItemCategory = $Enums.RoleplayItemCategory

export const RoleplayItemCategory: typeof $Enums.RoleplayItemCategory

export type RoleplayWeaponType = $Enums.RoleplayWeaponType

export const RoleplayWeaponType: typeof $Enums.RoleplayWeaponType

export type RoleplayWeaponInteraction = $Enums.RoleplayWeaponInteraction

export const RoleplayWeaponInteraction: typeof $Enums.RoleplayWeaponInteraction

export type RoomState = $Enums.RoomState

export const RoomState: typeof $Enums.RoomState

export type UserGender = $Enums.UserGender

export const UserGender: typeof $Enums.UserGender

export type UserLangue = $Enums.UserLangue

export const UserLangue: typeof $Enums.UserLangue

export type UserWardrobeGender = $Enums.UserWardrobeGender

export const UserWardrobeGender: typeof $Enums.UserWardrobeGender

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bans
 * const bans = await prisma.ban.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bans
   * const bans = await prisma.ban.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.ban`: Exposes CRUD operations for the **Ban** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bans
    * const bans = await prisma.ban.findMany()
    * ```
    */
  get ban(): Prisma.BanDelegate<ExtArgs>;

  /**
   * `prisma.botPet`: Exposes CRUD operations for the **BotPet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotPets
    * const botPets = await prisma.botPet.findMany()
    * ```
    */
  get botPet(): Prisma.BotPetDelegate<ExtArgs>;

  /**
   * `prisma.botUser`: Exposes CRUD operations for the **BotUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotUsers
    * const botUsers = await prisma.botUser.findMany()
    * ```
    */
  get botUser(): Prisma.BotUserDelegate<ExtArgs>;

  /**
   * `prisma.catalogBotPreset`: Exposes CRUD operations for the **CatalogBotPreset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogBotPresets
    * const catalogBotPresets = await prisma.catalogBotPreset.findMany()
    * ```
    */
  get catalogBotPreset(): Prisma.CatalogBotPresetDelegate<ExtArgs>;

  /**
   * `prisma.catalogItem`: Exposes CRUD operations for the **CatalogItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogItems
    * const catalogItems = await prisma.catalogItem.findMany()
    * ```
    */
  get catalogItem(): Prisma.CatalogItemDelegate<ExtArgs>;

  /**
   * `prisma.catalogItemLimited`: Exposes CRUD operations for the **CatalogItemLimited** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogItemLimiteds
    * const catalogItemLimiteds = await prisma.catalogItemLimited.findMany()
    * ```
    */
  get catalogItemLimited(): Prisma.CatalogItemLimitedDelegate<ExtArgs>;

  /**
   * `prisma.catalogMarketplaceData`: Exposes CRUD operations for the **CatalogMarketplaceData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogMarketplaceData
    * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findMany()
    * ```
    */
  get catalogMarketplaceData(): Prisma.CatalogMarketplaceDataDelegate<ExtArgs>;

  /**
   * `prisma.catalogMarketplaceOffer`: Exposes CRUD operations for the **CatalogMarketplaceOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogMarketplaceOffers
    * const catalogMarketplaceOffers = await prisma.catalogMarketplaceOffer.findMany()
    * ```
    */
  get catalogMarketplaceOffer(): Prisma.CatalogMarketplaceOfferDelegate<ExtArgs>;

  /**
   * `prisma.catalogPage`: Exposes CRUD operations for the **CatalogPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogPages
    * const catalogPages = await prisma.catalogPage.findMany()
    * ```
    */
  get catalogPage(): Prisma.CatalogPageDelegate<ExtArgs>;

  /**
   * `prisma.catalogPageLangue`: Exposes CRUD operations for the **CatalogPageLangue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogPageLangues
    * const catalogPageLangues = await prisma.catalogPageLangue.findMany()
    * ```
    */
  get catalogPageLangue(): Prisma.CatalogPageLangueDelegate<ExtArgs>;

  /**
   * `prisma.catalogPetRace`: Exposes CRUD operations for the **CatalogPetRace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogPetRaces
    * const catalogPetRaces = await prisma.catalogPetRace.findMany()
    * ```
    */
  get catalogPetRace(): Prisma.CatalogPetRaceDelegate<ExtArgs>;

  /**
   * `prisma.catalogPromotion`: Exposes CRUD operations for the **CatalogPromotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogPromotions
    * const catalogPromotions = await prisma.catalogPromotion.findMany()
    * ```
    */
  get catalogPromotion(): Prisma.CatalogPromotionDelegate<ExtArgs>;

  /**
   * `prisma.catalogVoucher`: Exposes CRUD operations for the **CatalogVoucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogVouchers
    * const catalogVouchers = await prisma.catalogVoucher.findMany()
    * ```
    */
  get catalogVoucher(): Prisma.CatalogVoucherDelegate<ExtArgs>;

  /**
   * `prisma.cmsForumPost`: Exposes CRUD operations for the **CmsForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsForumPosts
    * const cmsForumPosts = await prisma.cmsForumPost.findMany()
    * ```
    */
  get cmsForumPost(): Prisma.CmsForumPostDelegate<ExtArgs>;

  /**
   * `prisma.cmsForumThread`: Exposes CRUD operations for the **CmsForumThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsForumThreads
    * const cmsForumThreads = await prisma.cmsForumThread.findMany()
    * ```
    */
  get cmsForumThread(): Prisma.CmsForumThreadDelegate<ExtArgs>;

  /**
   * `prisma.cmsFourmCategory`: Exposes CRUD operations for the **CmsFourmCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsFourmCategories
    * const cmsFourmCategories = await prisma.cmsFourmCategory.findMany()
    * ```
    */
  get cmsFourmCategory(): Prisma.CmsFourmCategoryDelegate<ExtArgs>;

  /**
   * `prisma.cmsMailConfirm`: Exposes CRUD operations for the **CmsMailConfirm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsMailConfirms
    * const cmsMailConfirms = await prisma.cmsMailConfirm.findMany()
    * ```
    */
  get cmsMailConfirm(): Prisma.CmsMailConfirmDelegate<ExtArgs>;

  /**
   * `prisma.cmsMailForgot`: Exposes CRUD operations for the **CmsMailForgot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsMailForgots
    * const cmsMailForgots = await prisma.cmsMailForgot.findMany()
    * ```
    */
  get cmsMailForgot(): Prisma.CmsMailForgotDelegate<ExtArgs>;

  /**
   * `prisma.cmsNews`: Exposes CRUD operations for the **CmsNews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsNews
    * const cmsNews = await prisma.cmsNews.findMany()
    * ```
    */
  get cmsNews(): Prisma.CmsNewsDelegate<ExtArgs>;

  /**
   * `prisma.cmsStaff`: Exposes CRUD operations for the **CmsStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsStaffs
    * const cmsStaffs = await prisma.cmsStaff.findMany()
    * ```
    */
  get cmsStaff(): Prisma.CmsStaffDelegate<ExtArgs>;

  /**
   * `prisma.cmsStaffProtect`: Exposes CRUD operations for the **CmsStaffProtect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CmsStaffProtects
    * const cmsStaffProtects = await prisma.cmsStaffProtect.findMany()
    * ```
    */
  get cmsStaffProtect(): Prisma.CmsStaffProtectDelegate<ExtArgs>;

  /**
   * `prisma.emulatorAchievement`: Exposes CRUD operations for the **EmulatorAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorAchievements
    * const emulatorAchievements = await prisma.emulatorAchievement.findMany()
    * ```
    */
  get emulatorAchievement(): Prisma.EmulatorAchievementDelegate<ExtArgs>;

  /**
   * `prisma.emulatorBanner`: Exposes CRUD operations for the **EmulatorBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorBanners
    * const emulatorBanners = await prisma.emulatorBanner.findMany()
    * ```
    */
  get emulatorBanner(): Prisma.EmulatorBannerDelegate<ExtArgs>;

  /**
   * `prisma.emulatorChatStyle`: Exposes CRUD operations for the **EmulatorChatStyle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorChatStyles
    * const emulatorChatStyles = await prisma.emulatorChatStyle.findMany()
    * ```
    */
  get emulatorChatStyle(): Prisma.EmulatorChatStyleDelegate<ExtArgs>;

  /**
   * `prisma.emulatorCommand`: Exposes CRUD operations for the **EmulatorCommand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorCommands
    * const emulatorCommands = await prisma.emulatorCommand.findMany()
    * ```
    */
  get emulatorCommand(): Prisma.EmulatorCommandDelegate<ExtArgs>;

  /**
   * `prisma.emulatorCommandPet`: Exposes CRUD operations for the **EmulatorCommandPet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorCommandPets
    * const emulatorCommandPets = await prisma.emulatorCommandPet.findMany()
    * ```
    */
  get emulatorCommandPet(): Prisma.EmulatorCommandPetDelegate<ExtArgs>;

  /**
   * `prisma.emulatorEffect`: Exposes CRUD operations for the **EmulatorEffect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorEffects
    * const emulatorEffects = await prisma.emulatorEffect.findMany()
    * ```
    */
  get emulatorEffect(): Prisma.EmulatorEffectDelegate<ExtArgs>;

  /**
   * `prisma.emulatorLandingview`: Exposes CRUD operations for the **EmulatorLandingview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorLandingviews
    * const emulatorLandingviews = await prisma.emulatorLandingview.findMany()
    * ```
    */
  get emulatorLandingview(): Prisma.EmulatorLandingviewDelegate<ExtArgs>;

  /**
   * `prisma.emulatorLootbox`: Exposes CRUD operations for the **EmulatorLootbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorLootboxes
    * const emulatorLootboxes = await prisma.emulatorLootbox.findMany()
    * ```
    */
  get emulatorLootbox(): Prisma.EmulatorLootboxDelegate<ExtArgs>;

  /**
   * `prisma.emulatorPermission`: Exposes CRUD operations for the **EmulatorPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorPermissions
    * const emulatorPermissions = await prisma.emulatorPermission.findMany()
    * ```
    */
  get emulatorPermission(): Prisma.EmulatorPermissionDelegate<ExtArgs>;

  /**
   * `prisma.emulatorQuest`: Exposes CRUD operations for the **EmulatorQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorQuests
    * const emulatorQuests = await prisma.emulatorQuest.findMany()
    * ```
    */
  get emulatorQuest(): Prisma.EmulatorQuestDelegate<ExtArgs>;

  /**
   * `prisma.emulatorSetting`: Exposes CRUD operations for the **EmulatorSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorSettings
    * const emulatorSettings = await prisma.emulatorSetting.findMany()
    * ```
    */
  get emulatorSetting(): Prisma.EmulatorSettingDelegate<ExtArgs>;

  /**
   * `prisma.emulatorStats`: Exposes CRUD operations for the **EmulatorStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorStats
    * const emulatorStats = await prisma.emulatorStats.findMany()
    * ```
    */
  get emulatorStats(): Prisma.EmulatorStatsDelegate<ExtArgs>;

  /**
   * `prisma.emulatorStatus`: Exposes CRUD operations for the **EmulatorStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorStatuses
    * const emulatorStatuses = await prisma.emulatorStatus.findMany()
    * ```
    */
  get emulatorStatus(): Prisma.EmulatorStatusDelegate<ExtArgs>;

  /**
   * `prisma.emulatorText`: Exposes CRUD operations for the **EmulatorText** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmulatorTexts
    * const emulatorTexts = await prisma.emulatorText.findMany()
    * ```
    */
  get emulatorText(): Prisma.EmulatorTextDelegate<ExtArgs>;

  /**
   * `prisma.guild`: Exposes CRUD operations for the **Guild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guild.findMany()
    * ```
    */
  get guild(): Prisma.GuildDelegate<ExtArgs>;

  /**
   * `prisma.guildItem`: Exposes CRUD operations for the **GuildItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildItems
    * const guildItems = await prisma.guildItem.findMany()
    * ```
    */
  get guildItem(): Prisma.GuildItemDelegate<ExtArgs>;

  /**
   * `prisma.guildMembership`: Exposes CRUD operations for the **GuildMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildMemberships
    * const guildMemberships = await prisma.guildMembership.findMany()
    * ```
    */
  get guildMembership(): Prisma.GuildMembershipDelegate<ExtArgs>;

  /**
   * `prisma.guildRequest`: Exposes CRUD operations for the **GuildRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildRequests
    * const guildRequests = await prisma.guildRequest.findMany()
    * ```
    */
  get guildRequest(): Prisma.GuildRequestDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.itemBase`: Exposes CRUD operations for the **ItemBase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemBases
    * const itemBases = await prisma.itemBase.findMany()
    * ```
    */
  get itemBase(): Prisma.ItemBaseDelegate<ExtArgs>;

  /**
   * `prisma.itemLimited`: Exposes CRUD operations for the **ItemLimited** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemLimiteds
    * const itemLimiteds = await prisma.itemLimited.findMany()
    * ```
    */
  get itemLimited(): Prisma.ItemLimitedDelegate<ExtArgs>;

  /**
   * `prisma.itemMoodlight`: Exposes CRUD operations for the **ItemMoodlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemMoodlights
    * const itemMoodlights = await prisma.itemMoodlight.findMany()
    * ```
    */
  get itemMoodlight(): Prisma.ItemMoodlightDelegate<ExtArgs>;

  /**
   * `prisma.itemPresent`: Exposes CRUD operations for the **ItemPresent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemPresents
    * const itemPresents = await prisma.itemPresent.findMany()
    * ```
    */
  get itemPresent(): Prisma.ItemPresentDelegate<ExtArgs>;

  /**
   * `prisma.itemStat`: Exposes CRUD operations for the **ItemStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemStats
    * const itemStats = await prisma.itemStat.findMany()
    * ```
    */
  get itemStat(): Prisma.ItemStatDelegate<ExtArgs>;

  /**
   * `prisma.itemTeleport`: Exposes CRUD operations for the **ItemTeleport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTeleports
    * const itemTeleports = await prisma.itemTeleport.findMany()
    * ```
    */
  get itemTeleport(): Prisma.ItemTeleportDelegate<ExtArgs>;

  /**
   * `prisma.itemWired`: Exposes CRUD operations for the **ItemWired** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemWireds
    * const itemWireds = await prisma.itemWired.findMany()
    * ```
    */
  get itemWired(): Prisma.ItemWiredDelegate<ExtArgs>;

  /**
   * `prisma.logChat`: Exposes CRUD operations for the **LogChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogChats
    * const logChats = await prisma.logChat.findMany()
    * ```
    */
  get logChat(): Prisma.LogChatDelegate<ExtArgs>;

  /**
   * `prisma.logChatPub`: Exposes CRUD operations for the **LogChatPub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogChatPubs
    * const logChatPubs = await prisma.logChatPub.findMany()
    * ```
    */
  get logChatPub(): Prisma.LogChatPubDelegate<ExtArgs>;

  /**
   * `prisma.logCommand`: Exposes CRUD operations for the **LogCommand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogCommands
    * const logCommands = await prisma.logCommand.findMany()
    * ```
    */
  get logCommand(): Prisma.LogCommandDelegate<ExtArgs>;

  /**
   * `prisma.logFlagme`: Exposes CRUD operations for the **LogFlagme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogFlagmes
    * const logFlagmes = await prisma.logFlagme.findMany()
    * ```
    */
  get logFlagme(): Prisma.LogFlagmeDelegate<ExtArgs>;

  /**
   * `prisma.logLogin`: Exposes CRUD operations for the **LogLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogLogins
    * const logLogins = await prisma.logLogin.findMany()
    * ```
    */
  get logLogin(): Prisma.LogLoginDelegate<ExtArgs>;

  /**
   * `prisma.logLootbox`: Exposes CRUD operations for the **LogLootbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogLootboxes
    * const logLootboxes = await prisma.logLootbox.findMany()
    * ```
    */
  get logLootbox(): Prisma.LogLootboxDelegate<ExtArgs>;

  /**
   * `prisma.logPayment`: Exposes CRUD operations for the **LogPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogPayments
    * const logPayments = await prisma.logPayment.findMany()
    * ```
    */
  get logPayment(): Prisma.LogPaymentDelegate<ExtArgs>;

  /**
   * `prisma.logShop`: Exposes CRUD operations for the **LogShop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogShops
    * const logShops = await prisma.logShop.findMany()
    * ```
    */
  get logShop(): Prisma.LogShopDelegate<ExtArgs>;

  /**
   * `prisma.logSlotmachine`: Exposes CRUD operations for the **LogSlotmachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogSlotmachines
    * const logSlotmachines = await prisma.logSlotmachine.findMany()
    * ```
    */
  get logSlotmachine(): Prisma.LogSlotmachineDelegate<ExtArgs>;

  /**
   * `prisma.logStaff`: Exposes CRUD operations for the **LogStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogStaffs
    * const logStaffs = await prisma.logStaff.findMany()
    * ```
    */
  get logStaff(): Prisma.LogStaffDelegate<ExtArgs>;

  /**
   * `prisma.logTrade`: Exposes CRUD operations for the **LogTrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogTrades
    * const logTrades = await prisma.logTrade.findMany()
    * ```
    */
  get logTrade(): Prisma.LogTradeDelegate<ExtArgs>;

  /**
   * `prisma.logVpn`: Exposes CRUD operations for the **LogVpn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogVpns
    * const logVpns = await prisma.logVpn.findMany()
    * ```
    */
  get logVpn(): Prisma.LogVpnDelegate<ExtArgs>;

  /**
   * `prisma.logSandbox`: Exposes CRUD operations for the **LogSandbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogSandboxes
    * const logSandboxes = await prisma.logSandbox.findMany()
    * ```
    */
  get logSandbox(): Prisma.LogSandboxDelegate<ExtArgs>;

  /**
   * `prisma.messengerFriendship`: Exposes CRUD operations for the **MessengerFriendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessengerFriendships
    * const messengerFriendships = await prisma.messengerFriendship.findMany()
    * ```
    */
  get messengerFriendship(): Prisma.MessengerFriendshipDelegate<ExtArgs>;

  /**
   * `prisma.messengerOfflineMessage`: Exposes CRUD operations for the **MessengerOfflineMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessengerOfflineMessages
    * const messengerOfflineMessages = await prisma.messengerOfflineMessage.findMany()
    * ```
    */
  get messengerOfflineMessage(): Prisma.MessengerOfflineMessageDelegate<ExtArgs>;

  /**
   * `prisma.messengerRequest`: Exposes CRUD operations for the **MessengerRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessengerRequests
    * const messengerRequests = await prisma.messengerRequest.findMany()
    * ```
    */
  get messengerRequest(): Prisma.MessengerRequestDelegate<ExtArgs>;

  /**
   * `prisma.moderationPreset`: Exposes CRUD operations for the **ModerationPreset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationPresets
    * const moderationPresets = await prisma.moderationPreset.findMany()
    * ```
    */
  get moderationPreset(): Prisma.ModerationPresetDelegate<ExtArgs>;

  /**
   * `prisma.moderationResolution`: Exposes CRUD operations for the **ModerationResolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationResolutions
    * const moderationResolutions = await prisma.moderationResolution.findMany()
    * ```
    */
  get moderationResolution(): Prisma.ModerationResolutionDelegate<ExtArgs>;

  /**
   * `prisma.moderationTicket`: Exposes CRUD operations for the **ModerationTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationTickets
    * const moderationTickets = await prisma.moderationTicket.findMany()
    * ```
    */
  get moderationTicket(): Prisma.ModerationTicketDelegate<ExtArgs>;

  /**
   * `prisma.moderationTopic`: Exposes CRUD operations for the **ModerationTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationTopics
    * const moderationTopics = await prisma.moderationTopic.findMany()
    * ```
    */
  get moderationTopic(): Prisma.ModerationTopicDelegate<ExtArgs>;

  /**
   * `prisma.moderationTopicAction`: Exposes CRUD operations for the **ModerationTopicAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationTopicActions
    * const moderationTopicActions = await prisma.moderationTopicAction.findMany()
    * ```
    */
  get moderationTopicAction(): Prisma.ModerationTopicActionDelegate<ExtArgs>;

  /**
   * `prisma.navigatorCategory`: Exposes CRUD operations for the **NavigatorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavigatorCategories
    * const navigatorCategories = await prisma.navigatorCategory.findMany()
    * ```
    */
  get navigatorCategory(): Prisma.NavigatorCategoryDelegate<ExtArgs>;

  /**
   * `prisma.navigatorPublic`: Exposes CRUD operations for the **NavigatorPublic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavigatorPublics
    * const navigatorPublics = await prisma.navigatorPublic.findMany()
    * ```
    */
  get navigatorPublic(): Prisma.NavigatorPublicDelegate<ExtArgs>;

  /**
   * `prisma.roleplay`: Exposes CRUD operations for the **Roleplay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roleplays
    * const roleplays = await prisma.roleplay.findMany()
    * ```
    */
  get roleplay(): Prisma.RoleplayDelegate<ExtArgs>;

  /**
   * `prisma.roleplayEnemy`: Exposes CRUD operations for the **RoleplayEnemy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleplayEnemies
    * const roleplayEnemies = await prisma.roleplayEnemy.findMany()
    * ```
    */
  get roleplayEnemy(): Prisma.RoleplayEnemyDelegate<ExtArgs>;

  /**
   * `prisma.roleplayItem`: Exposes CRUD operations for the **RoleplayItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleplayItems
    * const roleplayItems = await prisma.roleplayItem.findMany()
    * ```
    */
  get roleplayItem(): Prisma.RoleplayItemDelegate<ExtArgs>;

  /**
   * `prisma.roleplayWeapon`: Exposes CRUD operations for the **RoleplayWeapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleplayWeapons
    * const roleplayWeapons = await prisma.roleplayWeapon.findMany()
    * ```
    */
  get roleplayWeapon(): Prisma.RoleplayWeaponDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.roomModel`: Exposes CRUD operations for the **RoomModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomModels
    * const roomModels = await prisma.roomModel.findMany()
    * ```
    */
  get roomModel(): Prisma.RoomModelDelegate<ExtArgs>;

  /**
   * `prisma.roomModelCustom`: Exposes CRUD operations for the **RoomModelCustom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomModelCustoms
    * const roomModelCustoms = await prisma.roomModelCustom.findMany()
    * ```
    */
  get roomModelCustom(): Prisma.RoomModelCustomDelegate<ExtArgs>;

  /**
   * `prisma.roomRight`: Exposes CRUD operations for the **RoomRight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomRights
    * const roomRights = await prisma.roomRight.findMany()
    * ```
    */
  get roomRight(): Prisma.RoomRightDelegate<ExtArgs>;

  /**
   * `prisma.roomSwearwordFilter`: Exposes CRUD operations for the **RoomSwearwordFilter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomSwearwordFilters
    * const roomSwearwordFilters = await prisma.roomSwearwordFilter.findMany()
    * ```
    */
  get roomSwearwordFilter(): Prisma.RoomSwearwordFilterDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.userBanner`: Exposes CRUD operations for the **UserBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBanners
    * const userBanners = await prisma.userBanner.findMany()
    * ```
    */
  get userBanner(): Prisma.UserBannerDelegate<ExtArgs>;

  /**
   * `prisma.userPhoto`: Exposes CRUD operations for the **UserPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhotos
    * const userPhotos = await prisma.userPhoto.findMany()
    * ```
    */
  get userPhoto(): Prisma.UserPhotoDelegate<ExtArgs>;

  /**
   * `prisma.userPremium`: Exposes CRUD operations for the **UserPremium** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPremiums
    * const userPremiums = await prisma.userPremium.findMany()
    * ```
    */
  get userPremium(): Prisma.UserPremiumDelegate<ExtArgs>;

  /**
   * `prisma.userQuest`: Exposes CRUD operations for the **UserQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuests
    * const userQuests = await prisma.userQuest.findMany()
    * ```
    */
  get userQuest(): Prisma.UserQuestDelegate<ExtArgs>;

  /**
   * `prisma.userRoleplay`: Exposes CRUD operations for the **UserRoleplay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleplays
    * const userRoleplays = await prisma.userRoleplay.findMany()
    * ```
    */
  get userRoleplay(): Prisma.UserRoleplayDelegate<ExtArgs>;

  /**
   * `prisma.userRoleplayItem`: Exposes CRUD operations for the **UserRoleplayItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleplayItems
    * const userRoleplayItems = await prisma.userRoleplayItem.findMany()
    * ```
    */
  get userRoleplayItem(): Prisma.UserRoleplayItemDelegate<ExtArgs>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs>;

  /**
   * `prisma.userWardrobe`: Exposes CRUD operations for the **UserWardrobe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWardrobes
    * const userWardrobes = await prisma.userWardrobe.findMany()
    * ```
    */
  get userWardrobe(): Prisma.UserWardrobeDelegate<ExtArgs>;

  /**
   * `prisma.wordFilterRetro`: Exposes CRUD operations for the **WordFilterRetro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WordFilterRetros
    * const wordFilterRetros = await prisma.wordFilterRetro.findMany()
    * ```
    */
  get wordFilterRetro(): Prisma.WordFilterRetroDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Ban: 'Ban',
    BotPet: 'BotPet',
    BotUser: 'BotUser',
    CatalogBotPreset: 'CatalogBotPreset',
    CatalogItem: 'CatalogItem',
    CatalogItemLimited: 'CatalogItemLimited',
    CatalogMarketplaceData: 'CatalogMarketplaceData',
    CatalogMarketplaceOffer: 'CatalogMarketplaceOffer',
    CatalogPage: 'CatalogPage',
    CatalogPageLangue: 'CatalogPageLangue',
    CatalogPetRace: 'CatalogPetRace',
    CatalogPromotion: 'CatalogPromotion',
    CatalogVoucher: 'CatalogVoucher',
    CmsForumPost: 'CmsForumPost',
    CmsForumThread: 'CmsForumThread',
    CmsFourmCategory: 'CmsFourmCategory',
    CmsMailConfirm: 'CmsMailConfirm',
    CmsMailForgot: 'CmsMailForgot',
    CmsNews: 'CmsNews',
    CmsStaff: 'CmsStaff',
    CmsStaffProtect: 'CmsStaffProtect',
    EmulatorAchievement: 'EmulatorAchievement',
    EmulatorBanner: 'EmulatorBanner',
    EmulatorChatStyle: 'EmulatorChatStyle',
    EmulatorCommand: 'EmulatorCommand',
    EmulatorCommandPet: 'EmulatorCommandPet',
    EmulatorEffect: 'EmulatorEffect',
    EmulatorLandingview: 'EmulatorLandingview',
    EmulatorLootbox: 'EmulatorLootbox',
    EmulatorPermission: 'EmulatorPermission',
    EmulatorQuest: 'EmulatorQuest',
    EmulatorSetting: 'EmulatorSetting',
    EmulatorStats: 'EmulatorStats',
    EmulatorStatus: 'EmulatorStatus',
    EmulatorText: 'EmulatorText',
    Guild: 'Guild',
    GuildItem: 'GuildItem',
    GuildMembership: 'GuildMembership',
    GuildRequest: 'GuildRequest',
    Item: 'Item',
    ItemBase: 'ItemBase',
    ItemLimited: 'ItemLimited',
    ItemMoodlight: 'ItemMoodlight',
    ItemPresent: 'ItemPresent',
    ItemStat: 'ItemStat',
    ItemTeleport: 'ItemTeleport',
    ItemWired: 'ItemWired',
    LogChat: 'LogChat',
    LogChatPub: 'LogChatPub',
    LogCommand: 'LogCommand',
    LogFlagme: 'LogFlagme',
    LogLogin: 'LogLogin',
    LogLootbox: 'LogLootbox',
    LogPayment: 'LogPayment',
    LogShop: 'LogShop',
    LogSlotmachine: 'LogSlotmachine',
    LogStaff: 'LogStaff',
    LogTrade: 'LogTrade',
    LogVpn: 'LogVpn',
    LogSandbox: 'LogSandbox',
    MessengerFriendship: 'MessengerFriendship',
    MessengerOfflineMessage: 'MessengerOfflineMessage',
    MessengerRequest: 'MessengerRequest',
    ModerationPreset: 'ModerationPreset',
    ModerationResolution: 'ModerationResolution',
    ModerationTicket: 'ModerationTicket',
    ModerationTopic: 'ModerationTopic',
    ModerationTopicAction: 'ModerationTopicAction',
    NavigatorCategory: 'NavigatorCategory',
    NavigatorPublic: 'NavigatorPublic',
    Roleplay: 'Roleplay',
    RoleplayEnemy: 'RoleplayEnemy',
    RoleplayItem: 'RoleplayItem',
    RoleplayWeapon: 'RoleplayWeapon',
    Room: 'Room',
    RoomModel: 'RoomModel',
    RoomModelCustom: 'RoomModelCustom',
    RoomRight: 'RoomRight',
    RoomSwearwordFilter: 'RoomSwearwordFilter',
    User: 'User',
    UserAchievement: 'UserAchievement',
    UserBadge: 'UserBadge',
    UserBanner: 'UserBanner',
    UserPhoto: 'UserPhoto',
    UserPremium: 'UserPremium',
    UserQuest: 'UserQuest',
    UserRoleplay: 'UserRoleplay',
    UserRoleplayItem: 'UserRoleplayItem',
    UserStats: 'UserStats',
    UserWardrobe: 'UserWardrobe',
    WordFilterRetro: 'WordFilterRetro'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'ban' | 'botPet' | 'botUser' | 'catalogBotPreset' | 'catalogItem' | 'catalogItemLimited' | 'catalogMarketplaceData' | 'catalogMarketplaceOffer' | 'catalogPage' | 'catalogPageLangue' | 'catalogPetRace' | 'catalogPromotion' | 'catalogVoucher' | 'cmsForumPost' | 'cmsForumThread' | 'cmsFourmCategory' | 'cmsMailConfirm' | 'cmsMailForgot' | 'cmsNews' | 'cmsStaff' | 'cmsStaffProtect' | 'emulatorAchievement' | 'emulatorBanner' | 'emulatorChatStyle' | 'emulatorCommand' | 'emulatorCommandPet' | 'emulatorEffect' | 'emulatorLandingview' | 'emulatorLootbox' | 'emulatorPermission' | 'emulatorQuest' | 'emulatorSetting' | 'emulatorStats' | 'emulatorStatus' | 'emulatorText' | 'guild' | 'guildItem' | 'guildMembership' | 'guildRequest' | 'item' | 'itemBase' | 'itemLimited' | 'itemMoodlight' | 'itemPresent' | 'itemStat' | 'itemTeleport' | 'itemWired' | 'logChat' | 'logChatPub' | 'logCommand' | 'logFlagme' | 'logLogin' | 'logLootbox' | 'logPayment' | 'logShop' | 'logSlotmachine' | 'logStaff' | 'logTrade' | 'logVpn' | 'logSandbox' | 'messengerFriendship' | 'messengerOfflineMessage' | 'messengerRequest' | 'moderationPreset' | 'moderationResolution' | 'moderationTicket' | 'moderationTopic' | 'moderationTopicAction' | 'navigatorCategory' | 'navigatorPublic' | 'roleplay' | 'roleplayEnemy' | 'roleplayItem' | 'roleplayWeapon' | 'room' | 'roomModel' | 'roomModelCustom' | 'roomRight' | 'roomSwearwordFilter' | 'user' | 'userAchievement' | 'userBadge' | 'userBanner' | 'userPhoto' | 'userPremium' | 'userQuest' | 'userRoleplay' | 'userRoleplayItem' | 'userStats' | 'userWardrobe' | 'wordFilterRetro'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Ban: {
        payload: Prisma.$BanPayload<ExtArgs>
        fields: Prisma.BanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>
          }
          findFirst: {
            args: Prisma.BanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>
          }
          findMany: {
            args: Prisma.BanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>[]
          }
          create: {
            args: Prisma.BanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>
          }
          createMany: {
            args: Prisma.BanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>
          }
          update: {
            args: Prisma.BanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>
          }
          deleteMany: {
            args: Prisma.BanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BanPayload>
          }
          aggregate: {
            args: Prisma.BanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBan>
          }
          groupBy: {
            args: Prisma.BanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BanCountArgs<ExtArgs>,
            result: $Utils.Optional<BanCountAggregateOutputType> | number
          }
        }
      }
      BotPet: {
        payload: Prisma.$BotPetPayload<ExtArgs>
        fields: Prisma.BotPetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotPetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotPetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>
          }
          findFirst: {
            args: Prisma.BotPetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotPetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>
          }
          findMany: {
            args: Prisma.BotPetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>[]
          }
          create: {
            args: Prisma.BotPetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>
          }
          createMany: {
            args: Prisma.BotPetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BotPetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>
          }
          update: {
            args: Prisma.BotPetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>
          }
          deleteMany: {
            args: Prisma.BotPetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BotPetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BotPetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotPetPayload>
          }
          aggregate: {
            args: Prisma.BotPetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBotPet>
          }
          groupBy: {
            args: Prisma.BotPetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BotPetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotPetCountArgs<ExtArgs>,
            result: $Utils.Optional<BotPetCountAggregateOutputType> | number
          }
        }
      }
      BotUser: {
        payload: Prisma.$BotUserPayload<ExtArgs>
        fields: Prisma.BotUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>
          }
          findFirst: {
            args: Prisma.BotUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>
          }
          findMany: {
            args: Prisma.BotUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>[]
          }
          create: {
            args: Prisma.BotUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>
          }
          createMany: {
            args: Prisma.BotUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BotUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>
          }
          update: {
            args: Prisma.BotUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>
          }
          deleteMany: {
            args: Prisma.BotUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BotUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BotUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BotUserPayload>
          }
          aggregate: {
            args: Prisma.BotUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBotUser>
          }
          groupBy: {
            args: Prisma.BotUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BotUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotUserCountArgs<ExtArgs>,
            result: $Utils.Optional<BotUserCountAggregateOutputType> | number
          }
        }
      }
      CatalogBotPreset: {
        payload: Prisma.$CatalogBotPresetPayload<ExtArgs>
        fields: Prisma.CatalogBotPresetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogBotPresetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogBotPresetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>
          }
          findFirst: {
            args: Prisma.CatalogBotPresetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogBotPresetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>
          }
          findMany: {
            args: Prisma.CatalogBotPresetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>[]
          }
          create: {
            args: Prisma.CatalogBotPresetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>
          }
          createMany: {
            args: Prisma.CatalogBotPresetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogBotPresetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>
          }
          update: {
            args: Prisma.CatalogBotPresetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>
          }
          deleteMany: {
            args: Prisma.CatalogBotPresetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogBotPresetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogBotPresetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogBotPresetPayload>
          }
          aggregate: {
            args: Prisma.CatalogBotPresetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogBotPreset>
          }
          groupBy: {
            args: Prisma.CatalogBotPresetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogBotPresetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogBotPresetCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogBotPresetCountAggregateOutputType> | number
          }
        }
      }
      CatalogItem: {
        payload: Prisma.$CatalogItemPayload<ExtArgs>
        fields: Prisma.CatalogItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          findFirst: {
            args: Prisma.CatalogItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          findMany: {
            args: Prisma.CatalogItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>[]
          }
          create: {
            args: Prisma.CatalogItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          createMany: {
            args: Prisma.CatalogItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          update: {
            args: Prisma.CatalogItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          deleteMany: {
            args: Prisma.CatalogItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemPayload>
          }
          aggregate: {
            args: Prisma.CatalogItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogItem>
          }
          groupBy: {
            args: Prisma.CatalogItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogItemCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogItemCountAggregateOutputType> | number
          }
        }
      }
      CatalogItemLimited: {
        payload: Prisma.$CatalogItemLimitedPayload<ExtArgs>
        fields: Prisma.CatalogItemLimitedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogItemLimitedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogItemLimitedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>
          }
          findFirst: {
            args: Prisma.CatalogItemLimitedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogItemLimitedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>
          }
          findMany: {
            args: Prisma.CatalogItemLimitedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>[]
          }
          create: {
            args: Prisma.CatalogItemLimitedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>
          }
          createMany: {
            args: Prisma.CatalogItemLimitedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogItemLimitedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>
          }
          update: {
            args: Prisma.CatalogItemLimitedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>
          }
          deleteMany: {
            args: Prisma.CatalogItemLimitedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogItemLimitedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogItemLimitedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogItemLimitedPayload>
          }
          aggregate: {
            args: Prisma.CatalogItemLimitedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogItemLimited>
          }
          groupBy: {
            args: Prisma.CatalogItemLimitedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogItemLimitedGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogItemLimitedCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogItemLimitedCountAggregateOutputType> | number
          }
        }
      }
      CatalogMarketplaceData: {
        payload: Prisma.$CatalogMarketplaceDataPayload<ExtArgs>
        fields: Prisma.CatalogMarketplaceDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogMarketplaceDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogMarketplaceDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>
          }
          findFirst: {
            args: Prisma.CatalogMarketplaceDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogMarketplaceDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>
          }
          findMany: {
            args: Prisma.CatalogMarketplaceDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>[]
          }
          create: {
            args: Prisma.CatalogMarketplaceDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>
          }
          createMany: {
            args: Prisma.CatalogMarketplaceDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogMarketplaceDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>
          }
          update: {
            args: Prisma.CatalogMarketplaceDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>
          }
          deleteMany: {
            args: Prisma.CatalogMarketplaceDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogMarketplaceDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogMarketplaceDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceDataPayload>
          }
          aggregate: {
            args: Prisma.CatalogMarketplaceDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogMarketplaceData>
          }
          groupBy: {
            args: Prisma.CatalogMarketplaceDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogMarketplaceDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogMarketplaceDataCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogMarketplaceDataCountAggregateOutputType> | number
          }
        }
      }
      CatalogMarketplaceOffer: {
        payload: Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>
        fields: Prisma.CatalogMarketplaceOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogMarketplaceOfferFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogMarketplaceOfferFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>
          }
          findFirst: {
            args: Prisma.CatalogMarketplaceOfferFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogMarketplaceOfferFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>
          }
          findMany: {
            args: Prisma.CatalogMarketplaceOfferFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>[]
          }
          create: {
            args: Prisma.CatalogMarketplaceOfferCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>
          }
          createMany: {
            args: Prisma.CatalogMarketplaceOfferCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogMarketplaceOfferDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>
          }
          update: {
            args: Prisma.CatalogMarketplaceOfferUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>
          }
          deleteMany: {
            args: Prisma.CatalogMarketplaceOfferDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogMarketplaceOfferUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogMarketplaceOfferUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogMarketplaceOfferPayload>
          }
          aggregate: {
            args: Prisma.CatalogMarketplaceOfferAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogMarketplaceOffer>
          }
          groupBy: {
            args: Prisma.CatalogMarketplaceOfferGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogMarketplaceOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogMarketplaceOfferCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogMarketplaceOfferCountAggregateOutputType> | number
          }
        }
      }
      CatalogPage: {
        payload: Prisma.$CatalogPagePayload<ExtArgs>
        fields: Prisma.CatalogPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogPageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogPageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>
          }
          findFirst: {
            args: Prisma.CatalogPageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogPageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>
          }
          findMany: {
            args: Prisma.CatalogPageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>[]
          }
          create: {
            args: Prisma.CatalogPageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>
          }
          createMany: {
            args: Prisma.CatalogPageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogPageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>
          }
          update: {
            args: Prisma.CatalogPageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>
          }
          deleteMany: {
            args: Prisma.CatalogPageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogPageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogPageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPagePayload>
          }
          aggregate: {
            args: Prisma.CatalogPageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogPage>
          }
          groupBy: {
            args: Prisma.CatalogPageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogPageCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPageCountAggregateOutputType> | number
          }
        }
      }
      CatalogPageLangue: {
        payload: Prisma.$CatalogPageLanguePayload<ExtArgs>
        fields: Prisma.CatalogPageLangueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogPageLangueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogPageLangueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>
          }
          findFirst: {
            args: Prisma.CatalogPageLangueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogPageLangueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>
          }
          findMany: {
            args: Prisma.CatalogPageLangueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>[]
          }
          create: {
            args: Prisma.CatalogPageLangueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>
          }
          createMany: {
            args: Prisma.CatalogPageLangueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogPageLangueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>
          }
          update: {
            args: Prisma.CatalogPageLangueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>
          }
          deleteMany: {
            args: Prisma.CatalogPageLangueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogPageLangueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogPageLangueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPageLanguePayload>
          }
          aggregate: {
            args: Prisma.CatalogPageLangueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogPageLangue>
          }
          groupBy: {
            args: Prisma.CatalogPageLangueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPageLangueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogPageLangueCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPageLangueCountAggregateOutputType> | number
          }
        }
      }
      CatalogPetRace: {
        payload: Prisma.$CatalogPetRacePayload<ExtArgs>
        fields: Prisma.CatalogPetRaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogPetRaceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogPetRaceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>
          }
          findFirst: {
            args: Prisma.CatalogPetRaceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogPetRaceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>
          }
          findMany: {
            args: Prisma.CatalogPetRaceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>[]
          }
          create: {
            args: Prisma.CatalogPetRaceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>
          }
          createMany: {
            args: Prisma.CatalogPetRaceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogPetRaceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>
          }
          update: {
            args: Prisma.CatalogPetRaceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>
          }
          deleteMany: {
            args: Prisma.CatalogPetRaceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogPetRaceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogPetRaceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPetRacePayload>
          }
          aggregate: {
            args: Prisma.CatalogPetRaceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogPetRace>
          }
          groupBy: {
            args: Prisma.CatalogPetRaceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPetRaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogPetRaceCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPetRaceCountAggregateOutputType> | number
          }
        }
      }
      CatalogPromotion: {
        payload: Prisma.$CatalogPromotionPayload<ExtArgs>
        fields: Prisma.CatalogPromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogPromotionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogPromotionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>
          }
          findFirst: {
            args: Prisma.CatalogPromotionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogPromotionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>
          }
          findMany: {
            args: Prisma.CatalogPromotionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>[]
          }
          create: {
            args: Prisma.CatalogPromotionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>
          }
          createMany: {
            args: Prisma.CatalogPromotionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogPromotionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>
          }
          update: {
            args: Prisma.CatalogPromotionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>
          }
          deleteMany: {
            args: Prisma.CatalogPromotionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogPromotionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogPromotionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogPromotionPayload>
          }
          aggregate: {
            args: Prisma.CatalogPromotionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogPromotion>
          }
          groupBy: {
            args: Prisma.CatalogPromotionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogPromotionCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogPromotionCountAggregateOutputType> | number
          }
        }
      }
      CatalogVoucher: {
        payload: Prisma.$CatalogVoucherPayload<ExtArgs>
        fields: Prisma.CatalogVoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogVoucherFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogVoucherFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>
          }
          findFirst: {
            args: Prisma.CatalogVoucherFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogVoucherFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>
          }
          findMany: {
            args: Prisma.CatalogVoucherFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>[]
          }
          create: {
            args: Prisma.CatalogVoucherCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>
          }
          createMany: {
            args: Prisma.CatalogVoucherCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CatalogVoucherDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>
          }
          update: {
            args: Prisma.CatalogVoucherUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>
          }
          deleteMany: {
            args: Prisma.CatalogVoucherDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogVoucherUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CatalogVoucherUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CatalogVoucherPayload>
          }
          aggregate: {
            args: Prisma.CatalogVoucherAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCatalogVoucher>
          }
          groupBy: {
            args: Prisma.CatalogVoucherGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CatalogVoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogVoucherCountArgs<ExtArgs>,
            result: $Utils.Optional<CatalogVoucherCountAggregateOutputType> | number
          }
        }
      }
      CmsForumPost: {
        payload: Prisma.$CmsForumPostPayload<ExtArgs>
        fields: Prisma.CmsForumPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsForumPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsForumPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>
          }
          findFirst: {
            args: Prisma.CmsForumPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsForumPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>
          }
          findMany: {
            args: Prisma.CmsForumPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>[]
          }
          create: {
            args: Prisma.CmsForumPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>
          }
          createMany: {
            args: Prisma.CmsForumPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsForumPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>
          }
          update: {
            args: Prisma.CmsForumPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>
          }
          deleteMany: {
            args: Prisma.CmsForumPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsForumPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsForumPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumPostPayload>
          }
          aggregate: {
            args: Prisma.CmsForumPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsForumPost>
          }
          groupBy: {
            args: Prisma.CmsForumPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsForumPostCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsForumPostCountAggregateOutputType> | number
          }
        }
      }
      CmsForumThread: {
        payload: Prisma.$CmsForumThreadPayload<ExtArgs>
        fields: Prisma.CmsForumThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsForumThreadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsForumThreadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>
          }
          findFirst: {
            args: Prisma.CmsForumThreadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsForumThreadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>
          }
          findMany: {
            args: Prisma.CmsForumThreadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>[]
          }
          create: {
            args: Prisma.CmsForumThreadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>
          }
          createMany: {
            args: Prisma.CmsForumThreadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsForumThreadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>
          }
          update: {
            args: Prisma.CmsForumThreadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>
          }
          deleteMany: {
            args: Prisma.CmsForumThreadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsForumThreadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsForumThreadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsForumThreadPayload>
          }
          aggregate: {
            args: Prisma.CmsForumThreadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsForumThread>
          }
          groupBy: {
            args: Prisma.CmsForumThreadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsForumThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsForumThreadCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsForumThreadCountAggregateOutputType> | number
          }
        }
      }
      CmsFourmCategory: {
        payload: Prisma.$CmsFourmCategoryPayload<ExtArgs>
        fields: Prisma.CmsFourmCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsFourmCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsFourmCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>
          }
          findFirst: {
            args: Prisma.CmsFourmCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsFourmCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>
          }
          findMany: {
            args: Prisma.CmsFourmCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>[]
          }
          create: {
            args: Prisma.CmsFourmCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>
          }
          createMany: {
            args: Prisma.CmsFourmCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsFourmCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>
          }
          update: {
            args: Prisma.CmsFourmCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CmsFourmCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsFourmCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsFourmCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsFourmCategoryPayload>
          }
          aggregate: {
            args: Prisma.CmsFourmCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsFourmCategory>
          }
          groupBy: {
            args: Prisma.CmsFourmCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsFourmCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsFourmCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsFourmCategoryCountAggregateOutputType> | number
          }
        }
      }
      CmsMailConfirm: {
        payload: Prisma.$CmsMailConfirmPayload<ExtArgs>
        fields: Prisma.CmsMailConfirmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsMailConfirmFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsMailConfirmFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>
          }
          findFirst: {
            args: Prisma.CmsMailConfirmFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsMailConfirmFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>
          }
          findMany: {
            args: Prisma.CmsMailConfirmFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>[]
          }
          create: {
            args: Prisma.CmsMailConfirmCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>
          }
          createMany: {
            args: Prisma.CmsMailConfirmCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsMailConfirmDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>
          }
          update: {
            args: Prisma.CmsMailConfirmUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>
          }
          deleteMany: {
            args: Prisma.CmsMailConfirmDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsMailConfirmUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsMailConfirmUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailConfirmPayload>
          }
          aggregate: {
            args: Prisma.CmsMailConfirmAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsMailConfirm>
          }
          groupBy: {
            args: Prisma.CmsMailConfirmGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsMailConfirmGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsMailConfirmCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsMailConfirmCountAggregateOutputType> | number
          }
        }
      }
      CmsMailForgot: {
        payload: Prisma.$CmsMailForgotPayload<ExtArgs>
        fields: Prisma.CmsMailForgotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsMailForgotFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsMailForgotFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>
          }
          findFirst: {
            args: Prisma.CmsMailForgotFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsMailForgotFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>
          }
          findMany: {
            args: Prisma.CmsMailForgotFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>[]
          }
          create: {
            args: Prisma.CmsMailForgotCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>
          }
          createMany: {
            args: Prisma.CmsMailForgotCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsMailForgotDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>
          }
          update: {
            args: Prisma.CmsMailForgotUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>
          }
          deleteMany: {
            args: Prisma.CmsMailForgotDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsMailForgotUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsMailForgotUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsMailForgotPayload>
          }
          aggregate: {
            args: Prisma.CmsMailForgotAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsMailForgot>
          }
          groupBy: {
            args: Prisma.CmsMailForgotGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsMailForgotGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsMailForgotCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsMailForgotCountAggregateOutputType> | number
          }
        }
      }
      CmsNews: {
        payload: Prisma.$CmsNewsPayload<ExtArgs>
        fields: Prisma.CmsNewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsNewsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsNewsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>
          }
          findFirst: {
            args: Prisma.CmsNewsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsNewsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>
          }
          findMany: {
            args: Prisma.CmsNewsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>[]
          }
          create: {
            args: Prisma.CmsNewsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>
          }
          createMany: {
            args: Prisma.CmsNewsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsNewsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>
          }
          update: {
            args: Prisma.CmsNewsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>
          }
          deleteMany: {
            args: Prisma.CmsNewsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsNewsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsNewsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsNewsPayload>
          }
          aggregate: {
            args: Prisma.CmsNewsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsNews>
          }
          groupBy: {
            args: Prisma.CmsNewsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsNewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsNewsCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsNewsCountAggregateOutputType> | number
          }
        }
      }
      CmsStaff: {
        payload: Prisma.$CmsStaffPayload<ExtArgs>
        fields: Prisma.CmsStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsStaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsStaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>
          }
          findFirst: {
            args: Prisma.CmsStaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsStaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>
          }
          findMany: {
            args: Prisma.CmsStaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>[]
          }
          create: {
            args: Prisma.CmsStaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>
          }
          createMany: {
            args: Prisma.CmsStaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsStaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>
          }
          update: {
            args: Prisma.CmsStaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>
          }
          deleteMany: {
            args: Prisma.CmsStaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsStaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsStaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffPayload>
          }
          aggregate: {
            args: Prisma.CmsStaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsStaff>
          }
          groupBy: {
            args: Prisma.CmsStaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsStaffCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsStaffCountAggregateOutputType> | number
          }
        }
      }
      CmsStaffProtect: {
        payload: Prisma.$CmsStaffProtectPayload<ExtArgs>
        fields: Prisma.CmsStaffProtectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CmsStaffProtectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CmsStaffProtectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>
          }
          findFirst: {
            args: Prisma.CmsStaffProtectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CmsStaffProtectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>
          }
          findMany: {
            args: Prisma.CmsStaffProtectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>[]
          }
          create: {
            args: Prisma.CmsStaffProtectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>
          }
          createMany: {
            args: Prisma.CmsStaffProtectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CmsStaffProtectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>
          }
          update: {
            args: Prisma.CmsStaffProtectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>
          }
          deleteMany: {
            args: Prisma.CmsStaffProtectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CmsStaffProtectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CmsStaffProtectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CmsStaffProtectPayload>
          }
          aggregate: {
            args: Prisma.CmsStaffProtectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCmsStaffProtect>
          }
          groupBy: {
            args: Prisma.CmsStaffProtectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CmsStaffProtectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CmsStaffProtectCountArgs<ExtArgs>,
            result: $Utils.Optional<CmsStaffProtectCountAggregateOutputType> | number
          }
        }
      }
      EmulatorAchievement: {
        payload: Prisma.$EmulatorAchievementPayload<ExtArgs>
        fields: Prisma.EmulatorAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorAchievementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorAchievementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>
          }
          findFirst: {
            args: Prisma.EmulatorAchievementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorAchievementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>
          }
          findMany: {
            args: Prisma.EmulatorAchievementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>[]
          }
          create: {
            args: Prisma.EmulatorAchievementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>
          }
          createMany: {
            args: Prisma.EmulatorAchievementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorAchievementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>
          }
          update: {
            args: Prisma.EmulatorAchievementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorAchievementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorAchievementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorAchievementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorAchievementPayload>
          }
          aggregate: {
            args: Prisma.EmulatorAchievementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorAchievement>
          }
          groupBy: {
            args: Prisma.EmulatorAchievementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorAchievementCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorAchievementCountAggregateOutputType> | number
          }
        }
      }
      EmulatorBanner: {
        payload: Prisma.$EmulatorBannerPayload<ExtArgs>
        fields: Prisma.EmulatorBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorBannerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorBannerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>
          }
          findFirst: {
            args: Prisma.EmulatorBannerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorBannerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>
          }
          findMany: {
            args: Prisma.EmulatorBannerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>[]
          }
          create: {
            args: Prisma.EmulatorBannerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>
          }
          createMany: {
            args: Prisma.EmulatorBannerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorBannerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>
          }
          update: {
            args: Prisma.EmulatorBannerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorBannerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorBannerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorBannerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorBannerPayload>
          }
          aggregate: {
            args: Prisma.EmulatorBannerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorBanner>
          }
          groupBy: {
            args: Prisma.EmulatorBannerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorBannerCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorBannerCountAggregateOutputType> | number
          }
        }
      }
      EmulatorChatStyle: {
        payload: Prisma.$EmulatorChatStylePayload<ExtArgs>
        fields: Prisma.EmulatorChatStyleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorChatStyleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorChatStyleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>
          }
          findFirst: {
            args: Prisma.EmulatorChatStyleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorChatStyleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>
          }
          findMany: {
            args: Prisma.EmulatorChatStyleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>[]
          }
          create: {
            args: Prisma.EmulatorChatStyleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>
          }
          createMany: {
            args: Prisma.EmulatorChatStyleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorChatStyleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>
          }
          update: {
            args: Prisma.EmulatorChatStyleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>
          }
          deleteMany: {
            args: Prisma.EmulatorChatStyleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorChatStyleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorChatStyleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorChatStylePayload>
          }
          aggregate: {
            args: Prisma.EmulatorChatStyleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorChatStyle>
          }
          groupBy: {
            args: Prisma.EmulatorChatStyleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorChatStyleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorChatStyleCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorChatStyleCountAggregateOutputType> | number
          }
        }
      }
      EmulatorCommand: {
        payload: Prisma.$EmulatorCommandPayload<ExtArgs>
        fields: Prisma.EmulatorCommandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorCommandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorCommandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>
          }
          findFirst: {
            args: Prisma.EmulatorCommandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorCommandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>
          }
          findMany: {
            args: Prisma.EmulatorCommandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>[]
          }
          create: {
            args: Prisma.EmulatorCommandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>
          }
          createMany: {
            args: Prisma.EmulatorCommandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorCommandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>
          }
          update: {
            args: Prisma.EmulatorCommandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorCommandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorCommandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorCommandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPayload>
          }
          aggregate: {
            args: Prisma.EmulatorCommandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorCommand>
          }
          groupBy: {
            args: Prisma.EmulatorCommandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorCommandGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorCommandCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorCommandCountAggregateOutputType> | number
          }
        }
      }
      EmulatorCommandPet: {
        payload: Prisma.$EmulatorCommandPetPayload<ExtArgs>
        fields: Prisma.EmulatorCommandPetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorCommandPetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorCommandPetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>
          }
          findFirst: {
            args: Prisma.EmulatorCommandPetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorCommandPetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>
          }
          findMany: {
            args: Prisma.EmulatorCommandPetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>[]
          }
          create: {
            args: Prisma.EmulatorCommandPetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>
          }
          createMany: {
            args: Prisma.EmulatorCommandPetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorCommandPetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>
          }
          update: {
            args: Prisma.EmulatorCommandPetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorCommandPetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorCommandPetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorCommandPetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorCommandPetPayload>
          }
          aggregate: {
            args: Prisma.EmulatorCommandPetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorCommandPet>
          }
          groupBy: {
            args: Prisma.EmulatorCommandPetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorCommandPetGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorCommandPetCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorCommandPetCountAggregateOutputType> | number
          }
        }
      }
      EmulatorEffect: {
        payload: Prisma.$EmulatorEffectPayload<ExtArgs>
        fields: Prisma.EmulatorEffectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorEffectFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorEffectFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>
          }
          findFirst: {
            args: Prisma.EmulatorEffectFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorEffectFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>
          }
          findMany: {
            args: Prisma.EmulatorEffectFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>[]
          }
          create: {
            args: Prisma.EmulatorEffectCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>
          }
          createMany: {
            args: Prisma.EmulatorEffectCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorEffectDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>
          }
          update: {
            args: Prisma.EmulatorEffectUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorEffectDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorEffectUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorEffectUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorEffectPayload>
          }
          aggregate: {
            args: Prisma.EmulatorEffectAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorEffect>
          }
          groupBy: {
            args: Prisma.EmulatorEffectGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorEffectGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorEffectCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorEffectCountAggregateOutputType> | number
          }
        }
      }
      EmulatorLandingview: {
        payload: Prisma.$EmulatorLandingviewPayload<ExtArgs>
        fields: Prisma.EmulatorLandingviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorLandingviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorLandingviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>
          }
          findFirst: {
            args: Prisma.EmulatorLandingviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorLandingviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>
          }
          findMany: {
            args: Prisma.EmulatorLandingviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>[]
          }
          create: {
            args: Prisma.EmulatorLandingviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>
          }
          createMany: {
            args: Prisma.EmulatorLandingviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorLandingviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>
          }
          update: {
            args: Prisma.EmulatorLandingviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorLandingviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorLandingviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorLandingviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLandingviewPayload>
          }
          aggregate: {
            args: Prisma.EmulatorLandingviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorLandingview>
          }
          groupBy: {
            args: Prisma.EmulatorLandingviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorLandingviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorLandingviewCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorLandingviewCountAggregateOutputType> | number
          }
        }
      }
      EmulatorLootbox: {
        payload: Prisma.$EmulatorLootboxPayload<ExtArgs>
        fields: Prisma.EmulatorLootboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorLootboxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorLootboxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>
          }
          findFirst: {
            args: Prisma.EmulatorLootboxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorLootboxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>
          }
          findMany: {
            args: Prisma.EmulatorLootboxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>[]
          }
          create: {
            args: Prisma.EmulatorLootboxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>
          }
          createMany: {
            args: Prisma.EmulatorLootboxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorLootboxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>
          }
          update: {
            args: Prisma.EmulatorLootboxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorLootboxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorLootboxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorLootboxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorLootboxPayload>
          }
          aggregate: {
            args: Prisma.EmulatorLootboxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorLootbox>
          }
          groupBy: {
            args: Prisma.EmulatorLootboxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorLootboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorLootboxCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorLootboxCountAggregateOutputType> | number
          }
        }
      }
      EmulatorPermission: {
        payload: Prisma.$EmulatorPermissionPayload<ExtArgs>
        fields: Prisma.EmulatorPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorPermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorPermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>
          }
          findFirst: {
            args: Prisma.EmulatorPermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorPermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>
          }
          findMany: {
            args: Prisma.EmulatorPermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>[]
          }
          create: {
            args: Prisma.EmulatorPermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>
          }
          createMany: {
            args: Prisma.EmulatorPermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorPermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>
          }
          update: {
            args: Prisma.EmulatorPermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorPermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorPermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorPermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorPermissionPayload>
          }
          aggregate: {
            args: Prisma.EmulatorPermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorPermission>
          }
          groupBy: {
            args: Prisma.EmulatorPermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorPermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorPermissionCountAggregateOutputType> | number
          }
        }
      }
      EmulatorQuest: {
        payload: Prisma.$EmulatorQuestPayload<ExtArgs>
        fields: Prisma.EmulatorQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorQuestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorQuestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>
          }
          findFirst: {
            args: Prisma.EmulatorQuestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorQuestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>
          }
          findMany: {
            args: Prisma.EmulatorQuestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>[]
          }
          create: {
            args: Prisma.EmulatorQuestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>
          }
          createMany: {
            args: Prisma.EmulatorQuestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorQuestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>
          }
          update: {
            args: Prisma.EmulatorQuestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorQuestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorQuestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorQuestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorQuestPayload>
          }
          aggregate: {
            args: Prisma.EmulatorQuestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorQuest>
          }
          groupBy: {
            args: Prisma.EmulatorQuestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorQuestCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorQuestCountAggregateOutputType> | number
          }
        }
      }
      EmulatorSetting: {
        payload: Prisma.$EmulatorSettingPayload<ExtArgs>
        fields: Prisma.EmulatorSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorSettingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorSettingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>
          }
          findFirst: {
            args: Prisma.EmulatorSettingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorSettingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>
          }
          findMany: {
            args: Prisma.EmulatorSettingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>[]
          }
          create: {
            args: Prisma.EmulatorSettingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>
          }
          createMany: {
            args: Prisma.EmulatorSettingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorSettingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>
          }
          update: {
            args: Prisma.EmulatorSettingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorSettingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorSettingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorSettingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorSettingPayload>
          }
          aggregate: {
            args: Prisma.EmulatorSettingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorSetting>
          }
          groupBy: {
            args: Prisma.EmulatorSettingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorSettingCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorSettingCountAggregateOutputType> | number
          }
        }
      }
      EmulatorStats: {
        payload: Prisma.$EmulatorStatsPayload<ExtArgs>
        fields: Prisma.EmulatorStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorStatsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorStatsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>
          }
          findFirst: {
            args: Prisma.EmulatorStatsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorStatsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>
          }
          findMany: {
            args: Prisma.EmulatorStatsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>[]
          }
          create: {
            args: Prisma.EmulatorStatsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>
          }
          createMany: {
            args: Prisma.EmulatorStatsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorStatsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>
          }
          update: {
            args: Prisma.EmulatorStatsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorStatsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorStatsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorStatsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatsPayload>
          }
          aggregate: {
            args: Prisma.EmulatorStatsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorStats>
          }
          groupBy: {
            args: Prisma.EmulatorStatsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorStatsCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorStatsCountAggregateOutputType> | number
          }
        }
      }
      EmulatorStatus: {
        payload: Prisma.$EmulatorStatusPayload<ExtArgs>
        fields: Prisma.EmulatorStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>
          }
          findFirst: {
            args: Prisma.EmulatorStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>
          }
          findMany: {
            args: Prisma.EmulatorStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>[]
          }
          create: {
            args: Prisma.EmulatorStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>
          }
          createMany: {
            args: Prisma.EmulatorStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>
          }
          update: {
            args: Prisma.EmulatorStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorStatusPayload>
          }
          aggregate: {
            args: Prisma.EmulatorStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorStatus>
          }
          groupBy: {
            args: Prisma.EmulatorStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorStatusCountAggregateOutputType> | number
          }
        }
      }
      EmulatorText: {
        payload: Prisma.$EmulatorTextPayload<ExtArgs>
        fields: Prisma.EmulatorTextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmulatorTextFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmulatorTextFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>
          }
          findFirst: {
            args: Prisma.EmulatorTextFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmulatorTextFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>
          }
          findMany: {
            args: Prisma.EmulatorTextFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>[]
          }
          create: {
            args: Prisma.EmulatorTextCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>
          }
          createMany: {
            args: Prisma.EmulatorTextCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmulatorTextDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>
          }
          update: {
            args: Prisma.EmulatorTextUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>
          }
          deleteMany: {
            args: Prisma.EmulatorTextDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmulatorTextUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmulatorTextUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmulatorTextPayload>
          }
          aggregate: {
            args: Prisma.EmulatorTextAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmulatorText>
          }
          groupBy: {
            args: Prisma.EmulatorTextGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorTextGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmulatorTextCountArgs<ExtArgs>,
            result: $Utils.Optional<EmulatorTextCountAggregateOutputType> | number
          }
        }
      }
      Guild: {
        payload: Prisma.$GuildPayload<ExtArgs>
        fields: Prisma.GuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          findFirst: {
            args: Prisma.GuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          findMany: {
            args: Prisma.GuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>[]
          }
          create: {
            args: Prisma.GuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          createMany: {
            args: Prisma.GuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          update: {
            args: Prisma.GuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          deleteMany: {
            args: Prisma.GuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          aggregate: {
            args: Prisma.GuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuild>
          }
          groupBy: {
            args: Prisma.GuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildCountAggregateOutputType> | number
          }
        }
      }
      GuildItem: {
        payload: Prisma.$GuildItemPayload<ExtArgs>
        fields: Prisma.GuildItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>
          }
          findFirst: {
            args: Prisma.GuildItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>
          }
          findMany: {
            args: Prisma.GuildItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>[]
          }
          create: {
            args: Prisma.GuildItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>
          }
          createMany: {
            args: Prisma.GuildItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GuildItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>
          }
          update: {
            args: Prisma.GuildItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>
          }
          deleteMany: {
            args: Prisma.GuildItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GuildItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GuildItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildItemPayload>
          }
          aggregate: {
            args: Prisma.GuildItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuildItem>
          }
          groupBy: {
            args: Prisma.GuildItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildItemCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildItemCountAggregateOutputType> | number
          }
        }
      }
      GuildMembership: {
        payload: Prisma.$GuildMembershipPayload<ExtArgs>
        fields: Prisma.GuildMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildMembershipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildMembershipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>
          }
          findFirst: {
            args: Prisma.GuildMembershipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildMembershipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>
          }
          findMany: {
            args: Prisma.GuildMembershipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>[]
          }
          create: {
            args: Prisma.GuildMembershipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>
          }
          createMany: {
            args: Prisma.GuildMembershipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GuildMembershipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>
          }
          update: {
            args: Prisma.GuildMembershipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>
          }
          deleteMany: {
            args: Prisma.GuildMembershipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GuildMembershipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GuildMembershipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMembershipPayload>
          }
          aggregate: {
            args: Prisma.GuildMembershipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuildMembership>
          }
          groupBy: {
            args: Prisma.GuildMembershipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildMembershipCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildMembershipCountAggregateOutputType> | number
          }
        }
      }
      GuildRequest: {
        payload: Prisma.$GuildRequestPayload<ExtArgs>
        fields: Prisma.GuildRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>
          }
          findFirst: {
            args: Prisma.GuildRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>
          }
          findMany: {
            args: Prisma.GuildRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>[]
          }
          create: {
            args: Prisma.GuildRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>
          }
          createMany: {
            args: Prisma.GuildRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GuildRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>
          }
          update: {
            args: Prisma.GuildRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>
          }
          deleteMany: {
            args: Prisma.GuildRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GuildRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GuildRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildRequestPayload>
          }
          aggregate: {
            args: Prisma.GuildRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuildRequest>
          }
          groupBy: {
            args: Prisma.GuildRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildRequestCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      ItemBase: {
        payload: Prisma.$ItemBasePayload<ExtArgs>
        fields: Prisma.ItemBaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemBaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemBaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>
          }
          findFirst: {
            args: Prisma.ItemBaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemBaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>
          }
          findMany: {
            args: Prisma.ItemBaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>[]
          }
          create: {
            args: Prisma.ItemBaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>
          }
          createMany: {
            args: Prisma.ItemBaseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemBaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>
          }
          update: {
            args: Prisma.ItemBaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>
          }
          deleteMany: {
            args: Prisma.ItemBaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemBaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemBaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemBasePayload>
          }
          aggregate: {
            args: Prisma.ItemBaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemBase>
          }
          groupBy: {
            args: Prisma.ItemBaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemBaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemBaseCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemBaseCountAggregateOutputType> | number
          }
        }
      }
      ItemLimited: {
        payload: Prisma.$ItemLimitedPayload<ExtArgs>
        fields: Prisma.ItemLimitedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemLimitedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemLimitedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>
          }
          findFirst: {
            args: Prisma.ItemLimitedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemLimitedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>
          }
          findMany: {
            args: Prisma.ItemLimitedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>[]
          }
          create: {
            args: Prisma.ItemLimitedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>
          }
          createMany: {
            args: Prisma.ItemLimitedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemLimitedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>
          }
          update: {
            args: Prisma.ItemLimitedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>
          }
          deleteMany: {
            args: Prisma.ItemLimitedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemLimitedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemLimitedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemLimitedPayload>
          }
          aggregate: {
            args: Prisma.ItemLimitedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemLimited>
          }
          groupBy: {
            args: Prisma.ItemLimitedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemLimitedGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemLimitedCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemLimitedCountAggregateOutputType> | number
          }
        }
      }
      ItemMoodlight: {
        payload: Prisma.$ItemMoodlightPayload<ExtArgs>
        fields: Prisma.ItemMoodlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemMoodlightFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemMoodlightFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>
          }
          findFirst: {
            args: Prisma.ItemMoodlightFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemMoodlightFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>
          }
          findMany: {
            args: Prisma.ItemMoodlightFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>[]
          }
          create: {
            args: Prisma.ItemMoodlightCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>
          }
          createMany: {
            args: Prisma.ItemMoodlightCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemMoodlightDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>
          }
          update: {
            args: Prisma.ItemMoodlightUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>
          }
          deleteMany: {
            args: Prisma.ItemMoodlightDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemMoodlightUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemMoodlightUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemMoodlightPayload>
          }
          aggregate: {
            args: Prisma.ItemMoodlightAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemMoodlight>
          }
          groupBy: {
            args: Prisma.ItemMoodlightGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemMoodlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemMoodlightCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemMoodlightCountAggregateOutputType> | number
          }
        }
      }
      ItemPresent: {
        payload: Prisma.$ItemPresentPayload<ExtArgs>
        fields: Prisma.ItemPresentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemPresentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemPresentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>
          }
          findFirst: {
            args: Prisma.ItemPresentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemPresentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>
          }
          findMany: {
            args: Prisma.ItemPresentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>[]
          }
          create: {
            args: Prisma.ItemPresentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>
          }
          createMany: {
            args: Prisma.ItemPresentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemPresentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>
          }
          update: {
            args: Prisma.ItemPresentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>
          }
          deleteMany: {
            args: Prisma.ItemPresentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemPresentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemPresentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemPresentPayload>
          }
          aggregate: {
            args: Prisma.ItemPresentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemPresent>
          }
          groupBy: {
            args: Prisma.ItemPresentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemPresentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemPresentCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemPresentCountAggregateOutputType> | number
          }
        }
      }
      ItemStat: {
        payload: Prisma.$ItemStatPayload<ExtArgs>
        fields: Prisma.ItemStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemStatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemStatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>
          }
          findFirst: {
            args: Prisma.ItemStatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemStatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>
          }
          findMany: {
            args: Prisma.ItemStatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>[]
          }
          create: {
            args: Prisma.ItemStatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>
          }
          createMany: {
            args: Prisma.ItemStatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemStatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>
          }
          update: {
            args: Prisma.ItemStatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>
          }
          deleteMany: {
            args: Prisma.ItemStatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemStatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemStatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemStatPayload>
          }
          aggregate: {
            args: Prisma.ItemStatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemStat>
          }
          groupBy: {
            args: Prisma.ItemStatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemStatCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemStatCountAggregateOutputType> | number
          }
        }
      }
      ItemTeleport: {
        payload: Prisma.$ItemTeleportPayload<ExtArgs>
        fields: Prisma.ItemTeleportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTeleportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTeleportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>
          }
          findFirst: {
            args: Prisma.ItemTeleportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTeleportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>
          }
          findMany: {
            args: Prisma.ItemTeleportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>[]
          }
          create: {
            args: Prisma.ItemTeleportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>
          }
          createMany: {
            args: Prisma.ItemTeleportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemTeleportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>
          }
          update: {
            args: Prisma.ItemTeleportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>
          }
          deleteMany: {
            args: Prisma.ItemTeleportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTeleportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemTeleportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemTeleportPayload>
          }
          aggregate: {
            args: Prisma.ItemTeleportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemTeleport>
          }
          groupBy: {
            args: Prisma.ItemTeleportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemTeleportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTeleportCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemTeleportCountAggregateOutputType> | number
          }
        }
      }
      ItemWired: {
        payload: Prisma.$ItemWiredPayload<ExtArgs>
        fields: Prisma.ItemWiredFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemWiredFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemWiredFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>
          }
          findFirst: {
            args: Prisma.ItemWiredFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemWiredFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>
          }
          findMany: {
            args: Prisma.ItemWiredFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>[]
          }
          create: {
            args: Prisma.ItemWiredCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>
          }
          createMany: {
            args: Prisma.ItemWiredCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemWiredDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>
          }
          update: {
            args: Prisma.ItemWiredUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>
          }
          deleteMany: {
            args: Prisma.ItemWiredDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemWiredUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemWiredUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemWiredPayload>
          }
          aggregate: {
            args: Prisma.ItemWiredAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItemWired>
          }
          groupBy: {
            args: Prisma.ItemWiredGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemWiredGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemWiredCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemWiredCountAggregateOutputType> | number
          }
        }
      }
      LogChat: {
        payload: Prisma.$LogChatPayload<ExtArgs>
        fields: Prisma.LogChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogChatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogChatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>
          }
          findFirst: {
            args: Prisma.LogChatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogChatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>
          }
          findMany: {
            args: Prisma.LogChatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>[]
          }
          create: {
            args: Prisma.LogChatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>
          }
          createMany: {
            args: Prisma.LogChatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogChatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>
          }
          update: {
            args: Prisma.LogChatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>
          }
          deleteMany: {
            args: Prisma.LogChatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogChatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogChatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPayload>
          }
          aggregate: {
            args: Prisma.LogChatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogChat>
          }
          groupBy: {
            args: Prisma.LogChatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogChatCountArgs<ExtArgs>,
            result: $Utils.Optional<LogChatCountAggregateOutputType> | number
          }
        }
      }
      LogChatPub: {
        payload: Prisma.$LogChatPubPayload<ExtArgs>
        fields: Prisma.LogChatPubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogChatPubFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogChatPubFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>
          }
          findFirst: {
            args: Prisma.LogChatPubFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogChatPubFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>
          }
          findMany: {
            args: Prisma.LogChatPubFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>[]
          }
          create: {
            args: Prisma.LogChatPubCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>
          }
          createMany: {
            args: Prisma.LogChatPubCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogChatPubDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>
          }
          update: {
            args: Prisma.LogChatPubUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>
          }
          deleteMany: {
            args: Prisma.LogChatPubDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogChatPubUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogChatPubUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogChatPubPayload>
          }
          aggregate: {
            args: Prisma.LogChatPubAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogChatPub>
          }
          groupBy: {
            args: Prisma.LogChatPubGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogChatPubGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogChatPubCountArgs<ExtArgs>,
            result: $Utils.Optional<LogChatPubCountAggregateOutputType> | number
          }
        }
      }
      LogCommand: {
        payload: Prisma.$LogCommandPayload<ExtArgs>
        fields: Prisma.LogCommandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogCommandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogCommandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>
          }
          findFirst: {
            args: Prisma.LogCommandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogCommandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>
          }
          findMany: {
            args: Prisma.LogCommandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>[]
          }
          create: {
            args: Prisma.LogCommandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>
          }
          createMany: {
            args: Prisma.LogCommandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogCommandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>
          }
          update: {
            args: Prisma.LogCommandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>
          }
          deleteMany: {
            args: Prisma.LogCommandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogCommandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogCommandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogCommandPayload>
          }
          aggregate: {
            args: Prisma.LogCommandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogCommand>
          }
          groupBy: {
            args: Prisma.LogCommandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogCommandGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCommandCountArgs<ExtArgs>,
            result: $Utils.Optional<LogCommandCountAggregateOutputType> | number
          }
        }
      }
      LogFlagme: {
        payload: Prisma.$LogFlagmePayload<ExtArgs>
        fields: Prisma.LogFlagmeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFlagmeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFlagmeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>
          }
          findFirst: {
            args: Prisma.LogFlagmeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFlagmeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>
          }
          findMany: {
            args: Prisma.LogFlagmeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>[]
          }
          create: {
            args: Prisma.LogFlagmeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>
          }
          createMany: {
            args: Prisma.LogFlagmeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogFlagmeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>
          }
          update: {
            args: Prisma.LogFlagmeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>
          }
          deleteMany: {
            args: Prisma.LogFlagmeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogFlagmeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogFlagmeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogFlagmePayload>
          }
          aggregate: {
            args: Prisma.LogFlagmeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogFlagme>
          }
          groupBy: {
            args: Prisma.LogFlagmeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogFlagmeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogFlagmeCountArgs<ExtArgs>,
            result: $Utils.Optional<LogFlagmeCountAggregateOutputType> | number
          }
        }
      }
      LogLogin: {
        payload: Prisma.$LogLoginPayload<ExtArgs>
        fields: Prisma.LogLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogLoginFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogLoginFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>
          }
          findFirst: {
            args: Prisma.LogLoginFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogLoginFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>
          }
          findMany: {
            args: Prisma.LogLoginFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>[]
          }
          create: {
            args: Prisma.LogLoginCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>
          }
          createMany: {
            args: Prisma.LogLoginCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogLoginDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>
          }
          update: {
            args: Prisma.LogLoginUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>
          }
          deleteMany: {
            args: Prisma.LogLoginDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogLoginUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogLoginUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLoginPayload>
          }
          aggregate: {
            args: Prisma.LogLoginAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogLogin>
          }
          groupBy: {
            args: Prisma.LogLoginGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogLoginCountArgs<ExtArgs>,
            result: $Utils.Optional<LogLoginCountAggregateOutputType> | number
          }
        }
      }
      LogLootbox: {
        payload: Prisma.$LogLootboxPayload<ExtArgs>
        fields: Prisma.LogLootboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogLootboxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogLootboxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>
          }
          findFirst: {
            args: Prisma.LogLootboxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogLootboxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>
          }
          findMany: {
            args: Prisma.LogLootboxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>[]
          }
          create: {
            args: Prisma.LogLootboxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>
          }
          createMany: {
            args: Prisma.LogLootboxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogLootboxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>
          }
          update: {
            args: Prisma.LogLootboxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>
          }
          deleteMany: {
            args: Prisma.LogLootboxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogLootboxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogLootboxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogLootboxPayload>
          }
          aggregate: {
            args: Prisma.LogLootboxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogLootbox>
          }
          groupBy: {
            args: Prisma.LogLootboxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogLootboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogLootboxCountArgs<ExtArgs>,
            result: $Utils.Optional<LogLootboxCountAggregateOutputType> | number
          }
        }
      }
      LogPayment: {
        payload: Prisma.$LogPaymentPayload<ExtArgs>
        fields: Prisma.LogPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>
          }
          findFirst: {
            args: Prisma.LogPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>
          }
          findMany: {
            args: Prisma.LogPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>[]
          }
          create: {
            args: Prisma.LogPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>
          }
          createMany: {
            args: Prisma.LogPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>
          }
          update: {
            args: Prisma.LogPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>
          }
          deleteMany: {
            args: Prisma.LogPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogPaymentPayload>
          }
          aggregate: {
            args: Prisma.LogPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogPayment>
          }
          groupBy: {
            args: Prisma.LogPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<LogPaymentCountAggregateOutputType> | number
          }
        }
      }
      LogShop: {
        payload: Prisma.$LogShopPayload<ExtArgs>
        fields: Prisma.LogShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogShopFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogShopFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>
          }
          findFirst: {
            args: Prisma.LogShopFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogShopFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>
          }
          findMany: {
            args: Prisma.LogShopFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>[]
          }
          create: {
            args: Prisma.LogShopCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>
          }
          createMany: {
            args: Prisma.LogShopCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogShopDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>
          }
          update: {
            args: Prisma.LogShopUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>
          }
          deleteMany: {
            args: Prisma.LogShopDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogShopUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogShopUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogShopPayload>
          }
          aggregate: {
            args: Prisma.LogShopAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogShop>
          }
          groupBy: {
            args: Prisma.LogShopGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogShopCountArgs<ExtArgs>,
            result: $Utils.Optional<LogShopCountAggregateOutputType> | number
          }
        }
      }
      LogSlotmachine: {
        payload: Prisma.$LogSlotmachinePayload<ExtArgs>
        fields: Prisma.LogSlotmachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogSlotmachineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogSlotmachineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>
          }
          findFirst: {
            args: Prisma.LogSlotmachineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogSlotmachineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>
          }
          findMany: {
            args: Prisma.LogSlotmachineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>[]
          }
          create: {
            args: Prisma.LogSlotmachineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>
          }
          createMany: {
            args: Prisma.LogSlotmachineCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogSlotmachineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>
          }
          update: {
            args: Prisma.LogSlotmachineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>
          }
          deleteMany: {
            args: Prisma.LogSlotmachineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogSlotmachineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogSlotmachineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSlotmachinePayload>
          }
          aggregate: {
            args: Prisma.LogSlotmachineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogSlotmachine>
          }
          groupBy: {
            args: Prisma.LogSlotmachineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogSlotmachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogSlotmachineCountArgs<ExtArgs>,
            result: $Utils.Optional<LogSlotmachineCountAggregateOutputType> | number
          }
        }
      }
      LogStaff: {
        payload: Prisma.$LogStaffPayload<ExtArgs>
        fields: Prisma.LogStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogStaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogStaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>
          }
          findFirst: {
            args: Prisma.LogStaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogStaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>
          }
          findMany: {
            args: Prisma.LogStaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>[]
          }
          create: {
            args: Prisma.LogStaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>
          }
          createMany: {
            args: Prisma.LogStaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogStaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>
          }
          update: {
            args: Prisma.LogStaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>
          }
          deleteMany: {
            args: Prisma.LogStaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogStaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogStaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogStaffPayload>
          }
          aggregate: {
            args: Prisma.LogStaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogStaff>
          }
          groupBy: {
            args: Prisma.LogStaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogStaffCountArgs<ExtArgs>,
            result: $Utils.Optional<LogStaffCountAggregateOutputType> | number
          }
        }
      }
      LogTrade: {
        payload: Prisma.$LogTradePayload<ExtArgs>
        fields: Prisma.LogTradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogTradeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogTradeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>
          }
          findFirst: {
            args: Prisma.LogTradeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogTradeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>
          }
          findMany: {
            args: Prisma.LogTradeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>[]
          }
          create: {
            args: Prisma.LogTradeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>
          }
          createMany: {
            args: Prisma.LogTradeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogTradeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>
          }
          update: {
            args: Prisma.LogTradeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>
          }
          deleteMany: {
            args: Prisma.LogTradeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogTradeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogTradeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogTradePayload>
          }
          aggregate: {
            args: Prisma.LogTradeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogTrade>
          }
          groupBy: {
            args: Prisma.LogTradeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogTradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogTradeCountArgs<ExtArgs>,
            result: $Utils.Optional<LogTradeCountAggregateOutputType> | number
          }
        }
      }
      LogVpn: {
        payload: Prisma.$LogVpnPayload<ExtArgs>
        fields: Prisma.LogVpnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogVpnFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogVpnFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>
          }
          findFirst: {
            args: Prisma.LogVpnFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogVpnFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>
          }
          findMany: {
            args: Prisma.LogVpnFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>[]
          }
          create: {
            args: Prisma.LogVpnCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>
          }
          createMany: {
            args: Prisma.LogVpnCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogVpnDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>
          }
          update: {
            args: Prisma.LogVpnUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>
          }
          deleteMany: {
            args: Prisma.LogVpnDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogVpnUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogVpnUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogVpnPayload>
          }
          aggregate: {
            args: Prisma.LogVpnAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogVpn>
          }
          groupBy: {
            args: Prisma.LogVpnGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogVpnGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogVpnCountArgs<ExtArgs>,
            result: $Utils.Optional<LogVpnCountAggregateOutputType> | number
          }
        }
      }
      LogSandbox: {
        payload: Prisma.$LogSandboxPayload<ExtArgs>
        fields: Prisma.LogSandboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogSandboxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogSandboxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>
          }
          findFirst: {
            args: Prisma.LogSandboxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogSandboxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>
          }
          findMany: {
            args: Prisma.LogSandboxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>[]
          }
          create: {
            args: Prisma.LogSandboxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>
          }
          createMany: {
            args: Prisma.LogSandboxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LogSandboxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>
          }
          update: {
            args: Prisma.LogSandboxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>
          }
          deleteMany: {
            args: Prisma.LogSandboxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LogSandboxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LogSandboxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LogSandboxPayload>
          }
          aggregate: {
            args: Prisma.LogSandboxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogSandbox>
          }
          groupBy: {
            args: Prisma.LogSandboxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LogSandboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogSandboxCountArgs<ExtArgs>,
            result: $Utils.Optional<LogSandboxCountAggregateOutputType> | number
          }
        }
      }
      MessengerFriendship: {
        payload: Prisma.$MessengerFriendshipPayload<ExtArgs>
        fields: Prisma.MessengerFriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessengerFriendshipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessengerFriendshipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>
          }
          findFirst: {
            args: Prisma.MessengerFriendshipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessengerFriendshipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>
          }
          findMany: {
            args: Prisma.MessengerFriendshipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>[]
          }
          create: {
            args: Prisma.MessengerFriendshipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>
          }
          createMany: {
            args: Prisma.MessengerFriendshipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessengerFriendshipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>
          }
          update: {
            args: Prisma.MessengerFriendshipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>
          }
          deleteMany: {
            args: Prisma.MessengerFriendshipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessengerFriendshipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessengerFriendshipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerFriendshipPayload>
          }
          aggregate: {
            args: Prisma.MessengerFriendshipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessengerFriendship>
          }
          groupBy: {
            args: Prisma.MessengerFriendshipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessengerFriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessengerFriendshipCountArgs<ExtArgs>,
            result: $Utils.Optional<MessengerFriendshipCountAggregateOutputType> | number
          }
        }
      }
      MessengerOfflineMessage: {
        payload: Prisma.$MessengerOfflineMessagePayload<ExtArgs>
        fields: Prisma.MessengerOfflineMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessengerOfflineMessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessengerOfflineMessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>
          }
          findFirst: {
            args: Prisma.MessengerOfflineMessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessengerOfflineMessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>
          }
          findMany: {
            args: Prisma.MessengerOfflineMessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>[]
          }
          create: {
            args: Prisma.MessengerOfflineMessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>
          }
          createMany: {
            args: Prisma.MessengerOfflineMessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessengerOfflineMessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>
          }
          update: {
            args: Prisma.MessengerOfflineMessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>
          }
          deleteMany: {
            args: Prisma.MessengerOfflineMessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessengerOfflineMessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessengerOfflineMessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerOfflineMessagePayload>
          }
          aggregate: {
            args: Prisma.MessengerOfflineMessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessengerOfflineMessage>
          }
          groupBy: {
            args: Prisma.MessengerOfflineMessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessengerOfflineMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessengerOfflineMessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessengerOfflineMessageCountAggregateOutputType> | number
          }
        }
      }
      MessengerRequest: {
        payload: Prisma.$MessengerRequestPayload<ExtArgs>
        fields: Prisma.MessengerRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessengerRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessengerRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>
          }
          findFirst: {
            args: Prisma.MessengerRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessengerRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>
          }
          findMany: {
            args: Prisma.MessengerRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>[]
          }
          create: {
            args: Prisma.MessengerRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>
          }
          createMany: {
            args: Prisma.MessengerRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessengerRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>
          }
          update: {
            args: Prisma.MessengerRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>
          }
          deleteMany: {
            args: Prisma.MessengerRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessengerRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessengerRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessengerRequestPayload>
          }
          aggregate: {
            args: Prisma.MessengerRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessengerRequest>
          }
          groupBy: {
            args: Prisma.MessengerRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessengerRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessengerRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<MessengerRequestCountAggregateOutputType> | number
          }
        }
      }
      ModerationPreset: {
        payload: Prisma.$ModerationPresetPayload<ExtArgs>
        fields: Prisma.ModerationPresetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationPresetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationPresetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>
          }
          findFirst: {
            args: Prisma.ModerationPresetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationPresetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>
          }
          findMany: {
            args: Prisma.ModerationPresetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>[]
          }
          create: {
            args: Prisma.ModerationPresetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>
          }
          createMany: {
            args: Prisma.ModerationPresetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModerationPresetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>
          }
          update: {
            args: Prisma.ModerationPresetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>
          }
          deleteMany: {
            args: Prisma.ModerationPresetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationPresetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModerationPresetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationPresetPayload>
          }
          aggregate: {
            args: Prisma.ModerationPresetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModerationPreset>
          }
          groupBy: {
            args: Prisma.ModerationPresetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModerationPresetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationPresetCountArgs<ExtArgs>,
            result: $Utils.Optional<ModerationPresetCountAggregateOutputType> | number
          }
        }
      }
      ModerationResolution: {
        payload: Prisma.$ModerationResolutionPayload<ExtArgs>
        fields: Prisma.ModerationResolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationResolutionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationResolutionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>
          }
          findFirst: {
            args: Prisma.ModerationResolutionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationResolutionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>
          }
          findMany: {
            args: Prisma.ModerationResolutionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>[]
          }
          create: {
            args: Prisma.ModerationResolutionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>
          }
          createMany: {
            args: Prisma.ModerationResolutionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModerationResolutionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>
          }
          update: {
            args: Prisma.ModerationResolutionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>
          }
          deleteMany: {
            args: Prisma.ModerationResolutionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationResolutionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModerationResolutionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationResolutionPayload>
          }
          aggregate: {
            args: Prisma.ModerationResolutionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModerationResolution>
          }
          groupBy: {
            args: Prisma.ModerationResolutionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModerationResolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationResolutionCountArgs<ExtArgs>,
            result: $Utils.Optional<ModerationResolutionCountAggregateOutputType> | number
          }
        }
      }
      ModerationTicket: {
        payload: Prisma.$ModerationTicketPayload<ExtArgs>
        fields: Prisma.ModerationTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationTicketFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationTicketFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>
          }
          findFirst: {
            args: Prisma.ModerationTicketFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationTicketFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>
          }
          findMany: {
            args: Prisma.ModerationTicketFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>[]
          }
          create: {
            args: Prisma.ModerationTicketCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>
          }
          createMany: {
            args: Prisma.ModerationTicketCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModerationTicketDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>
          }
          update: {
            args: Prisma.ModerationTicketUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>
          }
          deleteMany: {
            args: Prisma.ModerationTicketDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationTicketUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModerationTicketUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTicketPayload>
          }
          aggregate: {
            args: Prisma.ModerationTicketAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModerationTicket>
          }
          groupBy: {
            args: Prisma.ModerationTicketGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModerationTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationTicketCountArgs<ExtArgs>,
            result: $Utils.Optional<ModerationTicketCountAggregateOutputType> | number
          }
        }
      }
      ModerationTopic: {
        payload: Prisma.$ModerationTopicPayload<ExtArgs>
        fields: Prisma.ModerationTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationTopicFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationTopicFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>
          }
          findFirst: {
            args: Prisma.ModerationTopicFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationTopicFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>
          }
          findMany: {
            args: Prisma.ModerationTopicFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>[]
          }
          create: {
            args: Prisma.ModerationTopicCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>
          }
          createMany: {
            args: Prisma.ModerationTopicCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModerationTopicDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>
          }
          update: {
            args: Prisma.ModerationTopicUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>
          }
          deleteMany: {
            args: Prisma.ModerationTopicDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationTopicUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModerationTopicUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicPayload>
          }
          aggregate: {
            args: Prisma.ModerationTopicAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModerationTopic>
          }
          groupBy: {
            args: Prisma.ModerationTopicGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModerationTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationTopicCountArgs<ExtArgs>,
            result: $Utils.Optional<ModerationTopicCountAggregateOutputType> | number
          }
        }
      }
      ModerationTopicAction: {
        payload: Prisma.$ModerationTopicActionPayload<ExtArgs>
        fields: Prisma.ModerationTopicActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationTopicActionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationTopicActionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>
          }
          findFirst: {
            args: Prisma.ModerationTopicActionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationTopicActionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>
          }
          findMany: {
            args: Prisma.ModerationTopicActionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>[]
          }
          create: {
            args: Prisma.ModerationTopicActionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>
          }
          createMany: {
            args: Prisma.ModerationTopicActionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModerationTopicActionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>
          }
          update: {
            args: Prisma.ModerationTopicActionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>
          }
          deleteMany: {
            args: Prisma.ModerationTopicActionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationTopicActionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModerationTopicActionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModerationTopicActionPayload>
          }
          aggregate: {
            args: Prisma.ModerationTopicActionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModerationTopicAction>
          }
          groupBy: {
            args: Prisma.ModerationTopicActionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModerationTopicActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationTopicActionCountArgs<ExtArgs>,
            result: $Utils.Optional<ModerationTopicActionCountAggregateOutputType> | number
          }
        }
      }
      NavigatorCategory: {
        payload: Prisma.$NavigatorCategoryPayload<ExtArgs>
        fields: Prisma.NavigatorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavigatorCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavigatorCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>
          }
          findFirst: {
            args: Prisma.NavigatorCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavigatorCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>
          }
          findMany: {
            args: Prisma.NavigatorCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>[]
          }
          create: {
            args: Prisma.NavigatorCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>
          }
          createMany: {
            args: Prisma.NavigatorCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NavigatorCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>
          }
          update: {
            args: Prisma.NavigatorCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.NavigatorCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NavigatorCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NavigatorCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorCategoryPayload>
          }
          aggregate: {
            args: Prisma.NavigatorCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNavigatorCategory>
          }
          groupBy: {
            args: Prisma.NavigatorCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NavigatorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavigatorCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<NavigatorCategoryCountAggregateOutputType> | number
          }
        }
      }
      NavigatorPublic: {
        payload: Prisma.$NavigatorPublicPayload<ExtArgs>
        fields: Prisma.NavigatorPublicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavigatorPublicFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavigatorPublicFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>
          }
          findFirst: {
            args: Prisma.NavigatorPublicFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavigatorPublicFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>
          }
          findMany: {
            args: Prisma.NavigatorPublicFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>[]
          }
          create: {
            args: Prisma.NavigatorPublicCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>
          }
          createMany: {
            args: Prisma.NavigatorPublicCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NavigatorPublicDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>
          }
          update: {
            args: Prisma.NavigatorPublicUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>
          }
          deleteMany: {
            args: Prisma.NavigatorPublicDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NavigatorPublicUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NavigatorPublicUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NavigatorPublicPayload>
          }
          aggregate: {
            args: Prisma.NavigatorPublicAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNavigatorPublic>
          }
          groupBy: {
            args: Prisma.NavigatorPublicGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NavigatorPublicGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavigatorPublicCountArgs<ExtArgs>,
            result: $Utils.Optional<NavigatorPublicCountAggregateOutputType> | number
          }
        }
      }
      Roleplay: {
        payload: Prisma.$RoleplayPayload<ExtArgs>
        fields: Prisma.RoleplayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleplayFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleplayFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>
          }
          findFirst: {
            args: Prisma.RoleplayFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleplayFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>
          }
          findMany: {
            args: Prisma.RoleplayFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>[]
          }
          create: {
            args: Prisma.RoleplayCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>
          }
          createMany: {
            args: Prisma.RoleplayCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleplayDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>
          }
          update: {
            args: Prisma.RoleplayUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>
          }
          deleteMany: {
            args: Prisma.RoleplayDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleplayUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleplayUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayPayload>
          }
          aggregate: {
            args: Prisma.RoleplayAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoleplay>
          }
          groupBy: {
            args: Prisma.RoleplayGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleplayCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayCountAggregateOutputType> | number
          }
        }
      }
      RoleplayEnemy: {
        payload: Prisma.$RoleplayEnemyPayload<ExtArgs>
        fields: Prisma.RoleplayEnemyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleplayEnemyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleplayEnemyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>
          }
          findFirst: {
            args: Prisma.RoleplayEnemyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleplayEnemyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>
          }
          findMany: {
            args: Prisma.RoleplayEnemyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>[]
          }
          create: {
            args: Prisma.RoleplayEnemyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>
          }
          createMany: {
            args: Prisma.RoleplayEnemyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleplayEnemyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>
          }
          update: {
            args: Prisma.RoleplayEnemyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>
          }
          deleteMany: {
            args: Prisma.RoleplayEnemyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleplayEnemyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleplayEnemyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayEnemyPayload>
          }
          aggregate: {
            args: Prisma.RoleplayEnemyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoleplayEnemy>
          }
          groupBy: {
            args: Prisma.RoleplayEnemyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayEnemyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleplayEnemyCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayEnemyCountAggregateOutputType> | number
          }
        }
      }
      RoleplayItem: {
        payload: Prisma.$RoleplayItemPayload<ExtArgs>
        fields: Prisma.RoleplayItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleplayItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleplayItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>
          }
          findFirst: {
            args: Prisma.RoleplayItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleplayItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>
          }
          findMany: {
            args: Prisma.RoleplayItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>[]
          }
          create: {
            args: Prisma.RoleplayItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>
          }
          createMany: {
            args: Prisma.RoleplayItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleplayItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>
          }
          update: {
            args: Prisma.RoleplayItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>
          }
          deleteMany: {
            args: Prisma.RoleplayItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleplayItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleplayItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayItemPayload>
          }
          aggregate: {
            args: Prisma.RoleplayItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoleplayItem>
          }
          groupBy: {
            args: Prisma.RoleplayItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleplayItemCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayItemCountAggregateOutputType> | number
          }
        }
      }
      RoleplayWeapon: {
        payload: Prisma.$RoleplayWeaponPayload<ExtArgs>
        fields: Prisma.RoleplayWeaponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleplayWeaponFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleplayWeaponFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>
          }
          findFirst: {
            args: Prisma.RoleplayWeaponFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleplayWeaponFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>
          }
          findMany: {
            args: Prisma.RoleplayWeaponFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>[]
          }
          create: {
            args: Prisma.RoleplayWeaponCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>
          }
          createMany: {
            args: Prisma.RoleplayWeaponCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleplayWeaponDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>
          }
          update: {
            args: Prisma.RoleplayWeaponUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>
          }
          deleteMany: {
            args: Prisma.RoleplayWeaponDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleplayWeaponUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleplayWeaponUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoleplayWeaponPayload>
          }
          aggregate: {
            args: Prisma.RoleplayWeaponAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoleplayWeapon>
          }
          groupBy: {
            args: Prisma.RoleplayWeaponGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayWeaponGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleplayWeaponCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleplayWeaponCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomModel: {
        payload: Prisma.$RoomModelPayload<ExtArgs>
        fields: Prisma.RoomModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>
          }
          findFirst: {
            args: Prisma.RoomModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>
          }
          findMany: {
            args: Prisma.RoomModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>[]
          }
          create: {
            args: Prisma.RoomModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>
          }
          createMany: {
            args: Prisma.RoomModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>
          }
          update: {
            args: Prisma.RoomModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>
          }
          deleteMany: {
            args: Prisma.RoomModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelPayload>
          }
          aggregate: {
            args: Prisma.RoomModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomModel>
          }
          groupBy: {
            args: Prisma.RoomModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomModelCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomModelCountAggregateOutputType> | number
          }
        }
      }
      RoomModelCustom: {
        payload: Prisma.$RoomModelCustomPayload<ExtArgs>
        fields: Prisma.RoomModelCustomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomModelCustomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomModelCustomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>
          }
          findFirst: {
            args: Prisma.RoomModelCustomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomModelCustomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>
          }
          findMany: {
            args: Prisma.RoomModelCustomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>[]
          }
          create: {
            args: Prisma.RoomModelCustomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>
          }
          createMany: {
            args: Prisma.RoomModelCustomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomModelCustomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>
          }
          update: {
            args: Prisma.RoomModelCustomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>
          }
          deleteMany: {
            args: Prisma.RoomModelCustomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomModelCustomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomModelCustomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomModelCustomPayload>
          }
          aggregate: {
            args: Prisma.RoomModelCustomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomModelCustom>
          }
          groupBy: {
            args: Prisma.RoomModelCustomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomModelCustomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomModelCustomCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomModelCustomCountAggregateOutputType> | number
          }
        }
      }
      RoomRight: {
        payload: Prisma.$RoomRightPayload<ExtArgs>
        fields: Prisma.RoomRightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomRightFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomRightFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>
          }
          findFirst: {
            args: Prisma.RoomRightFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomRightFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>
          }
          findMany: {
            args: Prisma.RoomRightFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>[]
          }
          create: {
            args: Prisma.RoomRightCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>
          }
          createMany: {
            args: Prisma.RoomRightCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomRightDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>
          }
          update: {
            args: Prisma.RoomRightUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>
          }
          deleteMany: {
            args: Prisma.RoomRightDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomRightUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomRightUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomRightPayload>
          }
          aggregate: {
            args: Prisma.RoomRightAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomRight>
          }
          groupBy: {
            args: Prisma.RoomRightGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomRightGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomRightCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomRightCountAggregateOutputType> | number
          }
        }
      }
      RoomSwearwordFilter: {
        payload: Prisma.$RoomSwearwordFilterPayload<ExtArgs>
        fields: Prisma.RoomSwearwordFilterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomSwearwordFilterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomSwearwordFilterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>
          }
          findFirst: {
            args: Prisma.RoomSwearwordFilterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomSwearwordFilterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>
          }
          findMany: {
            args: Prisma.RoomSwearwordFilterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>[]
          }
          create: {
            args: Prisma.RoomSwearwordFilterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>
          }
          createMany: {
            args: Prisma.RoomSwearwordFilterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomSwearwordFilterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>
          }
          update: {
            args: Prisma.RoomSwearwordFilterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>
          }
          deleteMany: {
            args: Prisma.RoomSwearwordFilterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomSwearwordFilterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomSwearwordFilterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomSwearwordFilterPayload>
          }
          aggregate: {
            args: Prisma.RoomSwearwordFilterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomSwearwordFilter>
          }
          groupBy: {
            args: Prisma.RoomSwearwordFilterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomSwearwordFilterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomSwearwordFilterCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomSwearwordFilterCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>,
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBanner: {
        payload: Prisma.$UserBannerPayload<ExtArgs>
        fields: Prisma.UserBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBannerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBannerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>
          }
          findFirst: {
            args: Prisma.UserBannerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBannerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>
          }
          findMany: {
            args: Prisma.UserBannerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>[]
          }
          create: {
            args: Prisma.UserBannerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>
          }
          createMany: {
            args: Prisma.UserBannerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserBannerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>
          }
          update: {
            args: Prisma.UserBannerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>
          }
          deleteMany: {
            args: Prisma.UserBannerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserBannerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserBannerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserBannerPayload>
          }
          aggregate: {
            args: Prisma.UserBannerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserBanner>
          }
          groupBy: {
            args: Prisma.UserBannerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBannerCountArgs<ExtArgs>,
            result: $Utils.Optional<UserBannerCountAggregateOutputType> | number
          }
        }
      }
      UserPhoto: {
        payload: Prisma.$UserPhotoPayload<ExtArgs>
        fields: Prisma.UserPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findFirst: {
            args: Prisma.UserPhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findMany: {
            args: Prisma.UserPhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>[]
          }
          create: {
            args: Prisma.UserPhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          createMany: {
            args: Prisma.UserPhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserPhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          update: {
            args: Prisma.UserPhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          deleteMany: {
            args: Prisma.UserPhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          aggregate: {
            args: Prisma.UserPhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPhoto>
          }
          groupBy: {
            args: Prisma.UserPhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPhotoCountAggregateOutputType> | number
          }
        }
      }
      UserPremium: {
        payload: Prisma.$UserPremiumPayload<ExtArgs>
        fields: Prisma.UserPremiumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPremiumFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPremiumFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>
          }
          findFirst: {
            args: Prisma.UserPremiumFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPremiumFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>
          }
          findMany: {
            args: Prisma.UserPremiumFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>[]
          }
          create: {
            args: Prisma.UserPremiumCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>
          }
          createMany: {
            args: Prisma.UserPremiumCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserPremiumDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>
          }
          update: {
            args: Prisma.UserPremiumUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>
          }
          deleteMany: {
            args: Prisma.UserPremiumDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPremiumUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPremiumUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPremiumPayload>
          }
          aggregate: {
            args: Prisma.UserPremiumAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPremium>
          }
          groupBy: {
            args: Prisma.UserPremiumGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPremiumGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPremiumCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPremiumCountAggregateOutputType> | number
          }
        }
      }
      UserQuest: {
        payload: Prisma.$UserQuestPayload<ExtArgs>
        fields: Prisma.UserQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>
          }
          findFirst: {
            args: Prisma.UserQuestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>
          }
          findMany: {
            args: Prisma.UserQuestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>[]
          }
          create: {
            args: Prisma.UserQuestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>
          }
          createMany: {
            args: Prisma.UserQuestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserQuestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>
          }
          update: {
            args: Prisma.UserQuestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>
          }
          deleteMany: {
            args: Prisma.UserQuestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserQuestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserQuestPayload>
          }
          aggregate: {
            args: Prisma.UserQuestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserQuest>
          }
          groupBy: {
            args: Prisma.UserQuestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuestCountArgs<ExtArgs>,
            result: $Utils.Optional<UserQuestCountAggregateOutputType> | number
          }
        }
      }
      UserRoleplay: {
        payload: Prisma.$UserRoleplayPayload<ExtArgs>
        fields: Prisma.UserRoleplayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleplayFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleplayFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>
          }
          findFirst: {
            args: Prisma.UserRoleplayFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleplayFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>
          }
          findMany: {
            args: Prisma.UserRoleplayFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>[]
          }
          create: {
            args: Prisma.UserRoleplayCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>
          }
          createMany: {
            args: Prisma.UserRoleplayCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserRoleplayDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>
          }
          update: {
            args: Prisma.UserRoleplayUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>
          }
          deleteMany: {
            args: Prisma.UserRoleplayDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleplayUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleplayUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayPayload>
          }
          aggregate: {
            args: Prisma.UserRoleplayAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserRoleplay>
          }
          groupBy: {
            args: Prisma.UserRoleplayGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserRoleplayGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleplayCountArgs<ExtArgs>,
            result: $Utils.Optional<UserRoleplayCountAggregateOutputType> | number
          }
        }
      }
      UserRoleplayItem: {
        payload: Prisma.$UserRoleplayItemPayload<ExtArgs>
        fields: Prisma.UserRoleplayItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleplayItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleplayItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>
          }
          findFirst: {
            args: Prisma.UserRoleplayItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleplayItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>
          }
          findMany: {
            args: Prisma.UserRoleplayItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>[]
          }
          create: {
            args: Prisma.UserRoleplayItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>
          }
          createMany: {
            args: Prisma.UserRoleplayItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserRoleplayItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>
          }
          update: {
            args: Prisma.UserRoleplayItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>
          }
          deleteMany: {
            args: Prisma.UserRoleplayItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleplayItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleplayItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserRoleplayItemPayload>
          }
          aggregate: {
            args: Prisma.UserRoleplayItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserRoleplayItem>
          }
          groupBy: {
            args: Prisma.UserRoleplayItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserRoleplayItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleplayItemCountArgs<ExtArgs>,
            result: $Utils.Optional<UserRoleplayItemCountAggregateOutputType> | number
          }
        }
      }
      UserStats: {
        payload: Prisma.$UserStatsPayload<ExtArgs>
        fields: Prisma.UserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findFirst: {
            args: Prisma.UserStatsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findMany: {
            args: Prisma.UserStatsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          create: {
            args: Prisma.UserStatsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          createMany: {
            args: Prisma.UserStatsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserStatsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          update: {
            args: Prisma.UserStatsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          deleteMany: {
            args: Prisma.UserStatsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserStatsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          aggregate: {
            args: Prisma.UserStatsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserStats>
          }
          groupBy: {
            args: Prisma.UserStatsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStatsCountArgs<ExtArgs>,
            result: $Utils.Optional<UserStatsCountAggregateOutputType> | number
          }
        }
      }
      UserWardrobe: {
        payload: Prisma.$UserWardrobePayload<ExtArgs>
        fields: Prisma.UserWardrobeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWardrobeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWardrobeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>
          }
          findFirst: {
            args: Prisma.UserWardrobeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWardrobeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>
          }
          findMany: {
            args: Prisma.UserWardrobeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>[]
          }
          create: {
            args: Prisma.UserWardrobeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>
          }
          createMany: {
            args: Prisma.UserWardrobeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserWardrobeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>
          }
          update: {
            args: Prisma.UserWardrobeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>
          }
          deleteMany: {
            args: Prisma.UserWardrobeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserWardrobeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserWardrobeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserWardrobePayload>
          }
          aggregate: {
            args: Prisma.UserWardrobeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserWardrobe>
          }
          groupBy: {
            args: Prisma.UserWardrobeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserWardrobeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWardrobeCountArgs<ExtArgs>,
            result: $Utils.Optional<UserWardrobeCountAggregateOutputType> | number
          }
        }
      }
      WordFilterRetro: {
        payload: Prisma.$WordFilterRetroPayload<ExtArgs>
        fields: Prisma.WordFilterRetroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WordFilterRetroFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WordFilterRetroFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>
          }
          findFirst: {
            args: Prisma.WordFilterRetroFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WordFilterRetroFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>
          }
          findMany: {
            args: Prisma.WordFilterRetroFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>[]
          }
          create: {
            args: Prisma.WordFilterRetroCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>
          }
          createMany: {
            args: Prisma.WordFilterRetroCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WordFilterRetroDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>
          }
          update: {
            args: Prisma.WordFilterRetroUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>
          }
          deleteMany: {
            args: Prisma.WordFilterRetroDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WordFilterRetroUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WordFilterRetroUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordFilterRetroPayload>
          }
          aggregate: {
            args: Prisma.WordFilterRetroAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWordFilterRetro>
          }
          groupBy: {
            args: Prisma.WordFilterRetroGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WordFilterRetroGroupByOutputType>[]
          }
          count: {
            args: Prisma.WordFilterRetroCountArgs<ExtArgs>,
            result: $Utils.Optional<WordFilterRetroCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ItemBaseCountOutputType
   */

  export type ItemBaseCountOutputType = {
    logLootbox: number
    catalogItem: number
  }

  export type ItemBaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logLootbox?: boolean | ItemBaseCountOutputTypeCountLogLootboxArgs
    catalogItem?: boolean | ItemBaseCountOutputTypeCountCatalogItemArgs
  }

  // Custom InputTypes

  /**
   * ItemBaseCountOutputType without action
   */
  export type ItemBaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBaseCountOutputType
     */
    select?: ItemBaseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemBaseCountOutputType without action
   */
  export type ItemBaseCountOutputTypeCountLogLootboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogLootboxWhereInput
  }


  /**
   * ItemBaseCountOutputType without action
   */
  export type ItemBaseCountOutputTypeCountCatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogItemWhereInput
  }



  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    LogChat: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LogChat?: boolean | RoomCountOutputTypeCountLogChatArgs
  }

  // Custom InputTypes

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountLogChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogChatWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    logLogin: number
    logChat: number
    logSlotmachine: number
    logShop: number
    logLootbox: number
    logSandbox: number
    userOneTrade: number
    userTwoTrade: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logLogin?: boolean | UserCountOutputTypeCountLogLoginArgs
    logChat?: boolean | UserCountOutputTypeCountLogChatArgs
    logSlotmachine?: boolean | UserCountOutputTypeCountLogSlotmachineArgs
    logShop?: boolean | UserCountOutputTypeCountLogShopArgs
    logLootbox?: boolean | UserCountOutputTypeCountLogLootboxArgs
    logSandbox?: boolean | UserCountOutputTypeCountLogSandboxArgs
    userOneTrade?: boolean | UserCountOutputTypeCountUserOneTradeArgs
    userTwoTrade?: boolean | UserCountOutputTypeCountUserTwoTradeArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogLoginWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogChatWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogSlotmachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSlotmachineWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogShopWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogLootboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogLootboxWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogSandboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSandboxWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserOneTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogTradeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserTwoTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogTradeWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Ban
   */

  export type AggregateBan = {
    _count: BanCountAggregateOutputType | null
    _avg: BanAvgAggregateOutputType | null
    _sum: BanSumAggregateOutputType | null
    _min: BanMinAggregateOutputType | null
    _max: BanMaxAggregateOutputType | null
  }

  export type BanAvgAggregateOutputType = {
    id: number | null
    expire: number | null
    addedDate: number | null
  }

  export type BanSumAggregateOutputType = {
    id: number | null
    expire: number | null
    addedDate: number | null
  }

  export type BanMinAggregateOutputType = {
    id: number | null
    bantype: $Enums.BanBantype | null
    value: string | null
    reason: string | null
    expire: number | null
    addedBy: string | null
    addedDate: number | null
  }

  export type BanMaxAggregateOutputType = {
    id: number | null
    bantype: $Enums.BanBantype | null
    value: string | null
    reason: string | null
    expire: number | null
    addedBy: string | null
    addedDate: number | null
  }

  export type BanCountAggregateOutputType = {
    id: number
    bantype: number
    value: number
    reason: number
    expire: number
    addedBy: number
    addedDate: number
    _all: number
  }


  export type BanAvgAggregateInputType = {
    id?: true
    expire?: true
    addedDate?: true
  }

  export type BanSumAggregateInputType = {
    id?: true
    expire?: true
    addedDate?: true
  }

  export type BanMinAggregateInputType = {
    id?: true
    bantype?: true
    value?: true
    reason?: true
    expire?: true
    addedBy?: true
    addedDate?: true
  }

  export type BanMaxAggregateInputType = {
    id?: true
    bantype?: true
    value?: true
    reason?: true
    expire?: true
    addedBy?: true
    addedDate?: true
  }

  export type BanCountAggregateInputType = {
    id?: true
    bantype?: true
    value?: true
    reason?: true
    expire?: true
    addedBy?: true
    addedDate?: true
    _all?: true
  }

  export type BanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ban to aggregate.
     */
    where?: BanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bans to fetch.
     */
    orderBy?: BanOrderByWithRelationInput | BanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bans
    **/
    _count?: true | BanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanMaxAggregateInputType
  }

  export type GetBanAggregateType<T extends BanAggregateArgs> = {
        [P in keyof T & keyof AggregateBan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBan[P]>
      : GetScalarType<T[P], AggregateBan[P]>
  }




  export type BanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanWhereInput
    orderBy?: BanOrderByWithAggregationInput | BanOrderByWithAggregationInput[]
    by: BanScalarFieldEnum[] | BanScalarFieldEnum
    having?: BanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanCountAggregateInputType | true
    _avg?: BanAvgAggregateInputType
    _sum?: BanSumAggregateInputType
    _min?: BanMinAggregateInputType
    _max?: BanMaxAggregateInputType
  }

  export type BanGroupByOutputType = {
    id: number
    bantype: $Enums.BanBantype
    value: string
    reason: string
    expire: number
    addedBy: string
    addedDate: number
    _count: BanCountAggregateOutputType | null
    _avg: BanAvgAggregateOutputType | null
    _sum: BanSumAggregateOutputType | null
    _min: BanMinAggregateOutputType | null
    _max: BanMaxAggregateOutputType | null
  }

  type GetBanGroupByPayload<T extends BanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanGroupByOutputType[P]>
            : GetScalarType<T[P], BanGroupByOutputType[P]>
        }
      >
    >


  export type BanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bantype?: boolean
    value?: boolean
    reason?: boolean
    expire?: boolean
    addedBy?: boolean
    addedDate?: boolean
  }, ExtArgs["result"]["ban"]>

  export type BanSelectScalar = {
    id?: boolean
    bantype?: boolean
    value?: boolean
    reason?: boolean
    expire?: boolean
    addedBy?: boolean
    addedDate?: boolean
  }


  export type $BanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ban"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bantype: $Enums.BanBantype
      value: string
      reason: string
      expire: number
      addedBy: string
      addedDate: number
    }, ExtArgs["result"]["ban"]>
    composites: {}
  }


  type BanGetPayload<S extends boolean | null | undefined | BanDefaultArgs> = $Result.GetResult<Prisma.$BanPayload, S>

  type BanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BanCountAggregateInputType | true
    }

  export interface BanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ban'], meta: { name: 'Ban' } }
    /**
     * Find zero or one Ban that matches the filter.
     * @param {BanFindUniqueArgs} args - Arguments to find a Ban
     * @example
     * // Get one Ban
     * const ban = await prisma.ban.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BanFindUniqueArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ban that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BanFindUniqueOrThrowArgs} args - Arguments to find a Ban
     * @example
     * // Get one Ban
     * const ban = await prisma.ban.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ban that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanFindFirstArgs} args - Arguments to find a Ban
     * @example
     * // Get one Ban
     * const ban = await prisma.ban.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BanFindFirstArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ban that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanFindFirstOrThrowArgs} args - Arguments to find a Ban
     * @example
     * // Get one Ban
     * const ban = await prisma.ban.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bans
     * const bans = await prisma.ban.findMany()
     * 
     * // Get first 10 Bans
     * const bans = await prisma.ban.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banWithIdOnly = await prisma.ban.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ban.
     * @param {BanCreateArgs} args - Arguments to create a Ban.
     * @example
     * // Create one Ban
     * const Ban = await prisma.ban.create({
     *   data: {
     *     // ... data to create a Ban
     *   }
     * })
     * 
    **/
    create<T extends BanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BanCreateArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bans.
     *     @param {BanCreateManyArgs} args - Arguments to create many Bans.
     *     @example
     *     // Create many Bans
     *     const ban = await prisma.ban.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ban.
     * @param {BanDeleteArgs} args - Arguments to delete one Ban.
     * @example
     * // Delete one Ban
     * const Ban = await prisma.ban.delete({
     *   where: {
     *     // ... filter to delete one Ban
     *   }
     * })
     * 
    **/
    delete<T extends BanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BanDeleteArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ban.
     * @param {BanUpdateArgs} args - Arguments to update one Ban.
     * @example
     * // Update one Ban
     * const ban = await prisma.ban.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BanUpdateArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bans.
     * @param {BanDeleteManyArgs} args - Arguments to filter Bans to delete.
     * @example
     * // Delete a few Bans
     * const { count } = await prisma.ban.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bans
     * const ban = await prisma.ban.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ban.
     * @param {BanUpsertArgs} args - Arguments to update or create a Ban.
     * @example
     * // Update or create a Ban
     * const ban = await prisma.ban.upsert({
     *   create: {
     *     // ... data to create a Ban
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ban we want to update
     *   }
     * })
    **/
    upsert<T extends BanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BanUpsertArgs<ExtArgs>>
    ): Prisma__BanClient<$Result.GetResult<Prisma.$BanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanCountArgs} args - Arguments to filter Bans to count.
     * @example
     * // Count the number of Bans
     * const count = await prisma.ban.count({
     *   where: {
     *     // ... the filter for the Bans we want to count
     *   }
     * })
    **/
    count<T extends BanCountArgs>(
      args?: Subset<T, BanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ban.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanAggregateArgs>(args: Subset<T, BanAggregateArgs>): Prisma.PrismaPromise<GetBanAggregateType<T>>

    /**
     * Group by Ban.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BanGroupByArgs['orderBy'] }
        : { orderBy?: BanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ban model
   */
  readonly fields: BanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ban.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ban model
   */ 
  interface BanFieldRefs {
    readonly id: FieldRef<"Ban", 'Int'>
    readonly bantype: FieldRef<"Ban", 'BanBantype'>
    readonly value: FieldRef<"Ban", 'String'>
    readonly reason: FieldRef<"Ban", 'String'>
    readonly expire: FieldRef<"Ban", 'Int'>
    readonly addedBy: FieldRef<"Ban", 'String'>
    readonly addedDate: FieldRef<"Ban", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Ban findUnique
   */
  export type BanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * Filter, which Ban to fetch.
     */
    where: BanWhereUniqueInput
  }


  /**
   * Ban findUniqueOrThrow
   */
  export type BanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * Filter, which Ban to fetch.
     */
    where: BanWhereUniqueInput
  }


  /**
   * Ban findFirst
   */
  export type BanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * Filter, which Ban to fetch.
     */
    where?: BanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bans to fetch.
     */
    orderBy?: BanOrderByWithRelationInput | BanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bans.
     */
    cursor?: BanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bans.
     */
    distinct?: BanScalarFieldEnum | BanScalarFieldEnum[]
  }


  /**
   * Ban findFirstOrThrow
   */
  export type BanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * Filter, which Ban to fetch.
     */
    where?: BanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bans to fetch.
     */
    orderBy?: BanOrderByWithRelationInput | BanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bans.
     */
    cursor?: BanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bans.
     */
    distinct?: BanScalarFieldEnum | BanScalarFieldEnum[]
  }


  /**
   * Ban findMany
   */
  export type BanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * Filter, which Bans to fetch.
     */
    where?: BanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bans to fetch.
     */
    orderBy?: BanOrderByWithRelationInput | BanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bans.
     */
    cursor?: BanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bans.
     */
    skip?: number
    distinct?: BanScalarFieldEnum | BanScalarFieldEnum[]
  }


  /**
   * Ban create
   */
  export type BanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * The data needed to create a Ban.
     */
    data: XOR<BanCreateInput, BanUncheckedCreateInput>
  }


  /**
   * Ban createMany
   */
  export type BanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bans.
     */
    data: BanCreateManyInput | BanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ban update
   */
  export type BanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * The data needed to update a Ban.
     */
    data: XOR<BanUpdateInput, BanUncheckedUpdateInput>
    /**
     * Choose, which Ban to update.
     */
    where: BanWhereUniqueInput
  }


  /**
   * Ban updateMany
   */
  export type BanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bans.
     */
    data: XOR<BanUpdateManyMutationInput, BanUncheckedUpdateManyInput>
    /**
     * Filter which Bans to update
     */
    where?: BanWhereInput
  }


  /**
   * Ban upsert
   */
  export type BanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * The filter to search for the Ban to update in case it exists.
     */
    where: BanWhereUniqueInput
    /**
     * In case the Ban found by the `where` argument doesn't exist, create a new Ban with this data.
     */
    create: XOR<BanCreateInput, BanUncheckedCreateInput>
    /**
     * In case the Ban was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BanUpdateInput, BanUncheckedUpdateInput>
  }


  /**
   * Ban delete
   */
  export type BanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
    /**
     * Filter which Ban to delete.
     */
    where: BanWhereUniqueInput
  }


  /**
   * Ban deleteMany
   */
  export type BanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bans to delete
     */
    where?: BanWhereInput
  }


  /**
   * Ban without action
   */
  export type BanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ban
     */
    select?: BanSelect<ExtArgs> | null
  }



  /**
   * Model BotPet
   */

  export type AggregateBotPet = {
    _count: BotPetCountAggregateOutputType | null
    _avg: BotPetAvgAggregateOutputType | null
    _sum: BotPetSumAggregateOutputType | null
    _min: BotPetMinAggregateOutputType | null
    _max: BotPetMaxAggregateOutputType | null
  }

  export type BotPetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    type: number | null
    experience: number | null
    energy: number | null
    nutrition: number | null
    respect: number | null
    createstamp: number | null
    x: number | null
    y: number | null
    z: number | null
    haveSaddle: number | null
    hairdye: number | null
    pethair: number | null
  }

  export type BotPetSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    type: number | null
    experience: number | null
    energy: number | null
    nutrition: number | null
    respect: number | null
    createstamp: number | null
    x: number | null
    y: number | null
    z: number | null
    haveSaddle: number | null
    hairdye: number | null
    pethair: number | null
  }

  export type BotPetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    name: string | null
    race: string | null
    color: string | null
    type: number | null
    experience: number | null
    energy: number | null
    nutrition: number | null
    respect: number | null
    createstamp: number | null
    x: number | null
    y: number | null
    z: number | null
    haveSaddle: number | null
    hairdye: number | null
    pethair: number | null
    anyoneRide: boolean | null
  }

  export type BotPetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    name: string | null
    race: string | null
    color: string | null
    type: number | null
    experience: number | null
    energy: number | null
    nutrition: number | null
    respect: number | null
    createstamp: number | null
    x: number | null
    y: number | null
    z: number | null
    haveSaddle: number | null
    hairdye: number | null
    pethair: number | null
    anyoneRide: boolean | null
  }

  export type BotPetCountAggregateOutputType = {
    id: number
    userId: number
    roomId: number
    name: number
    race: number
    color: number
    type: number
    experience: number
    energy: number
    nutrition: number
    respect: number
    createstamp: number
    x: number
    y: number
    z: number
    haveSaddle: number
    hairdye: number
    pethair: number
    anyoneRide: number
    _all: number
  }


  export type BotPetAvgAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    type?: true
    experience?: true
    energy?: true
    nutrition?: true
    respect?: true
    createstamp?: true
    x?: true
    y?: true
    z?: true
    haveSaddle?: true
    hairdye?: true
    pethair?: true
  }

  export type BotPetSumAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    type?: true
    experience?: true
    energy?: true
    nutrition?: true
    respect?: true
    createstamp?: true
    x?: true
    y?: true
    z?: true
    haveSaddle?: true
    hairdye?: true
    pethair?: true
  }

  export type BotPetMinAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    name?: true
    race?: true
    color?: true
    type?: true
    experience?: true
    energy?: true
    nutrition?: true
    respect?: true
    createstamp?: true
    x?: true
    y?: true
    z?: true
    haveSaddle?: true
    hairdye?: true
    pethair?: true
    anyoneRide?: true
  }

  export type BotPetMaxAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    name?: true
    race?: true
    color?: true
    type?: true
    experience?: true
    energy?: true
    nutrition?: true
    respect?: true
    createstamp?: true
    x?: true
    y?: true
    z?: true
    haveSaddle?: true
    hairdye?: true
    pethair?: true
    anyoneRide?: true
  }

  export type BotPetCountAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    name?: true
    race?: true
    color?: true
    type?: true
    experience?: true
    energy?: true
    nutrition?: true
    respect?: true
    createstamp?: true
    x?: true
    y?: true
    z?: true
    haveSaddle?: true
    hairdye?: true
    pethair?: true
    anyoneRide?: true
    _all?: true
  }

  export type BotPetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotPet to aggregate.
     */
    where?: BotPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPets to fetch.
     */
    orderBy?: BotPetOrderByWithRelationInput | BotPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotPets
    **/
    _count?: true | BotPetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotPetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotPetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotPetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotPetMaxAggregateInputType
  }

  export type GetBotPetAggregateType<T extends BotPetAggregateArgs> = {
        [P in keyof T & keyof AggregateBotPet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotPet[P]>
      : GetScalarType<T[P], AggregateBotPet[P]>
  }




  export type BotPetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotPetWhereInput
    orderBy?: BotPetOrderByWithAggregationInput | BotPetOrderByWithAggregationInput[]
    by: BotPetScalarFieldEnum[] | BotPetScalarFieldEnum
    having?: BotPetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotPetCountAggregateInputType | true
    _avg?: BotPetAvgAggregateInputType
    _sum?: BotPetSumAggregateInputType
    _min?: BotPetMinAggregateInputType
    _max?: BotPetMaxAggregateInputType
  }

  export type BotPetGroupByOutputType = {
    id: number
    userId: number
    roomId: number
    name: string
    race: string
    color: string
    type: number
    experience: number
    energy: number
    nutrition: number
    respect: number
    createstamp: number
    x: number
    y: number
    z: number
    haveSaddle: number
    hairdye: number
    pethair: number
    anyoneRide: boolean
    _count: BotPetCountAggregateOutputType | null
    _avg: BotPetAvgAggregateOutputType | null
    _sum: BotPetSumAggregateOutputType | null
    _min: BotPetMinAggregateOutputType | null
    _max: BotPetMaxAggregateOutputType | null
  }

  type GetBotPetGroupByPayload<T extends BotPetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotPetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotPetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotPetGroupByOutputType[P]>
            : GetScalarType<T[P], BotPetGroupByOutputType[P]>
        }
      >
    >


  export type BotPetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomId?: boolean
    name?: boolean
    race?: boolean
    color?: boolean
    type?: boolean
    experience?: boolean
    energy?: boolean
    nutrition?: boolean
    respect?: boolean
    createstamp?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    haveSaddle?: boolean
    hairdye?: boolean
    pethair?: boolean
    anyoneRide?: boolean
  }, ExtArgs["result"]["botPet"]>

  export type BotPetSelectScalar = {
    id?: boolean
    userId?: boolean
    roomId?: boolean
    name?: boolean
    race?: boolean
    color?: boolean
    type?: boolean
    experience?: boolean
    energy?: boolean
    nutrition?: boolean
    respect?: boolean
    createstamp?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    haveSaddle?: boolean
    hairdye?: boolean
    pethair?: boolean
    anyoneRide?: boolean
  }


  export type $BotPetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotPet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roomId: number
      name: string
      race: string
      color: string
      type: number
      experience: number
      energy: number
      nutrition: number
      respect: number
      createstamp: number
      x: number
      y: number
      z: number
      haveSaddle: number
      hairdye: number
      pethair: number
      anyoneRide: boolean
    }, ExtArgs["result"]["botPet"]>
    composites: {}
  }


  type BotPetGetPayload<S extends boolean | null | undefined | BotPetDefaultArgs> = $Result.GetResult<Prisma.$BotPetPayload, S>

  type BotPetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BotPetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BotPetCountAggregateInputType | true
    }

  export interface BotPetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotPet'], meta: { name: 'BotPet' } }
    /**
     * Find zero or one BotPet that matches the filter.
     * @param {BotPetFindUniqueArgs} args - Arguments to find a BotPet
     * @example
     * // Get one BotPet
     * const botPet = await prisma.botPet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BotPetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BotPetFindUniqueArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BotPet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BotPetFindUniqueOrThrowArgs} args - Arguments to find a BotPet
     * @example
     * // Get one BotPet
     * const botPet = await prisma.botPet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BotPetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BotPetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BotPet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetFindFirstArgs} args - Arguments to find a BotPet
     * @example
     * // Get one BotPet
     * const botPet = await prisma.botPet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BotPetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BotPetFindFirstArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BotPet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetFindFirstOrThrowArgs} args - Arguments to find a BotPet
     * @example
     * // Get one BotPet
     * const botPet = await prisma.botPet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BotPetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BotPetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BotPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotPets
     * const botPets = await prisma.botPet.findMany()
     * 
     * // Get first 10 BotPets
     * const botPets = await prisma.botPet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botPetWithIdOnly = await prisma.botPet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BotPetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BotPetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BotPet.
     * @param {BotPetCreateArgs} args - Arguments to create a BotPet.
     * @example
     * // Create one BotPet
     * const BotPet = await prisma.botPet.create({
     *   data: {
     *     // ... data to create a BotPet
     *   }
     * })
     * 
    **/
    create<T extends BotPetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BotPetCreateArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BotPets.
     *     @param {BotPetCreateManyArgs} args - Arguments to create many BotPets.
     *     @example
     *     // Create many BotPets
     *     const botPet = await prisma.botPet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BotPetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BotPetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BotPet.
     * @param {BotPetDeleteArgs} args - Arguments to delete one BotPet.
     * @example
     * // Delete one BotPet
     * const BotPet = await prisma.botPet.delete({
     *   where: {
     *     // ... filter to delete one BotPet
     *   }
     * })
     * 
    **/
    delete<T extends BotPetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BotPetDeleteArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BotPet.
     * @param {BotPetUpdateArgs} args - Arguments to update one BotPet.
     * @example
     * // Update one BotPet
     * const botPet = await prisma.botPet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BotPetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BotPetUpdateArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BotPets.
     * @param {BotPetDeleteManyArgs} args - Arguments to filter BotPets to delete.
     * @example
     * // Delete a few BotPets
     * const { count } = await prisma.botPet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BotPetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BotPetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotPets
     * const botPet = await prisma.botPet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BotPetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BotPetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BotPet.
     * @param {BotPetUpsertArgs} args - Arguments to update or create a BotPet.
     * @example
     * // Update or create a BotPet
     * const botPet = await prisma.botPet.upsert({
     *   create: {
     *     // ... data to create a BotPet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotPet we want to update
     *   }
     * })
    **/
    upsert<T extends BotPetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BotPetUpsertArgs<ExtArgs>>
    ): Prisma__BotPetClient<$Result.GetResult<Prisma.$BotPetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BotPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetCountArgs} args - Arguments to filter BotPets to count.
     * @example
     * // Count the number of BotPets
     * const count = await prisma.botPet.count({
     *   where: {
     *     // ... the filter for the BotPets we want to count
     *   }
     * })
    **/
    count<T extends BotPetCountArgs>(
      args?: Subset<T, BotPetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotPetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotPetAggregateArgs>(args: Subset<T, BotPetAggregateArgs>): Prisma.PrismaPromise<GetBotPetAggregateType<T>>

    /**
     * Group by BotPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotPetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotPetGroupByArgs['orderBy'] }
        : { orderBy?: BotPetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotPetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotPet model
   */
  readonly fields: BotPetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotPet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotPetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BotPet model
   */ 
  interface BotPetFieldRefs {
    readonly id: FieldRef<"BotPet", 'Int'>
    readonly userId: FieldRef<"BotPet", 'Int'>
    readonly roomId: FieldRef<"BotPet", 'Int'>
    readonly name: FieldRef<"BotPet", 'String'>
    readonly race: FieldRef<"BotPet", 'String'>
    readonly color: FieldRef<"BotPet", 'String'>
    readonly type: FieldRef<"BotPet", 'Int'>
    readonly experience: FieldRef<"BotPet", 'Int'>
    readonly energy: FieldRef<"BotPet", 'Int'>
    readonly nutrition: FieldRef<"BotPet", 'Int'>
    readonly respect: FieldRef<"BotPet", 'Int'>
    readonly createstamp: FieldRef<"BotPet", 'Int'>
    readonly x: FieldRef<"BotPet", 'Int'>
    readonly y: FieldRef<"BotPet", 'Int'>
    readonly z: FieldRef<"BotPet", 'Float'>
    readonly haveSaddle: FieldRef<"BotPet", 'Int'>
    readonly hairdye: FieldRef<"BotPet", 'Int'>
    readonly pethair: FieldRef<"BotPet", 'Int'>
    readonly anyoneRide: FieldRef<"BotPet", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * BotPet findUnique
   */
  export type BotPetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * Filter, which BotPet to fetch.
     */
    where: BotPetWhereUniqueInput
  }


  /**
   * BotPet findUniqueOrThrow
   */
  export type BotPetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * Filter, which BotPet to fetch.
     */
    where: BotPetWhereUniqueInput
  }


  /**
   * BotPet findFirst
   */
  export type BotPetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * Filter, which BotPet to fetch.
     */
    where?: BotPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPets to fetch.
     */
    orderBy?: BotPetOrderByWithRelationInput | BotPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotPets.
     */
    cursor?: BotPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotPets.
     */
    distinct?: BotPetScalarFieldEnum | BotPetScalarFieldEnum[]
  }


  /**
   * BotPet findFirstOrThrow
   */
  export type BotPetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * Filter, which BotPet to fetch.
     */
    where?: BotPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPets to fetch.
     */
    orderBy?: BotPetOrderByWithRelationInput | BotPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotPets.
     */
    cursor?: BotPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotPets.
     */
    distinct?: BotPetScalarFieldEnum | BotPetScalarFieldEnum[]
  }


  /**
   * BotPet findMany
   */
  export type BotPetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * Filter, which BotPets to fetch.
     */
    where?: BotPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPets to fetch.
     */
    orderBy?: BotPetOrderByWithRelationInput | BotPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotPets.
     */
    cursor?: BotPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPets.
     */
    skip?: number
    distinct?: BotPetScalarFieldEnum | BotPetScalarFieldEnum[]
  }


  /**
   * BotPet create
   */
  export type BotPetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * The data needed to create a BotPet.
     */
    data: XOR<BotPetCreateInput, BotPetUncheckedCreateInput>
  }


  /**
   * BotPet createMany
   */
  export type BotPetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotPets.
     */
    data: BotPetCreateManyInput | BotPetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BotPet update
   */
  export type BotPetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * The data needed to update a BotPet.
     */
    data: XOR<BotPetUpdateInput, BotPetUncheckedUpdateInput>
    /**
     * Choose, which BotPet to update.
     */
    where: BotPetWhereUniqueInput
  }


  /**
   * BotPet updateMany
   */
  export type BotPetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotPets.
     */
    data: XOR<BotPetUpdateManyMutationInput, BotPetUncheckedUpdateManyInput>
    /**
     * Filter which BotPets to update
     */
    where?: BotPetWhereInput
  }


  /**
   * BotPet upsert
   */
  export type BotPetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * The filter to search for the BotPet to update in case it exists.
     */
    where: BotPetWhereUniqueInput
    /**
     * In case the BotPet found by the `where` argument doesn't exist, create a new BotPet with this data.
     */
    create: XOR<BotPetCreateInput, BotPetUncheckedCreateInput>
    /**
     * In case the BotPet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotPetUpdateInput, BotPetUncheckedUpdateInput>
  }


  /**
   * BotPet delete
   */
  export type BotPetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
    /**
     * Filter which BotPet to delete.
     */
    where: BotPetWhereUniqueInput
  }


  /**
   * BotPet deleteMany
   */
  export type BotPetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotPets to delete
     */
    where?: BotPetWhereInput
  }


  /**
   * BotPet without action
   */
  export type BotPetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPet
     */
    select?: BotPetSelect<ExtArgs> | null
  }



  /**
   * Model BotUser
   */

  export type AggregateBotUser = {
    _count: BotUserCountAggregateOutputType | null
    _avg: BotUserAvgAggregateOutputType | null
    _sum: BotUserSumAggregateOutputType | null
    _min: BotUserMinAggregateOutputType | null
    _max: BotUserMaxAggregateOutputType | null
  }

  export type BotUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    x: number | null
    y: number | null
    z: number | null
    rotation: number | null
    chatSeconds: number | null
    status: number | null
    enable: number | null
    handitem: number | null
  }

  export type BotUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    x: number | null
    y: number | null
    z: number | null
    rotation: number | null
    chatSeconds: number | null
    status: number | null
    enable: number | null
    handitem: number | null
  }

  export type BotUserMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    motto: string | null
    gender: string | null
    look: string | null
    roomId: number | null
    walkEnabled: boolean | null
    x: number | null
    y: number | null
    z: number | null
    rotation: number | null
    chatEnabled: boolean | null
    chatText: string | null
    chatSeconds: number | null
    isDancing: boolean | null
    isMixchat: boolean | null
    status: number | null
    enable: number | null
    handitem: number | null
    aiType: $Enums.BotUserAiType | null
  }

  export type BotUserMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    motto: string | null
    gender: string | null
    look: string | null
    roomId: number | null
    walkEnabled: boolean | null
    x: number | null
    y: number | null
    z: number | null
    rotation: number | null
    chatEnabled: boolean | null
    chatText: string | null
    chatSeconds: number | null
    isDancing: boolean | null
    isMixchat: boolean | null
    status: number | null
    enable: number | null
    handitem: number | null
    aiType: $Enums.BotUserAiType | null
  }

  export type BotUserCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    motto: number
    gender: number
    look: number
    roomId: number
    walkEnabled: number
    x: number
    y: number
    z: number
    rotation: number
    chatEnabled: number
    chatText: number
    chatSeconds: number
    isDancing: number
    isMixchat: number
    status: number
    enable: number
    handitem: number
    aiType: number
    _all: number
  }


  export type BotUserAvgAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    x?: true
    y?: true
    z?: true
    rotation?: true
    chatSeconds?: true
    status?: true
    enable?: true
    handitem?: true
  }

  export type BotUserSumAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    x?: true
    y?: true
    z?: true
    rotation?: true
    chatSeconds?: true
    status?: true
    enable?: true
    handitem?: true
  }

  export type BotUserMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    motto?: true
    gender?: true
    look?: true
    roomId?: true
    walkEnabled?: true
    x?: true
    y?: true
    z?: true
    rotation?: true
    chatEnabled?: true
    chatText?: true
    chatSeconds?: true
    isDancing?: true
    isMixchat?: true
    status?: true
    enable?: true
    handitem?: true
    aiType?: true
  }

  export type BotUserMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    motto?: true
    gender?: true
    look?: true
    roomId?: true
    walkEnabled?: true
    x?: true
    y?: true
    z?: true
    rotation?: true
    chatEnabled?: true
    chatText?: true
    chatSeconds?: true
    isDancing?: true
    isMixchat?: true
    status?: true
    enable?: true
    handitem?: true
    aiType?: true
  }

  export type BotUserCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    motto?: true
    gender?: true
    look?: true
    roomId?: true
    walkEnabled?: true
    x?: true
    y?: true
    z?: true
    rotation?: true
    chatEnabled?: true
    chatText?: true
    chatSeconds?: true
    isDancing?: true
    isMixchat?: true
    status?: true
    enable?: true
    handitem?: true
    aiType?: true
    _all?: true
  }

  export type BotUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotUser to aggregate.
     */
    where?: BotUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsers to fetch.
     */
    orderBy?: BotUserOrderByWithRelationInput | BotUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotUsers
    **/
    _count?: true | BotUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotUserMaxAggregateInputType
  }

  export type GetBotUserAggregateType<T extends BotUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBotUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotUser[P]>
      : GetScalarType<T[P], AggregateBotUser[P]>
  }




  export type BotUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUserWhereInput
    orderBy?: BotUserOrderByWithAggregationInput | BotUserOrderByWithAggregationInput[]
    by: BotUserScalarFieldEnum[] | BotUserScalarFieldEnum
    having?: BotUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotUserCountAggregateInputType | true
    _avg?: BotUserAvgAggregateInputType
    _sum?: BotUserSumAggregateInputType
    _min?: BotUserMinAggregateInputType
    _max?: BotUserMaxAggregateInputType
  }

  export type BotUserGroupByOutputType = {
    id: number
    userId: number
    name: string
    motto: string
    gender: string
    look: string
    roomId: number
    walkEnabled: boolean
    x: number
    y: number
    z: number
    rotation: number
    chatEnabled: boolean
    chatText: string
    chatSeconds: number
    isDancing: boolean
    isMixchat: boolean
    status: number
    enable: number
    handitem: number
    aiType: $Enums.BotUserAiType
    _count: BotUserCountAggregateOutputType | null
    _avg: BotUserAvgAggregateOutputType | null
    _sum: BotUserSumAggregateOutputType | null
    _min: BotUserMinAggregateOutputType | null
    _max: BotUserMaxAggregateOutputType | null
  }

  type GetBotUserGroupByPayload<T extends BotUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotUserGroupByOutputType[P]>
            : GetScalarType<T[P], BotUserGroupByOutputType[P]>
        }
      >
    >


  export type BotUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    motto?: boolean
    gender?: boolean
    look?: boolean
    roomId?: boolean
    walkEnabled?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    rotation?: boolean
    chatEnabled?: boolean
    chatText?: boolean
    chatSeconds?: boolean
    isDancing?: boolean
    isMixchat?: boolean
    status?: boolean
    enable?: boolean
    handitem?: boolean
    aiType?: boolean
  }, ExtArgs["result"]["botUser"]>

  export type BotUserSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    motto?: boolean
    gender?: boolean
    look?: boolean
    roomId?: boolean
    walkEnabled?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    rotation?: boolean
    chatEnabled?: boolean
    chatText?: boolean
    chatSeconds?: boolean
    isDancing?: boolean
    isMixchat?: boolean
    status?: boolean
    enable?: boolean
    handitem?: boolean
    aiType?: boolean
  }


  export type $BotUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      motto: string
      gender: string
      look: string
      roomId: number
      walkEnabled: boolean
      x: number
      y: number
      z: number
      rotation: number
      chatEnabled: boolean
      chatText: string
      chatSeconds: number
      isDancing: boolean
      isMixchat: boolean
      status: number
      enable: number
      handitem: number
      aiType: $Enums.BotUserAiType
    }, ExtArgs["result"]["botUser"]>
    composites: {}
  }


  type BotUserGetPayload<S extends boolean | null | undefined | BotUserDefaultArgs> = $Result.GetResult<Prisma.$BotUserPayload, S>

  type BotUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BotUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BotUserCountAggregateInputType | true
    }

  export interface BotUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotUser'], meta: { name: 'BotUser' } }
    /**
     * Find zero or one BotUser that matches the filter.
     * @param {BotUserFindUniqueArgs} args - Arguments to find a BotUser
     * @example
     * // Get one BotUser
     * const botUser = await prisma.botUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BotUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BotUserFindUniqueArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BotUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BotUserFindUniqueOrThrowArgs} args - Arguments to find a BotUser
     * @example
     * // Get one BotUser
     * const botUser = await prisma.botUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BotUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BotUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BotUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserFindFirstArgs} args - Arguments to find a BotUser
     * @example
     * // Get one BotUser
     * const botUser = await prisma.botUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BotUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BotUserFindFirstArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BotUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserFindFirstOrThrowArgs} args - Arguments to find a BotUser
     * @example
     * // Get one BotUser
     * const botUser = await prisma.botUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BotUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BotUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BotUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotUsers
     * const botUsers = await prisma.botUser.findMany()
     * 
     * // Get first 10 BotUsers
     * const botUsers = await prisma.botUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botUserWithIdOnly = await prisma.botUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BotUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BotUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BotUser.
     * @param {BotUserCreateArgs} args - Arguments to create a BotUser.
     * @example
     * // Create one BotUser
     * const BotUser = await prisma.botUser.create({
     *   data: {
     *     // ... data to create a BotUser
     *   }
     * })
     * 
    **/
    create<T extends BotUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BotUserCreateArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BotUsers.
     *     @param {BotUserCreateManyArgs} args - Arguments to create many BotUsers.
     *     @example
     *     // Create many BotUsers
     *     const botUser = await prisma.botUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BotUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BotUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BotUser.
     * @param {BotUserDeleteArgs} args - Arguments to delete one BotUser.
     * @example
     * // Delete one BotUser
     * const BotUser = await prisma.botUser.delete({
     *   where: {
     *     // ... filter to delete one BotUser
     *   }
     * })
     * 
    **/
    delete<T extends BotUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BotUserDeleteArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BotUser.
     * @param {BotUserUpdateArgs} args - Arguments to update one BotUser.
     * @example
     * // Update one BotUser
     * const botUser = await prisma.botUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BotUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BotUserUpdateArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BotUsers.
     * @param {BotUserDeleteManyArgs} args - Arguments to filter BotUsers to delete.
     * @example
     * // Delete a few BotUsers
     * const { count } = await prisma.botUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BotUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BotUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotUsers
     * const botUser = await prisma.botUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BotUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BotUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BotUser.
     * @param {BotUserUpsertArgs} args - Arguments to update or create a BotUser.
     * @example
     * // Update or create a BotUser
     * const botUser = await prisma.botUser.upsert({
     *   create: {
     *     // ... data to create a BotUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotUser we want to update
     *   }
     * })
    **/
    upsert<T extends BotUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BotUserUpsertArgs<ExtArgs>>
    ): Prisma__BotUserClient<$Result.GetResult<Prisma.$BotUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BotUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserCountArgs} args - Arguments to filter BotUsers to count.
     * @example
     * // Count the number of BotUsers
     * const count = await prisma.botUser.count({
     *   where: {
     *     // ... the filter for the BotUsers we want to count
     *   }
     * })
    **/
    count<T extends BotUserCountArgs>(
      args?: Subset<T, BotUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotUserAggregateArgs>(args: Subset<T, BotUserAggregateArgs>): Prisma.PrismaPromise<GetBotUserAggregateType<T>>

    /**
     * Group by BotUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotUserGroupByArgs['orderBy'] }
        : { orderBy?: BotUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotUser model
   */
  readonly fields: BotUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BotUser model
   */ 
  interface BotUserFieldRefs {
    readonly id: FieldRef<"BotUser", 'Int'>
    readonly userId: FieldRef<"BotUser", 'Int'>
    readonly name: FieldRef<"BotUser", 'String'>
    readonly motto: FieldRef<"BotUser", 'String'>
    readonly gender: FieldRef<"BotUser", 'String'>
    readonly look: FieldRef<"BotUser", 'String'>
    readonly roomId: FieldRef<"BotUser", 'Int'>
    readonly walkEnabled: FieldRef<"BotUser", 'Boolean'>
    readonly x: FieldRef<"BotUser", 'Int'>
    readonly y: FieldRef<"BotUser", 'Int'>
    readonly z: FieldRef<"BotUser", 'Int'>
    readonly rotation: FieldRef<"BotUser", 'Int'>
    readonly chatEnabled: FieldRef<"BotUser", 'Boolean'>
    readonly chatText: FieldRef<"BotUser", 'String'>
    readonly chatSeconds: FieldRef<"BotUser", 'Int'>
    readonly isDancing: FieldRef<"BotUser", 'Boolean'>
    readonly isMixchat: FieldRef<"BotUser", 'Boolean'>
    readonly status: FieldRef<"BotUser", 'Int'>
    readonly enable: FieldRef<"BotUser", 'Int'>
    readonly handitem: FieldRef<"BotUser", 'Int'>
    readonly aiType: FieldRef<"BotUser", 'BotUserAiType'>
  }
    

  // Custom InputTypes

  /**
   * BotUser findUnique
   */
  export type BotUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * Filter, which BotUser to fetch.
     */
    where: BotUserWhereUniqueInput
  }


  /**
   * BotUser findUniqueOrThrow
   */
  export type BotUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * Filter, which BotUser to fetch.
     */
    where: BotUserWhereUniqueInput
  }


  /**
   * BotUser findFirst
   */
  export type BotUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * Filter, which BotUser to fetch.
     */
    where?: BotUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsers to fetch.
     */
    orderBy?: BotUserOrderByWithRelationInput | BotUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotUsers.
     */
    cursor?: BotUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotUsers.
     */
    distinct?: BotUserScalarFieldEnum | BotUserScalarFieldEnum[]
  }


  /**
   * BotUser findFirstOrThrow
   */
  export type BotUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * Filter, which BotUser to fetch.
     */
    where?: BotUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsers to fetch.
     */
    orderBy?: BotUserOrderByWithRelationInput | BotUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotUsers.
     */
    cursor?: BotUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotUsers.
     */
    distinct?: BotUserScalarFieldEnum | BotUserScalarFieldEnum[]
  }


  /**
   * BotUser findMany
   */
  export type BotUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * Filter, which BotUsers to fetch.
     */
    where?: BotUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsers to fetch.
     */
    orderBy?: BotUserOrderByWithRelationInput | BotUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotUsers.
     */
    cursor?: BotUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsers.
     */
    skip?: number
    distinct?: BotUserScalarFieldEnum | BotUserScalarFieldEnum[]
  }


  /**
   * BotUser create
   */
  export type BotUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * The data needed to create a BotUser.
     */
    data: XOR<BotUserCreateInput, BotUserUncheckedCreateInput>
  }


  /**
   * BotUser createMany
   */
  export type BotUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotUsers.
     */
    data: BotUserCreateManyInput | BotUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BotUser update
   */
  export type BotUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * The data needed to update a BotUser.
     */
    data: XOR<BotUserUpdateInput, BotUserUncheckedUpdateInput>
    /**
     * Choose, which BotUser to update.
     */
    where: BotUserWhereUniqueInput
  }


  /**
   * BotUser updateMany
   */
  export type BotUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotUsers.
     */
    data: XOR<BotUserUpdateManyMutationInput, BotUserUncheckedUpdateManyInput>
    /**
     * Filter which BotUsers to update
     */
    where?: BotUserWhereInput
  }


  /**
   * BotUser upsert
   */
  export type BotUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * The filter to search for the BotUser to update in case it exists.
     */
    where: BotUserWhereUniqueInput
    /**
     * In case the BotUser found by the `where` argument doesn't exist, create a new BotUser with this data.
     */
    create: XOR<BotUserCreateInput, BotUserUncheckedCreateInput>
    /**
     * In case the BotUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotUserUpdateInput, BotUserUncheckedUpdateInput>
  }


  /**
   * BotUser delete
   */
  export type BotUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
    /**
     * Filter which BotUser to delete.
     */
    where: BotUserWhereUniqueInput
  }


  /**
   * BotUser deleteMany
   */
  export type BotUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotUsers to delete
     */
    where?: BotUserWhereInput
  }


  /**
   * BotUser without action
   */
  export type BotUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUser
     */
    select?: BotUserSelect<ExtArgs> | null
  }



  /**
   * Model CatalogBotPreset
   */

  export type AggregateCatalogBotPreset = {
    _count: CatalogBotPresetCountAggregateOutputType | null
    _avg: CatalogBotPresetAvgAggregateOutputType | null
    _sum: CatalogBotPresetSumAggregateOutputType | null
    _min: CatalogBotPresetMinAggregateOutputType | null
    _max: CatalogBotPresetMaxAggregateOutputType | null
  }

  export type CatalogBotPresetAvgAggregateOutputType = {
    id: number | null
  }

  export type CatalogBotPresetSumAggregateOutputType = {
    id: number | null
  }

  export type CatalogBotPresetMinAggregateOutputType = {
    id: number | null
    name: string | null
    figure: string | null
    gender: string | null
    motto: string | null
    aiType: $Enums.CatalogBotPresetAiType | null
  }

  export type CatalogBotPresetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    figure: string | null
    gender: string | null
    motto: string | null
    aiType: $Enums.CatalogBotPresetAiType | null
  }

  export type CatalogBotPresetCountAggregateOutputType = {
    id: number
    name: number
    figure: number
    gender: number
    motto: number
    aiType: number
    _all: number
  }


  export type CatalogBotPresetAvgAggregateInputType = {
    id?: true
  }

  export type CatalogBotPresetSumAggregateInputType = {
    id?: true
  }

  export type CatalogBotPresetMinAggregateInputType = {
    id?: true
    name?: true
    figure?: true
    gender?: true
    motto?: true
    aiType?: true
  }

  export type CatalogBotPresetMaxAggregateInputType = {
    id?: true
    name?: true
    figure?: true
    gender?: true
    motto?: true
    aiType?: true
  }

  export type CatalogBotPresetCountAggregateInputType = {
    id?: true
    name?: true
    figure?: true
    gender?: true
    motto?: true
    aiType?: true
    _all?: true
  }

  export type CatalogBotPresetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogBotPreset to aggregate.
     */
    where?: CatalogBotPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBotPresets to fetch.
     */
    orderBy?: CatalogBotPresetOrderByWithRelationInput | CatalogBotPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogBotPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBotPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBotPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogBotPresets
    **/
    _count?: true | CatalogBotPresetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogBotPresetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogBotPresetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogBotPresetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogBotPresetMaxAggregateInputType
  }

  export type GetCatalogBotPresetAggregateType<T extends CatalogBotPresetAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogBotPreset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogBotPreset[P]>
      : GetScalarType<T[P], AggregateCatalogBotPreset[P]>
  }




  export type CatalogBotPresetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogBotPresetWhereInput
    orderBy?: CatalogBotPresetOrderByWithAggregationInput | CatalogBotPresetOrderByWithAggregationInput[]
    by: CatalogBotPresetScalarFieldEnum[] | CatalogBotPresetScalarFieldEnum
    having?: CatalogBotPresetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogBotPresetCountAggregateInputType | true
    _avg?: CatalogBotPresetAvgAggregateInputType
    _sum?: CatalogBotPresetSumAggregateInputType
    _min?: CatalogBotPresetMinAggregateInputType
    _max?: CatalogBotPresetMaxAggregateInputType
  }

  export type CatalogBotPresetGroupByOutputType = {
    id: number
    name: string
    figure: string
    gender: string
    motto: string
    aiType: $Enums.CatalogBotPresetAiType
    _count: CatalogBotPresetCountAggregateOutputType | null
    _avg: CatalogBotPresetAvgAggregateOutputType | null
    _sum: CatalogBotPresetSumAggregateOutputType | null
    _min: CatalogBotPresetMinAggregateOutputType | null
    _max: CatalogBotPresetMaxAggregateOutputType | null
  }

  type GetCatalogBotPresetGroupByPayload<T extends CatalogBotPresetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogBotPresetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogBotPresetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogBotPresetGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogBotPresetGroupByOutputType[P]>
        }
      >
    >


  export type CatalogBotPresetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    figure?: boolean
    gender?: boolean
    motto?: boolean
    aiType?: boolean
  }, ExtArgs["result"]["catalogBotPreset"]>

  export type CatalogBotPresetSelectScalar = {
    id?: boolean
    name?: boolean
    figure?: boolean
    gender?: boolean
    motto?: boolean
    aiType?: boolean
  }


  export type $CatalogBotPresetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogBotPreset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      figure: string
      gender: string
      motto: string
      aiType: $Enums.CatalogBotPresetAiType
    }, ExtArgs["result"]["catalogBotPreset"]>
    composites: {}
  }


  type CatalogBotPresetGetPayload<S extends boolean | null | undefined | CatalogBotPresetDefaultArgs> = $Result.GetResult<Prisma.$CatalogBotPresetPayload, S>

  type CatalogBotPresetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogBotPresetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogBotPresetCountAggregateInputType | true
    }

  export interface CatalogBotPresetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogBotPreset'], meta: { name: 'CatalogBotPreset' } }
    /**
     * Find zero or one CatalogBotPreset that matches the filter.
     * @param {CatalogBotPresetFindUniqueArgs} args - Arguments to find a CatalogBotPreset
     * @example
     * // Get one CatalogBotPreset
     * const catalogBotPreset = await prisma.catalogBotPreset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogBotPresetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogBotPresetFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogBotPreset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogBotPresetFindUniqueOrThrowArgs} args - Arguments to find a CatalogBotPreset
     * @example
     * // Get one CatalogBotPreset
     * const catalogBotPreset = await prisma.catalogBotPreset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogBotPresetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogBotPresetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogBotPreset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetFindFirstArgs} args - Arguments to find a CatalogBotPreset
     * @example
     * // Get one CatalogBotPreset
     * const catalogBotPreset = await prisma.catalogBotPreset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogBotPresetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogBotPresetFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogBotPreset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetFindFirstOrThrowArgs} args - Arguments to find a CatalogBotPreset
     * @example
     * // Get one CatalogBotPreset
     * const catalogBotPreset = await prisma.catalogBotPreset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogBotPresetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogBotPresetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogBotPresets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogBotPresets
     * const catalogBotPresets = await prisma.catalogBotPreset.findMany()
     * 
     * // Get first 10 CatalogBotPresets
     * const catalogBotPresets = await prisma.catalogBotPreset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogBotPresetWithIdOnly = await prisma.catalogBotPreset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogBotPresetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogBotPresetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogBotPreset.
     * @param {CatalogBotPresetCreateArgs} args - Arguments to create a CatalogBotPreset.
     * @example
     * // Create one CatalogBotPreset
     * const CatalogBotPreset = await prisma.catalogBotPreset.create({
     *   data: {
     *     // ... data to create a CatalogBotPreset
     *   }
     * })
     * 
    **/
    create<T extends CatalogBotPresetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogBotPresetCreateArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogBotPresets.
     *     @param {CatalogBotPresetCreateManyArgs} args - Arguments to create many CatalogBotPresets.
     *     @example
     *     // Create many CatalogBotPresets
     *     const catalogBotPreset = await prisma.catalogBotPreset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogBotPresetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogBotPresetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogBotPreset.
     * @param {CatalogBotPresetDeleteArgs} args - Arguments to delete one CatalogBotPreset.
     * @example
     * // Delete one CatalogBotPreset
     * const CatalogBotPreset = await prisma.catalogBotPreset.delete({
     *   where: {
     *     // ... filter to delete one CatalogBotPreset
     *   }
     * })
     * 
    **/
    delete<T extends CatalogBotPresetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogBotPresetDeleteArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogBotPreset.
     * @param {CatalogBotPresetUpdateArgs} args - Arguments to update one CatalogBotPreset.
     * @example
     * // Update one CatalogBotPreset
     * const catalogBotPreset = await prisma.catalogBotPreset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogBotPresetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogBotPresetUpdateArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogBotPresets.
     * @param {CatalogBotPresetDeleteManyArgs} args - Arguments to filter CatalogBotPresets to delete.
     * @example
     * // Delete a few CatalogBotPresets
     * const { count } = await prisma.catalogBotPreset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogBotPresetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogBotPresetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogBotPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogBotPresets
     * const catalogBotPreset = await prisma.catalogBotPreset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogBotPresetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogBotPresetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogBotPreset.
     * @param {CatalogBotPresetUpsertArgs} args - Arguments to update or create a CatalogBotPreset.
     * @example
     * // Update or create a CatalogBotPreset
     * const catalogBotPreset = await prisma.catalogBotPreset.upsert({
     *   create: {
     *     // ... data to create a CatalogBotPreset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogBotPreset we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogBotPresetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogBotPresetUpsertArgs<ExtArgs>>
    ): Prisma__CatalogBotPresetClient<$Result.GetResult<Prisma.$CatalogBotPresetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogBotPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetCountArgs} args - Arguments to filter CatalogBotPresets to count.
     * @example
     * // Count the number of CatalogBotPresets
     * const count = await prisma.catalogBotPreset.count({
     *   where: {
     *     // ... the filter for the CatalogBotPresets we want to count
     *   }
     * })
    **/
    count<T extends CatalogBotPresetCountArgs>(
      args?: Subset<T, CatalogBotPresetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogBotPresetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogBotPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogBotPresetAggregateArgs>(args: Subset<T, CatalogBotPresetAggregateArgs>): Prisma.PrismaPromise<GetCatalogBotPresetAggregateType<T>>

    /**
     * Group by CatalogBotPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogBotPresetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogBotPresetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogBotPresetGroupByArgs['orderBy'] }
        : { orderBy?: CatalogBotPresetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogBotPresetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogBotPresetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogBotPreset model
   */
  readonly fields: CatalogBotPresetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogBotPreset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogBotPresetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogBotPreset model
   */ 
  interface CatalogBotPresetFieldRefs {
    readonly id: FieldRef<"CatalogBotPreset", 'Int'>
    readonly name: FieldRef<"CatalogBotPreset", 'String'>
    readonly figure: FieldRef<"CatalogBotPreset", 'String'>
    readonly gender: FieldRef<"CatalogBotPreset", 'String'>
    readonly motto: FieldRef<"CatalogBotPreset", 'String'>
    readonly aiType: FieldRef<"CatalogBotPreset", 'CatalogBotPresetAiType'>
  }
    

  // Custom InputTypes

  /**
   * CatalogBotPreset findUnique
   */
  export type CatalogBotPresetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * Filter, which CatalogBotPreset to fetch.
     */
    where: CatalogBotPresetWhereUniqueInput
  }


  /**
   * CatalogBotPreset findUniqueOrThrow
   */
  export type CatalogBotPresetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * Filter, which CatalogBotPreset to fetch.
     */
    where: CatalogBotPresetWhereUniqueInput
  }


  /**
   * CatalogBotPreset findFirst
   */
  export type CatalogBotPresetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * Filter, which CatalogBotPreset to fetch.
     */
    where?: CatalogBotPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBotPresets to fetch.
     */
    orderBy?: CatalogBotPresetOrderByWithRelationInput | CatalogBotPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogBotPresets.
     */
    cursor?: CatalogBotPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBotPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBotPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogBotPresets.
     */
    distinct?: CatalogBotPresetScalarFieldEnum | CatalogBotPresetScalarFieldEnum[]
  }


  /**
   * CatalogBotPreset findFirstOrThrow
   */
  export type CatalogBotPresetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * Filter, which CatalogBotPreset to fetch.
     */
    where?: CatalogBotPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBotPresets to fetch.
     */
    orderBy?: CatalogBotPresetOrderByWithRelationInput | CatalogBotPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogBotPresets.
     */
    cursor?: CatalogBotPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBotPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBotPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogBotPresets.
     */
    distinct?: CatalogBotPresetScalarFieldEnum | CatalogBotPresetScalarFieldEnum[]
  }


  /**
   * CatalogBotPreset findMany
   */
  export type CatalogBotPresetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * Filter, which CatalogBotPresets to fetch.
     */
    where?: CatalogBotPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogBotPresets to fetch.
     */
    orderBy?: CatalogBotPresetOrderByWithRelationInput | CatalogBotPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogBotPresets.
     */
    cursor?: CatalogBotPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogBotPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogBotPresets.
     */
    skip?: number
    distinct?: CatalogBotPresetScalarFieldEnum | CatalogBotPresetScalarFieldEnum[]
  }


  /**
   * CatalogBotPreset create
   */
  export type CatalogBotPresetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogBotPreset.
     */
    data: XOR<CatalogBotPresetCreateInput, CatalogBotPresetUncheckedCreateInput>
  }


  /**
   * CatalogBotPreset createMany
   */
  export type CatalogBotPresetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogBotPresets.
     */
    data: CatalogBotPresetCreateManyInput | CatalogBotPresetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogBotPreset update
   */
  export type CatalogBotPresetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogBotPreset.
     */
    data: XOR<CatalogBotPresetUpdateInput, CatalogBotPresetUncheckedUpdateInput>
    /**
     * Choose, which CatalogBotPreset to update.
     */
    where: CatalogBotPresetWhereUniqueInput
  }


  /**
   * CatalogBotPreset updateMany
   */
  export type CatalogBotPresetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogBotPresets.
     */
    data: XOR<CatalogBotPresetUpdateManyMutationInput, CatalogBotPresetUncheckedUpdateManyInput>
    /**
     * Filter which CatalogBotPresets to update
     */
    where?: CatalogBotPresetWhereInput
  }


  /**
   * CatalogBotPreset upsert
   */
  export type CatalogBotPresetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogBotPreset to update in case it exists.
     */
    where: CatalogBotPresetWhereUniqueInput
    /**
     * In case the CatalogBotPreset found by the `where` argument doesn't exist, create a new CatalogBotPreset with this data.
     */
    create: XOR<CatalogBotPresetCreateInput, CatalogBotPresetUncheckedCreateInput>
    /**
     * In case the CatalogBotPreset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogBotPresetUpdateInput, CatalogBotPresetUncheckedUpdateInput>
  }


  /**
   * CatalogBotPreset delete
   */
  export type CatalogBotPresetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
    /**
     * Filter which CatalogBotPreset to delete.
     */
    where: CatalogBotPresetWhereUniqueInput
  }


  /**
   * CatalogBotPreset deleteMany
   */
  export type CatalogBotPresetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogBotPresets to delete
     */
    where?: CatalogBotPresetWhereInput
  }


  /**
   * CatalogBotPreset without action
   */
  export type CatalogBotPresetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogBotPreset
     */
    select?: CatalogBotPresetSelect<ExtArgs> | null
  }



  /**
   * Model CatalogItem
   */

  export type AggregateCatalogItem = {
    _count: CatalogItemCountAggregateOutputType | null
    _avg: CatalogItemAvgAggregateOutputType | null
    _sum: CatalogItemSumAggregateOutputType | null
    _min: CatalogItemMinAggregateOutputType | null
    _max: CatalogItemMaxAggregateOutputType | null
  }

  export type CatalogItemAvgAggregateOutputType = {
    id: number | null
    pageId: number | null
    itemId: number | null
    costCredits: number | null
    costPixels: number | null
    costDiamonds: number | null
    costLimitcoins: number | null
    amount: number | null
  }

  export type CatalogItemSumAggregateOutputType = {
    id: number | null
    pageId: number | null
    itemId: number | null
    costCredits: number | null
    costPixels: number | null
    costDiamonds: number | null
    costLimitcoins: number | null
    amount: number | null
  }

  export type CatalogItemMinAggregateOutputType = {
    id: number | null
    pageId: number | null
    itemId: number | null
    catalogName: string | null
    costCredits: number | null
    costPixels: number | null
    costDiamonds: number | null
    costLimitcoins: number | null
    amount: number | null
    offerActive: boolean | null
    badge: string | null
  }

  export type CatalogItemMaxAggregateOutputType = {
    id: number | null
    pageId: number | null
    itemId: number | null
    catalogName: string | null
    costCredits: number | null
    costPixels: number | null
    costDiamonds: number | null
    costLimitcoins: number | null
    amount: number | null
    offerActive: boolean | null
    badge: string | null
  }

  export type CatalogItemCountAggregateOutputType = {
    id: number
    pageId: number
    itemId: number
    catalogName: number
    costCredits: number
    costPixels: number
    costDiamonds: number
    costLimitcoins: number
    amount: number
    offerActive: number
    badge: number
    _all: number
  }


  export type CatalogItemAvgAggregateInputType = {
    id?: true
    pageId?: true
    itemId?: true
    costCredits?: true
    costPixels?: true
    costDiamonds?: true
    costLimitcoins?: true
    amount?: true
  }

  export type CatalogItemSumAggregateInputType = {
    id?: true
    pageId?: true
    itemId?: true
    costCredits?: true
    costPixels?: true
    costDiamonds?: true
    costLimitcoins?: true
    amount?: true
  }

  export type CatalogItemMinAggregateInputType = {
    id?: true
    pageId?: true
    itemId?: true
    catalogName?: true
    costCredits?: true
    costPixels?: true
    costDiamonds?: true
    costLimitcoins?: true
    amount?: true
    offerActive?: true
    badge?: true
  }

  export type CatalogItemMaxAggregateInputType = {
    id?: true
    pageId?: true
    itemId?: true
    catalogName?: true
    costCredits?: true
    costPixels?: true
    costDiamonds?: true
    costLimitcoins?: true
    amount?: true
    offerActive?: true
    badge?: true
  }

  export type CatalogItemCountAggregateInputType = {
    id?: true
    pageId?: true
    itemId?: true
    catalogName?: true
    costCredits?: true
    costPixels?: true
    costDiamonds?: true
    costLimitcoins?: true
    amount?: true
    offerActive?: true
    badge?: true
    _all?: true
  }

  export type CatalogItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogItem to aggregate.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogItems
    **/
    _count?: true | CatalogItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogItemMaxAggregateInputType
  }

  export type GetCatalogItemAggregateType<T extends CatalogItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogItem[P]>
      : GetScalarType<T[P], AggregateCatalogItem[P]>
  }




  export type CatalogItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogItemWhereInput
    orderBy?: CatalogItemOrderByWithAggregationInput | CatalogItemOrderByWithAggregationInput[]
    by: CatalogItemScalarFieldEnum[] | CatalogItemScalarFieldEnum
    having?: CatalogItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogItemCountAggregateInputType | true
    _avg?: CatalogItemAvgAggregateInputType
    _sum?: CatalogItemSumAggregateInputType
    _min?: CatalogItemMinAggregateInputType
    _max?: CatalogItemMaxAggregateInputType
  }

  export type CatalogItemGroupByOutputType = {
    id: number
    pageId: number
    itemId: number
    catalogName: string
    costCredits: number
    costPixels: number
    costDiamonds: number
    costLimitcoins: number
    amount: number
    offerActive: boolean
    badge: string
    _count: CatalogItemCountAggregateOutputType | null
    _avg: CatalogItemAvgAggregateOutputType | null
    _sum: CatalogItemSumAggregateOutputType | null
    _min: CatalogItemMinAggregateOutputType | null
    _max: CatalogItemMaxAggregateOutputType | null
  }

  type GetCatalogItemGroupByPayload<T extends CatalogItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogItemGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogItemGroupByOutputType[P]>
        }
      >
    >


  export type CatalogItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    itemId?: boolean
    catalogName?: boolean
    costCredits?: boolean
    costPixels?: boolean
    costDiamonds?: boolean
    costLimitcoins?: boolean
    amount?: boolean
    offerActive?: boolean
    badge?: boolean
    catalogItemLimited?: boolean | CatalogItem$catalogItemLimitedArgs<ExtArgs>
    itemBase?: boolean | ItemBaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogItem"]>

  export type CatalogItemSelectScalar = {
    id?: boolean
    pageId?: boolean
    itemId?: boolean
    catalogName?: boolean
    costCredits?: boolean
    costPixels?: boolean
    costDiamonds?: boolean
    costLimitcoins?: boolean
    amount?: boolean
    offerActive?: boolean
    badge?: boolean
  }

  export type CatalogItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogItemLimited?: boolean | CatalogItem$catalogItemLimitedArgs<ExtArgs>
    itemBase?: boolean | ItemBaseDefaultArgs<ExtArgs>
  }


  export type $CatalogItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogItem"
    objects: {
      catalogItemLimited: Prisma.$CatalogItemLimitedPayload<ExtArgs> | null
      itemBase: Prisma.$ItemBasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pageId: number
      itemId: number
      catalogName: string
      costCredits: number
      costPixels: number
      costDiamonds: number
      costLimitcoins: number
      amount: number
      offerActive: boolean
      badge: string
    }, ExtArgs["result"]["catalogItem"]>
    composites: {}
  }


  type CatalogItemGetPayload<S extends boolean | null | undefined | CatalogItemDefaultArgs> = $Result.GetResult<Prisma.$CatalogItemPayload, S>

  type CatalogItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogItemCountAggregateInputType | true
    }

  export interface CatalogItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogItem'], meta: { name: 'CatalogItem' } }
    /**
     * Find zero or one CatalogItem that matches the filter.
     * @param {CatalogItemFindUniqueArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogItemFindUniqueOrThrowArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemFindFirstArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemFindFirstOrThrowArgs} args - Arguments to find a CatalogItem
     * @example
     * // Get one CatalogItem
     * const catalogItem = await prisma.catalogItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogItems
     * const catalogItems = await prisma.catalogItem.findMany()
     * 
     * // Get first 10 CatalogItems
     * const catalogItems = await prisma.catalogItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogItemWithIdOnly = await prisma.catalogItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogItem.
     * @param {CatalogItemCreateArgs} args - Arguments to create a CatalogItem.
     * @example
     * // Create one CatalogItem
     * const CatalogItem = await prisma.catalogItem.create({
     *   data: {
     *     // ... data to create a CatalogItem
     *   }
     * })
     * 
    **/
    create<T extends CatalogItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemCreateArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogItems.
     *     @param {CatalogItemCreateManyArgs} args - Arguments to create many CatalogItems.
     *     @example
     *     // Create many CatalogItems
     *     const catalogItem = await prisma.catalogItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogItem.
     * @param {CatalogItemDeleteArgs} args - Arguments to delete one CatalogItem.
     * @example
     * // Delete one CatalogItem
     * const CatalogItem = await prisma.catalogItem.delete({
     *   where: {
     *     // ... filter to delete one CatalogItem
     *   }
     * })
     * 
    **/
    delete<T extends CatalogItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemDeleteArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogItem.
     * @param {CatalogItemUpdateArgs} args - Arguments to update one CatalogItem.
     * @example
     * // Update one CatalogItem
     * const catalogItem = await prisma.catalogItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemUpdateArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogItems.
     * @param {CatalogItemDeleteManyArgs} args - Arguments to filter CatalogItems to delete.
     * @example
     * // Delete a few CatalogItems
     * const { count } = await prisma.catalogItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogItems
     * const catalogItem = await prisma.catalogItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogItem.
     * @param {CatalogItemUpsertArgs} args - Arguments to update or create a CatalogItem.
     * @example
     * // Update or create a CatalogItem
     * const catalogItem = await prisma.catalogItem.upsert({
     *   create: {
     *     // ... data to create a CatalogItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogItem we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemUpsertArgs<ExtArgs>>
    ): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemCountArgs} args - Arguments to filter CatalogItems to count.
     * @example
     * // Count the number of CatalogItems
     * const count = await prisma.catalogItem.count({
     *   where: {
     *     // ... the filter for the CatalogItems we want to count
     *   }
     * })
    **/
    count<T extends CatalogItemCountArgs>(
      args?: Subset<T, CatalogItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogItemAggregateArgs>(args: Subset<T, CatalogItemAggregateArgs>): Prisma.PrismaPromise<GetCatalogItemAggregateType<T>>

    /**
     * Group by CatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogItemGroupByArgs['orderBy'] }
        : { orderBy?: CatalogItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogItem model
   */
  readonly fields: CatalogItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    catalogItemLimited<T extends CatalogItem$catalogItemLimitedArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItem$catalogItemLimitedArgs<ExtArgs>>): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    itemBase<T extends ItemBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemBaseDefaultArgs<ExtArgs>>): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogItem model
   */ 
  interface CatalogItemFieldRefs {
    readonly id: FieldRef<"CatalogItem", 'Int'>
    readonly pageId: FieldRef<"CatalogItem", 'Int'>
    readonly itemId: FieldRef<"CatalogItem", 'Int'>
    readonly catalogName: FieldRef<"CatalogItem", 'String'>
    readonly costCredits: FieldRef<"CatalogItem", 'Int'>
    readonly costPixels: FieldRef<"CatalogItem", 'Int'>
    readonly costDiamonds: FieldRef<"CatalogItem", 'Int'>
    readonly costLimitcoins: FieldRef<"CatalogItem", 'Int'>
    readonly amount: FieldRef<"CatalogItem", 'Int'>
    readonly offerActive: FieldRef<"CatalogItem", 'Boolean'>
    readonly badge: FieldRef<"CatalogItem", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CatalogItem findUnique
   */
  export type CatalogItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where: CatalogItemWhereUniqueInput
  }


  /**
   * CatalogItem findUniqueOrThrow
   */
  export type CatalogItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where: CatalogItemWhereUniqueInput
  }


  /**
   * CatalogItem findFirst
   */
  export type CatalogItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogItems.
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogItems.
     */
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }


  /**
   * CatalogItem findFirstOrThrow
   */
  export type CatalogItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItem to fetch.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogItems.
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogItems.
     */
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }


  /**
   * CatalogItem findMany
   */
  export type CatalogItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItems to fetch.
     */
    where?: CatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItems to fetch.
     */
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogItems.
     */
    cursor?: CatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItems.
     */
    skip?: number
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }


  /**
   * CatalogItem create
   */
  export type CatalogItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogItem.
     */
    data: XOR<CatalogItemCreateInput, CatalogItemUncheckedCreateInput>
  }


  /**
   * CatalogItem createMany
   */
  export type CatalogItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogItems.
     */
    data: CatalogItemCreateManyInput | CatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogItem update
   */
  export type CatalogItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogItem.
     */
    data: XOR<CatalogItemUpdateInput, CatalogItemUncheckedUpdateInput>
    /**
     * Choose, which CatalogItem to update.
     */
    where: CatalogItemWhereUniqueInput
  }


  /**
   * CatalogItem updateMany
   */
  export type CatalogItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogItems.
     */
    data: XOR<CatalogItemUpdateManyMutationInput, CatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which CatalogItems to update
     */
    where?: CatalogItemWhereInput
  }


  /**
   * CatalogItem upsert
   */
  export type CatalogItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogItem to update in case it exists.
     */
    where: CatalogItemWhereUniqueInput
    /**
     * In case the CatalogItem found by the `where` argument doesn't exist, create a new CatalogItem with this data.
     */
    create: XOR<CatalogItemCreateInput, CatalogItemUncheckedCreateInput>
    /**
     * In case the CatalogItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogItemUpdateInput, CatalogItemUncheckedUpdateInput>
  }


  /**
   * CatalogItem delete
   */
  export type CatalogItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    /**
     * Filter which CatalogItem to delete.
     */
    where: CatalogItemWhereUniqueInput
  }


  /**
   * CatalogItem deleteMany
   */
  export type CatalogItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogItems to delete
     */
    where?: CatalogItemWhereInput
  }


  /**
   * CatalogItem.catalogItemLimited
   */
  export type CatalogItem$catalogItemLimitedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    where?: CatalogItemLimitedWhereInput
  }


  /**
   * CatalogItem without action
   */
  export type CatalogItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
  }



  /**
   * Model CatalogItemLimited
   */

  export type AggregateCatalogItemLimited = {
    _count: CatalogItemLimitedCountAggregateOutputType | null
    _avg: CatalogItemLimitedAvgAggregateOutputType | null
    _sum: CatalogItemLimitedSumAggregateOutputType | null
    _min: CatalogItemLimitedMinAggregateOutputType | null
    _max: CatalogItemLimitedMaxAggregateOutputType | null
  }

  export type CatalogItemLimitedAvgAggregateOutputType = {
    catalogItemId: number | null
    limitedSells: number | null
    limitedStack: number | null
  }

  export type CatalogItemLimitedSumAggregateOutputType = {
    catalogItemId: number | null
    limitedSells: number | null
    limitedStack: number | null
  }

  export type CatalogItemLimitedMinAggregateOutputType = {
    catalogItemId: number | null
    limitedSells: number | null
    limitedStack: number | null
  }

  export type CatalogItemLimitedMaxAggregateOutputType = {
    catalogItemId: number | null
    limitedSells: number | null
    limitedStack: number | null
  }

  export type CatalogItemLimitedCountAggregateOutputType = {
    catalogItemId: number
    limitedSells: number
    limitedStack: number
    _all: number
  }


  export type CatalogItemLimitedAvgAggregateInputType = {
    catalogItemId?: true
    limitedSells?: true
    limitedStack?: true
  }

  export type CatalogItemLimitedSumAggregateInputType = {
    catalogItemId?: true
    limitedSells?: true
    limitedStack?: true
  }

  export type CatalogItemLimitedMinAggregateInputType = {
    catalogItemId?: true
    limitedSells?: true
    limitedStack?: true
  }

  export type CatalogItemLimitedMaxAggregateInputType = {
    catalogItemId?: true
    limitedSells?: true
    limitedStack?: true
  }

  export type CatalogItemLimitedCountAggregateInputType = {
    catalogItemId?: true
    limitedSells?: true
    limitedStack?: true
    _all?: true
  }

  export type CatalogItemLimitedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogItemLimited to aggregate.
     */
    where?: CatalogItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItemLimiteds to fetch.
     */
    orderBy?: CatalogItemLimitedOrderByWithRelationInput | CatalogItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItemLimiteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogItemLimiteds
    **/
    _count?: true | CatalogItemLimitedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogItemLimitedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogItemLimitedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogItemLimitedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogItemLimitedMaxAggregateInputType
  }

  export type GetCatalogItemLimitedAggregateType<T extends CatalogItemLimitedAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogItemLimited]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogItemLimited[P]>
      : GetScalarType<T[P], AggregateCatalogItemLimited[P]>
  }




  export type CatalogItemLimitedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogItemLimitedWhereInput
    orderBy?: CatalogItemLimitedOrderByWithAggregationInput | CatalogItemLimitedOrderByWithAggregationInput[]
    by: CatalogItemLimitedScalarFieldEnum[] | CatalogItemLimitedScalarFieldEnum
    having?: CatalogItemLimitedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogItemLimitedCountAggregateInputType | true
    _avg?: CatalogItemLimitedAvgAggregateInputType
    _sum?: CatalogItemLimitedSumAggregateInputType
    _min?: CatalogItemLimitedMinAggregateInputType
    _max?: CatalogItemLimitedMaxAggregateInputType
  }

  export type CatalogItemLimitedGroupByOutputType = {
    catalogItemId: number
    limitedSells: number
    limitedStack: number
    _count: CatalogItemLimitedCountAggregateOutputType | null
    _avg: CatalogItemLimitedAvgAggregateOutputType | null
    _sum: CatalogItemLimitedSumAggregateOutputType | null
    _min: CatalogItemLimitedMinAggregateOutputType | null
    _max: CatalogItemLimitedMaxAggregateOutputType | null
  }

  type GetCatalogItemLimitedGroupByPayload<T extends CatalogItemLimitedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogItemLimitedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogItemLimitedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogItemLimitedGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogItemLimitedGroupByOutputType[P]>
        }
      >
    >


  export type CatalogItemLimitedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    catalogItemId?: boolean
    limitedSells?: boolean
    limitedStack?: boolean
    catalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogItemLimited"]>

  export type CatalogItemLimitedSelectScalar = {
    catalogItemId?: boolean
    limitedSells?: boolean
    limitedStack?: boolean
  }

  export type CatalogItemLimitedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catalogItem?: boolean | CatalogItemDefaultArgs<ExtArgs>
  }


  export type $CatalogItemLimitedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogItemLimited"
    objects: {
      catalogItem: Prisma.$CatalogItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      catalogItemId: number
      limitedSells: number
      limitedStack: number
    }, ExtArgs["result"]["catalogItemLimited"]>
    composites: {}
  }


  type CatalogItemLimitedGetPayload<S extends boolean | null | undefined | CatalogItemLimitedDefaultArgs> = $Result.GetResult<Prisma.$CatalogItemLimitedPayload, S>

  type CatalogItemLimitedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogItemLimitedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogItemLimitedCountAggregateInputType | true
    }

  export interface CatalogItemLimitedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogItemLimited'], meta: { name: 'CatalogItemLimited' } }
    /**
     * Find zero or one CatalogItemLimited that matches the filter.
     * @param {CatalogItemLimitedFindUniqueArgs} args - Arguments to find a CatalogItemLimited
     * @example
     * // Get one CatalogItemLimited
     * const catalogItemLimited = await prisma.catalogItemLimited.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogItemLimitedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemLimitedFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogItemLimited that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogItemLimitedFindUniqueOrThrowArgs} args - Arguments to find a CatalogItemLimited
     * @example
     * // Get one CatalogItemLimited
     * const catalogItemLimited = await prisma.catalogItemLimited.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogItemLimitedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemLimitedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogItemLimited that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedFindFirstArgs} args - Arguments to find a CatalogItemLimited
     * @example
     * // Get one CatalogItemLimited
     * const catalogItemLimited = await prisma.catalogItemLimited.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogItemLimitedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemLimitedFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogItemLimited that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedFindFirstOrThrowArgs} args - Arguments to find a CatalogItemLimited
     * @example
     * // Get one CatalogItemLimited
     * const catalogItemLimited = await prisma.catalogItemLimited.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogItemLimitedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemLimitedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogItemLimiteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogItemLimiteds
     * const catalogItemLimiteds = await prisma.catalogItemLimited.findMany()
     * 
     * // Get first 10 CatalogItemLimiteds
     * const catalogItemLimiteds = await prisma.catalogItemLimited.findMany({ take: 10 })
     * 
     * // Only select the `catalogItemId`
     * const catalogItemLimitedWithCatalogItemIdOnly = await prisma.catalogItemLimited.findMany({ select: { catalogItemId: true } })
     * 
    **/
    findMany<T extends CatalogItemLimitedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemLimitedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogItemLimited.
     * @param {CatalogItemLimitedCreateArgs} args - Arguments to create a CatalogItemLimited.
     * @example
     * // Create one CatalogItemLimited
     * const CatalogItemLimited = await prisma.catalogItemLimited.create({
     *   data: {
     *     // ... data to create a CatalogItemLimited
     *   }
     * })
     * 
    **/
    create<T extends CatalogItemLimitedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemLimitedCreateArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogItemLimiteds.
     *     @param {CatalogItemLimitedCreateManyArgs} args - Arguments to create many CatalogItemLimiteds.
     *     @example
     *     // Create many CatalogItemLimiteds
     *     const catalogItemLimited = await prisma.catalogItemLimited.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogItemLimitedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemLimitedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogItemLimited.
     * @param {CatalogItemLimitedDeleteArgs} args - Arguments to delete one CatalogItemLimited.
     * @example
     * // Delete one CatalogItemLimited
     * const CatalogItemLimited = await prisma.catalogItemLimited.delete({
     *   where: {
     *     // ... filter to delete one CatalogItemLimited
     *   }
     * })
     * 
    **/
    delete<T extends CatalogItemLimitedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemLimitedDeleteArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogItemLimited.
     * @param {CatalogItemLimitedUpdateArgs} args - Arguments to update one CatalogItemLimited.
     * @example
     * // Update one CatalogItemLimited
     * const catalogItemLimited = await prisma.catalogItemLimited.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogItemLimitedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemLimitedUpdateArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogItemLimiteds.
     * @param {CatalogItemLimitedDeleteManyArgs} args - Arguments to filter CatalogItemLimiteds to delete.
     * @example
     * // Delete a few CatalogItemLimiteds
     * const { count } = await prisma.catalogItemLimited.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogItemLimitedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogItemLimitedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogItemLimiteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogItemLimiteds
     * const catalogItemLimited = await prisma.catalogItemLimited.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogItemLimitedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemLimitedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogItemLimited.
     * @param {CatalogItemLimitedUpsertArgs} args - Arguments to update or create a CatalogItemLimited.
     * @example
     * // Update or create a CatalogItemLimited
     * const catalogItemLimited = await prisma.catalogItemLimited.upsert({
     *   create: {
     *     // ... data to create a CatalogItemLimited
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogItemLimited we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogItemLimitedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogItemLimitedUpsertArgs<ExtArgs>>
    ): Prisma__CatalogItemLimitedClient<$Result.GetResult<Prisma.$CatalogItemLimitedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogItemLimiteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedCountArgs} args - Arguments to filter CatalogItemLimiteds to count.
     * @example
     * // Count the number of CatalogItemLimiteds
     * const count = await prisma.catalogItemLimited.count({
     *   where: {
     *     // ... the filter for the CatalogItemLimiteds we want to count
     *   }
     * })
    **/
    count<T extends CatalogItemLimitedCountArgs>(
      args?: Subset<T, CatalogItemLimitedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogItemLimitedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogItemLimited.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogItemLimitedAggregateArgs>(args: Subset<T, CatalogItemLimitedAggregateArgs>): Prisma.PrismaPromise<GetCatalogItemLimitedAggregateType<T>>

    /**
     * Group by CatalogItemLimited.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogItemLimitedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogItemLimitedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogItemLimitedGroupByArgs['orderBy'] }
        : { orderBy?: CatalogItemLimitedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogItemLimitedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogItemLimitedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogItemLimited model
   */
  readonly fields: CatalogItemLimitedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogItemLimited.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogItemLimitedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    catalogItem<T extends CatalogItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogItemDefaultArgs<ExtArgs>>): Prisma__CatalogItemClient<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogItemLimited model
   */ 
  interface CatalogItemLimitedFieldRefs {
    readonly catalogItemId: FieldRef<"CatalogItemLimited", 'Int'>
    readonly limitedSells: FieldRef<"CatalogItemLimited", 'Int'>
    readonly limitedStack: FieldRef<"CatalogItemLimited", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CatalogItemLimited findUnique
   */
  export type CatalogItemLimitedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItemLimited to fetch.
     */
    where: CatalogItemLimitedWhereUniqueInput
  }


  /**
   * CatalogItemLimited findUniqueOrThrow
   */
  export type CatalogItemLimitedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItemLimited to fetch.
     */
    where: CatalogItemLimitedWhereUniqueInput
  }


  /**
   * CatalogItemLimited findFirst
   */
  export type CatalogItemLimitedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItemLimited to fetch.
     */
    where?: CatalogItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItemLimiteds to fetch.
     */
    orderBy?: CatalogItemLimitedOrderByWithRelationInput | CatalogItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogItemLimiteds.
     */
    cursor?: CatalogItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItemLimiteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogItemLimiteds.
     */
    distinct?: CatalogItemLimitedScalarFieldEnum | CatalogItemLimitedScalarFieldEnum[]
  }


  /**
   * CatalogItemLimited findFirstOrThrow
   */
  export type CatalogItemLimitedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItemLimited to fetch.
     */
    where?: CatalogItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItemLimiteds to fetch.
     */
    orderBy?: CatalogItemLimitedOrderByWithRelationInput | CatalogItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogItemLimiteds.
     */
    cursor?: CatalogItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItemLimiteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogItemLimiteds.
     */
    distinct?: CatalogItemLimitedScalarFieldEnum | CatalogItemLimitedScalarFieldEnum[]
  }


  /**
   * CatalogItemLimited findMany
   */
  export type CatalogItemLimitedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * Filter, which CatalogItemLimiteds to fetch.
     */
    where?: CatalogItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogItemLimiteds to fetch.
     */
    orderBy?: CatalogItemLimitedOrderByWithRelationInput | CatalogItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogItemLimiteds.
     */
    cursor?: CatalogItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogItemLimiteds.
     */
    skip?: number
    distinct?: CatalogItemLimitedScalarFieldEnum | CatalogItemLimitedScalarFieldEnum[]
  }


  /**
   * CatalogItemLimited create
   */
  export type CatalogItemLimitedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogItemLimited.
     */
    data: XOR<CatalogItemLimitedCreateInput, CatalogItemLimitedUncheckedCreateInput>
  }


  /**
   * CatalogItemLimited createMany
   */
  export type CatalogItemLimitedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogItemLimiteds.
     */
    data: CatalogItemLimitedCreateManyInput | CatalogItemLimitedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogItemLimited update
   */
  export type CatalogItemLimitedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogItemLimited.
     */
    data: XOR<CatalogItemLimitedUpdateInput, CatalogItemLimitedUncheckedUpdateInput>
    /**
     * Choose, which CatalogItemLimited to update.
     */
    where: CatalogItemLimitedWhereUniqueInput
  }


  /**
   * CatalogItemLimited updateMany
   */
  export type CatalogItemLimitedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogItemLimiteds.
     */
    data: XOR<CatalogItemLimitedUpdateManyMutationInput, CatalogItemLimitedUncheckedUpdateManyInput>
    /**
     * Filter which CatalogItemLimiteds to update
     */
    where?: CatalogItemLimitedWhereInput
  }


  /**
   * CatalogItemLimited upsert
   */
  export type CatalogItemLimitedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogItemLimited to update in case it exists.
     */
    where: CatalogItemLimitedWhereUniqueInput
    /**
     * In case the CatalogItemLimited found by the `where` argument doesn't exist, create a new CatalogItemLimited with this data.
     */
    create: XOR<CatalogItemLimitedCreateInput, CatalogItemLimitedUncheckedCreateInput>
    /**
     * In case the CatalogItemLimited was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogItemLimitedUpdateInput, CatalogItemLimitedUncheckedUpdateInput>
  }


  /**
   * CatalogItemLimited delete
   */
  export type CatalogItemLimitedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
    /**
     * Filter which CatalogItemLimited to delete.
     */
    where: CatalogItemLimitedWhereUniqueInput
  }


  /**
   * CatalogItemLimited deleteMany
   */
  export type CatalogItemLimitedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogItemLimiteds to delete
     */
    where?: CatalogItemLimitedWhereInput
  }


  /**
   * CatalogItemLimited without action
   */
  export type CatalogItemLimitedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItemLimited
     */
    select?: CatalogItemLimitedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemLimitedInclude<ExtArgs> | null
  }



  /**
   * Model CatalogMarketplaceData
   */

  export type AggregateCatalogMarketplaceData = {
    _count: CatalogMarketplaceDataCountAggregateOutputType | null
    _avg: CatalogMarketplaceDataAvgAggregateOutputType | null
    _sum: CatalogMarketplaceDataSumAggregateOutputType | null
    _min: CatalogMarketplaceDataMinAggregateOutputType | null
    _max: CatalogMarketplaceDataMaxAggregateOutputType | null
  }

  export type CatalogMarketplaceDataAvgAggregateOutputType = {
    id: number | null
    sprite: number | null
    sold: number | null
    avgprice: number | null
  }

  export type CatalogMarketplaceDataSumAggregateOutputType = {
    id: number | null
    sprite: number | null
    sold: number | null
    avgprice: number | null
  }

  export type CatalogMarketplaceDataMinAggregateOutputType = {
    id: number | null
    sprite: number | null
    sold: number | null
    avgprice: number | null
  }

  export type CatalogMarketplaceDataMaxAggregateOutputType = {
    id: number | null
    sprite: number | null
    sold: number | null
    avgprice: number | null
  }

  export type CatalogMarketplaceDataCountAggregateOutputType = {
    id: number
    sprite: number
    sold: number
    avgprice: number
    _all: number
  }


  export type CatalogMarketplaceDataAvgAggregateInputType = {
    id?: true
    sprite?: true
    sold?: true
    avgprice?: true
  }

  export type CatalogMarketplaceDataSumAggregateInputType = {
    id?: true
    sprite?: true
    sold?: true
    avgprice?: true
  }

  export type CatalogMarketplaceDataMinAggregateInputType = {
    id?: true
    sprite?: true
    sold?: true
    avgprice?: true
  }

  export type CatalogMarketplaceDataMaxAggregateInputType = {
    id?: true
    sprite?: true
    sold?: true
    avgprice?: true
  }

  export type CatalogMarketplaceDataCountAggregateInputType = {
    id?: true
    sprite?: true
    sold?: true
    avgprice?: true
    _all?: true
  }

  export type CatalogMarketplaceDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogMarketplaceData to aggregate.
     */
    where?: CatalogMarketplaceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceData to fetch.
     */
    orderBy?: CatalogMarketplaceDataOrderByWithRelationInput | CatalogMarketplaceDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogMarketplaceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogMarketplaceData
    **/
    _count?: true | CatalogMarketplaceDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogMarketplaceDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogMarketplaceDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogMarketplaceDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogMarketplaceDataMaxAggregateInputType
  }

  export type GetCatalogMarketplaceDataAggregateType<T extends CatalogMarketplaceDataAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogMarketplaceData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogMarketplaceData[P]>
      : GetScalarType<T[P], AggregateCatalogMarketplaceData[P]>
  }




  export type CatalogMarketplaceDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogMarketplaceDataWhereInput
    orderBy?: CatalogMarketplaceDataOrderByWithAggregationInput | CatalogMarketplaceDataOrderByWithAggregationInput[]
    by: CatalogMarketplaceDataScalarFieldEnum[] | CatalogMarketplaceDataScalarFieldEnum
    having?: CatalogMarketplaceDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogMarketplaceDataCountAggregateInputType | true
    _avg?: CatalogMarketplaceDataAvgAggregateInputType
    _sum?: CatalogMarketplaceDataSumAggregateInputType
    _min?: CatalogMarketplaceDataMinAggregateInputType
    _max?: CatalogMarketplaceDataMaxAggregateInputType
  }

  export type CatalogMarketplaceDataGroupByOutputType = {
    id: number
    sprite: number
    sold: number
    avgprice: number
    _count: CatalogMarketplaceDataCountAggregateOutputType | null
    _avg: CatalogMarketplaceDataAvgAggregateOutputType | null
    _sum: CatalogMarketplaceDataSumAggregateOutputType | null
    _min: CatalogMarketplaceDataMinAggregateOutputType | null
    _max: CatalogMarketplaceDataMaxAggregateOutputType | null
  }

  type GetCatalogMarketplaceDataGroupByPayload<T extends CatalogMarketplaceDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogMarketplaceDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogMarketplaceDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogMarketplaceDataGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogMarketplaceDataGroupByOutputType[P]>
        }
      >
    >


  export type CatalogMarketplaceDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sprite?: boolean
    sold?: boolean
    avgprice?: boolean
  }, ExtArgs["result"]["catalogMarketplaceData"]>

  export type CatalogMarketplaceDataSelectScalar = {
    id?: boolean
    sprite?: boolean
    sold?: boolean
    avgprice?: boolean
  }


  export type $CatalogMarketplaceDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogMarketplaceData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sprite: number
      sold: number
      avgprice: number
    }, ExtArgs["result"]["catalogMarketplaceData"]>
    composites: {}
  }


  type CatalogMarketplaceDataGetPayload<S extends boolean | null | undefined | CatalogMarketplaceDataDefaultArgs> = $Result.GetResult<Prisma.$CatalogMarketplaceDataPayload, S>

  type CatalogMarketplaceDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogMarketplaceDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogMarketplaceDataCountAggregateInputType | true
    }

  export interface CatalogMarketplaceDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogMarketplaceData'], meta: { name: 'CatalogMarketplaceData' } }
    /**
     * Find zero or one CatalogMarketplaceData that matches the filter.
     * @param {CatalogMarketplaceDataFindUniqueArgs} args - Arguments to find a CatalogMarketplaceData
     * @example
     * // Get one CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogMarketplaceDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceDataFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogMarketplaceData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogMarketplaceDataFindUniqueOrThrowArgs} args - Arguments to find a CatalogMarketplaceData
     * @example
     * // Get one CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogMarketplaceDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogMarketplaceData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataFindFirstArgs} args - Arguments to find a CatalogMarketplaceData
     * @example
     * // Get one CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogMarketplaceDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceDataFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogMarketplaceData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataFindFirstOrThrowArgs} args - Arguments to find a CatalogMarketplaceData
     * @example
     * // Get one CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogMarketplaceDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogMarketplaceData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findMany()
     * 
     * // Get first 10 CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogMarketplaceDataWithIdOnly = await prisma.catalogMarketplaceData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogMarketplaceDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogMarketplaceData.
     * @param {CatalogMarketplaceDataCreateArgs} args - Arguments to create a CatalogMarketplaceData.
     * @example
     * // Create one CatalogMarketplaceData
     * const CatalogMarketplaceData = await prisma.catalogMarketplaceData.create({
     *   data: {
     *     // ... data to create a CatalogMarketplaceData
     *   }
     * })
     * 
    **/
    create<T extends CatalogMarketplaceDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceDataCreateArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogMarketplaceData.
     *     @param {CatalogMarketplaceDataCreateManyArgs} args - Arguments to create many CatalogMarketplaceData.
     *     @example
     *     // Create many CatalogMarketplaceData
     *     const catalogMarketplaceData = await prisma.catalogMarketplaceData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogMarketplaceDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogMarketplaceData.
     * @param {CatalogMarketplaceDataDeleteArgs} args - Arguments to delete one CatalogMarketplaceData.
     * @example
     * // Delete one CatalogMarketplaceData
     * const CatalogMarketplaceData = await prisma.catalogMarketplaceData.delete({
     *   where: {
     *     // ... filter to delete one CatalogMarketplaceData
     *   }
     * })
     * 
    **/
    delete<T extends CatalogMarketplaceDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceDataDeleteArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogMarketplaceData.
     * @param {CatalogMarketplaceDataUpdateArgs} args - Arguments to update one CatalogMarketplaceData.
     * @example
     * // Update one CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogMarketplaceDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceDataUpdateArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogMarketplaceData.
     * @param {CatalogMarketplaceDataDeleteManyArgs} args - Arguments to filter CatalogMarketplaceData to delete.
     * @example
     * // Delete a few CatalogMarketplaceData
     * const { count } = await prisma.catalogMarketplaceData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogMarketplaceDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogMarketplaceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogMarketplaceDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogMarketplaceData.
     * @param {CatalogMarketplaceDataUpsertArgs} args - Arguments to update or create a CatalogMarketplaceData.
     * @example
     * // Update or create a CatalogMarketplaceData
     * const catalogMarketplaceData = await prisma.catalogMarketplaceData.upsert({
     *   create: {
     *     // ... data to create a CatalogMarketplaceData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogMarketplaceData we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogMarketplaceDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceDataUpsertArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceDataClient<$Result.GetResult<Prisma.$CatalogMarketplaceDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogMarketplaceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataCountArgs} args - Arguments to filter CatalogMarketplaceData to count.
     * @example
     * // Count the number of CatalogMarketplaceData
     * const count = await prisma.catalogMarketplaceData.count({
     *   where: {
     *     // ... the filter for the CatalogMarketplaceData we want to count
     *   }
     * })
    **/
    count<T extends CatalogMarketplaceDataCountArgs>(
      args?: Subset<T, CatalogMarketplaceDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogMarketplaceDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogMarketplaceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogMarketplaceDataAggregateArgs>(args: Subset<T, CatalogMarketplaceDataAggregateArgs>): Prisma.PrismaPromise<GetCatalogMarketplaceDataAggregateType<T>>

    /**
     * Group by CatalogMarketplaceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogMarketplaceDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogMarketplaceDataGroupByArgs['orderBy'] }
        : { orderBy?: CatalogMarketplaceDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogMarketplaceDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogMarketplaceDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogMarketplaceData model
   */
  readonly fields: CatalogMarketplaceDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogMarketplaceData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogMarketplaceDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogMarketplaceData model
   */ 
  interface CatalogMarketplaceDataFieldRefs {
    readonly id: FieldRef<"CatalogMarketplaceData", 'Int'>
    readonly sprite: FieldRef<"CatalogMarketplaceData", 'Int'>
    readonly sold: FieldRef<"CatalogMarketplaceData", 'Int'>
    readonly avgprice: FieldRef<"CatalogMarketplaceData", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CatalogMarketplaceData findUnique
   */
  export type CatalogMarketplaceDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceData to fetch.
     */
    where: CatalogMarketplaceDataWhereUniqueInput
  }


  /**
   * CatalogMarketplaceData findUniqueOrThrow
   */
  export type CatalogMarketplaceDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceData to fetch.
     */
    where: CatalogMarketplaceDataWhereUniqueInput
  }


  /**
   * CatalogMarketplaceData findFirst
   */
  export type CatalogMarketplaceDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceData to fetch.
     */
    where?: CatalogMarketplaceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceData to fetch.
     */
    orderBy?: CatalogMarketplaceDataOrderByWithRelationInput | CatalogMarketplaceDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogMarketplaceData.
     */
    cursor?: CatalogMarketplaceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogMarketplaceData.
     */
    distinct?: CatalogMarketplaceDataScalarFieldEnum | CatalogMarketplaceDataScalarFieldEnum[]
  }


  /**
   * CatalogMarketplaceData findFirstOrThrow
   */
  export type CatalogMarketplaceDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceData to fetch.
     */
    where?: CatalogMarketplaceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceData to fetch.
     */
    orderBy?: CatalogMarketplaceDataOrderByWithRelationInput | CatalogMarketplaceDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogMarketplaceData.
     */
    cursor?: CatalogMarketplaceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogMarketplaceData.
     */
    distinct?: CatalogMarketplaceDataScalarFieldEnum | CatalogMarketplaceDataScalarFieldEnum[]
  }


  /**
   * CatalogMarketplaceData findMany
   */
  export type CatalogMarketplaceDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceData to fetch.
     */
    where?: CatalogMarketplaceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceData to fetch.
     */
    orderBy?: CatalogMarketplaceDataOrderByWithRelationInput | CatalogMarketplaceDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogMarketplaceData.
     */
    cursor?: CatalogMarketplaceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceData.
     */
    skip?: number
    distinct?: CatalogMarketplaceDataScalarFieldEnum | CatalogMarketplaceDataScalarFieldEnum[]
  }


  /**
   * CatalogMarketplaceData create
   */
  export type CatalogMarketplaceDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogMarketplaceData.
     */
    data: XOR<CatalogMarketplaceDataCreateInput, CatalogMarketplaceDataUncheckedCreateInput>
  }


  /**
   * CatalogMarketplaceData createMany
   */
  export type CatalogMarketplaceDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogMarketplaceData.
     */
    data: CatalogMarketplaceDataCreateManyInput | CatalogMarketplaceDataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogMarketplaceData update
   */
  export type CatalogMarketplaceDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogMarketplaceData.
     */
    data: XOR<CatalogMarketplaceDataUpdateInput, CatalogMarketplaceDataUncheckedUpdateInput>
    /**
     * Choose, which CatalogMarketplaceData to update.
     */
    where: CatalogMarketplaceDataWhereUniqueInput
  }


  /**
   * CatalogMarketplaceData updateMany
   */
  export type CatalogMarketplaceDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogMarketplaceData.
     */
    data: XOR<CatalogMarketplaceDataUpdateManyMutationInput, CatalogMarketplaceDataUncheckedUpdateManyInput>
    /**
     * Filter which CatalogMarketplaceData to update
     */
    where?: CatalogMarketplaceDataWhereInput
  }


  /**
   * CatalogMarketplaceData upsert
   */
  export type CatalogMarketplaceDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogMarketplaceData to update in case it exists.
     */
    where: CatalogMarketplaceDataWhereUniqueInput
    /**
     * In case the CatalogMarketplaceData found by the `where` argument doesn't exist, create a new CatalogMarketplaceData with this data.
     */
    create: XOR<CatalogMarketplaceDataCreateInput, CatalogMarketplaceDataUncheckedCreateInput>
    /**
     * In case the CatalogMarketplaceData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogMarketplaceDataUpdateInput, CatalogMarketplaceDataUncheckedUpdateInput>
  }


  /**
   * CatalogMarketplaceData delete
   */
  export type CatalogMarketplaceDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
    /**
     * Filter which CatalogMarketplaceData to delete.
     */
    where: CatalogMarketplaceDataWhereUniqueInput
  }


  /**
   * CatalogMarketplaceData deleteMany
   */
  export type CatalogMarketplaceDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogMarketplaceData to delete
     */
    where?: CatalogMarketplaceDataWhereInput
  }


  /**
   * CatalogMarketplaceData without action
   */
  export type CatalogMarketplaceDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceData
     */
    select?: CatalogMarketplaceDataSelect<ExtArgs> | null
  }



  /**
   * Model CatalogMarketplaceOffer
   */

  export type AggregateCatalogMarketplaceOffer = {
    _count: CatalogMarketplaceOfferCountAggregateOutputType | null
    _avg: CatalogMarketplaceOfferAvgAggregateOutputType | null
    _sum: CatalogMarketplaceOfferSumAggregateOutputType | null
    _min: CatalogMarketplaceOfferMinAggregateOutputType | null
    _max: CatalogMarketplaceOfferMaxAggregateOutputType | null
  }

  export type CatalogMarketplaceOfferAvgAggregateOutputType = {
    offerId: number | null
    userId: number | null
    itemId: number | null
    askingPrice: number | null
    totalPrice: number | null
    spriteId: number | null
    itemType: number | null
    timestamp: number | null
    state: number | null
    furniId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type CatalogMarketplaceOfferSumAggregateOutputType = {
    offerId: number | null
    userId: number | null
    itemId: number | null
    askingPrice: number | null
    totalPrice: number | null
    spriteId: number | null
    itemType: number | null
    timestamp: number | null
    state: number | null
    furniId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type CatalogMarketplaceOfferMinAggregateOutputType = {
    offerId: number | null
    userId: number | null
    itemId: number | null
    askingPrice: number | null
    totalPrice: number | null
    publicName: string | null
    spriteId: number | null
    itemType: number | null
    timestamp: number | null
    state: number | null
    extraData: string | null
    furniId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type CatalogMarketplaceOfferMaxAggregateOutputType = {
    offerId: number | null
    userId: number | null
    itemId: number | null
    askingPrice: number | null
    totalPrice: number | null
    publicName: string | null
    spriteId: number | null
    itemType: number | null
    timestamp: number | null
    state: number | null
    extraData: string | null
    furniId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type CatalogMarketplaceOfferCountAggregateOutputType = {
    offerId: number
    userId: number
    itemId: number
    askingPrice: number
    totalPrice: number
    publicName: number
    spriteId: number
    itemType: number
    timestamp: number
    state: number
    extraData: number
    furniId: number
    limitedNumber: number
    limitedStack: number
    _all: number
  }


  export type CatalogMarketplaceOfferAvgAggregateInputType = {
    offerId?: true
    userId?: true
    itemId?: true
    askingPrice?: true
    totalPrice?: true
    spriteId?: true
    itemType?: true
    timestamp?: true
    state?: true
    furniId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type CatalogMarketplaceOfferSumAggregateInputType = {
    offerId?: true
    userId?: true
    itemId?: true
    askingPrice?: true
    totalPrice?: true
    spriteId?: true
    itemType?: true
    timestamp?: true
    state?: true
    furniId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type CatalogMarketplaceOfferMinAggregateInputType = {
    offerId?: true
    userId?: true
    itemId?: true
    askingPrice?: true
    totalPrice?: true
    publicName?: true
    spriteId?: true
    itemType?: true
    timestamp?: true
    state?: true
    extraData?: true
    furniId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type CatalogMarketplaceOfferMaxAggregateInputType = {
    offerId?: true
    userId?: true
    itemId?: true
    askingPrice?: true
    totalPrice?: true
    publicName?: true
    spriteId?: true
    itemType?: true
    timestamp?: true
    state?: true
    extraData?: true
    furniId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type CatalogMarketplaceOfferCountAggregateInputType = {
    offerId?: true
    userId?: true
    itemId?: true
    askingPrice?: true
    totalPrice?: true
    publicName?: true
    spriteId?: true
    itemType?: true
    timestamp?: true
    state?: true
    extraData?: true
    furniId?: true
    limitedNumber?: true
    limitedStack?: true
    _all?: true
  }

  export type CatalogMarketplaceOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogMarketplaceOffer to aggregate.
     */
    where?: CatalogMarketplaceOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceOffers to fetch.
     */
    orderBy?: CatalogMarketplaceOfferOrderByWithRelationInput | CatalogMarketplaceOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogMarketplaceOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogMarketplaceOffers
    **/
    _count?: true | CatalogMarketplaceOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogMarketplaceOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogMarketplaceOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogMarketplaceOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogMarketplaceOfferMaxAggregateInputType
  }

  export type GetCatalogMarketplaceOfferAggregateType<T extends CatalogMarketplaceOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogMarketplaceOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogMarketplaceOffer[P]>
      : GetScalarType<T[P], AggregateCatalogMarketplaceOffer[P]>
  }




  export type CatalogMarketplaceOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogMarketplaceOfferWhereInput
    orderBy?: CatalogMarketplaceOfferOrderByWithAggregationInput | CatalogMarketplaceOfferOrderByWithAggregationInput[]
    by: CatalogMarketplaceOfferScalarFieldEnum[] | CatalogMarketplaceOfferScalarFieldEnum
    having?: CatalogMarketplaceOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogMarketplaceOfferCountAggregateInputType | true
    _avg?: CatalogMarketplaceOfferAvgAggregateInputType
    _sum?: CatalogMarketplaceOfferSumAggregateInputType
    _min?: CatalogMarketplaceOfferMinAggregateInputType
    _max?: CatalogMarketplaceOfferMaxAggregateInputType
  }

  export type CatalogMarketplaceOfferGroupByOutputType = {
    offerId: number
    userId: number
    itemId: number
    askingPrice: number
    totalPrice: number
    publicName: string
    spriteId: number
    itemType: number
    timestamp: number
    state: number
    extraData: string
    furniId: number
    limitedNumber: number
    limitedStack: number
    _count: CatalogMarketplaceOfferCountAggregateOutputType | null
    _avg: CatalogMarketplaceOfferAvgAggregateOutputType | null
    _sum: CatalogMarketplaceOfferSumAggregateOutputType | null
    _min: CatalogMarketplaceOfferMinAggregateOutputType | null
    _max: CatalogMarketplaceOfferMaxAggregateOutputType | null
  }

  type GetCatalogMarketplaceOfferGroupByPayload<T extends CatalogMarketplaceOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogMarketplaceOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogMarketplaceOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogMarketplaceOfferGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogMarketplaceOfferGroupByOutputType[P]>
        }
      >
    >


  export type CatalogMarketplaceOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    offerId?: boolean
    userId?: boolean
    itemId?: boolean
    askingPrice?: boolean
    totalPrice?: boolean
    publicName?: boolean
    spriteId?: boolean
    itemType?: boolean
    timestamp?: boolean
    state?: boolean
    extraData?: boolean
    furniId?: boolean
    limitedNumber?: boolean
    limitedStack?: boolean
  }, ExtArgs["result"]["catalogMarketplaceOffer"]>

  export type CatalogMarketplaceOfferSelectScalar = {
    offerId?: boolean
    userId?: boolean
    itemId?: boolean
    askingPrice?: boolean
    totalPrice?: boolean
    publicName?: boolean
    spriteId?: boolean
    itemType?: boolean
    timestamp?: boolean
    state?: boolean
    extraData?: boolean
    furniId?: boolean
    limitedNumber?: boolean
    limitedStack?: boolean
  }


  export type $CatalogMarketplaceOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogMarketplaceOffer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      offerId: number
      userId: number
      itemId: number
      askingPrice: number
      totalPrice: number
      publicName: string
      spriteId: number
      itemType: number
      timestamp: number
      state: number
      extraData: string
      furniId: number
      limitedNumber: number
      limitedStack: number
    }, ExtArgs["result"]["catalogMarketplaceOffer"]>
    composites: {}
  }


  type CatalogMarketplaceOfferGetPayload<S extends boolean | null | undefined | CatalogMarketplaceOfferDefaultArgs> = $Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload, S>

  type CatalogMarketplaceOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogMarketplaceOfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogMarketplaceOfferCountAggregateInputType | true
    }

  export interface CatalogMarketplaceOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogMarketplaceOffer'], meta: { name: 'CatalogMarketplaceOffer' } }
    /**
     * Find zero or one CatalogMarketplaceOffer that matches the filter.
     * @param {CatalogMarketplaceOfferFindUniqueArgs} args - Arguments to find a CatalogMarketplaceOffer
     * @example
     * // Get one CatalogMarketplaceOffer
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogMarketplaceOfferFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceOfferFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogMarketplaceOffer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogMarketplaceOfferFindUniqueOrThrowArgs} args - Arguments to find a CatalogMarketplaceOffer
     * @example
     * // Get one CatalogMarketplaceOffer
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogMarketplaceOfferFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceOfferFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogMarketplaceOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferFindFirstArgs} args - Arguments to find a CatalogMarketplaceOffer
     * @example
     * // Get one CatalogMarketplaceOffer
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogMarketplaceOfferFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceOfferFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogMarketplaceOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferFindFirstOrThrowArgs} args - Arguments to find a CatalogMarketplaceOffer
     * @example
     * // Get one CatalogMarketplaceOffer
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogMarketplaceOfferFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceOfferFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogMarketplaceOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogMarketplaceOffers
     * const catalogMarketplaceOffers = await prisma.catalogMarketplaceOffer.findMany()
     * 
     * // Get first 10 CatalogMarketplaceOffers
     * const catalogMarketplaceOffers = await prisma.catalogMarketplaceOffer.findMany({ take: 10 })
     * 
     * // Only select the `offerId`
     * const catalogMarketplaceOfferWithOfferIdOnly = await prisma.catalogMarketplaceOffer.findMany({ select: { offerId: true } })
     * 
    **/
    findMany<T extends CatalogMarketplaceOfferFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceOfferFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogMarketplaceOffer.
     * @param {CatalogMarketplaceOfferCreateArgs} args - Arguments to create a CatalogMarketplaceOffer.
     * @example
     * // Create one CatalogMarketplaceOffer
     * const CatalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.create({
     *   data: {
     *     // ... data to create a CatalogMarketplaceOffer
     *   }
     * })
     * 
    **/
    create<T extends CatalogMarketplaceOfferCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceOfferCreateArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogMarketplaceOffers.
     *     @param {CatalogMarketplaceOfferCreateManyArgs} args - Arguments to create many CatalogMarketplaceOffers.
     *     @example
     *     // Create many CatalogMarketplaceOffers
     *     const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogMarketplaceOfferCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceOfferCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogMarketplaceOffer.
     * @param {CatalogMarketplaceOfferDeleteArgs} args - Arguments to delete one CatalogMarketplaceOffer.
     * @example
     * // Delete one CatalogMarketplaceOffer
     * const CatalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.delete({
     *   where: {
     *     // ... filter to delete one CatalogMarketplaceOffer
     *   }
     * })
     * 
    **/
    delete<T extends CatalogMarketplaceOfferDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceOfferDeleteArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogMarketplaceOffer.
     * @param {CatalogMarketplaceOfferUpdateArgs} args - Arguments to update one CatalogMarketplaceOffer.
     * @example
     * // Update one CatalogMarketplaceOffer
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogMarketplaceOfferUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceOfferUpdateArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogMarketplaceOffers.
     * @param {CatalogMarketplaceOfferDeleteManyArgs} args - Arguments to filter CatalogMarketplaceOffers to delete.
     * @example
     * // Delete a few CatalogMarketplaceOffers
     * const { count } = await prisma.catalogMarketplaceOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogMarketplaceOfferDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogMarketplaceOfferDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogMarketplaceOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogMarketplaceOffers
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogMarketplaceOfferUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceOfferUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogMarketplaceOffer.
     * @param {CatalogMarketplaceOfferUpsertArgs} args - Arguments to update or create a CatalogMarketplaceOffer.
     * @example
     * // Update or create a CatalogMarketplaceOffer
     * const catalogMarketplaceOffer = await prisma.catalogMarketplaceOffer.upsert({
     *   create: {
     *     // ... data to create a CatalogMarketplaceOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogMarketplaceOffer we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogMarketplaceOfferUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogMarketplaceOfferUpsertArgs<ExtArgs>>
    ): Prisma__CatalogMarketplaceOfferClient<$Result.GetResult<Prisma.$CatalogMarketplaceOfferPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogMarketplaceOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferCountArgs} args - Arguments to filter CatalogMarketplaceOffers to count.
     * @example
     * // Count the number of CatalogMarketplaceOffers
     * const count = await prisma.catalogMarketplaceOffer.count({
     *   where: {
     *     // ... the filter for the CatalogMarketplaceOffers we want to count
     *   }
     * })
    **/
    count<T extends CatalogMarketplaceOfferCountArgs>(
      args?: Subset<T, CatalogMarketplaceOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogMarketplaceOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogMarketplaceOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogMarketplaceOfferAggregateArgs>(args: Subset<T, CatalogMarketplaceOfferAggregateArgs>): Prisma.PrismaPromise<GetCatalogMarketplaceOfferAggregateType<T>>

    /**
     * Group by CatalogMarketplaceOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogMarketplaceOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogMarketplaceOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogMarketplaceOfferGroupByArgs['orderBy'] }
        : { orderBy?: CatalogMarketplaceOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogMarketplaceOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogMarketplaceOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogMarketplaceOffer model
   */
  readonly fields: CatalogMarketplaceOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogMarketplaceOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogMarketplaceOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogMarketplaceOffer model
   */ 
  interface CatalogMarketplaceOfferFieldRefs {
    readonly offerId: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly userId: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly itemId: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly askingPrice: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly totalPrice: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly publicName: FieldRef<"CatalogMarketplaceOffer", 'String'>
    readonly spriteId: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly itemType: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly timestamp: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly state: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly extraData: FieldRef<"CatalogMarketplaceOffer", 'String'>
    readonly furniId: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly limitedNumber: FieldRef<"CatalogMarketplaceOffer", 'Int'>
    readonly limitedStack: FieldRef<"CatalogMarketplaceOffer", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CatalogMarketplaceOffer findUnique
   */
  export type CatalogMarketplaceOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceOffer to fetch.
     */
    where: CatalogMarketplaceOfferWhereUniqueInput
  }


  /**
   * CatalogMarketplaceOffer findUniqueOrThrow
   */
  export type CatalogMarketplaceOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceOffer to fetch.
     */
    where: CatalogMarketplaceOfferWhereUniqueInput
  }


  /**
   * CatalogMarketplaceOffer findFirst
   */
  export type CatalogMarketplaceOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceOffer to fetch.
     */
    where?: CatalogMarketplaceOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceOffers to fetch.
     */
    orderBy?: CatalogMarketplaceOfferOrderByWithRelationInput | CatalogMarketplaceOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogMarketplaceOffers.
     */
    cursor?: CatalogMarketplaceOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogMarketplaceOffers.
     */
    distinct?: CatalogMarketplaceOfferScalarFieldEnum | CatalogMarketplaceOfferScalarFieldEnum[]
  }


  /**
   * CatalogMarketplaceOffer findFirstOrThrow
   */
  export type CatalogMarketplaceOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceOffer to fetch.
     */
    where?: CatalogMarketplaceOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceOffers to fetch.
     */
    orderBy?: CatalogMarketplaceOfferOrderByWithRelationInput | CatalogMarketplaceOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogMarketplaceOffers.
     */
    cursor?: CatalogMarketplaceOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogMarketplaceOffers.
     */
    distinct?: CatalogMarketplaceOfferScalarFieldEnum | CatalogMarketplaceOfferScalarFieldEnum[]
  }


  /**
   * CatalogMarketplaceOffer findMany
   */
  export type CatalogMarketplaceOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * Filter, which CatalogMarketplaceOffers to fetch.
     */
    where?: CatalogMarketplaceOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogMarketplaceOffers to fetch.
     */
    orderBy?: CatalogMarketplaceOfferOrderByWithRelationInput | CatalogMarketplaceOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogMarketplaceOffers.
     */
    cursor?: CatalogMarketplaceOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogMarketplaceOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogMarketplaceOffers.
     */
    skip?: number
    distinct?: CatalogMarketplaceOfferScalarFieldEnum | CatalogMarketplaceOfferScalarFieldEnum[]
  }


  /**
   * CatalogMarketplaceOffer create
   */
  export type CatalogMarketplaceOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogMarketplaceOffer.
     */
    data: XOR<CatalogMarketplaceOfferCreateInput, CatalogMarketplaceOfferUncheckedCreateInput>
  }


  /**
   * CatalogMarketplaceOffer createMany
   */
  export type CatalogMarketplaceOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogMarketplaceOffers.
     */
    data: CatalogMarketplaceOfferCreateManyInput | CatalogMarketplaceOfferCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogMarketplaceOffer update
   */
  export type CatalogMarketplaceOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogMarketplaceOffer.
     */
    data: XOR<CatalogMarketplaceOfferUpdateInput, CatalogMarketplaceOfferUncheckedUpdateInput>
    /**
     * Choose, which CatalogMarketplaceOffer to update.
     */
    where: CatalogMarketplaceOfferWhereUniqueInput
  }


  /**
   * CatalogMarketplaceOffer updateMany
   */
  export type CatalogMarketplaceOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogMarketplaceOffers.
     */
    data: XOR<CatalogMarketplaceOfferUpdateManyMutationInput, CatalogMarketplaceOfferUncheckedUpdateManyInput>
    /**
     * Filter which CatalogMarketplaceOffers to update
     */
    where?: CatalogMarketplaceOfferWhereInput
  }


  /**
   * CatalogMarketplaceOffer upsert
   */
  export type CatalogMarketplaceOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogMarketplaceOffer to update in case it exists.
     */
    where: CatalogMarketplaceOfferWhereUniqueInput
    /**
     * In case the CatalogMarketplaceOffer found by the `where` argument doesn't exist, create a new CatalogMarketplaceOffer with this data.
     */
    create: XOR<CatalogMarketplaceOfferCreateInput, CatalogMarketplaceOfferUncheckedCreateInput>
    /**
     * In case the CatalogMarketplaceOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogMarketplaceOfferUpdateInput, CatalogMarketplaceOfferUncheckedUpdateInput>
  }


  /**
   * CatalogMarketplaceOffer delete
   */
  export type CatalogMarketplaceOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
    /**
     * Filter which CatalogMarketplaceOffer to delete.
     */
    where: CatalogMarketplaceOfferWhereUniqueInput
  }


  /**
   * CatalogMarketplaceOffer deleteMany
   */
  export type CatalogMarketplaceOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogMarketplaceOffers to delete
     */
    where?: CatalogMarketplaceOfferWhereInput
  }


  /**
   * CatalogMarketplaceOffer without action
   */
  export type CatalogMarketplaceOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogMarketplaceOffer
     */
    select?: CatalogMarketplaceOfferSelect<ExtArgs> | null
  }



  /**
   * Model CatalogPage
   */

  export type AggregateCatalogPage = {
    _count: CatalogPageCountAggregateOutputType | null
    _avg: CatalogPageAvgAggregateOutputType | null
    _sum: CatalogPageSumAggregateOutputType | null
    _min: CatalogPageMinAggregateOutputType | null
    _max: CatalogPageMaxAggregateOutputType | null
  }

  export type CatalogPageAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    iconImage: number | null
    orderNum: number | null
  }

  export type CatalogPageSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    iconImage: number | null
    orderNum: number | null
  }

  export type CatalogPageMinAggregateOutputType = {
    id: number | null
    parentId: number | null
    caption: string | null
    iconImage: number | null
    enabled: boolean | null
    requiredRight: string | null
    orderNum: number | null
    pageLayout: string | null
    pageLink: string | null
    pageStrings1: string | null
    pageStrings2: string | null
    isPremium: boolean | null
  }

  export type CatalogPageMaxAggregateOutputType = {
    id: number | null
    parentId: number | null
    caption: string | null
    iconImage: number | null
    enabled: boolean | null
    requiredRight: string | null
    orderNum: number | null
    pageLayout: string | null
    pageLink: string | null
    pageStrings1: string | null
    pageStrings2: string | null
    isPremium: boolean | null
  }

  export type CatalogPageCountAggregateOutputType = {
    id: number
    parentId: number
    caption: number
    iconImage: number
    enabled: number
    requiredRight: number
    orderNum: number
    pageLayout: number
    pageLink: number
    pageStrings1: number
    pageStrings2: number
    isPremium: number
    _all: number
  }


  export type CatalogPageAvgAggregateInputType = {
    id?: true
    parentId?: true
    iconImage?: true
    orderNum?: true
  }

  export type CatalogPageSumAggregateInputType = {
    id?: true
    parentId?: true
    iconImage?: true
    orderNum?: true
  }

  export type CatalogPageMinAggregateInputType = {
    id?: true
    parentId?: true
    caption?: true
    iconImage?: true
    enabled?: true
    requiredRight?: true
    orderNum?: true
    pageLayout?: true
    pageLink?: true
    pageStrings1?: true
    pageStrings2?: true
    isPremium?: true
  }

  export type CatalogPageMaxAggregateInputType = {
    id?: true
    parentId?: true
    caption?: true
    iconImage?: true
    enabled?: true
    requiredRight?: true
    orderNum?: true
    pageLayout?: true
    pageLink?: true
    pageStrings1?: true
    pageStrings2?: true
    isPremium?: true
  }

  export type CatalogPageCountAggregateInputType = {
    id?: true
    parentId?: true
    caption?: true
    iconImage?: true
    enabled?: true
    requiredRight?: true
    orderNum?: true
    pageLayout?: true
    pageLink?: true
    pageStrings1?: true
    pageStrings2?: true
    isPremium?: true
    _all?: true
  }

  export type CatalogPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPage to aggregate.
     */
    where?: CatalogPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPages to fetch.
     */
    orderBy?: CatalogPageOrderByWithRelationInput | CatalogPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogPages
    **/
    _count?: true | CatalogPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogPageMaxAggregateInputType
  }

  export type GetCatalogPageAggregateType<T extends CatalogPageAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogPage[P]>
      : GetScalarType<T[P], AggregateCatalogPage[P]>
  }




  export type CatalogPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogPageWhereInput
    orderBy?: CatalogPageOrderByWithAggregationInput | CatalogPageOrderByWithAggregationInput[]
    by: CatalogPageScalarFieldEnum[] | CatalogPageScalarFieldEnum
    having?: CatalogPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogPageCountAggregateInputType | true
    _avg?: CatalogPageAvgAggregateInputType
    _sum?: CatalogPageSumAggregateInputType
    _min?: CatalogPageMinAggregateInputType
    _max?: CatalogPageMaxAggregateInputType
  }

  export type CatalogPageGroupByOutputType = {
    id: number
    parentId: number
    caption: string
    iconImage: number
    enabled: boolean
    requiredRight: string
    orderNum: number
    pageLayout: string
    pageLink: string
    pageStrings1: string
    pageStrings2: string
    isPremium: boolean
    _count: CatalogPageCountAggregateOutputType | null
    _avg: CatalogPageAvgAggregateOutputType | null
    _sum: CatalogPageSumAggregateOutputType | null
    _min: CatalogPageMinAggregateOutputType | null
    _max: CatalogPageMaxAggregateOutputType | null
  }

  type GetCatalogPageGroupByPayload<T extends CatalogPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogPageGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogPageGroupByOutputType[P]>
        }
      >
    >


  export type CatalogPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    caption?: boolean
    iconImage?: boolean
    enabled?: boolean
    requiredRight?: boolean
    orderNum?: boolean
    pageLayout?: boolean
    pageLink?: boolean
    pageStrings1?: boolean
    pageStrings2?: boolean
    isPremium?: boolean
  }, ExtArgs["result"]["catalogPage"]>

  export type CatalogPageSelectScalar = {
    id?: boolean
    parentId?: boolean
    caption?: boolean
    iconImage?: boolean
    enabled?: boolean
    requiredRight?: boolean
    orderNum?: boolean
    pageLayout?: boolean
    pageLink?: boolean
    pageStrings1?: boolean
    pageStrings2?: boolean
    isPremium?: boolean
  }


  export type $CatalogPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogPage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parentId: number
      caption: string
      iconImage: number
      enabled: boolean
      requiredRight: string
      orderNum: number
      pageLayout: string
      pageLink: string
      pageStrings1: string
      pageStrings2: string
      isPremium: boolean
    }, ExtArgs["result"]["catalogPage"]>
    composites: {}
  }


  type CatalogPageGetPayload<S extends boolean | null | undefined | CatalogPageDefaultArgs> = $Result.GetResult<Prisma.$CatalogPagePayload, S>

  type CatalogPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogPageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogPageCountAggregateInputType | true
    }

  export interface CatalogPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogPage'], meta: { name: 'CatalogPage' } }
    /**
     * Find zero or one CatalogPage that matches the filter.
     * @param {CatalogPageFindUniqueArgs} args - Arguments to find a CatalogPage
     * @example
     * // Get one CatalogPage
     * const catalogPage = await prisma.catalogPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogPageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogPage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogPageFindUniqueOrThrowArgs} args - Arguments to find a CatalogPage
     * @example
     * // Get one CatalogPage
     * const catalogPage = await prisma.catalogPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogPageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageFindFirstArgs} args - Arguments to find a CatalogPage
     * @example
     * // Get one CatalogPage
     * const catalogPage = await prisma.catalogPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogPageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageFindFirstOrThrowArgs} args - Arguments to find a CatalogPage
     * @example
     * // Get one CatalogPage
     * const catalogPage = await prisma.catalogPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogPageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogPages
     * const catalogPages = await prisma.catalogPage.findMany()
     * 
     * // Get first 10 CatalogPages
     * const catalogPages = await prisma.catalogPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogPageWithIdOnly = await prisma.catalogPage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogPageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogPage.
     * @param {CatalogPageCreateArgs} args - Arguments to create a CatalogPage.
     * @example
     * // Create one CatalogPage
     * const CatalogPage = await prisma.catalogPage.create({
     *   data: {
     *     // ... data to create a CatalogPage
     *   }
     * })
     * 
    **/
    create<T extends CatalogPageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageCreateArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogPages.
     *     @param {CatalogPageCreateManyArgs} args - Arguments to create many CatalogPages.
     *     @example
     *     // Create many CatalogPages
     *     const catalogPage = await prisma.catalogPage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogPageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogPage.
     * @param {CatalogPageDeleteArgs} args - Arguments to delete one CatalogPage.
     * @example
     * // Delete one CatalogPage
     * const CatalogPage = await prisma.catalogPage.delete({
     *   where: {
     *     // ... filter to delete one CatalogPage
     *   }
     * })
     * 
    **/
    delete<T extends CatalogPageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageDeleteArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogPage.
     * @param {CatalogPageUpdateArgs} args - Arguments to update one CatalogPage.
     * @example
     * // Update one CatalogPage
     * const catalogPage = await prisma.catalogPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogPageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageUpdateArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogPages.
     * @param {CatalogPageDeleteManyArgs} args - Arguments to filter CatalogPages to delete.
     * @example
     * // Delete a few CatalogPages
     * const { count } = await prisma.catalogPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogPageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogPages
     * const catalogPage = await prisma.catalogPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogPageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogPage.
     * @param {CatalogPageUpsertArgs} args - Arguments to update or create a CatalogPage.
     * @example
     * // Update or create a CatalogPage
     * const catalogPage = await prisma.catalogPage.upsert({
     *   create: {
     *     // ... data to create a CatalogPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogPage we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogPageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageUpsertArgs<ExtArgs>>
    ): Prisma__CatalogPageClient<$Result.GetResult<Prisma.$CatalogPagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageCountArgs} args - Arguments to filter CatalogPages to count.
     * @example
     * // Count the number of CatalogPages
     * const count = await prisma.catalogPage.count({
     *   where: {
     *     // ... the filter for the CatalogPages we want to count
     *   }
     * })
    **/
    count<T extends CatalogPageCountArgs>(
      args?: Subset<T, CatalogPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogPageAggregateArgs>(args: Subset<T, CatalogPageAggregateArgs>): Prisma.PrismaPromise<GetCatalogPageAggregateType<T>>

    /**
     * Group by CatalogPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogPageGroupByArgs['orderBy'] }
        : { orderBy?: CatalogPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogPage model
   */
  readonly fields: CatalogPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogPage model
   */ 
  interface CatalogPageFieldRefs {
    readonly id: FieldRef<"CatalogPage", 'Int'>
    readonly parentId: FieldRef<"CatalogPage", 'Int'>
    readonly caption: FieldRef<"CatalogPage", 'String'>
    readonly iconImage: FieldRef<"CatalogPage", 'Int'>
    readonly enabled: FieldRef<"CatalogPage", 'Boolean'>
    readonly requiredRight: FieldRef<"CatalogPage", 'String'>
    readonly orderNum: FieldRef<"CatalogPage", 'Int'>
    readonly pageLayout: FieldRef<"CatalogPage", 'String'>
    readonly pageLink: FieldRef<"CatalogPage", 'String'>
    readonly pageStrings1: FieldRef<"CatalogPage", 'String'>
    readonly pageStrings2: FieldRef<"CatalogPage", 'String'>
    readonly isPremium: FieldRef<"CatalogPage", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CatalogPage findUnique
   */
  export type CatalogPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPage to fetch.
     */
    where: CatalogPageWhereUniqueInput
  }


  /**
   * CatalogPage findUniqueOrThrow
   */
  export type CatalogPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPage to fetch.
     */
    where: CatalogPageWhereUniqueInput
  }


  /**
   * CatalogPage findFirst
   */
  export type CatalogPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPage to fetch.
     */
    where?: CatalogPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPages to fetch.
     */
    orderBy?: CatalogPageOrderByWithRelationInput | CatalogPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPages.
     */
    cursor?: CatalogPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPages.
     */
    distinct?: CatalogPageScalarFieldEnum | CatalogPageScalarFieldEnum[]
  }


  /**
   * CatalogPage findFirstOrThrow
   */
  export type CatalogPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPage to fetch.
     */
    where?: CatalogPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPages to fetch.
     */
    orderBy?: CatalogPageOrderByWithRelationInput | CatalogPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPages.
     */
    cursor?: CatalogPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPages.
     */
    distinct?: CatalogPageScalarFieldEnum | CatalogPageScalarFieldEnum[]
  }


  /**
   * CatalogPage findMany
   */
  export type CatalogPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPages to fetch.
     */
    where?: CatalogPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPages to fetch.
     */
    orderBy?: CatalogPageOrderByWithRelationInput | CatalogPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogPages.
     */
    cursor?: CatalogPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPages.
     */
    skip?: number
    distinct?: CatalogPageScalarFieldEnum | CatalogPageScalarFieldEnum[]
  }


  /**
   * CatalogPage create
   */
  export type CatalogPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogPage.
     */
    data: XOR<CatalogPageCreateInput, CatalogPageUncheckedCreateInput>
  }


  /**
   * CatalogPage createMany
   */
  export type CatalogPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogPages.
     */
    data: CatalogPageCreateManyInput | CatalogPageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogPage update
   */
  export type CatalogPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogPage.
     */
    data: XOR<CatalogPageUpdateInput, CatalogPageUncheckedUpdateInput>
    /**
     * Choose, which CatalogPage to update.
     */
    where: CatalogPageWhereUniqueInput
  }


  /**
   * CatalogPage updateMany
   */
  export type CatalogPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogPages.
     */
    data: XOR<CatalogPageUpdateManyMutationInput, CatalogPageUncheckedUpdateManyInput>
    /**
     * Filter which CatalogPages to update
     */
    where?: CatalogPageWhereInput
  }


  /**
   * CatalogPage upsert
   */
  export type CatalogPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogPage to update in case it exists.
     */
    where: CatalogPageWhereUniqueInput
    /**
     * In case the CatalogPage found by the `where` argument doesn't exist, create a new CatalogPage with this data.
     */
    create: XOR<CatalogPageCreateInput, CatalogPageUncheckedCreateInput>
    /**
     * In case the CatalogPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogPageUpdateInput, CatalogPageUncheckedUpdateInput>
  }


  /**
   * CatalogPage delete
   */
  export type CatalogPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
    /**
     * Filter which CatalogPage to delete.
     */
    where: CatalogPageWhereUniqueInput
  }


  /**
   * CatalogPage deleteMany
   */
  export type CatalogPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPages to delete
     */
    where?: CatalogPageWhereInput
  }


  /**
   * CatalogPage without action
   */
  export type CatalogPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPage
     */
    select?: CatalogPageSelect<ExtArgs> | null
  }



  /**
   * Model CatalogPageLangue
   */

  export type AggregateCatalogPageLangue = {
    _count: CatalogPageLangueCountAggregateOutputType | null
    _avg: CatalogPageLangueAvgAggregateOutputType | null
    _sum: CatalogPageLangueSumAggregateOutputType | null
    _min: CatalogPageLangueMinAggregateOutputType | null
    _max: CatalogPageLangueMaxAggregateOutputType | null
  }

  export type CatalogPageLangueAvgAggregateOutputType = {
    pageId: number | null
  }

  export type CatalogPageLangueSumAggregateOutputType = {
    pageId: number | null
  }

  export type CatalogPageLangueMinAggregateOutputType = {
    pageId: number | null
    captionFr: string | null
    captionEn: string | null
    captionBr: string | null
    pageStrings2Fr: string | null
    pageStrings2En: string | null
    pageStrings2Br: string | null
  }

  export type CatalogPageLangueMaxAggregateOutputType = {
    pageId: number | null
    captionFr: string | null
    captionEn: string | null
    captionBr: string | null
    pageStrings2Fr: string | null
    pageStrings2En: string | null
    pageStrings2Br: string | null
  }

  export type CatalogPageLangueCountAggregateOutputType = {
    pageId: number
    captionFr: number
    captionEn: number
    captionBr: number
    pageStrings2Fr: number
    pageStrings2En: number
    pageStrings2Br: number
    _all: number
  }


  export type CatalogPageLangueAvgAggregateInputType = {
    pageId?: true
  }

  export type CatalogPageLangueSumAggregateInputType = {
    pageId?: true
  }

  export type CatalogPageLangueMinAggregateInputType = {
    pageId?: true
    captionFr?: true
    captionEn?: true
    captionBr?: true
    pageStrings2Fr?: true
    pageStrings2En?: true
    pageStrings2Br?: true
  }

  export type CatalogPageLangueMaxAggregateInputType = {
    pageId?: true
    captionFr?: true
    captionEn?: true
    captionBr?: true
    pageStrings2Fr?: true
    pageStrings2En?: true
    pageStrings2Br?: true
  }

  export type CatalogPageLangueCountAggregateInputType = {
    pageId?: true
    captionFr?: true
    captionEn?: true
    captionBr?: true
    pageStrings2Fr?: true
    pageStrings2En?: true
    pageStrings2Br?: true
    _all?: true
  }

  export type CatalogPageLangueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPageLangue to aggregate.
     */
    where?: CatalogPageLangueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPageLangues to fetch.
     */
    orderBy?: CatalogPageLangueOrderByWithRelationInput | CatalogPageLangueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogPageLangueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPageLangues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPageLangues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogPageLangues
    **/
    _count?: true | CatalogPageLangueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogPageLangueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogPageLangueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogPageLangueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogPageLangueMaxAggregateInputType
  }

  export type GetCatalogPageLangueAggregateType<T extends CatalogPageLangueAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogPageLangue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogPageLangue[P]>
      : GetScalarType<T[P], AggregateCatalogPageLangue[P]>
  }




  export type CatalogPageLangueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogPageLangueWhereInput
    orderBy?: CatalogPageLangueOrderByWithAggregationInput | CatalogPageLangueOrderByWithAggregationInput[]
    by: CatalogPageLangueScalarFieldEnum[] | CatalogPageLangueScalarFieldEnum
    having?: CatalogPageLangueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogPageLangueCountAggregateInputType | true
    _avg?: CatalogPageLangueAvgAggregateInputType
    _sum?: CatalogPageLangueSumAggregateInputType
    _min?: CatalogPageLangueMinAggregateInputType
    _max?: CatalogPageLangueMaxAggregateInputType
  }

  export type CatalogPageLangueGroupByOutputType = {
    pageId: number
    captionFr: string | null
    captionEn: string | null
    captionBr: string | null
    pageStrings2Fr: string | null
    pageStrings2En: string | null
    pageStrings2Br: string | null
    _count: CatalogPageLangueCountAggregateOutputType | null
    _avg: CatalogPageLangueAvgAggregateOutputType | null
    _sum: CatalogPageLangueSumAggregateOutputType | null
    _min: CatalogPageLangueMinAggregateOutputType | null
    _max: CatalogPageLangueMaxAggregateOutputType | null
  }

  type GetCatalogPageLangueGroupByPayload<T extends CatalogPageLangueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogPageLangueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogPageLangueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogPageLangueGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogPageLangueGroupByOutputType[P]>
        }
      >
    >


  export type CatalogPageLangueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pageId?: boolean
    captionFr?: boolean
    captionEn?: boolean
    captionBr?: boolean
    pageStrings2Fr?: boolean
    pageStrings2En?: boolean
    pageStrings2Br?: boolean
  }, ExtArgs["result"]["catalogPageLangue"]>

  export type CatalogPageLangueSelectScalar = {
    pageId?: boolean
    captionFr?: boolean
    captionEn?: boolean
    captionBr?: boolean
    pageStrings2Fr?: boolean
    pageStrings2En?: boolean
    pageStrings2Br?: boolean
  }


  export type $CatalogPageLanguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogPageLangue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pageId: number
      captionFr: string | null
      captionEn: string | null
      captionBr: string | null
      pageStrings2Fr: string | null
      pageStrings2En: string | null
      pageStrings2Br: string | null
    }, ExtArgs["result"]["catalogPageLangue"]>
    composites: {}
  }


  type CatalogPageLangueGetPayload<S extends boolean | null | undefined | CatalogPageLangueDefaultArgs> = $Result.GetResult<Prisma.$CatalogPageLanguePayload, S>

  type CatalogPageLangueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogPageLangueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogPageLangueCountAggregateInputType | true
    }

  export interface CatalogPageLangueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogPageLangue'], meta: { name: 'CatalogPageLangue' } }
    /**
     * Find zero or one CatalogPageLangue that matches the filter.
     * @param {CatalogPageLangueFindUniqueArgs} args - Arguments to find a CatalogPageLangue
     * @example
     * // Get one CatalogPageLangue
     * const catalogPageLangue = await prisma.catalogPageLangue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogPageLangueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageLangueFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogPageLangue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogPageLangueFindUniqueOrThrowArgs} args - Arguments to find a CatalogPageLangue
     * @example
     * // Get one CatalogPageLangue
     * const catalogPageLangue = await prisma.catalogPageLangue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogPageLangueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageLangueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogPageLangue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueFindFirstArgs} args - Arguments to find a CatalogPageLangue
     * @example
     * // Get one CatalogPageLangue
     * const catalogPageLangue = await prisma.catalogPageLangue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogPageLangueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageLangueFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogPageLangue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueFindFirstOrThrowArgs} args - Arguments to find a CatalogPageLangue
     * @example
     * // Get one CatalogPageLangue
     * const catalogPageLangue = await prisma.catalogPageLangue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogPageLangueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageLangueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogPageLangues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogPageLangues
     * const catalogPageLangues = await prisma.catalogPageLangue.findMany()
     * 
     * // Get first 10 CatalogPageLangues
     * const catalogPageLangues = await prisma.catalogPageLangue.findMany({ take: 10 })
     * 
     * // Only select the `pageId`
     * const catalogPageLangueWithPageIdOnly = await prisma.catalogPageLangue.findMany({ select: { pageId: true } })
     * 
    **/
    findMany<T extends CatalogPageLangueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageLangueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogPageLangue.
     * @param {CatalogPageLangueCreateArgs} args - Arguments to create a CatalogPageLangue.
     * @example
     * // Create one CatalogPageLangue
     * const CatalogPageLangue = await prisma.catalogPageLangue.create({
     *   data: {
     *     // ... data to create a CatalogPageLangue
     *   }
     * })
     * 
    **/
    create<T extends CatalogPageLangueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageLangueCreateArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogPageLangues.
     *     @param {CatalogPageLangueCreateManyArgs} args - Arguments to create many CatalogPageLangues.
     *     @example
     *     // Create many CatalogPageLangues
     *     const catalogPageLangue = await prisma.catalogPageLangue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogPageLangueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageLangueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogPageLangue.
     * @param {CatalogPageLangueDeleteArgs} args - Arguments to delete one CatalogPageLangue.
     * @example
     * // Delete one CatalogPageLangue
     * const CatalogPageLangue = await prisma.catalogPageLangue.delete({
     *   where: {
     *     // ... filter to delete one CatalogPageLangue
     *   }
     * })
     * 
    **/
    delete<T extends CatalogPageLangueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageLangueDeleteArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogPageLangue.
     * @param {CatalogPageLangueUpdateArgs} args - Arguments to update one CatalogPageLangue.
     * @example
     * // Update one CatalogPageLangue
     * const catalogPageLangue = await prisma.catalogPageLangue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogPageLangueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageLangueUpdateArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogPageLangues.
     * @param {CatalogPageLangueDeleteManyArgs} args - Arguments to filter CatalogPageLangues to delete.
     * @example
     * // Delete a few CatalogPageLangues
     * const { count } = await prisma.catalogPageLangue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogPageLangueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPageLangueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogPageLangues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogPageLangues
     * const catalogPageLangue = await prisma.catalogPageLangue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogPageLangueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageLangueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogPageLangue.
     * @param {CatalogPageLangueUpsertArgs} args - Arguments to update or create a CatalogPageLangue.
     * @example
     * // Update or create a CatalogPageLangue
     * const catalogPageLangue = await prisma.catalogPageLangue.upsert({
     *   create: {
     *     // ... data to create a CatalogPageLangue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogPageLangue we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogPageLangueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPageLangueUpsertArgs<ExtArgs>>
    ): Prisma__CatalogPageLangueClient<$Result.GetResult<Prisma.$CatalogPageLanguePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogPageLangues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueCountArgs} args - Arguments to filter CatalogPageLangues to count.
     * @example
     * // Count the number of CatalogPageLangues
     * const count = await prisma.catalogPageLangue.count({
     *   where: {
     *     // ... the filter for the CatalogPageLangues we want to count
     *   }
     * })
    **/
    count<T extends CatalogPageLangueCountArgs>(
      args?: Subset<T, CatalogPageLangueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogPageLangueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogPageLangue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogPageLangueAggregateArgs>(args: Subset<T, CatalogPageLangueAggregateArgs>): Prisma.PrismaPromise<GetCatalogPageLangueAggregateType<T>>

    /**
     * Group by CatalogPageLangue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPageLangueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogPageLangueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogPageLangueGroupByArgs['orderBy'] }
        : { orderBy?: CatalogPageLangueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogPageLangueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogPageLangueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogPageLangue model
   */
  readonly fields: CatalogPageLangueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogPageLangue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogPageLangueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogPageLangue model
   */ 
  interface CatalogPageLangueFieldRefs {
    readonly pageId: FieldRef<"CatalogPageLangue", 'Int'>
    readonly captionFr: FieldRef<"CatalogPageLangue", 'String'>
    readonly captionEn: FieldRef<"CatalogPageLangue", 'String'>
    readonly captionBr: FieldRef<"CatalogPageLangue", 'String'>
    readonly pageStrings2Fr: FieldRef<"CatalogPageLangue", 'String'>
    readonly pageStrings2En: FieldRef<"CatalogPageLangue", 'String'>
    readonly pageStrings2Br: FieldRef<"CatalogPageLangue", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CatalogPageLangue findUnique
   */
  export type CatalogPageLangueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPageLangue to fetch.
     */
    where: CatalogPageLangueWhereUniqueInput
  }


  /**
   * CatalogPageLangue findUniqueOrThrow
   */
  export type CatalogPageLangueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPageLangue to fetch.
     */
    where: CatalogPageLangueWhereUniqueInput
  }


  /**
   * CatalogPageLangue findFirst
   */
  export type CatalogPageLangueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPageLangue to fetch.
     */
    where?: CatalogPageLangueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPageLangues to fetch.
     */
    orderBy?: CatalogPageLangueOrderByWithRelationInput | CatalogPageLangueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPageLangues.
     */
    cursor?: CatalogPageLangueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPageLangues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPageLangues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPageLangues.
     */
    distinct?: CatalogPageLangueScalarFieldEnum | CatalogPageLangueScalarFieldEnum[]
  }


  /**
   * CatalogPageLangue findFirstOrThrow
   */
  export type CatalogPageLangueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPageLangue to fetch.
     */
    where?: CatalogPageLangueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPageLangues to fetch.
     */
    orderBy?: CatalogPageLangueOrderByWithRelationInput | CatalogPageLangueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPageLangues.
     */
    cursor?: CatalogPageLangueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPageLangues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPageLangues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPageLangues.
     */
    distinct?: CatalogPageLangueScalarFieldEnum | CatalogPageLangueScalarFieldEnum[]
  }


  /**
   * CatalogPageLangue findMany
   */
  export type CatalogPageLangueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPageLangues to fetch.
     */
    where?: CatalogPageLangueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPageLangues to fetch.
     */
    orderBy?: CatalogPageLangueOrderByWithRelationInput | CatalogPageLangueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogPageLangues.
     */
    cursor?: CatalogPageLangueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPageLangues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPageLangues.
     */
    skip?: number
    distinct?: CatalogPageLangueScalarFieldEnum | CatalogPageLangueScalarFieldEnum[]
  }


  /**
   * CatalogPageLangue create
   */
  export type CatalogPageLangueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogPageLangue.
     */
    data: XOR<CatalogPageLangueCreateInput, CatalogPageLangueUncheckedCreateInput>
  }


  /**
   * CatalogPageLangue createMany
   */
  export type CatalogPageLangueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogPageLangues.
     */
    data: CatalogPageLangueCreateManyInput | CatalogPageLangueCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogPageLangue update
   */
  export type CatalogPageLangueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogPageLangue.
     */
    data: XOR<CatalogPageLangueUpdateInput, CatalogPageLangueUncheckedUpdateInput>
    /**
     * Choose, which CatalogPageLangue to update.
     */
    where: CatalogPageLangueWhereUniqueInput
  }


  /**
   * CatalogPageLangue updateMany
   */
  export type CatalogPageLangueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogPageLangues.
     */
    data: XOR<CatalogPageLangueUpdateManyMutationInput, CatalogPageLangueUncheckedUpdateManyInput>
    /**
     * Filter which CatalogPageLangues to update
     */
    where?: CatalogPageLangueWhereInput
  }


  /**
   * CatalogPageLangue upsert
   */
  export type CatalogPageLangueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogPageLangue to update in case it exists.
     */
    where: CatalogPageLangueWhereUniqueInput
    /**
     * In case the CatalogPageLangue found by the `where` argument doesn't exist, create a new CatalogPageLangue with this data.
     */
    create: XOR<CatalogPageLangueCreateInput, CatalogPageLangueUncheckedCreateInput>
    /**
     * In case the CatalogPageLangue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogPageLangueUpdateInput, CatalogPageLangueUncheckedUpdateInput>
  }


  /**
   * CatalogPageLangue delete
   */
  export type CatalogPageLangueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
    /**
     * Filter which CatalogPageLangue to delete.
     */
    where: CatalogPageLangueWhereUniqueInput
  }


  /**
   * CatalogPageLangue deleteMany
   */
  export type CatalogPageLangueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPageLangues to delete
     */
    where?: CatalogPageLangueWhereInput
  }


  /**
   * CatalogPageLangue without action
   */
  export type CatalogPageLangueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPageLangue
     */
    select?: CatalogPageLangueSelect<ExtArgs> | null
  }



  /**
   * Model CatalogPetRace
   */

  export type AggregateCatalogPetRace = {
    _count: CatalogPetRaceCountAggregateOutputType | null
    _avg: CatalogPetRaceAvgAggregateOutputType | null
    _sum: CatalogPetRaceSumAggregateOutputType | null
    _min: CatalogPetRaceMinAggregateOutputType | null
    _max: CatalogPetRaceMaxAggregateOutputType | null
  }

  export type CatalogPetRaceAvgAggregateOutputType = {
    id: number | null
    raceid: number | null
    color1: number | null
    color2: number | null
  }

  export type CatalogPetRaceSumAggregateOutputType = {
    id: number | null
    raceid: number | null
    color1: number | null
    color2: number | null
  }

  export type CatalogPetRaceMinAggregateOutputType = {
    id: number | null
    raceid: number | null
    color1: number | null
    color2: number | null
    has1color: boolean | null
    has2color: boolean | null
  }

  export type CatalogPetRaceMaxAggregateOutputType = {
    id: number | null
    raceid: number | null
    color1: number | null
    color2: number | null
    has1color: boolean | null
    has2color: boolean | null
  }

  export type CatalogPetRaceCountAggregateOutputType = {
    id: number
    raceid: number
    color1: number
    color2: number
    has1color: number
    has2color: number
    _all: number
  }


  export type CatalogPetRaceAvgAggregateInputType = {
    id?: true
    raceid?: true
    color1?: true
    color2?: true
  }

  export type CatalogPetRaceSumAggregateInputType = {
    id?: true
    raceid?: true
    color1?: true
    color2?: true
  }

  export type CatalogPetRaceMinAggregateInputType = {
    id?: true
    raceid?: true
    color1?: true
    color2?: true
    has1color?: true
    has2color?: true
  }

  export type CatalogPetRaceMaxAggregateInputType = {
    id?: true
    raceid?: true
    color1?: true
    color2?: true
    has1color?: true
    has2color?: true
  }

  export type CatalogPetRaceCountAggregateInputType = {
    id?: true
    raceid?: true
    color1?: true
    color2?: true
    has1color?: true
    has2color?: true
    _all?: true
  }

  export type CatalogPetRaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPetRace to aggregate.
     */
    where?: CatalogPetRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPetRaces to fetch.
     */
    orderBy?: CatalogPetRaceOrderByWithRelationInput | CatalogPetRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogPetRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPetRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPetRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogPetRaces
    **/
    _count?: true | CatalogPetRaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogPetRaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogPetRaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogPetRaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogPetRaceMaxAggregateInputType
  }

  export type GetCatalogPetRaceAggregateType<T extends CatalogPetRaceAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogPetRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogPetRace[P]>
      : GetScalarType<T[P], AggregateCatalogPetRace[P]>
  }




  export type CatalogPetRaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogPetRaceWhereInput
    orderBy?: CatalogPetRaceOrderByWithAggregationInput | CatalogPetRaceOrderByWithAggregationInput[]
    by: CatalogPetRaceScalarFieldEnum[] | CatalogPetRaceScalarFieldEnum
    having?: CatalogPetRaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogPetRaceCountAggregateInputType | true
    _avg?: CatalogPetRaceAvgAggregateInputType
    _sum?: CatalogPetRaceSumAggregateInputType
    _min?: CatalogPetRaceMinAggregateInputType
    _max?: CatalogPetRaceMaxAggregateInputType
  }

  export type CatalogPetRaceGroupByOutputType = {
    id: number
    raceid: number
    color1: number | null
    color2: number | null
    has1color: boolean
    has2color: boolean
    _count: CatalogPetRaceCountAggregateOutputType | null
    _avg: CatalogPetRaceAvgAggregateOutputType | null
    _sum: CatalogPetRaceSumAggregateOutputType | null
    _min: CatalogPetRaceMinAggregateOutputType | null
    _max: CatalogPetRaceMaxAggregateOutputType | null
  }

  type GetCatalogPetRaceGroupByPayload<T extends CatalogPetRaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogPetRaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogPetRaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogPetRaceGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogPetRaceGroupByOutputType[P]>
        }
      >
    >


  export type CatalogPetRaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceid?: boolean
    color1?: boolean
    color2?: boolean
    has1color?: boolean
    has2color?: boolean
  }, ExtArgs["result"]["catalogPetRace"]>

  export type CatalogPetRaceSelectScalar = {
    id?: boolean
    raceid?: boolean
    color1?: boolean
    color2?: boolean
    has1color?: boolean
    has2color?: boolean
  }


  export type $CatalogPetRacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogPetRace"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      raceid: number
      color1: number | null
      color2: number | null
      has1color: boolean
      has2color: boolean
    }, ExtArgs["result"]["catalogPetRace"]>
    composites: {}
  }


  type CatalogPetRaceGetPayload<S extends boolean | null | undefined | CatalogPetRaceDefaultArgs> = $Result.GetResult<Prisma.$CatalogPetRacePayload, S>

  type CatalogPetRaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogPetRaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogPetRaceCountAggregateInputType | true
    }

  export interface CatalogPetRaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogPetRace'], meta: { name: 'CatalogPetRace' } }
    /**
     * Find zero or one CatalogPetRace that matches the filter.
     * @param {CatalogPetRaceFindUniqueArgs} args - Arguments to find a CatalogPetRace
     * @example
     * // Get one CatalogPetRace
     * const catalogPetRace = await prisma.catalogPetRace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogPetRaceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPetRaceFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogPetRace that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogPetRaceFindUniqueOrThrowArgs} args - Arguments to find a CatalogPetRace
     * @example
     * // Get one CatalogPetRace
     * const catalogPetRace = await prisma.catalogPetRace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogPetRaceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPetRaceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogPetRace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceFindFirstArgs} args - Arguments to find a CatalogPetRace
     * @example
     * // Get one CatalogPetRace
     * const catalogPetRace = await prisma.catalogPetRace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogPetRaceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPetRaceFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogPetRace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceFindFirstOrThrowArgs} args - Arguments to find a CatalogPetRace
     * @example
     * // Get one CatalogPetRace
     * const catalogPetRace = await prisma.catalogPetRace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogPetRaceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPetRaceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogPetRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogPetRaces
     * const catalogPetRaces = await prisma.catalogPetRace.findMany()
     * 
     * // Get first 10 CatalogPetRaces
     * const catalogPetRaces = await prisma.catalogPetRace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogPetRaceWithIdOnly = await prisma.catalogPetRace.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogPetRaceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPetRaceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogPetRace.
     * @param {CatalogPetRaceCreateArgs} args - Arguments to create a CatalogPetRace.
     * @example
     * // Create one CatalogPetRace
     * const CatalogPetRace = await prisma.catalogPetRace.create({
     *   data: {
     *     // ... data to create a CatalogPetRace
     *   }
     * })
     * 
    **/
    create<T extends CatalogPetRaceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPetRaceCreateArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogPetRaces.
     *     @param {CatalogPetRaceCreateManyArgs} args - Arguments to create many CatalogPetRaces.
     *     @example
     *     // Create many CatalogPetRaces
     *     const catalogPetRace = await prisma.catalogPetRace.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogPetRaceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPetRaceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogPetRace.
     * @param {CatalogPetRaceDeleteArgs} args - Arguments to delete one CatalogPetRace.
     * @example
     * // Delete one CatalogPetRace
     * const CatalogPetRace = await prisma.catalogPetRace.delete({
     *   where: {
     *     // ... filter to delete one CatalogPetRace
     *   }
     * })
     * 
    **/
    delete<T extends CatalogPetRaceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPetRaceDeleteArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogPetRace.
     * @param {CatalogPetRaceUpdateArgs} args - Arguments to update one CatalogPetRace.
     * @example
     * // Update one CatalogPetRace
     * const catalogPetRace = await prisma.catalogPetRace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogPetRaceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPetRaceUpdateArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogPetRaces.
     * @param {CatalogPetRaceDeleteManyArgs} args - Arguments to filter CatalogPetRaces to delete.
     * @example
     * // Delete a few CatalogPetRaces
     * const { count } = await prisma.catalogPetRace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogPetRaceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPetRaceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogPetRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogPetRaces
     * const catalogPetRace = await prisma.catalogPetRace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogPetRaceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPetRaceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogPetRace.
     * @param {CatalogPetRaceUpsertArgs} args - Arguments to update or create a CatalogPetRace.
     * @example
     * // Update or create a CatalogPetRace
     * const catalogPetRace = await prisma.catalogPetRace.upsert({
     *   create: {
     *     // ... data to create a CatalogPetRace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogPetRace we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogPetRaceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPetRaceUpsertArgs<ExtArgs>>
    ): Prisma__CatalogPetRaceClient<$Result.GetResult<Prisma.$CatalogPetRacePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogPetRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceCountArgs} args - Arguments to filter CatalogPetRaces to count.
     * @example
     * // Count the number of CatalogPetRaces
     * const count = await prisma.catalogPetRace.count({
     *   where: {
     *     // ... the filter for the CatalogPetRaces we want to count
     *   }
     * })
    **/
    count<T extends CatalogPetRaceCountArgs>(
      args?: Subset<T, CatalogPetRaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogPetRaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogPetRace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogPetRaceAggregateArgs>(args: Subset<T, CatalogPetRaceAggregateArgs>): Prisma.PrismaPromise<GetCatalogPetRaceAggregateType<T>>

    /**
     * Group by CatalogPetRace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPetRaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogPetRaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogPetRaceGroupByArgs['orderBy'] }
        : { orderBy?: CatalogPetRaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogPetRaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogPetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogPetRace model
   */
  readonly fields: CatalogPetRaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogPetRace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogPetRaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogPetRace model
   */ 
  interface CatalogPetRaceFieldRefs {
    readonly id: FieldRef<"CatalogPetRace", 'Int'>
    readonly raceid: FieldRef<"CatalogPetRace", 'Int'>
    readonly color1: FieldRef<"CatalogPetRace", 'Int'>
    readonly color2: FieldRef<"CatalogPetRace", 'Int'>
    readonly has1color: FieldRef<"CatalogPetRace", 'Boolean'>
    readonly has2color: FieldRef<"CatalogPetRace", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CatalogPetRace findUnique
   */
  export type CatalogPetRaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPetRace to fetch.
     */
    where: CatalogPetRaceWhereUniqueInput
  }


  /**
   * CatalogPetRace findUniqueOrThrow
   */
  export type CatalogPetRaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPetRace to fetch.
     */
    where: CatalogPetRaceWhereUniqueInput
  }


  /**
   * CatalogPetRace findFirst
   */
  export type CatalogPetRaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPetRace to fetch.
     */
    where?: CatalogPetRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPetRaces to fetch.
     */
    orderBy?: CatalogPetRaceOrderByWithRelationInput | CatalogPetRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPetRaces.
     */
    cursor?: CatalogPetRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPetRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPetRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPetRaces.
     */
    distinct?: CatalogPetRaceScalarFieldEnum | CatalogPetRaceScalarFieldEnum[]
  }


  /**
   * CatalogPetRace findFirstOrThrow
   */
  export type CatalogPetRaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPetRace to fetch.
     */
    where?: CatalogPetRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPetRaces to fetch.
     */
    orderBy?: CatalogPetRaceOrderByWithRelationInput | CatalogPetRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPetRaces.
     */
    cursor?: CatalogPetRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPetRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPetRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPetRaces.
     */
    distinct?: CatalogPetRaceScalarFieldEnum | CatalogPetRaceScalarFieldEnum[]
  }


  /**
   * CatalogPetRace findMany
   */
  export type CatalogPetRaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPetRaces to fetch.
     */
    where?: CatalogPetRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPetRaces to fetch.
     */
    orderBy?: CatalogPetRaceOrderByWithRelationInput | CatalogPetRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogPetRaces.
     */
    cursor?: CatalogPetRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPetRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPetRaces.
     */
    skip?: number
    distinct?: CatalogPetRaceScalarFieldEnum | CatalogPetRaceScalarFieldEnum[]
  }


  /**
   * CatalogPetRace create
   */
  export type CatalogPetRaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogPetRace.
     */
    data: XOR<CatalogPetRaceCreateInput, CatalogPetRaceUncheckedCreateInput>
  }


  /**
   * CatalogPetRace createMany
   */
  export type CatalogPetRaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogPetRaces.
     */
    data: CatalogPetRaceCreateManyInput | CatalogPetRaceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogPetRace update
   */
  export type CatalogPetRaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogPetRace.
     */
    data: XOR<CatalogPetRaceUpdateInput, CatalogPetRaceUncheckedUpdateInput>
    /**
     * Choose, which CatalogPetRace to update.
     */
    where: CatalogPetRaceWhereUniqueInput
  }


  /**
   * CatalogPetRace updateMany
   */
  export type CatalogPetRaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogPetRaces.
     */
    data: XOR<CatalogPetRaceUpdateManyMutationInput, CatalogPetRaceUncheckedUpdateManyInput>
    /**
     * Filter which CatalogPetRaces to update
     */
    where?: CatalogPetRaceWhereInput
  }


  /**
   * CatalogPetRace upsert
   */
  export type CatalogPetRaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogPetRace to update in case it exists.
     */
    where: CatalogPetRaceWhereUniqueInput
    /**
     * In case the CatalogPetRace found by the `where` argument doesn't exist, create a new CatalogPetRace with this data.
     */
    create: XOR<CatalogPetRaceCreateInput, CatalogPetRaceUncheckedCreateInput>
    /**
     * In case the CatalogPetRace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogPetRaceUpdateInput, CatalogPetRaceUncheckedUpdateInput>
  }


  /**
   * CatalogPetRace delete
   */
  export type CatalogPetRaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
    /**
     * Filter which CatalogPetRace to delete.
     */
    where: CatalogPetRaceWhereUniqueInput
  }


  /**
   * CatalogPetRace deleteMany
   */
  export type CatalogPetRaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPetRaces to delete
     */
    where?: CatalogPetRaceWhereInput
  }


  /**
   * CatalogPetRace without action
   */
  export type CatalogPetRaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPetRace
     */
    select?: CatalogPetRaceSelect<ExtArgs> | null
  }



  /**
   * Model CatalogPromotion
   */

  export type AggregateCatalogPromotion = {
    _count: CatalogPromotionCountAggregateOutputType | null
    _avg: CatalogPromotionAvgAggregateOutputType | null
    _sum: CatalogPromotionSumAggregateOutputType | null
    _min: CatalogPromotionMinAggregateOutputType | null
    _max: CatalogPromotionMaxAggregateOutputType | null
  }

  export type CatalogPromotionAvgAggregateOutputType = {
    id: number | null
    unknown: number | null
    parentId: number | null
  }

  export type CatalogPromotionSumAggregateOutputType = {
    id: number | null
    unknown: number | null
    parentId: number | null
  }

  export type CatalogPromotionMinAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    titleBr: string | null
    image: string | null
    unknown: number | null
    pageLink: string | null
    parentId: number | null
  }

  export type CatalogPromotionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    titleBr: string | null
    image: string | null
    unknown: number | null
    pageLink: string | null
    parentId: number | null
  }

  export type CatalogPromotionCountAggregateOutputType = {
    id: number
    title: number
    titleEn: number
    titleBr: number
    image: number
    unknown: number
    pageLink: number
    parentId: number
    _all: number
  }


  export type CatalogPromotionAvgAggregateInputType = {
    id?: true
    unknown?: true
    parentId?: true
  }

  export type CatalogPromotionSumAggregateInputType = {
    id?: true
    unknown?: true
    parentId?: true
  }

  export type CatalogPromotionMinAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    titleBr?: true
    image?: true
    unknown?: true
    pageLink?: true
    parentId?: true
  }

  export type CatalogPromotionMaxAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    titleBr?: true
    image?: true
    unknown?: true
    pageLink?: true
    parentId?: true
  }

  export type CatalogPromotionCountAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    titleBr?: true
    image?: true
    unknown?: true
    pageLink?: true
    parentId?: true
    _all?: true
  }

  export type CatalogPromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPromotion to aggregate.
     */
    where?: CatalogPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPromotions to fetch.
     */
    orderBy?: CatalogPromotionOrderByWithRelationInput | CatalogPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogPromotions
    **/
    _count?: true | CatalogPromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogPromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogPromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogPromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogPromotionMaxAggregateInputType
  }

  export type GetCatalogPromotionAggregateType<T extends CatalogPromotionAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogPromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogPromotion[P]>
      : GetScalarType<T[P], AggregateCatalogPromotion[P]>
  }




  export type CatalogPromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogPromotionWhereInput
    orderBy?: CatalogPromotionOrderByWithAggregationInput | CatalogPromotionOrderByWithAggregationInput[]
    by: CatalogPromotionScalarFieldEnum[] | CatalogPromotionScalarFieldEnum
    having?: CatalogPromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogPromotionCountAggregateInputType | true
    _avg?: CatalogPromotionAvgAggregateInputType
    _sum?: CatalogPromotionSumAggregateInputType
    _min?: CatalogPromotionMinAggregateInputType
    _max?: CatalogPromotionMaxAggregateInputType
  }

  export type CatalogPromotionGroupByOutputType = {
    id: number
    title: string | null
    titleEn: string | null
    titleBr: string | null
    image: string | null
    unknown: number | null
    pageLink: string | null
    parentId: number | null
    _count: CatalogPromotionCountAggregateOutputType | null
    _avg: CatalogPromotionAvgAggregateOutputType | null
    _sum: CatalogPromotionSumAggregateOutputType | null
    _min: CatalogPromotionMinAggregateOutputType | null
    _max: CatalogPromotionMaxAggregateOutputType | null
  }

  type GetCatalogPromotionGroupByPayload<T extends CatalogPromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogPromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogPromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogPromotionGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogPromotionGroupByOutputType[P]>
        }
      >
    >


  export type CatalogPromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    titleBr?: boolean
    image?: boolean
    unknown?: boolean
    pageLink?: boolean
    parentId?: boolean
  }, ExtArgs["result"]["catalogPromotion"]>

  export type CatalogPromotionSelectScalar = {
    id?: boolean
    title?: boolean
    titleEn?: boolean
    titleBr?: boolean
    image?: boolean
    unknown?: boolean
    pageLink?: boolean
    parentId?: boolean
  }


  export type $CatalogPromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogPromotion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      titleEn: string | null
      titleBr: string | null
      image: string | null
      unknown: number | null
      pageLink: string | null
      parentId: number | null
    }, ExtArgs["result"]["catalogPromotion"]>
    composites: {}
  }


  type CatalogPromotionGetPayload<S extends boolean | null | undefined | CatalogPromotionDefaultArgs> = $Result.GetResult<Prisma.$CatalogPromotionPayload, S>

  type CatalogPromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogPromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogPromotionCountAggregateInputType | true
    }

  export interface CatalogPromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogPromotion'], meta: { name: 'CatalogPromotion' } }
    /**
     * Find zero or one CatalogPromotion that matches the filter.
     * @param {CatalogPromotionFindUniqueArgs} args - Arguments to find a CatalogPromotion
     * @example
     * // Get one CatalogPromotion
     * const catalogPromotion = await prisma.catalogPromotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogPromotionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPromotionFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogPromotion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogPromotionFindUniqueOrThrowArgs} args - Arguments to find a CatalogPromotion
     * @example
     * // Get one CatalogPromotion
     * const catalogPromotion = await prisma.catalogPromotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogPromotionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPromotionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogPromotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionFindFirstArgs} args - Arguments to find a CatalogPromotion
     * @example
     * // Get one CatalogPromotion
     * const catalogPromotion = await prisma.catalogPromotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogPromotionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPromotionFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogPromotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionFindFirstOrThrowArgs} args - Arguments to find a CatalogPromotion
     * @example
     * // Get one CatalogPromotion
     * const catalogPromotion = await prisma.catalogPromotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogPromotionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPromotionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogPromotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogPromotions
     * const catalogPromotions = await prisma.catalogPromotion.findMany()
     * 
     * // Get first 10 CatalogPromotions
     * const catalogPromotions = await prisma.catalogPromotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogPromotionWithIdOnly = await prisma.catalogPromotion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CatalogPromotionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPromotionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogPromotion.
     * @param {CatalogPromotionCreateArgs} args - Arguments to create a CatalogPromotion.
     * @example
     * // Create one CatalogPromotion
     * const CatalogPromotion = await prisma.catalogPromotion.create({
     *   data: {
     *     // ... data to create a CatalogPromotion
     *   }
     * })
     * 
    **/
    create<T extends CatalogPromotionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPromotionCreateArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogPromotions.
     *     @param {CatalogPromotionCreateManyArgs} args - Arguments to create many CatalogPromotions.
     *     @example
     *     // Create many CatalogPromotions
     *     const catalogPromotion = await prisma.catalogPromotion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogPromotionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPromotionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogPromotion.
     * @param {CatalogPromotionDeleteArgs} args - Arguments to delete one CatalogPromotion.
     * @example
     * // Delete one CatalogPromotion
     * const CatalogPromotion = await prisma.catalogPromotion.delete({
     *   where: {
     *     // ... filter to delete one CatalogPromotion
     *   }
     * })
     * 
    **/
    delete<T extends CatalogPromotionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPromotionDeleteArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogPromotion.
     * @param {CatalogPromotionUpdateArgs} args - Arguments to update one CatalogPromotion.
     * @example
     * // Update one CatalogPromotion
     * const catalogPromotion = await prisma.catalogPromotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogPromotionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPromotionUpdateArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogPromotions.
     * @param {CatalogPromotionDeleteManyArgs} args - Arguments to filter CatalogPromotions to delete.
     * @example
     * // Delete a few CatalogPromotions
     * const { count } = await prisma.catalogPromotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogPromotionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogPromotionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogPromotions
     * const catalogPromotion = await prisma.catalogPromotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogPromotionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPromotionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogPromotion.
     * @param {CatalogPromotionUpsertArgs} args - Arguments to update or create a CatalogPromotion.
     * @example
     * // Update or create a CatalogPromotion
     * const catalogPromotion = await prisma.catalogPromotion.upsert({
     *   create: {
     *     // ... data to create a CatalogPromotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogPromotion we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogPromotionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogPromotionUpsertArgs<ExtArgs>>
    ): Prisma__CatalogPromotionClient<$Result.GetResult<Prisma.$CatalogPromotionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionCountArgs} args - Arguments to filter CatalogPromotions to count.
     * @example
     * // Count the number of CatalogPromotions
     * const count = await prisma.catalogPromotion.count({
     *   where: {
     *     // ... the filter for the CatalogPromotions we want to count
     *   }
     * })
    **/
    count<T extends CatalogPromotionCountArgs>(
      args?: Subset<T, CatalogPromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogPromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogPromotionAggregateArgs>(args: Subset<T, CatalogPromotionAggregateArgs>): Prisma.PrismaPromise<GetCatalogPromotionAggregateType<T>>

    /**
     * Group by CatalogPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogPromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogPromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogPromotionGroupByArgs['orderBy'] }
        : { orderBy?: CatalogPromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogPromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogPromotion model
   */
  readonly fields: CatalogPromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogPromotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogPromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogPromotion model
   */ 
  interface CatalogPromotionFieldRefs {
    readonly id: FieldRef<"CatalogPromotion", 'Int'>
    readonly title: FieldRef<"CatalogPromotion", 'String'>
    readonly titleEn: FieldRef<"CatalogPromotion", 'String'>
    readonly titleBr: FieldRef<"CatalogPromotion", 'String'>
    readonly image: FieldRef<"CatalogPromotion", 'String'>
    readonly unknown: FieldRef<"CatalogPromotion", 'Int'>
    readonly pageLink: FieldRef<"CatalogPromotion", 'String'>
    readonly parentId: FieldRef<"CatalogPromotion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CatalogPromotion findUnique
   */
  export type CatalogPromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPromotion to fetch.
     */
    where: CatalogPromotionWhereUniqueInput
  }


  /**
   * CatalogPromotion findUniqueOrThrow
   */
  export type CatalogPromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPromotion to fetch.
     */
    where: CatalogPromotionWhereUniqueInput
  }


  /**
   * CatalogPromotion findFirst
   */
  export type CatalogPromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPromotion to fetch.
     */
    where?: CatalogPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPromotions to fetch.
     */
    orderBy?: CatalogPromotionOrderByWithRelationInput | CatalogPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPromotions.
     */
    cursor?: CatalogPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPromotions.
     */
    distinct?: CatalogPromotionScalarFieldEnum | CatalogPromotionScalarFieldEnum[]
  }


  /**
   * CatalogPromotion findFirstOrThrow
   */
  export type CatalogPromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPromotion to fetch.
     */
    where?: CatalogPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPromotions to fetch.
     */
    orderBy?: CatalogPromotionOrderByWithRelationInput | CatalogPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogPromotions.
     */
    cursor?: CatalogPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogPromotions.
     */
    distinct?: CatalogPromotionScalarFieldEnum | CatalogPromotionScalarFieldEnum[]
  }


  /**
   * CatalogPromotion findMany
   */
  export type CatalogPromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * Filter, which CatalogPromotions to fetch.
     */
    where?: CatalogPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogPromotions to fetch.
     */
    orderBy?: CatalogPromotionOrderByWithRelationInput | CatalogPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogPromotions.
     */
    cursor?: CatalogPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogPromotions.
     */
    skip?: number
    distinct?: CatalogPromotionScalarFieldEnum | CatalogPromotionScalarFieldEnum[]
  }


  /**
   * CatalogPromotion create
   */
  export type CatalogPromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogPromotion.
     */
    data?: XOR<CatalogPromotionCreateInput, CatalogPromotionUncheckedCreateInput>
  }


  /**
   * CatalogPromotion createMany
   */
  export type CatalogPromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogPromotions.
     */
    data: CatalogPromotionCreateManyInput | CatalogPromotionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogPromotion update
   */
  export type CatalogPromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogPromotion.
     */
    data: XOR<CatalogPromotionUpdateInput, CatalogPromotionUncheckedUpdateInput>
    /**
     * Choose, which CatalogPromotion to update.
     */
    where: CatalogPromotionWhereUniqueInput
  }


  /**
   * CatalogPromotion updateMany
   */
  export type CatalogPromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogPromotions.
     */
    data: XOR<CatalogPromotionUpdateManyMutationInput, CatalogPromotionUncheckedUpdateManyInput>
    /**
     * Filter which CatalogPromotions to update
     */
    where?: CatalogPromotionWhereInput
  }


  /**
   * CatalogPromotion upsert
   */
  export type CatalogPromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogPromotion to update in case it exists.
     */
    where: CatalogPromotionWhereUniqueInput
    /**
     * In case the CatalogPromotion found by the `where` argument doesn't exist, create a new CatalogPromotion with this data.
     */
    create: XOR<CatalogPromotionCreateInput, CatalogPromotionUncheckedCreateInput>
    /**
     * In case the CatalogPromotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogPromotionUpdateInput, CatalogPromotionUncheckedUpdateInput>
  }


  /**
   * CatalogPromotion delete
   */
  export type CatalogPromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
    /**
     * Filter which CatalogPromotion to delete.
     */
    where: CatalogPromotionWhereUniqueInput
  }


  /**
   * CatalogPromotion deleteMany
   */
  export type CatalogPromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogPromotions to delete
     */
    where?: CatalogPromotionWhereInput
  }


  /**
   * CatalogPromotion without action
   */
  export type CatalogPromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogPromotion
     */
    select?: CatalogPromotionSelect<ExtArgs> | null
  }



  /**
   * Model CatalogVoucher
   */

  export type AggregateCatalogVoucher = {
    _count: CatalogVoucherCountAggregateOutputType | null
    _avg: CatalogVoucherAvgAggregateOutputType | null
    _sum: CatalogVoucherSumAggregateOutputType | null
    _min: CatalogVoucherMinAggregateOutputType | null
    _max: CatalogVoucherMaxAggregateOutputType | null
  }

  export type CatalogVoucherAvgAggregateOutputType = {
    value: number | null
    currentUses: number | null
    maxUses: number | null
  }

  export type CatalogVoucherSumAggregateOutputType = {
    value: number | null
    currentUses: number | null
    maxUses: number | null
  }

  export type CatalogVoucherMinAggregateOutputType = {
    voucher: string | null
    type: $Enums.CatalogVoucherType | null
    value: number | null
    currentUses: number | null
    maxUses: number | null
    enabled: boolean | null
  }

  export type CatalogVoucherMaxAggregateOutputType = {
    voucher: string | null
    type: $Enums.CatalogVoucherType | null
    value: number | null
    currentUses: number | null
    maxUses: number | null
    enabled: boolean | null
  }

  export type CatalogVoucherCountAggregateOutputType = {
    voucher: number
    type: number
    value: number
    currentUses: number
    maxUses: number
    enabled: number
    _all: number
  }


  export type CatalogVoucherAvgAggregateInputType = {
    value?: true
    currentUses?: true
    maxUses?: true
  }

  export type CatalogVoucherSumAggregateInputType = {
    value?: true
    currentUses?: true
    maxUses?: true
  }

  export type CatalogVoucherMinAggregateInputType = {
    voucher?: true
    type?: true
    value?: true
    currentUses?: true
    maxUses?: true
    enabled?: true
  }

  export type CatalogVoucherMaxAggregateInputType = {
    voucher?: true
    type?: true
    value?: true
    currentUses?: true
    maxUses?: true
    enabled?: true
  }

  export type CatalogVoucherCountAggregateInputType = {
    voucher?: true
    type?: true
    value?: true
    currentUses?: true
    maxUses?: true
    enabled?: true
    _all?: true
  }

  export type CatalogVoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogVoucher to aggregate.
     */
    where?: CatalogVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVouchers to fetch.
     */
    orderBy?: CatalogVoucherOrderByWithRelationInput | CatalogVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogVouchers
    **/
    _count?: true | CatalogVoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogVoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogVoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogVoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogVoucherMaxAggregateInputType
  }

  export type GetCatalogVoucherAggregateType<T extends CatalogVoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogVoucher[P]>
      : GetScalarType<T[P], AggregateCatalogVoucher[P]>
  }




  export type CatalogVoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogVoucherWhereInput
    orderBy?: CatalogVoucherOrderByWithAggregationInput | CatalogVoucherOrderByWithAggregationInput[]
    by: CatalogVoucherScalarFieldEnum[] | CatalogVoucherScalarFieldEnum
    having?: CatalogVoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogVoucherCountAggregateInputType | true
    _avg?: CatalogVoucherAvgAggregateInputType
    _sum?: CatalogVoucherSumAggregateInputType
    _min?: CatalogVoucherMinAggregateInputType
    _max?: CatalogVoucherMaxAggregateInputType
  }

  export type CatalogVoucherGroupByOutputType = {
    voucher: string
    type: $Enums.CatalogVoucherType
    value: number
    currentUses: number
    maxUses: number
    enabled: boolean
    _count: CatalogVoucherCountAggregateOutputType | null
    _avg: CatalogVoucherAvgAggregateOutputType | null
    _sum: CatalogVoucherSumAggregateOutputType | null
    _min: CatalogVoucherMinAggregateOutputType | null
    _max: CatalogVoucherMaxAggregateOutputType | null
  }

  type GetCatalogVoucherGroupByPayload<T extends CatalogVoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogVoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogVoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogVoucherGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogVoucherGroupByOutputType[P]>
        }
      >
    >


  export type CatalogVoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    voucher?: boolean
    type?: boolean
    value?: boolean
    currentUses?: boolean
    maxUses?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["catalogVoucher"]>

  export type CatalogVoucherSelectScalar = {
    voucher?: boolean
    type?: boolean
    value?: boolean
    currentUses?: boolean
    maxUses?: boolean
    enabled?: boolean
  }


  export type $CatalogVoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogVoucher"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      voucher: string
      type: $Enums.CatalogVoucherType
      value: number
      currentUses: number
      maxUses: number
      enabled: boolean
    }, ExtArgs["result"]["catalogVoucher"]>
    composites: {}
  }


  type CatalogVoucherGetPayload<S extends boolean | null | undefined | CatalogVoucherDefaultArgs> = $Result.GetResult<Prisma.$CatalogVoucherPayload, S>

  type CatalogVoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogVoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogVoucherCountAggregateInputType | true
    }

  export interface CatalogVoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogVoucher'], meta: { name: 'CatalogVoucher' } }
    /**
     * Find zero or one CatalogVoucher that matches the filter.
     * @param {CatalogVoucherFindUniqueArgs} args - Arguments to find a CatalogVoucher
     * @example
     * // Get one CatalogVoucher
     * const catalogVoucher = await prisma.catalogVoucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CatalogVoucherFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVoucherFindUniqueArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CatalogVoucher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CatalogVoucherFindUniqueOrThrowArgs} args - Arguments to find a CatalogVoucher
     * @example
     * // Get one CatalogVoucher
     * const catalogVoucher = await prisma.catalogVoucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CatalogVoucherFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVoucherFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CatalogVoucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherFindFirstArgs} args - Arguments to find a CatalogVoucher
     * @example
     * // Get one CatalogVoucher
     * const catalogVoucher = await prisma.catalogVoucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CatalogVoucherFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVoucherFindFirstArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CatalogVoucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherFindFirstOrThrowArgs} args - Arguments to find a CatalogVoucher
     * @example
     * // Get one CatalogVoucher
     * const catalogVoucher = await prisma.catalogVoucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CatalogVoucherFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVoucherFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CatalogVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogVouchers
     * const catalogVouchers = await prisma.catalogVoucher.findMany()
     * 
     * // Get first 10 CatalogVouchers
     * const catalogVouchers = await prisma.catalogVoucher.findMany({ take: 10 })
     * 
     * // Only select the `voucher`
     * const catalogVoucherWithVoucherOnly = await prisma.catalogVoucher.findMany({ select: { voucher: true } })
     * 
    **/
    findMany<T extends CatalogVoucherFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVoucherFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CatalogVoucher.
     * @param {CatalogVoucherCreateArgs} args - Arguments to create a CatalogVoucher.
     * @example
     * // Create one CatalogVoucher
     * const CatalogVoucher = await prisma.catalogVoucher.create({
     *   data: {
     *     // ... data to create a CatalogVoucher
     *   }
     * })
     * 
    **/
    create<T extends CatalogVoucherCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVoucherCreateArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CatalogVouchers.
     *     @param {CatalogVoucherCreateManyArgs} args - Arguments to create many CatalogVouchers.
     *     @example
     *     // Create many CatalogVouchers
     *     const catalogVoucher = await prisma.catalogVoucher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CatalogVoucherCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVoucherCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogVoucher.
     * @param {CatalogVoucherDeleteArgs} args - Arguments to delete one CatalogVoucher.
     * @example
     * // Delete one CatalogVoucher
     * const CatalogVoucher = await prisma.catalogVoucher.delete({
     *   where: {
     *     // ... filter to delete one CatalogVoucher
     *   }
     * })
     * 
    **/
    delete<T extends CatalogVoucherDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVoucherDeleteArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CatalogVoucher.
     * @param {CatalogVoucherUpdateArgs} args - Arguments to update one CatalogVoucher.
     * @example
     * // Update one CatalogVoucher
     * const catalogVoucher = await prisma.catalogVoucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CatalogVoucherUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVoucherUpdateArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CatalogVouchers.
     * @param {CatalogVoucherDeleteManyArgs} args - Arguments to filter CatalogVouchers to delete.
     * @example
     * // Delete a few CatalogVouchers
     * const { count } = await prisma.catalogVoucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CatalogVoucherDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CatalogVoucherDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogVouchers
     * const catalogVoucher = await prisma.catalogVoucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CatalogVoucherUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVoucherUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogVoucher.
     * @param {CatalogVoucherUpsertArgs} args - Arguments to update or create a CatalogVoucher.
     * @example
     * // Update or create a CatalogVoucher
     * const catalogVoucher = await prisma.catalogVoucher.upsert({
     *   create: {
     *     // ... data to create a CatalogVoucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogVoucher we want to update
     *   }
     * })
    **/
    upsert<T extends CatalogVoucherUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CatalogVoucherUpsertArgs<ExtArgs>>
    ): Prisma__CatalogVoucherClient<$Result.GetResult<Prisma.$CatalogVoucherPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CatalogVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherCountArgs} args - Arguments to filter CatalogVouchers to count.
     * @example
     * // Count the number of CatalogVouchers
     * const count = await prisma.catalogVoucher.count({
     *   where: {
     *     // ... the filter for the CatalogVouchers we want to count
     *   }
     * })
    **/
    count<T extends CatalogVoucherCountArgs>(
      args?: Subset<T, CatalogVoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogVoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogVoucherAggregateArgs>(args: Subset<T, CatalogVoucherAggregateArgs>): Prisma.PrismaPromise<GetCatalogVoucherAggregateType<T>>

    /**
     * Group by CatalogVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogVoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogVoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogVoucherGroupByArgs['orderBy'] }
        : { orderBy?: CatalogVoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogVoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogVoucher model
   */
  readonly fields: CatalogVoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogVoucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogVoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CatalogVoucher model
   */ 
  interface CatalogVoucherFieldRefs {
    readonly voucher: FieldRef<"CatalogVoucher", 'String'>
    readonly type: FieldRef<"CatalogVoucher", 'CatalogVoucherType'>
    readonly value: FieldRef<"CatalogVoucher", 'Int'>
    readonly currentUses: FieldRef<"CatalogVoucher", 'Int'>
    readonly maxUses: FieldRef<"CatalogVoucher", 'Int'>
    readonly enabled: FieldRef<"CatalogVoucher", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CatalogVoucher findUnique
   */
  export type CatalogVoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * Filter, which CatalogVoucher to fetch.
     */
    where: CatalogVoucherWhereUniqueInput
  }


  /**
   * CatalogVoucher findUniqueOrThrow
   */
  export type CatalogVoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * Filter, which CatalogVoucher to fetch.
     */
    where: CatalogVoucherWhereUniqueInput
  }


  /**
   * CatalogVoucher findFirst
   */
  export type CatalogVoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * Filter, which CatalogVoucher to fetch.
     */
    where?: CatalogVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVouchers to fetch.
     */
    orderBy?: CatalogVoucherOrderByWithRelationInput | CatalogVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogVouchers.
     */
    cursor?: CatalogVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogVouchers.
     */
    distinct?: CatalogVoucherScalarFieldEnum | CatalogVoucherScalarFieldEnum[]
  }


  /**
   * CatalogVoucher findFirstOrThrow
   */
  export type CatalogVoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * Filter, which CatalogVoucher to fetch.
     */
    where?: CatalogVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVouchers to fetch.
     */
    orderBy?: CatalogVoucherOrderByWithRelationInput | CatalogVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogVouchers.
     */
    cursor?: CatalogVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogVouchers.
     */
    distinct?: CatalogVoucherScalarFieldEnum | CatalogVoucherScalarFieldEnum[]
  }


  /**
   * CatalogVoucher findMany
   */
  export type CatalogVoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * Filter, which CatalogVouchers to fetch.
     */
    where?: CatalogVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogVouchers to fetch.
     */
    orderBy?: CatalogVoucherOrderByWithRelationInput | CatalogVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogVouchers.
     */
    cursor?: CatalogVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogVouchers.
     */
    skip?: number
    distinct?: CatalogVoucherScalarFieldEnum | CatalogVoucherScalarFieldEnum[]
  }


  /**
   * CatalogVoucher create
   */
  export type CatalogVoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * The data needed to create a CatalogVoucher.
     */
    data: XOR<CatalogVoucherCreateInput, CatalogVoucherUncheckedCreateInput>
  }


  /**
   * CatalogVoucher createMany
   */
  export type CatalogVoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogVouchers.
     */
    data: CatalogVoucherCreateManyInput | CatalogVoucherCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CatalogVoucher update
   */
  export type CatalogVoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * The data needed to update a CatalogVoucher.
     */
    data: XOR<CatalogVoucherUpdateInput, CatalogVoucherUncheckedUpdateInput>
    /**
     * Choose, which CatalogVoucher to update.
     */
    where: CatalogVoucherWhereUniqueInput
  }


  /**
   * CatalogVoucher updateMany
   */
  export type CatalogVoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogVouchers.
     */
    data: XOR<CatalogVoucherUpdateManyMutationInput, CatalogVoucherUncheckedUpdateManyInput>
    /**
     * Filter which CatalogVouchers to update
     */
    where?: CatalogVoucherWhereInput
  }


  /**
   * CatalogVoucher upsert
   */
  export type CatalogVoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * The filter to search for the CatalogVoucher to update in case it exists.
     */
    where: CatalogVoucherWhereUniqueInput
    /**
     * In case the CatalogVoucher found by the `where` argument doesn't exist, create a new CatalogVoucher with this data.
     */
    create: XOR<CatalogVoucherCreateInput, CatalogVoucherUncheckedCreateInput>
    /**
     * In case the CatalogVoucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogVoucherUpdateInput, CatalogVoucherUncheckedUpdateInput>
  }


  /**
   * CatalogVoucher delete
   */
  export type CatalogVoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
    /**
     * Filter which CatalogVoucher to delete.
     */
    where: CatalogVoucherWhereUniqueInput
  }


  /**
   * CatalogVoucher deleteMany
   */
  export type CatalogVoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogVouchers to delete
     */
    where?: CatalogVoucherWhereInput
  }


  /**
   * CatalogVoucher without action
   */
  export type CatalogVoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogVoucher
     */
    select?: CatalogVoucherSelect<ExtArgs> | null
  }



  /**
   * Model CmsForumPost
   */

  export type AggregateCmsForumPost = {
    _count: CmsForumPostCountAggregateOutputType | null
    _avg: CmsForumPostAvgAggregateOutputType | null
    _sum: CmsForumPostSumAggregateOutputType | null
    _min: CmsForumPostMinAggregateOutputType | null
    _max: CmsForumPostMaxAggregateOutputType | null
  }

  export type CmsForumPostAvgAggregateOutputType = {
    id: number | null
    threadid: number | null
    idAuteur: number | null
  }

  export type CmsForumPostSumAggregateOutputType = {
    id: number | null
    threadid: number | null
    idAuteur: number | null
  }

  export type CmsForumPostMinAggregateOutputType = {
    id: number | null
    threadid: number | null
    message: string | null
    author: string | null
    date: string | null
    motto: string | null
    look: string | null
    idAuteur: number | null
    rank: boolean | null
  }

  export type CmsForumPostMaxAggregateOutputType = {
    id: number | null
    threadid: number | null
    message: string | null
    author: string | null
    date: string | null
    motto: string | null
    look: string | null
    idAuteur: number | null
    rank: boolean | null
  }

  export type CmsForumPostCountAggregateOutputType = {
    id: number
    threadid: number
    message: number
    author: number
    date: number
    motto: number
    look: number
    idAuteur: number
    rank: number
    _all: number
  }


  export type CmsForumPostAvgAggregateInputType = {
    id?: true
    threadid?: true
    idAuteur?: true
  }

  export type CmsForumPostSumAggregateInputType = {
    id?: true
    threadid?: true
    idAuteur?: true
  }

  export type CmsForumPostMinAggregateInputType = {
    id?: true
    threadid?: true
    message?: true
    author?: true
    date?: true
    motto?: true
    look?: true
    idAuteur?: true
    rank?: true
  }

  export type CmsForumPostMaxAggregateInputType = {
    id?: true
    threadid?: true
    message?: true
    author?: true
    date?: true
    motto?: true
    look?: true
    idAuteur?: true
    rank?: true
  }

  export type CmsForumPostCountAggregateInputType = {
    id?: true
    threadid?: true
    message?: true
    author?: true
    date?: true
    motto?: true
    look?: true
    idAuteur?: true
    rank?: true
    _all?: true
  }

  export type CmsForumPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsForumPost to aggregate.
     */
    where?: CmsForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumPosts to fetch.
     */
    orderBy?: CmsForumPostOrderByWithRelationInput | CmsForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsForumPosts
    **/
    _count?: true | CmsForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsForumPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsForumPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsForumPostMaxAggregateInputType
  }

  export type GetCmsForumPostAggregateType<T extends CmsForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsForumPost[P]>
      : GetScalarType<T[P], AggregateCmsForumPost[P]>
  }




  export type CmsForumPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsForumPostWhereInput
    orderBy?: CmsForumPostOrderByWithAggregationInput | CmsForumPostOrderByWithAggregationInput[]
    by: CmsForumPostScalarFieldEnum[] | CmsForumPostScalarFieldEnum
    having?: CmsForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsForumPostCountAggregateInputType | true
    _avg?: CmsForumPostAvgAggregateInputType
    _sum?: CmsForumPostSumAggregateInputType
    _min?: CmsForumPostMinAggregateInputType
    _max?: CmsForumPostMaxAggregateInputType
  }

  export type CmsForumPostGroupByOutputType = {
    id: number
    threadid: number
    message: string
    author: string
    date: string
    motto: string
    look: string
    idAuteur: number
    rank: boolean
    _count: CmsForumPostCountAggregateOutputType | null
    _avg: CmsForumPostAvgAggregateOutputType | null
    _sum: CmsForumPostSumAggregateOutputType | null
    _min: CmsForumPostMinAggregateOutputType | null
    _max: CmsForumPostMaxAggregateOutputType | null
  }

  type GetCmsForumPostGroupByPayload<T extends CmsForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], CmsForumPostGroupByOutputType[P]>
        }
      >
    >


  export type CmsForumPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadid?: boolean
    message?: boolean
    author?: boolean
    date?: boolean
    motto?: boolean
    look?: boolean
    idAuteur?: boolean
    rank?: boolean
  }, ExtArgs["result"]["cmsForumPost"]>

  export type CmsForumPostSelectScalar = {
    id?: boolean
    threadid?: boolean
    message?: boolean
    author?: boolean
    date?: boolean
    motto?: boolean
    look?: boolean
    idAuteur?: boolean
    rank?: boolean
  }


  export type $CmsForumPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsForumPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      threadid: number
      message: string
      author: string
      date: string
      motto: string
      look: string
      idAuteur: number
      rank: boolean
    }, ExtArgs["result"]["cmsForumPost"]>
    composites: {}
  }


  type CmsForumPostGetPayload<S extends boolean | null | undefined | CmsForumPostDefaultArgs> = $Result.GetResult<Prisma.$CmsForumPostPayload, S>

  type CmsForumPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsForumPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsForumPostCountAggregateInputType | true
    }

  export interface CmsForumPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsForumPost'], meta: { name: 'CmsForumPost' } }
    /**
     * Find zero or one CmsForumPost that matches the filter.
     * @param {CmsForumPostFindUniqueArgs} args - Arguments to find a CmsForumPost
     * @example
     * // Get one CmsForumPost
     * const cmsForumPost = await prisma.cmsForumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsForumPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumPostFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsForumPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsForumPostFindUniqueOrThrowArgs} args - Arguments to find a CmsForumPost
     * @example
     * // Get one CmsForumPost
     * const cmsForumPost = await prisma.cmsForumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsForumPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostFindFirstArgs} args - Arguments to find a CmsForumPost
     * @example
     * // Get one CmsForumPost
     * const cmsForumPost = await prisma.cmsForumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsForumPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumPostFindFirstArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsForumPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostFindFirstOrThrowArgs} args - Arguments to find a CmsForumPost
     * @example
     * // Get one CmsForumPost
     * const cmsForumPost = await prisma.cmsForumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsForumPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsForumPosts
     * const cmsForumPosts = await prisma.cmsForumPost.findMany()
     * 
     * // Get first 10 CmsForumPosts
     * const cmsForumPosts = await prisma.cmsForumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsForumPostWithIdOnly = await prisma.cmsForumPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsForumPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsForumPost.
     * @param {CmsForumPostCreateArgs} args - Arguments to create a CmsForumPost.
     * @example
     * // Create one CmsForumPost
     * const CmsForumPost = await prisma.cmsForumPost.create({
     *   data: {
     *     // ... data to create a CmsForumPost
     *   }
     * })
     * 
    **/
    create<T extends CmsForumPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumPostCreateArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsForumPosts.
     *     @param {CmsForumPostCreateManyArgs} args - Arguments to create many CmsForumPosts.
     *     @example
     *     // Create many CmsForumPosts
     *     const cmsForumPost = await prisma.cmsForumPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsForumPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsForumPost.
     * @param {CmsForumPostDeleteArgs} args - Arguments to delete one CmsForumPost.
     * @example
     * // Delete one CmsForumPost
     * const CmsForumPost = await prisma.cmsForumPost.delete({
     *   where: {
     *     // ... filter to delete one CmsForumPost
     *   }
     * })
     * 
    **/
    delete<T extends CmsForumPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumPostDeleteArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsForumPost.
     * @param {CmsForumPostUpdateArgs} args - Arguments to update one CmsForumPost.
     * @example
     * // Update one CmsForumPost
     * const cmsForumPost = await prisma.cmsForumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsForumPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumPostUpdateArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsForumPosts.
     * @param {CmsForumPostDeleteManyArgs} args - Arguments to filter CmsForumPosts to delete.
     * @example
     * // Delete a few CmsForumPosts
     * const { count } = await prisma.cmsForumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsForumPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsForumPosts
     * const cmsForumPost = await prisma.cmsForumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsForumPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsForumPost.
     * @param {CmsForumPostUpsertArgs} args - Arguments to update or create a CmsForumPost.
     * @example
     * // Update or create a CmsForumPost
     * const cmsForumPost = await prisma.cmsForumPost.upsert({
     *   create: {
     *     // ... data to create a CmsForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsForumPost we want to update
     *   }
     * })
    **/
    upsert<T extends CmsForumPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumPostUpsertArgs<ExtArgs>>
    ): Prisma__CmsForumPostClient<$Result.GetResult<Prisma.$CmsForumPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostCountArgs} args - Arguments to filter CmsForumPosts to count.
     * @example
     * // Count the number of CmsForumPosts
     * const count = await prisma.cmsForumPost.count({
     *   where: {
     *     // ... the filter for the CmsForumPosts we want to count
     *   }
     * })
    **/
    count<T extends CmsForumPostCountArgs>(
      args?: Subset<T, CmsForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsForumPostAggregateArgs>(args: Subset<T, CmsForumPostAggregateArgs>): Prisma.PrismaPromise<GetCmsForumPostAggregateType<T>>

    /**
     * Group by CmsForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsForumPostGroupByArgs['orderBy'] }
        : { orderBy?: CmsForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsForumPost model
   */
  readonly fields: CmsForumPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsForumPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsForumPost model
   */ 
  interface CmsForumPostFieldRefs {
    readonly id: FieldRef<"CmsForumPost", 'Int'>
    readonly threadid: FieldRef<"CmsForumPost", 'Int'>
    readonly message: FieldRef<"CmsForumPost", 'String'>
    readonly author: FieldRef<"CmsForumPost", 'String'>
    readonly date: FieldRef<"CmsForumPost", 'String'>
    readonly motto: FieldRef<"CmsForumPost", 'String'>
    readonly look: FieldRef<"CmsForumPost", 'String'>
    readonly idAuteur: FieldRef<"CmsForumPost", 'Int'>
    readonly rank: FieldRef<"CmsForumPost", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CmsForumPost findUnique
   */
  export type CmsForumPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumPost to fetch.
     */
    where: CmsForumPostWhereUniqueInput
  }


  /**
   * CmsForumPost findUniqueOrThrow
   */
  export type CmsForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumPost to fetch.
     */
    where: CmsForumPostWhereUniqueInput
  }


  /**
   * CmsForumPost findFirst
   */
  export type CmsForumPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumPost to fetch.
     */
    where?: CmsForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumPosts to fetch.
     */
    orderBy?: CmsForumPostOrderByWithRelationInput | CmsForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsForumPosts.
     */
    cursor?: CmsForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsForumPosts.
     */
    distinct?: CmsForumPostScalarFieldEnum | CmsForumPostScalarFieldEnum[]
  }


  /**
   * CmsForumPost findFirstOrThrow
   */
  export type CmsForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumPost to fetch.
     */
    where?: CmsForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumPosts to fetch.
     */
    orderBy?: CmsForumPostOrderByWithRelationInput | CmsForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsForumPosts.
     */
    cursor?: CmsForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsForumPosts.
     */
    distinct?: CmsForumPostScalarFieldEnum | CmsForumPostScalarFieldEnum[]
  }


  /**
   * CmsForumPost findMany
   */
  export type CmsForumPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumPosts to fetch.
     */
    where?: CmsForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumPosts to fetch.
     */
    orderBy?: CmsForumPostOrderByWithRelationInput | CmsForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsForumPosts.
     */
    cursor?: CmsForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumPosts.
     */
    skip?: number
    distinct?: CmsForumPostScalarFieldEnum | CmsForumPostScalarFieldEnum[]
  }


  /**
   * CmsForumPost create
   */
  export type CmsForumPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsForumPost.
     */
    data: XOR<CmsForumPostCreateInput, CmsForumPostUncheckedCreateInput>
  }


  /**
   * CmsForumPost createMany
   */
  export type CmsForumPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsForumPosts.
     */
    data: CmsForumPostCreateManyInput | CmsForumPostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsForumPost update
   */
  export type CmsForumPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsForumPost.
     */
    data: XOR<CmsForumPostUpdateInput, CmsForumPostUncheckedUpdateInput>
    /**
     * Choose, which CmsForumPost to update.
     */
    where: CmsForumPostWhereUniqueInput
  }


  /**
   * CmsForumPost updateMany
   */
  export type CmsForumPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsForumPosts.
     */
    data: XOR<CmsForumPostUpdateManyMutationInput, CmsForumPostUncheckedUpdateManyInput>
    /**
     * Filter which CmsForumPosts to update
     */
    where?: CmsForumPostWhereInput
  }


  /**
   * CmsForumPost upsert
   */
  export type CmsForumPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsForumPost to update in case it exists.
     */
    where: CmsForumPostWhereUniqueInput
    /**
     * In case the CmsForumPost found by the `where` argument doesn't exist, create a new CmsForumPost with this data.
     */
    create: XOR<CmsForumPostCreateInput, CmsForumPostUncheckedCreateInput>
    /**
     * In case the CmsForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsForumPostUpdateInput, CmsForumPostUncheckedUpdateInput>
  }


  /**
   * CmsForumPost delete
   */
  export type CmsForumPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
    /**
     * Filter which CmsForumPost to delete.
     */
    where: CmsForumPostWhereUniqueInput
  }


  /**
   * CmsForumPost deleteMany
   */
  export type CmsForumPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsForumPosts to delete
     */
    where?: CmsForumPostWhereInput
  }


  /**
   * CmsForumPost without action
   */
  export type CmsForumPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumPost
     */
    select?: CmsForumPostSelect<ExtArgs> | null
  }



  /**
   * Model CmsForumThread
   */

  export type AggregateCmsForumThread = {
    _count: CmsForumThreadCountAggregateOutputType | null
    _avg: CmsForumThreadAvgAggregateOutputType | null
    _sum: CmsForumThreadSumAggregateOutputType | null
    _min: CmsForumThreadMinAggregateOutputType | null
    _max: CmsForumThreadMaxAggregateOutputType | null
  }

  export type CmsForumThreadAvgAggregateOutputType = {
    id: number | null
    type: number | null
    posts: number | null
    mainPost: number | null
    statut: number | null
    views: number | null
  }

  export type CmsForumThreadSumAggregateOutputType = {
    id: number | null
    type: number | null
    posts: number | null
    mainPost: number | null
    statut: number | null
    views: number | null
  }

  export type CmsForumThreadMinAggregateOutputType = {
    id: number | null
    type: number | null
    title: string | null
    author: string | null
    date: string | null
    lastpostAuthor: string | null
    lastpostDate: string | null
    posts: number | null
    mainPost: number | null
    statut: number | null
    categorie: boolean | null
    views: number | null
  }

  export type CmsForumThreadMaxAggregateOutputType = {
    id: number | null
    type: number | null
    title: string | null
    author: string | null
    date: string | null
    lastpostAuthor: string | null
    lastpostDate: string | null
    posts: number | null
    mainPost: number | null
    statut: number | null
    categorie: boolean | null
    views: number | null
  }

  export type CmsForumThreadCountAggregateOutputType = {
    id: number
    type: number
    title: number
    author: number
    date: number
    lastpostAuthor: number
    lastpostDate: number
    posts: number
    mainPost: number
    statut: number
    categorie: number
    views: number
    _all: number
  }


  export type CmsForumThreadAvgAggregateInputType = {
    id?: true
    type?: true
    posts?: true
    mainPost?: true
    statut?: true
    views?: true
  }

  export type CmsForumThreadSumAggregateInputType = {
    id?: true
    type?: true
    posts?: true
    mainPost?: true
    statut?: true
    views?: true
  }

  export type CmsForumThreadMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    author?: true
    date?: true
    lastpostAuthor?: true
    lastpostDate?: true
    posts?: true
    mainPost?: true
    statut?: true
    categorie?: true
    views?: true
  }

  export type CmsForumThreadMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    author?: true
    date?: true
    lastpostAuthor?: true
    lastpostDate?: true
    posts?: true
    mainPost?: true
    statut?: true
    categorie?: true
    views?: true
  }

  export type CmsForumThreadCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    author?: true
    date?: true
    lastpostAuthor?: true
    lastpostDate?: true
    posts?: true
    mainPost?: true
    statut?: true
    categorie?: true
    views?: true
    _all?: true
  }

  export type CmsForumThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsForumThread to aggregate.
     */
    where?: CmsForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumThreads to fetch.
     */
    orderBy?: CmsForumThreadOrderByWithRelationInput | CmsForumThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsForumThreads
    **/
    _count?: true | CmsForumThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsForumThreadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsForumThreadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsForumThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsForumThreadMaxAggregateInputType
  }

  export type GetCmsForumThreadAggregateType<T extends CmsForumThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsForumThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsForumThread[P]>
      : GetScalarType<T[P], AggregateCmsForumThread[P]>
  }




  export type CmsForumThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsForumThreadWhereInput
    orderBy?: CmsForumThreadOrderByWithAggregationInput | CmsForumThreadOrderByWithAggregationInput[]
    by: CmsForumThreadScalarFieldEnum[] | CmsForumThreadScalarFieldEnum
    having?: CmsForumThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsForumThreadCountAggregateInputType | true
    _avg?: CmsForumThreadAvgAggregateInputType
    _sum?: CmsForumThreadSumAggregateInputType
    _min?: CmsForumThreadMinAggregateInputType
    _max?: CmsForumThreadMaxAggregateInputType
  }

  export type CmsForumThreadGroupByOutputType = {
    id: number
    type: number
    title: string
    author: string
    date: string
    lastpostAuthor: string
    lastpostDate: string
    posts: number
    mainPost: number
    statut: number
    categorie: boolean
    views: number
    _count: CmsForumThreadCountAggregateOutputType | null
    _avg: CmsForumThreadAvgAggregateOutputType | null
    _sum: CmsForumThreadSumAggregateOutputType | null
    _min: CmsForumThreadMinAggregateOutputType | null
    _max: CmsForumThreadMaxAggregateOutputType | null
  }

  type GetCmsForumThreadGroupByPayload<T extends CmsForumThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsForumThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsForumThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsForumThreadGroupByOutputType[P]>
            : GetScalarType<T[P], CmsForumThreadGroupByOutputType[P]>
        }
      >
    >


  export type CmsForumThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    author?: boolean
    date?: boolean
    lastpostAuthor?: boolean
    lastpostDate?: boolean
    posts?: boolean
    mainPost?: boolean
    statut?: boolean
    categorie?: boolean
    views?: boolean
  }, ExtArgs["result"]["cmsForumThread"]>

  export type CmsForumThreadSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    author?: boolean
    date?: boolean
    lastpostAuthor?: boolean
    lastpostDate?: boolean
    posts?: boolean
    mainPost?: boolean
    statut?: boolean
    categorie?: boolean
    views?: boolean
  }


  export type $CmsForumThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsForumThread"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: number
      title: string
      author: string
      date: string
      lastpostAuthor: string
      lastpostDate: string
      posts: number
      mainPost: number
      statut: number
      categorie: boolean
      views: number
    }, ExtArgs["result"]["cmsForumThread"]>
    composites: {}
  }


  type CmsForumThreadGetPayload<S extends boolean | null | undefined | CmsForumThreadDefaultArgs> = $Result.GetResult<Prisma.$CmsForumThreadPayload, S>

  type CmsForumThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsForumThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsForumThreadCountAggregateInputType | true
    }

  export interface CmsForumThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsForumThread'], meta: { name: 'CmsForumThread' } }
    /**
     * Find zero or one CmsForumThread that matches the filter.
     * @param {CmsForumThreadFindUniqueArgs} args - Arguments to find a CmsForumThread
     * @example
     * // Get one CmsForumThread
     * const cmsForumThread = await prisma.cmsForumThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsForumThreadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumThreadFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsForumThread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsForumThreadFindUniqueOrThrowArgs} args - Arguments to find a CmsForumThread
     * @example
     * // Get one CmsForumThread
     * const cmsForumThread = await prisma.cmsForumThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsForumThreadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumThreadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsForumThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadFindFirstArgs} args - Arguments to find a CmsForumThread
     * @example
     * // Get one CmsForumThread
     * const cmsForumThread = await prisma.cmsForumThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsForumThreadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumThreadFindFirstArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsForumThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadFindFirstOrThrowArgs} args - Arguments to find a CmsForumThread
     * @example
     * // Get one CmsForumThread
     * const cmsForumThread = await prisma.cmsForumThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsForumThreadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumThreadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsForumThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsForumThreads
     * const cmsForumThreads = await prisma.cmsForumThread.findMany()
     * 
     * // Get first 10 CmsForumThreads
     * const cmsForumThreads = await prisma.cmsForumThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsForumThreadWithIdOnly = await prisma.cmsForumThread.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsForumThreadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumThreadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsForumThread.
     * @param {CmsForumThreadCreateArgs} args - Arguments to create a CmsForumThread.
     * @example
     * // Create one CmsForumThread
     * const CmsForumThread = await prisma.cmsForumThread.create({
     *   data: {
     *     // ... data to create a CmsForumThread
     *   }
     * })
     * 
    **/
    create<T extends CmsForumThreadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumThreadCreateArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsForumThreads.
     *     @param {CmsForumThreadCreateManyArgs} args - Arguments to create many CmsForumThreads.
     *     @example
     *     // Create many CmsForumThreads
     *     const cmsForumThread = await prisma.cmsForumThread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsForumThreadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumThreadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsForumThread.
     * @param {CmsForumThreadDeleteArgs} args - Arguments to delete one CmsForumThread.
     * @example
     * // Delete one CmsForumThread
     * const CmsForumThread = await prisma.cmsForumThread.delete({
     *   where: {
     *     // ... filter to delete one CmsForumThread
     *   }
     * })
     * 
    **/
    delete<T extends CmsForumThreadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumThreadDeleteArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsForumThread.
     * @param {CmsForumThreadUpdateArgs} args - Arguments to update one CmsForumThread.
     * @example
     * // Update one CmsForumThread
     * const cmsForumThread = await prisma.cmsForumThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsForumThreadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumThreadUpdateArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsForumThreads.
     * @param {CmsForumThreadDeleteManyArgs} args - Arguments to filter CmsForumThreads to delete.
     * @example
     * // Delete a few CmsForumThreads
     * const { count } = await prisma.cmsForumThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsForumThreadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsForumThreadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsForumThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsForumThreads
     * const cmsForumThread = await prisma.cmsForumThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsForumThreadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumThreadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsForumThread.
     * @param {CmsForumThreadUpsertArgs} args - Arguments to update or create a CmsForumThread.
     * @example
     * // Update or create a CmsForumThread
     * const cmsForumThread = await prisma.cmsForumThread.upsert({
     *   create: {
     *     // ... data to create a CmsForumThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsForumThread we want to update
     *   }
     * })
    **/
    upsert<T extends CmsForumThreadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsForumThreadUpsertArgs<ExtArgs>>
    ): Prisma__CmsForumThreadClient<$Result.GetResult<Prisma.$CmsForumThreadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsForumThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadCountArgs} args - Arguments to filter CmsForumThreads to count.
     * @example
     * // Count the number of CmsForumThreads
     * const count = await prisma.cmsForumThread.count({
     *   where: {
     *     // ... the filter for the CmsForumThreads we want to count
     *   }
     * })
    **/
    count<T extends CmsForumThreadCountArgs>(
      args?: Subset<T, CmsForumThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsForumThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsForumThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsForumThreadAggregateArgs>(args: Subset<T, CmsForumThreadAggregateArgs>): Prisma.PrismaPromise<GetCmsForumThreadAggregateType<T>>

    /**
     * Group by CmsForumThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsForumThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsForumThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsForumThreadGroupByArgs['orderBy'] }
        : { orderBy?: CmsForumThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsForumThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsForumThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsForumThread model
   */
  readonly fields: CmsForumThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsForumThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsForumThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsForumThread model
   */ 
  interface CmsForumThreadFieldRefs {
    readonly id: FieldRef<"CmsForumThread", 'Int'>
    readonly type: FieldRef<"CmsForumThread", 'Int'>
    readonly title: FieldRef<"CmsForumThread", 'String'>
    readonly author: FieldRef<"CmsForumThread", 'String'>
    readonly date: FieldRef<"CmsForumThread", 'String'>
    readonly lastpostAuthor: FieldRef<"CmsForumThread", 'String'>
    readonly lastpostDate: FieldRef<"CmsForumThread", 'String'>
    readonly posts: FieldRef<"CmsForumThread", 'Int'>
    readonly mainPost: FieldRef<"CmsForumThread", 'Int'>
    readonly statut: FieldRef<"CmsForumThread", 'Int'>
    readonly categorie: FieldRef<"CmsForumThread", 'Boolean'>
    readonly views: FieldRef<"CmsForumThread", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CmsForumThread findUnique
   */
  export type CmsForumThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumThread to fetch.
     */
    where: CmsForumThreadWhereUniqueInput
  }


  /**
   * CmsForumThread findUniqueOrThrow
   */
  export type CmsForumThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumThread to fetch.
     */
    where: CmsForumThreadWhereUniqueInput
  }


  /**
   * CmsForumThread findFirst
   */
  export type CmsForumThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumThread to fetch.
     */
    where?: CmsForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumThreads to fetch.
     */
    orderBy?: CmsForumThreadOrderByWithRelationInput | CmsForumThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsForumThreads.
     */
    cursor?: CmsForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsForumThreads.
     */
    distinct?: CmsForumThreadScalarFieldEnum | CmsForumThreadScalarFieldEnum[]
  }


  /**
   * CmsForumThread findFirstOrThrow
   */
  export type CmsForumThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumThread to fetch.
     */
    where?: CmsForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumThreads to fetch.
     */
    orderBy?: CmsForumThreadOrderByWithRelationInput | CmsForumThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsForumThreads.
     */
    cursor?: CmsForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsForumThreads.
     */
    distinct?: CmsForumThreadScalarFieldEnum | CmsForumThreadScalarFieldEnum[]
  }


  /**
   * CmsForumThread findMany
   */
  export type CmsForumThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * Filter, which CmsForumThreads to fetch.
     */
    where?: CmsForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsForumThreads to fetch.
     */
    orderBy?: CmsForumThreadOrderByWithRelationInput | CmsForumThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsForumThreads.
     */
    cursor?: CmsForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsForumThreads.
     */
    skip?: number
    distinct?: CmsForumThreadScalarFieldEnum | CmsForumThreadScalarFieldEnum[]
  }


  /**
   * CmsForumThread create
   */
  export type CmsForumThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsForumThread.
     */
    data: XOR<CmsForumThreadCreateInput, CmsForumThreadUncheckedCreateInput>
  }


  /**
   * CmsForumThread createMany
   */
  export type CmsForumThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsForumThreads.
     */
    data: CmsForumThreadCreateManyInput | CmsForumThreadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsForumThread update
   */
  export type CmsForumThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsForumThread.
     */
    data: XOR<CmsForumThreadUpdateInput, CmsForumThreadUncheckedUpdateInput>
    /**
     * Choose, which CmsForumThread to update.
     */
    where: CmsForumThreadWhereUniqueInput
  }


  /**
   * CmsForumThread updateMany
   */
  export type CmsForumThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsForumThreads.
     */
    data: XOR<CmsForumThreadUpdateManyMutationInput, CmsForumThreadUncheckedUpdateManyInput>
    /**
     * Filter which CmsForumThreads to update
     */
    where?: CmsForumThreadWhereInput
  }


  /**
   * CmsForumThread upsert
   */
  export type CmsForumThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsForumThread to update in case it exists.
     */
    where: CmsForumThreadWhereUniqueInput
    /**
     * In case the CmsForumThread found by the `where` argument doesn't exist, create a new CmsForumThread with this data.
     */
    create: XOR<CmsForumThreadCreateInput, CmsForumThreadUncheckedCreateInput>
    /**
     * In case the CmsForumThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsForumThreadUpdateInput, CmsForumThreadUncheckedUpdateInput>
  }


  /**
   * CmsForumThread delete
   */
  export type CmsForumThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
    /**
     * Filter which CmsForumThread to delete.
     */
    where: CmsForumThreadWhereUniqueInput
  }


  /**
   * CmsForumThread deleteMany
   */
  export type CmsForumThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsForumThreads to delete
     */
    where?: CmsForumThreadWhereInput
  }


  /**
   * CmsForumThread without action
   */
  export type CmsForumThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsForumThread
     */
    select?: CmsForumThreadSelect<ExtArgs> | null
  }



  /**
   * Model CmsFourmCategory
   */

  export type AggregateCmsFourmCategory = {
    _count: CmsFourmCategoryCountAggregateOutputType | null
    _avg: CmsFourmCategoryAvgAggregateOutputType | null
    _sum: CmsFourmCategorySumAggregateOutputType | null
    _min: CmsFourmCategoryMinAggregateOutputType | null
    _max: CmsFourmCategoryMaxAggregateOutputType | null
  }

  export type CmsFourmCategoryAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CmsFourmCategorySumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CmsFourmCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    order: number | null
  }

  export type CmsFourmCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    order: number | null
  }

  export type CmsFourmCategoryCountAggregateOutputType = {
    id: number
    name: number
    order: number
    _all: number
  }


  export type CmsFourmCategoryAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type CmsFourmCategorySumAggregateInputType = {
    id?: true
    order?: true
  }

  export type CmsFourmCategoryMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
  }

  export type CmsFourmCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
  }

  export type CmsFourmCategoryCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    _all?: true
  }

  export type CmsFourmCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsFourmCategory to aggregate.
     */
    where?: CmsFourmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsFourmCategories to fetch.
     */
    orderBy?: CmsFourmCategoryOrderByWithRelationInput | CmsFourmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsFourmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsFourmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsFourmCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsFourmCategories
    **/
    _count?: true | CmsFourmCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsFourmCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsFourmCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsFourmCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsFourmCategoryMaxAggregateInputType
  }

  export type GetCmsFourmCategoryAggregateType<T extends CmsFourmCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsFourmCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsFourmCategory[P]>
      : GetScalarType<T[P], AggregateCmsFourmCategory[P]>
  }




  export type CmsFourmCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsFourmCategoryWhereInput
    orderBy?: CmsFourmCategoryOrderByWithAggregationInput | CmsFourmCategoryOrderByWithAggregationInput[]
    by: CmsFourmCategoryScalarFieldEnum[] | CmsFourmCategoryScalarFieldEnum
    having?: CmsFourmCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsFourmCategoryCountAggregateInputType | true
    _avg?: CmsFourmCategoryAvgAggregateInputType
    _sum?: CmsFourmCategorySumAggregateInputType
    _min?: CmsFourmCategoryMinAggregateInputType
    _max?: CmsFourmCategoryMaxAggregateInputType
  }

  export type CmsFourmCategoryGroupByOutputType = {
    id: number
    name: string | null
    order: number
    _count: CmsFourmCategoryCountAggregateOutputType | null
    _avg: CmsFourmCategoryAvgAggregateOutputType | null
    _sum: CmsFourmCategorySumAggregateOutputType | null
    _min: CmsFourmCategoryMinAggregateOutputType | null
    _max: CmsFourmCategoryMaxAggregateOutputType | null
  }

  type GetCmsFourmCategoryGroupByPayload<T extends CmsFourmCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsFourmCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsFourmCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsFourmCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CmsFourmCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CmsFourmCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
  }, ExtArgs["result"]["cmsFourmCategory"]>

  export type CmsFourmCategorySelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
  }


  export type $CmsFourmCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsFourmCategory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      order: number
    }, ExtArgs["result"]["cmsFourmCategory"]>
    composites: {}
  }


  type CmsFourmCategoryGetPayload<S extends boolean | null | undefined | CmsFourmCategoryDefaultArgs> = $Result.GetResult<Prisma.$CmsFourmCategoryPayload, S>

  type CmsFourmCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsFourmCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsFourmCategoryCountAggregateInputType | true
    }

  export interface CmsFourmCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsFourmCategory'], meta: { name: 'CmsFourmCategory' } }
    /**
     * Find zero or one CmsFourmCategory that matches the filter.
     * @param {CmsFourmCategoryFindUniqueArgs} args - Arguments to find a CmsFourmCategory
     * @example
     * // Get one CmsFourmCategory
     * const cmsFourmCategory = await prisma.cmsFourmCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsFourmCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsFourmCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsFourmCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsFourmCategoryFindUniqueOrThrowArgs} args - Arguments to find a CmsFourmCategory
     * @example
     * // Get one CmsFourmCategory
     * const cmsFourmCategory = await prisma.cmsFourmCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsFourmCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsFourmCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsFourmCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryFindFirstArgs} args - Arguments to find a CmsFourmCategory
     * @example
     * // Get one CmsFourmCategory
     * const cmsFourmCategory = await prisma.cmsFourmCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsFourmCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsFourmCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsFourmCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryFindFirstOrThrowArgs} args - Arguments to find a CmsFourmCategory
     * @example
     * // Get one CmsFourmCategory
     * const cmsFourmCategory = await prisma.cmsFourmCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsFourmCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsFourmCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsFourmCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsFourmCategories
     * const cmsFourmCategories = await prisma.cmsFourmCategory.findMany()
     * 
     * // Get first 10 CmsFourmCategories
     * const cmsFourmCategories = await prisma.cmsFourmCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsFourmCategoryWithIdOnly = await prisma.cmsFourmCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsFourmCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsFourmCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsFourmCategory.
     * @param {CmsFourmCategoryCreateArgs} args - Arguments to create a CmsFourmCategory.
     * @example
     * // Create one CmsFourmCategory
     * const CmsFourmCategory = await prisma.cmsFourmCategory.create({
     *   data: {
     *     // ... data to create a CmsFourmCategory
     *   }
     * })
     * 
    **/
    create<T extends CmsFourmCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsFourmCategoryCreateArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsFourmCategories.
     *     @param {CmsFourmCategoryCreateManyArgs} args - Arguments to create many CmsFourmCategories.
     *     @example
     *     // Create many CmsFourmCategories
     *     const cmsFourmCategory = await prisma.cmsFourmCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsFourmCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsFourmCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsFourmCategory.
     * @param {CmsFourmCategoryDeleteArgs} args - Arguments to delete one CmsFourmCategory.
     * @example
     * // Delete one CmsFourmCategory
     * const CmsFourmCategory = await prisma.cmsFourmCategory.delete({
     *   where: {
     *     // ... filter to delete one CmsFourmCategory
     *   }
     * })
     * 
    **/
    delete<T extends CmsFourmCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsFourmCategoryDeleteArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsFourmCategory.
     * @param {CmsFourmCategoryUpdateArgs} args - Arguments to update one CmsFourmCategory.
     * @example
     * // Update one CmsFourmCategory
     * const cmsFourmCategory = await prisma.cmsFourmCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsFourmCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsFourmCategoryUpdateArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsFourmCategories.
     * @param {CmsFourmCategoryDeleteManyArgs} args - Arguments to filter CmsFourmCategories to delete.
     * @example
     * // Delete a few CmsFourmCategories
     * const { count } = await prisma.cmsFourmCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsFourmCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsFourmCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsFourmCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsFourmCategories
     * const cmsFourmCategory = await prisma.cmsFourmCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsFourmCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsFourmCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsFourmCategory.
     * @param {CmsFourmCategoryUpsertArgs} args - Arguments to update or create a CmsFourmCategory.
     * @example
     * // Update or create a CmsFourmCategory
     * const cmsFourmCategory = await prisma.cmsFourmCategory.upsert({
     *   create: {
     *     // ... data to create a CmsFourmCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsFourmCategory we want to update
     *   }
     * })
    **/
    upsert<T extends CmsFourmCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsFourmCategoryUpsertArgs<ExtArgs>>
    ): Prisma__CmsFourmCategoryClient<$Result.GetResult<Prisma.$CmsFourmCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsFourmCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryCountArgs} args - Arguments to filter CmsFourmCategories to count.
     * @example
     * // Count the number of CmsFourmCategories
     * const count = await prisma.cmsFourmCategory.count({
     *   where: {
     *     // ... the filter for the CmsFourmCategories we want to count
     *   }
     * })
    **/
    count<T extends CmsFourmCategoryCountArgs>(
      args?: Subset<T, CmsFourmCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsFourmCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsFourmCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsFourmCategoryAggregateArgs>(args: Subset<T, CmsFourmCategoryAggregateArgs>): Prisma.PrismaPromise<GetCmsFourmCategoryAggregateType<T>>

    /**
     * Group by CmsFourmCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsFourmCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsFourmCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsFourmCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CmsFourmCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsFourmCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsFourmCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsFourmCategory model
   */
  readonly fields: CmsFourmCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsFourmCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsFourmCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsFourmCategory model
   */ 
  interface CmsFourmCategoryFieldRefs {
    readonly id: FieldRef<"CmsFourmCategory", 'Int'>
    readonly name: FieldRef<"CmsFourmCategory", 'String'>
    readonly order: FieldRef<"CmsFourmCategory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CmsFourmCategory findUnique
   */
  export type CmsFourmCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * Filter, which CmsFourmCategory to fetch.
     */
    where: CmsFourmCategoryWhereUniqueInput
  }


  /**
   * CmsFourmCategory findUniqueOrThrow
   */
  export type CmsFourmCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * Filter, which CmsFourmCategory to fetch.
     */
    where: CmsFourmCategoryWhereUniqueInput
  }


  /**
   * CmsFourmCategory findFirst
   */
  export type CmsFourmCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * Filter, which CmsFourmCategory to fetch.
     */
    where?: CmsFourmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsFourmCategories to fetch.
     */
    orderBy?: CmsFourmCategoryOrderByWithRelationInput | CmsFourmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsFourmCategories.
     */
    cursor?: CmsFourmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsFourmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsFourmCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsFourmCategories.
     */
    distinct?: CmsFourmCategoryScalarFieldEnum | CmsFourmCategoryScalarFieldEnum[]
  }


  /**
   * CmsFourmCategory findFirstOrThrow
   */
  export type CmsFourmCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * Filter, which CmsFourmCategory to fetch.
     */
    where?: CmsFourmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsFourmCategories to fetch.
     */
    orderBy?: CmsFourmCategoryOrderByWithRelationInput | CmsFourmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsFourmCategories.
     */
    cursor?: CmsFourmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsFourmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsFourmCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsFourmCategories.
     */
    distinct?: CmsFourmCategoryScalarFieldEnum | CmsFourmCategoryScalarFieldEnum[]
  }


  /**
   * CmsFourmCategory findMany
   */
  export type CmsFourmCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * Filter, which CmsFourmCategories to fetch.
     */
    where?: CmsFourmCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsFourmCategories to fetch.
     */
    orderBy?: CmsFourmCategoryOrderByWithRelationInput | CmsFourmCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsFourmCategories.
     */
    cursor?: CmsFourmCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsFourmCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsFourmCategories.
     */
    skip?: number
    distinct?: CmsFourmCategoryScalarFieldEnum | CmsFourmCategoryScalarFieldEnum[]
  }


  /**
   * CmsFourmCategory create
   */
  export type CmsFourmCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * The data needed to create a CmsFourmCategory.
     */
    data?: XOR<CmsFourmCategoryCreateInput, CmsFourmCategoryUncheckedCreateInput>
  }


  /**
   * CmsFourmCategory createMany
   */
  export type CmsFourmCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsFourmCategories.
     */
    data: CmsFourmCategoryCreateManyInput | CmsFourmCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsFourmCategory update
   */
  export type CmsFourmCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * The data needed to update a CmsFourmCategory.
     */
    data: XOR<CmsFourmCategoryUpdateInput, CmsFourmCategoryUncheckedUpdateInput>
    /**
     * Choose, which CmsFourmCategory to update.
     */
    where: CmsFourmCategoryWhereUniqueInput
  }


  /**
   * CmsFourmCategory updateMany
   */
  export type CmsFourmCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsFourmCategories.
     */
    data: XOR<CmsFourmCategoryUpdateManyMutationInput, CmsFourmCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CmsFourmCategories to update
     */
    where?: CmsFourmCategoryWhereInput
  }


  /**
   * CmsFourmCategory upsert
   */
  export type CmsFourmCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * The filter to search for the CmsFourmCategory to update in case it exists.
     */
    where: CmsFourmCategoryWhereUniqueInput
    /**
     * In case the CmsFourmCategory found by the `where` argument doesn't exist, create a new CmsFourmCategory with this data.
     */
    create: XOR<CmsFourmCategoryCreateInput, CmsFourmCategoryUncheckedCreateInput>
    /**
     * In case the CmsFourmCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsFourmCategoryUpdateInput, CmsFourmCategoryUncheckedUpdateInput>
  }


  /**
   * CmsFourmCategory delete
   */
  export type CmsFourmCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
    /**
     * Filter which CmsFourmCategory to delete.
     */
    where: CmsFourmCategoryWhereUniqueInput
  }


  /**
   * CmsFourmCategory deleteMany
   */
  export type CmsFourmCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsFourmCategories to delete
     */
    where?: CmsFourmCategoryWhereInput
  }


  /**
   * CmsFourmCategory without action
   */
  export type CmsFourmCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsFourmCategory
     */
    select?: CmsFourmCategorySelect<ExtArgs> | null
  }



  /**
   * Model CmsMailConfirm
   */

  export type AggregateCmsMailConfirm = {
    _count: CmsMailConfirmCountAggregateOutputType | null
    _avg: CmsMailConfirmAvgAggregateOutputType | null
    _sum: CmsMailConfirmSumAggregateOutputType | null
    _min: CmsMailConfirmMinAggregateOutputType | null
    _max: CmsMailConfirmMaxAggregateOutputType | null
  }

  export type CmsMailConfirmAvgAggregateOutputType = {
    userId: number | null
    temps: number | null
    type: number | null
  }

  export type CmsMailConfirmSumAggregateOutputType = {
    userId: number | null
    temps: number | null
    type: number | null
  }

  export type CmsMailConfirmMinAggregateOutputType = {
    userId: number | null
    codedevalidation: string | null
    email: string | null
    temps: number | null
    type: number | null
  }

  export type CmsMailConfirmMaxAggregateOutputType = {
    userId: number | null
    codedevalidation: string | null
    email: string | null
    temps: number | null
    type: number | null
  }

  export type CmsMailConfirmCountAggregateOutputType = {
    userId: number
    codedevalidation: number
    email: number
    temps: number
    type: number
    _all: number
  }


  export type CmsMailConfirmAvgAggregateInputType = {
    userId?: true
    temps?: true
    type?: true
  }

  export type CmsMailConfirmSumAggregateInputType = {
    userId?: true
    temps?: true
    type?: true
  }

  export type CmsMailConfirmMinAggregateInputType = {
    userId?: true
    codedevalidation?: true
    email?: true
    temps?: true
    type?: true
  }

  export type CmsMailConfirmMaxAggregateInputType = {
    userId?: true
    codedevalidation?: true
    email?: true
    temps?: true
    type?: true
  }

  export type CmsMailConfirmCountAggregateInputType = {
    userId?: true
    codedevalidation?: true
    email?: true
    temps?: true
    type?: true
    _all?: true
  }

  export type CmsMailConfirmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsMailConfirm to aggregate.
     */
    where?: CmsMailConfirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailConfirms to fetch.
     */
    orderBy?: CmsMailConfirmOrderByWithRelationInput | CmsMailConfirmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsMailConfirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailConfirms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailConfirms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsMailConfirms
    **/
    _count?: true | CmsMailConfirmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsMailConfirmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsMailConfirmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsMailConfirmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsMailConfirmMaxAggregateInputType
  }

  export type GetCmsMailConfirmAggregateType<T extends CmsMailConfirmAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsMailConfirm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsMailConfirm[P]>
      : GetScalarType<T[P], AggregateCmsMailConfirm[P]>
  }




  export type CmsMailConfirmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsMailConfirmWhereInput
    orderBy?: CmsMailConfirmOrderByWithAggregationInput | CmsMailConfirmOrderByWithAggregationInput[]
    by: CmsMailConfirmScalarFieldEnum[] | CmsMailConfirmScalarFieldEnum
    having?: CmsMailConfirmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsMailConfirmCountAggregateInputType | true
    _avg?: CmsMailConfirmAvgAggregateInputType
    _sum?: CmsMailConfirmSumAggregateInputType
    _min?: CmsMailConfirmMinAggregateInputType
    _max?: CmsMailConfirmMaxAggregateInputType
  }

  export type CmsMailConfirmGroupByOutputType = {
    userId: number
    codedevalidation: string
    email: string
    temps: number
    type: number
    _count: CmsMailConfirmCountAggregateOutputType | null
    _avg: CmsMailConfirmAvgAggregateOutputType | null
    _sum: CmsMailConfirmSumAggregateOutputType | null
    _min: CmsMailConfirmMinAggregateOutputType | null
    _max: CmsMailConfirmMaxAggregateOutputType | null
  }

  type GetCmsMailConfirmGroupByPayload<T extends CmsMailConfirmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsMailConfirmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsMailConfirmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsMailConfirmGroupByOutputType[P]>
            : GetScalarType<T[P], CmsMailConfirmGroupByOutputType[P]>
        }
      >
    >


  export type CmsMailConfirmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    codedevalidation?: boolean
    email?: boolean
    temps?: boolean
    type?: boolean
  }, ExtArgs["result"]["cmsMailConfirm"]>

  export type CmsMailConfirmSelectScalar = {
    userId?: boolean
    codedevalidation?: boolean
    email?: boolean
    temps?: boolean
    type?: boolean
  }


  export type $CmsMailConfirmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsMailConfirm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      codedevalidation: string
      email: string
      temps: number
      type: number
    }, ExtArgs["result"]["cmsMailConfirm"]>
    composites: {}
  }


  type CmsMailConfirmGetPayload<S extends boolean | null | undefined | CmsMailConfirmDefaultArgs> = $Result.GetResult<Prisma.$CmsMailConfirmPayload, S>

  type CmsMailConfirmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsMailConfirmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsMailConfirmCountAggregateInputType | true
    }

  export interface CmsMailConfirmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsMailConfirm'], meta: { name: 'CmsMailConfirm' } }
    /**
     * Find zero or one CmsMailConfirm that matches the filter.
     * @param {CmsMailConfirmFindUniqueArgs} args - Arguments to find a CmsMailConfirm
     * @example
     * // Get one CmsMailConfirm
     * const cmsMailConfirm = await prisma.cmsMailConfirm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsMailConfirmFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailConfirmFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsMailConfirm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsMailConfirmFindUniqueOrThrowArgs} args - Arguments to find a CmsMailConfirm
     * @example
     * // Get one CmsMailConfirm
     * const cmsMailConfirm = await prisma.cmsMailConfirm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsMailConfirmFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailConfirmFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsMailConfirm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmFindFirstArgs} args - Arguments to find a CmsMailConfirm
     * @example
     * // Get one CmsMailConfirm
     * const cmsMailConfirm = await prisma.cmsMailConfirm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsMailConfirmFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailConfirmFindFirstArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsMailConfirm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmFindFirstOrThrowArgs} args - Arguments to find a CmsMailConfirm
     * @example
     * // Get one CmsMailConfirm
     * const cmsMailConfirm = await prisma.cmsMailConfirm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsMailConfirmFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailConfirmFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsMailConfirms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsMailConfirms
     * const cmsMailConfirms = await prisma.cmsMailConfirm.findMany()
     * 
     * // Get first 10 CmsMailConfirms
     * const cmsMailConfirms = await prisma.cmsMailConfirm.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const cmsMailConfirmWithUserIdOnly = await prisma.cmsMailConfirm.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CmsMailConfirmFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailConfirmFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsMailConfirm.
     * @param {CmsMailConfirmCreateArgs} args - Arguments to create a CmsMailConfirm.
     * @example
     * // Create one CmsMailConfirm
     * const CmsMailConfirm = await prisma.cmsMailConfirm.create({
     *   data: {
     *     // ... data to create a CmsMailConfirm
     *   }
     * })
     * 
    **/
    create<T extends CmsMailConfirmCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailConfirmCreateArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsMailConfirms.
     *     @param {CmsMailConfirmCreateManyArgs} args - Arguments to create many CmsMailConfirms.
     *     @example
     *     // Create many CmsMailConfirms
     *     const cmsMailConfirm = await prisma.cmsMailConfirm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsMailConfirmCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailConfirmCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsMailConfirm.
     * @param {CmsMailConfirmDeleteArgs} args - Arguments to delete one CmsMailConfirm.
     * @example
     * // Delete one CmsMailConfirm
     * const CmsMailConfirm = await prisma.cmsMailConfirm.delete({
     *   where: {
     *     // ... filter to delete one CmsMailConfirm
     *   }
     * })
     * 
    **/
    delete<T extends CmsMailConfirmDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailConfirmDeleteArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsMailConfirm.
     * @param {CmsMailConfirmUpdateArgs} args - Arguments to update one CmsMailConfirm.
     * @example
     * // Update one CmsMailConfirm
     * const cmsMailConfirm = await prisma.cmsMailConfirm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsMailConfirmUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailConfirmUpdateArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsMailConfirms.
     * @param {CmsMailConfirmDeleteManyArgs} args - Arguments to filter CmsMailConfirms to delete.
     * @example
     * // Delete a few CmsMailConfirms
     * const { count } = await prisma.cmsMailConfirm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsMailConfirmDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailConfirmDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsMailConfirms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsMailConfirms
     * const cmsMailConfirm = await prisma.cmsMailConfirm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsMailConfirmUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailConfirmUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsMailConfirm.
     * @param {CmsMailConfirmUpsertArgs} args - Arguments to update or create a CmsMailConfirm.
     * @example
     * // Update or create a CmsMailConfirm
     * const cmsMailConfirm = await prisma.cmsMailConfirm.upsert({
     *   create: {
     *     // ... data to create a CmsMailConfirm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsMailConfirm we want to update
     *   }
     * })
    **/
    upsert<T extends CmsMailConfirmUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailConfirmUpsertArgs<ExtArgs>>
    ): Prisma__CmsMailConfirmClient<$Result.GetResult<Prisma.$CmsMailConfirmPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsMailConfirms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmCountArgs} args - Arguments to filter CmsMailConfirms to count.
     * @example
     * // Count the number of CmsMailConfirms
     * const count = await prisma.cmsMailConfirm.count({
     *   where: {
     *     // ... the filter for the CmsMailConfirms we want to count
     *   }
     * })
    **/
    count<T extends CmsMailConfirmCountArgs>(
      args?: Subset<T, CmsMailConfirmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsMailConfirmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsMailConfirm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsMailConfirmAggregateArgs>(args: Subset<T, CmsMailConfirmAggregateArgs>): Prisma.PrismaPromise<GetCmsMailConfirmAggregateType<T>>

    /**
     * Group by CmsMailConfirm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailConfirmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsMailConfirmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsMailConfirmGroupByArgs['orderBy'] }
        : { orderBy?: CmsMailConfirmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsMailConfirmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsMailConfirmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsMailConfirm model
   */
  readonly fields: CmsMailConfirmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsMailConfirm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsMailConfirmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsMailConfirm model
   */ 
  interface CmsMailConfirmFieldRefs {
    readonly userId: FieldRef<"CmsMailConfirm", 'Int'>
    readonly codedevalidation: FieldRef<"CmsMailConfirm", 'String'>
    readonly email: FieldRef<"CmsMailConfirm", 'String'>
    readonly temps: FieldRef<"CmsMailConfirm", 'Int'>
    readonly type: FieldRef<"CmsMailConfirm", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CmsMailConfirm findUnique
   */
  export type CmsMailConfirmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailConfirm to fetch.
     */
    where: CmsMailConfirmWhereUniqueInput
  }


  /**
   * CmsMailConfirm findUniqueOrThrow
   */
  export type CmsMailConfirmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailConfirm to fetch.
     */
    where: CmsMailConfirmWhereUniqueInput
  }


  /**
   * CmsMailConfirm findFirst
   */
  export type CmsMailConfirmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailConfirm to fetch.
     */
    where?: CmsMailConfirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailConfirms to fetch.
     */
    orderBy?: CmsMailConfirmOrderByWithRelationInput | CmsMailConfirmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsMailConfirms.
     */
    cursor?: CmsMailConfirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailConfirms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailConfirms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsMailConfirms.
     */
    distinct?: CmsMailConfirmScalarFieldEnum | CmsMailConfirmScalarFieldEnum[]
  }


  /**
   * CmsMailConfirm findFirstOrThrow
   */
  export type CmsMailConfirmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailConfirm to fetch.
     */
    where?: CmsMailConfirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailConfirms to fetch.
     */
    orderBy?: CmsMailConfirmOrderByWithRelationInput | CmsMailConfirmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsMailConfirms.
     */
    cursor?: CmsMailConfirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailConfirms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailConfirms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsMailConfirms.
     */
    distinct?: CmsMailConfirmScalarFieldEnum | CmsMailConfirmScalarFieldEnum[]
  }


  /**
   * CmsMailConfirm findMany
   */
  export type CmsMailConfirmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailConfirms to fetch.
     */
    where?: CmsMailConfirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailConfirms to fetch.
     */
    orderBy?: CmsMailConfirmOrderByWithRelationInput | CmsMailConfirmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsMailConfirms.
     */
    cursor?: CmsMailConfirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailConfirms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailConfirms.
     */
    skip?: number
    distinct?: CmsMailConfirmScalarFieldEnum | CmsMailConfirmScalarFieldEnum[]
  }


  /**
   * CmsMailConfirm create
   */
  export type CmsMailConfirmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsMailConfirm.
     */
    data: XOR<CmsMailConfirmCreateInput, CmsMailConfirmUncheckedCreateInput>
  }


  /**
   * CmsMailConfirm createMany
   */
  export type CmsMailConfirmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsMailConfirms.
     */
    data: CmsMailConfirmCreateManyInput | CmsMailConfirmCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsMailConfirm update
   */
  export type CmsMailConfirmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsMailConfirm.
     */
    data: XOR<CmsMailConfirmUpdateInput, CmsMailConfirmUncheckedUpdateInput>
    /**
     * Choose, which CmsMailConfirm to update.
     */
    where: CmsMailConfirmWhereUniqueInput
  }


  /**
   * CmsMailConfirm updateMany
   */
  export type CmsMailConfirmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsMailConfirms.
     */
    data: XOR<CmsMailConfirmUpdateManyMutationInput, CmsMailConfirmUncheckedUpdateManyInput>
    /**
     * Filter which CmsMailConfirms to update
     */
    where?: CmsMailConfirmWhereInput
  }


  /**
   * CmsMailConfirm upsert
   */
  export type CmsMailConfirmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsMailConfirm to update in case it exists.
     */
    where: CmsMailConfirmWhereUniqueInput
    /**
     * In case the CmsMailConfirm found by the `where` argument doesn't exist, create a new CmsMailConfirm with this data.
     */
    create: XOR<CmsMailConfirmCreateInput, CmsMailConfirmUncheckedCreateInput>
    /**
     * In case the CmsMailConfirm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsMailConfirmUpdateInput, CmsMailConfirmUncheckedUpdateInput>
  }


  /**
   * CmsMailConfirm delete
   */
  export type CmsMailConfirmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
    /**
     * Filter which CmsMailConfirm to delete.
     */
    where: CmsMailConfirmWhereUniqueInput
  }


  /**
   * CmsMailConfirm deleteMany
   */
  export type CmsMailConfirmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsMailConfirms to delete
     */
    where?: CmsMailConfirmWhereInput
  }


  /**
   * CmsMailConfirm without action
   */
  export type CmsMailConfirmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailConfirm
     */
    select?: CmsMailConfirmSelect<ExtArgs> | null
  }



  /**
   * Model CmsMailForgot
   */

  export type AggregateCmsMailForgot = {
    _count: CmsMailForgotCountAggregateOutputType | null
    _avg: CmsMailForgotAvgAggregateOutputType | null
    _sum: CmsMailForgotSumAggregateOutputType | null
    _min: CmsMailForgotMinAggregateOutputType | null
    _max: CmsMailForgotMaxAggregateOutputType | null
  }

  export type CmsMailForgotAvgAggregateOutputType = {
    id: number | null
    expire: number | null
  }

  export type CmsMailForgotSumAggregateOutputType = {
    id: number | null
    expire: number | null
  }

  export type CmsMailForgotMinAggregateOutputType = {
    id: number | null
    pass: string | null
    email: string | null
    expire: number | null
    users: string | null
  }

  export type CmsMailForgotMaxAggregateOutputType = {
    id: number | null
    pass: string | null
    email: string | null
    expire: number | null
    users: string | null
  }

  export type CmsMailForgotCountAggregateOutputType = {
    id: number
    pass: number
    email: number
    expire: number
    users: number
    _all: number
  }


  export type CmsMailForgotAvgAggregateInputType = {
    id?: true
    expire?: true
  }

  export type CmsMailForgotSumAggregateInputType = {
    id?: true
    expire?: true
  }

  export type CmsMailForgotMinAggregateInputType = {
    id?: true
    pass?: true
    email?: true
    expire?: true
    users?: true
  }

  export type CmsMailForgotMaxAggregateInputType = {
    id?: true
    pass?: true
    email?: true
    expire?: true
    users?: true
  }

  export type CmsMailForgotCountAggregateInputType = {
    id?: true
    pass?: true
    email?: true
    expire?: true
    users?: true
    _all?: true
  }

  export type CmsMailForgotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsMailForgot to aggregate.
     */
    where?: CmsMailForgotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailForgots to fetch.
     */
    orderBy?: CmsMailForgotOrderByWithRelationInput | CmsMailForgotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsMailForgotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailForgots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailForgots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsMailForgots
    **/
    _count?: true | CmsMailForgotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsMailForgotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsMailForgotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsMailForgotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsMailForgotMaxAggregateInputType
  }

  export type GetCmsMailForgotAggregateType<T extends CmsMailForgotAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsMailForgot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsMailForgot[P]>
      : GetScalarType<T[P], AggregateCmsMailForgot[P]>
  }




  export type CmsMailForgotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsMailForgotWhereInput
    orderBy?: CmsMailForgotOrderByWithAggregationInput | CmsMailForgotOrderByWithAggregationInput[]
    by: CmsMailForgotScalarFieldEnum[] | CmsMailForgotScalarFieldEnum
    having?: CmsMailForgotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsMailForgotCountAggregateInputType | true
    _avg?: CmsMailForgotAvgAggregateInputType
    _sum?: CmsMailForgotSumAggregateInputType
    _min?: CmsMailForgotMinAggregateInputType
    _max?: CmsMailForgotMaxAggregateInputType
  }

  export type CmsMailForgotGroupByOutputType = {
    id: number
    pass: string
    email: string
    expire: number
    users: string
    _count: CmsMailForgotCountAggregateOutputType | null
    _avg: CmsMailForgotAvgAggregateOutputType | null
    _sum: CmsMailForgotSumAggregateOutputType | null
    _min: CmsMailForgotMinAggregateOutputType | null
    _max: CmsMailForgotMaxAggregateOutputType | null
  }

  type GetCmsMailForgotGroupByPayload<T extends CmsMailForgotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsMailForgotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsMailForgotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsMailForgotGroupByOutputType[P]>
            : GetScalarType<T[P], CmsMailForgotGroupByOutputType[P]>
        }
      >
    >


  export type CmsMailForgotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pass?: boolean
    email?: boolean
    expire?: boolean
    users?: boolean
  }, ExtArgs["result"]["cmsMailForgot"]>

  export type CmsMailForgotSelectScalar = {
    id?: boolean
    pass?: boolean
    email?: boolean
    expire?: boolean
    users?: boolean
  }


  export type $CmsMailForgotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsMailForgot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pass: string
      email: string
      expire: number
      users: string
    }, ExtArgs["result"]["cmsMailForgot"]>
    composites: {}
  }


  type CmsMailForgotGetPayload<S extends boolean | null | undefined | CmsMailForgotDefaultArgs> = $Result.GetResult<Prisma.$CmsMailForgotPayload, S>

  type CmsMailForgotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsMailForgotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsMailForgotCountAggregateInputType | true
    }

  export interface CmsMailForgotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsMailForgot'], meta: { name: 'CmsMailForgot' } }
    /**
     * Find zero or one CmsMailForgot that matches the filter.
     * @param {CmsMailForgotFindUniqueArgs} args - Arguments to find a CmsMailForgot
     * @example
     * // Get one CmsMailForgot
     * const cmsMailForgot = await prisma.cmsMailForgot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsMailForgotFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailForgotFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsMailForgot that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsMailForgotFindUniqueOrThrowArgs} args - Arguments to find a CmsMailForgot
     * @example
     * // Get one CmsMailForgot
     * const cmsMailForgot = await prisma.cmsMailForgot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsMailForgotFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailForgotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsMailForgot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotFindFirstArgs} args - Arguments to find a CmsMailForgot
     * @example
     * // Get one CmsMailForgot
     * const cmsMailForgot = await prisma.cmsMailForgot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsMailForgotFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailForgotFindFirstArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsMailForgot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotFindFirstOrThrowArgs} args - Arguments to find a CmsMailForgot
     * @example
     * // Get one CmsMailForgot
     * const cmsMailForgot = await prisma.cmsMailForgot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsMailForgotFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailForgotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsMailForgots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsMailForgots
     * const cmsMailForgots = await prisma.cmsMailForgot.findMany()
     * 
     * // Get first 10 CmsMailForgots
     * const cmsMailForgots = await prisma.cmsMailForgot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsMailForgotWithIdOnly = await prisma.cmsMailForgot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsMailForgotFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailForgotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsMailForgot.
     * @param {CmsMailForgotCreateArgs} args - Arguments to create a CmsMailForgot.
     * @example
     * // Create one CmsMailForgot
     * const CmsMailForgot = await prisma.cmsMailForgot.create({
     *   data: {
     *     // ... data to create a CmsMailForgot
     *   }
     * })
     * 
    **/
    create<T extends CmsMailForgotCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailForgotCreateArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsMailForgots.
     *     @param {CmsMailForgotCreateManyArgs} args - Arguments to create many CmsMailForgots.
     *     @example
     *     // Create many CmsMailForgots
     *     const cmsMailForgot = await prisma.cmsMailForgot.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsMailForgotCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailForgotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsMailForgot.
     * @param {CmsMailForgotDeleteArgs} args - Arguments to delete one CmsMailForgot.
     * @example
     * // Delete one CmsMailForgot
     * const CmsMailForgot = await prisma.cmsMailForgot.delete({
     *   where: {
     *     // ... filter to delete one CmsMailForgot
     *   }
     * })
     * 
    **/
    delete<T extends CmsMailForgotDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailForgotDeleteArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsMailForgot.
     * @param {CmsMailForgotUpdateArgs} args - Arguments to update one CmsMailForgot.
     * @example
     * // Update one CmsMailForgot
     * const cmsMailForgot = await prisma.cmsMailForgot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsMailForgotUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailForgotUpdateArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsMailForgots.
     * @param {CmsMailForgotDeleteManyArgs} args - Arguments to filter CmsMailForgots to delete.
     * @example
     * // Delete a few CmsMailForgots
     * const { count } = await prisma.cmsMailForgot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsMailForgotDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsMailForgotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsMailForgots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsMailForgots
     * const cmsMailForgot = await prisma.cmsMailForgot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsMailForgotUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailForgotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsMailForgot.
     * @param {CmsMailForgotUpsertArgs} args - Arguments to update or create a CmsMailForgot.
     * @example
     * // Update or create a CmsMailForgot
     * const cmsMailForgot = await prisma.cmsMailForgot.upsert({
     *   create: {
     *     // ... data to create a CmsMailForgot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsMailForgot we want to update
     *   }
     * })
    **/
    upsert<T extends CmsMailForgotUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsMailForgotUpsertArgs<ExtArgs>>
    ): Prisma__CmsMailForgotClient<$Result.GetResult<Prisma.$CmsMailForgotPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsMailForgots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotCountArgs} args - Arguments to filter CmsMailForgots to count.
     * @example
     * // Count the number of CmsMailForgots
     * const count = await prisma.cmsMailForgot.count({
     *   where: {
     *     // ... the filter for the CmsMailForgots we want to count
     *   }
     * })
    **/
    count<T extends CmsMailForgotCountArgs>(
      args?: Subset<T, CmsMailForgotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsMailForgotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsMailForgot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsMailForgotAggregateArgs>(args: Subset<T, CmsMailForgotAggregateArgs>): Prisma.PrismaPromise<GetCmsMailForgotAggregateType<T>>

    /**
     * Group by CmsMailForgot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsMailForgotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsMailForgotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsMailForgotGroupByArgs['orderBy'] }
        : { orderBy?: CmsMailForgotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsMailForgotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsMailForgotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsMailForgot model
   */
  readonly fields: CmsMailForgotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsMailForgot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsMailForgotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsMailForgot model
   */ 
  interface CmsMailForgotFieldRefs {
    readonly id: FieldRef<"CmsMailForgot", 'Int'>
    readonly pass: FieldRef<"CmsMailForgot", 'String'>
    readonly email: FieldRef<"CmsMailForgot", 'String'>
    readonly expire: FieldRef<"CmsMailForgot", 'Int'>
    readonly users: FieldRef<"CmsMailForgot", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CmsMailForgot findUnique
   */
  export type CmsMailForgotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailForgot to fetch.
     */
    where: CmsMailForgotWhereUniqueInput
  }


  /**
   * CmsMailForgot findUniqueOrThrow
   */
  export type CmsMailForgotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailForgot to fetch.
     */
    where: CmsMailForgotWhereUniqueInput
  }


  /**
   * CmsMailForgot findFirst
   */
  export type CmsMailForgotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailForgot to fetch.
     */
    where?: CmsMailForgotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailForgots to fetch.
     */
    orderBy?: CmsMailForgotOrderByWithRelationInput | CmsMailForgotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsMailForgots.
     */
    cursor?: CmsMailForgotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailForgots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailForgots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsMailForgots.
     */
    distinct?: CmsMailForgotScalarFieldEnum | CmsMailForgotScalarFieldEnum[]
  }


  /**
   * CmsMailForgot findFirstOrThrow
   */
  export type CmsMailForgotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailForgot to fetch.
     */
    where?: CmsMailForgotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailForgots to fetch.
     */
    orderBy?: CmsMailForgotOrderByWithRelationInput | CmsMailForgotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsMailForgots.
     */
    cursor?: CmsMailForgotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailForgots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailForgots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsMailForgots.
     */
    distinct?: CmsMailForgotScalarFieldEnum | CmsMailForgotScalarFieldEnum[]
  }


  /**
   * CmsMailForgot findMany
   */
  export type CmsMailForgotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * Filter, which CmsMailForgots to fetch.
     */
    where?: CmsMailForgotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsMailForgots to fetch.
     */
    orderBy?: CmsMailForgotOrderByWithRelationInput | CmsMailForgotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsMailForgots.
     */
    cursor?: CmsMailForgotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsMailForgots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsMailForgots.
     */
    skip?: number
    distinct?: CmsMailForgotScalarFieldEnum | CmsMailForgotScalarFieldEnum[]
  }


  /**
   * CmsMailForgot create
   */
  export type CmsMailForgotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsMailForgot.
     */
    data: XOR<CmsMailForgotCreateInput, CmsMailForgotUncheckedCreateInput>
  }


  /**
   * CmsMailForgot createMany
   */
  export type CmsMailForgotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsMailForgots.
     */
    data: CmsMailForgotCreateManyInput | CmsMailForgotCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsMailForgot update
   */
  export type CmsMailForgotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsMailForgot.
     */
    data: XOR<CmsMailForgotUpdateInput, CmsMailForgotUncheckedUpdateInput>
    /**
     * Choose, which CmsMailForgot to update.
     */
    where: CmsMailForgotWhereUniqueInput
  }


  /**
   * CmsMailForgot updateMany
   */
  export type CmsMailForgotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsMailForgots.
     */
    data: XOR<CmsMailForgotUpdateManyMutationInput, CmsMailForgotUncheckedUpdateManyInput>
    /**
     * Filter which CmsMailForgots to update
     */
    where?: CmsMailForgotWhereInput
  }


  /**
   * CmsMailForgot upsert
   */
  export type CmsMailForgotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsMailForgot to update in case it exists.
     */
    where: CmsMailForgotWhereUniqueInput
    /**
     * In case the CmsMailForgot found by the `where` argument doesn't exist, create a new CmsMailForgot with this data.
     */
    create: XOR<CmsMailForgotCreateInput, CmsMailForgotUncheckedCreateInput>
    /**
     * In case the CmsMailForgot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsMailForgotUpdateInput, CmsMailForgotUncheckedUpdateInput>
  }


  /**
   * CmsMailForgot delete
   */
  export type CmsMailForgotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
    /**
     * Filter which CmsMailForgot to delete.
     */
    where: CmsMailForgotWhereUniqueInput
  }


  /**
   * CmsMailForgot deleteMany
   */
  export type CmsMailForgotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsMailForgots to delete
     */
    where?: CmsMailForgotWhereInput
  }


  /**
   * CmsMailForgot without action
   */
  export type CmsMailForgotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsMailForgot
     */
    select?: CmsMailForgotSelect<ExtArgs> | null
  }



  /**
   * Model CmsNews
   */

  export type AggregateCmsNews = {
    _count: CmsNewsCountAggregateOutputType | null
    _avg: CmsNewsAvgAggregateOutputType | null
    _sum: CmsNewsSumAggregateOutputType | null
    _min: CmsNewsMinAggregateOutputType | null
    _max: CmsNewsMaxAggregateOutputType | null
  }

  export type CmsNewsAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    timestamp: number | null
    authorId: number | null
  }

  export type CmsNewsSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    timestamp: number | null
    authorId: number | null
  }

  export type CmsNewsMinAggregateOutputType = {
    id: number | null
    title: string | null
    categoryId: number | null
    topstoryImage: string | null
    body: string | null
    snippet: string | null
    timestamp: number | null
    author: string | null
    authorId: number | null
    link_keyword: string | null
  }

  export type CmsNewsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    categoryId: number | null
    topstoryImage: string | null
    body: string | null
    snippet: string | null
    timestamp: number | null
    author: string | null
    authorId: number | null
    link_keyword: string | null
  }

  export type CmsNewsCountAggregateOutputType = {
    id: number
    title: number
    categoryId: number
    topstoryImage: number
    body: number
    snippet: number
    timestamp: number
    author: number
    authorId: number
    link_keyword: number
    _all: number
  }


  export type CmsNewsAvgAggregateInputType = {
    id?: true
    categoryId?: true
    timestamp?: true
    authorId?: true
  }

  export type CmsNewsSumAggregateInputType = {
    id?: true
    categoryId?: true
    timestamp?: true
    authorId?: true
  }

  export type CmsNewsMinAggregateInputType = {
    id?: true
    title?: true
    categoryId?: true
    topstoryImage?: true
    body?: true
    snippet?: true
    timestamp?: true
    author?: true
    authorId?: true
    link_keyword?: true
  }

  export type CmsNewsMaxAggregateInputType = {
    id?: true
    title?: true
    categoryId?: true
    topstoryImage?: true
    body?: true
    snippet?: true
    timestamp?: true
    author?: true
    authorId?: true
    link_keyword?: true
  }

  export type CmsNewsCountAggregateInputType = {
    id?: true
    title?: true
    categoryId?: true
    topstoryImage?: true
    body?: true
    snippet?: true
    timestamp?: true
    author?: true
    authorId?: true
    link_keyword?: true
    _all?: true
  }

  export type CmsNewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsNews to aggregate.
     */
    where?: CmsNewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsNews to fetch.
     */
    orderBy?: CmsNewsOrderByWithRelationInput | CmsNewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsNewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsNews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsNews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsNews
    **/
    _count?: true | CmsNewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsNewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsNewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsNewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsNewsMaxAggregateInputType
  }

  export type GetCmsNewsAggregateType<T extends CmsNewsAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsNews[P]>
      : GetScalarType<T[P], AggregateCmsNews[P]>
  }




  export type CmsNewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsNewsWhereInput
    orderBy?: CmsNewsOrderByWithAggregationInput | CmsNewsOrderByWithAggregationInput[]
    by: CmsNewsScalarFieldEnum[] | CmsNewsScalarFieldEnum
    having?: CmsNewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsNewsCountAggregateInputType | true
    _avg?: CmsNewsAvgAggregateInputType
    _sum?: CmsNewsSumAggregateInputType
    _min?: CmsNewsMinAggregateInputType
    _max?: CmsNewsMaxAggregateInputType
  }

  export type CmsNewsGroupByOutputType = {
    id: number
    title: string
    categoryId: number
    topstoryImage: string
    body: string
    snippet: string
    timestamp: number
    author: string
    authorId: number
    link_keyword: string
    _count: CmsNewsCountAggregateOutputType | null
    _avg: CmsNewsAvgAggregateOutputType | null
    _sum: CmsNewsSumAggregateOutputType | null
    _min: CmsNewsMinAggregateOutputType | null
    _max: CmsNewsMaxAggregateOutputType | null
  }

  type GetCmsNewsGroupByPayload<T extends CmsNewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsNewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsNewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsNewsGroupByOutputType[P]>
            : GetScalarType<T[P], CmsNewsGroupByOutputType[P]>
        }
      >
    >


  export type CmsNewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    categoryId?: boolean
    topstoryImage?: boolean
    body?: boolean
    snippet?: boolean
    timestamp?: boolean
    author?: boolean
    authorId?: boolean
    link_keyword?: boolean
  }, ExtArgs["result"]["cmsNews"]>

  export type CmsNewsSelectScalar = {
    id?: boolean
    title?: boolean
    categoryId?: boolean
    topstoryImage?: boolean
    body?: boolean
    snippet?: boolean
    timestamp?: boolean
    author?: boolean
    authorId?: boolean
    link_keyword?: boolean
  }


  export type $CmsNewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsNews"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      categoryId: number
      topstoryImage: string
      body: string
      snippet: string
      timestamp: number
      author: string
      authorId: number
      link_keyword: string
    }, ExtArgs["result"]["cmsNews"]>
    composites: {}
  }


  type CmsNewsGetPayload<S extends boolean | null | undefined | CmsNewsDefaultArgs> = $Result.GetResult<Prisma.$CmsNewsPayload, S>

  type CmsNewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsNewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsNewsCountAggregateInputType | true
    }

  export interface CmsNewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsNews'], meta: { name: 'CmsNews' } }
    /**
     * Find zero or one CmsNews that matches the filter.
     * @param {CmsNewsFindUniqueArgs} args - Arguments to find a CmsNews
     * @example
     * // Get one CmsNews
     * const cmsNews = await prisma.cmsNews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsNewsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsNewsFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsNews that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsNewsFindUniqueOrThrowArgs} args - Arguments to find a CmsNews
     * @example
     * // Get one CmsNews
     * const cmsNews = await prisma.cmsNews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsNewsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsNewsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsNews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsFindFirstArgs} args - Arguments to find a CmsNews
     * @example
     * // Get one CmsNews
     * const cmsNews = await prisma.cmsNews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsNewsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsNewsFindFirstArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsNews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsFindFirstOrThrowArgs} args - Arguments to find a CmsNews
     * @example
     * // Get one CmsNews
     * const cmsNews = await prisma.cmsNews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsNewsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsNewsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsNews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsNews
     * const cmsNews = await prisma.cmsNews.findMany()
     * 
     * // Get first 10 CmsNews
     * const cmsNews = await prisma.cmsNews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsNewsWithIdOnly = await prisma.cmsNews.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsNewsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsNewsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsNews.
     * @param {CmsNewsCreateArgs} args - Arguments to create a CmsNews.
     * @example
     * // Create one CmsNews
     * const CmsNews = await prisma.cmsNews.create({
     *   data: {
     *     // ... data to create a CmsNews
     *   }
     * })
     * 
    **/
    create<T extends CmsNewsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsNewsCreateArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsNews.
     *     @param {CmsNewsCreateManyArgs} args - Arguments to create many CmsNews.
     *     @example
     *     // Create many CmsNews
     *     const cmsNews = await prisma.cmsNews.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsNewsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsNewsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsNews.
     * @param {CmsNewsDeleteArgs} args - Arguments to delete one CmsNews.
     * @example
     * // Delete one CmsNews
     * const CmsNews = await prisma.cmsNews.delete({
     *   where: {
     *     // ... filter to delete one CmsNews
     *   }
     * })
     * 
    **/
    delete<T extends CmsNewsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsNewsDeleteArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsNews.
     * @param {CmsNewsUpdateArgs} args - Arguments to update one CmsNews.
     * @example
     * // Update one CmsNews
     * const cmsNews = await prisma.cmsNews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsNewsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsNewsUpdateArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsNews.
     * @param {CmsNewsDeleteManyArgs} args - Arguments to filter CmsNews to delete.
     * @example
     * // Delete a few CmsNews
     * const { count } = await prisma.cmsNews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsNewsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsNewsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsNews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsNews
     * const cmsNews = await prisma.cmsNews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsNewsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsNewsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsNews.
     * @param {CmsNewsUpsertArgs} args - Arguments to update or create a CmsNews.
     * @example
     * // Update or create a CmsNews
     * const cmsNews = await prisma.cmsNews.upsert({
     *   create: {
     *     // ... data to create a CmsNews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsNews we want to update
     *   }
     * })
    **/
    upsert<T extends CmsNewsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsNewsUpsertArgs<ExtArgs>>
    ): Prisma__CmsNewsClient<$Result.GetResult<Prisma.$CmsNewsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsNews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsCountArgs} args - Arguments to filter CmsNews to count.
     * @example
     * // Count the number of CmsNews
     * const count = await prisma.cmsNews.count({
     *   where: {
     *     // ... the filter for the CmsNews we want to count
     *   }
     * })
    **/
    count<T extends CmsNewsCountArgs>(
      args?: Subset<T, CmsNewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsNewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsNews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsNewsAggregateArgs>(args: Subset<T, CmsNewsAggregateArgs>): Prisma.PrismaPromise<GetCmsNewsAggregateType<T>>

    /**
     * Group by CmsNews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsNewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsNewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsNewsGroupByArgs['orderBy'] }
        : { orderBy?: CmsNewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsNewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsNews model
   */
  readonly fields: CmsNewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsNews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsNewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsNews model
   */ 
  interface CmsNewsFieldRefs {
    readonly id: FieldRef<"CmsNews", 'Int'>
    readonly title: FieldRef<"CmsNews", 'String'>
    readonly categoryId: FieldRef<"CmsNews", 'Int'>
    readonly topstoryImage: FieldRef<"CmsNews", 'String'>
    readonly body: FieldRef<"CmsNews", 'String'>
    readonly snippet: FieldRef<"CmsNews", 'String'>
    readonly timestamp: FieldRef<"CmsNews", 'Int'>
    readonly author: FieldRef<"CmsNews", 'String'>
    readonly authorId: FieldRef<"CmsNews", 'Int'>
    readonly link_keyword: FieldRef<"CmsNews", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CmsNews findUnique
   */
  export type CmsNewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * Filter, which CmsNews to fetch.
     */
    where: CmsNewsWhereUniqueInput
  }


  /**
   * CmsNews findUniqueOrThrow
   */
  export type CmsNewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * Filter, which CmsNews to fetch.
     */
    where: CmsNewsWhereUniqueInput
  }


  /**
   * CmsNews findFirst
   */
  export type CmsNewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * Filter, which CmsNews to fetch.
     */
    where?: CmsNewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsNews to fetch.
     */
    orderBy?: CmsNewsOrderByWithRelationInput | CmsNewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsNews.
     */
    cursor?: CmsNewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsNews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsNews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsNews.
     */
    distinct?: CmsNewsScalarFieldEnum | CmsNewsScalarFieldEnum[]
  }


  /**
   * CmsNews findFirstOrThrow
   */
  export type CmsNewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * Filter, which CmsNews to fetch.
     */
    where?: CmsNewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsNews to fetch.
     */
    orderBy?: CmsNewsOrderByWithRelationInput | CmsNewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsNews.
     */
    cursor?: CmsNewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsNews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsNews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsNews.
     */
    distinct?: CmsNewsScalarFieldEnum | CmsNewsScalarFieldEnum[]
  }


  /**
   * CmsNews findMany
   */
  export type CmsNewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * Filter, which CmsNews to fetch.
     */
    where?: CmsNewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsNews to fetch.
     */
    orderBy?: CmsNewsOrderByWithRelationInput | CmsNewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsNews.
     */
    cursor?: CmsNewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsNews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsNews.
     */
    skip?: number
    distinct?: CmsNewsScalarFieldEnum | CmsNewsScalarFieldEnum[]
  }


  /**
   * CmsNews create
   */
  export type CmsNewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsNews.
     */
    data: XOR<CmsNewsCreateInput, CmsNewsUncheckedCreateInput>
  }


  /**
   * CmsNews createMany
   */
  export type CmsNewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsNews.
     */
    data: CmsNewsCreateManyInput | CmsNewsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsNews update
   */
  export type CmsNewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsNews.
     */
    data: XOR<CmsNewsUpdateInput, CmsNewsUncheckedUpdateInput>
    /**
     * Choose, which CmsNews to update.
     */
    where: CmsNewsWhereUniqueInput
  }


  /**
   * CmsNews updateMany
   */
  export type CmsNewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsNews.
     */
    data: XOR<CmsNewsUpdateManyMutationInput, CmsNewsUncheckedUpdateManyInput>
    /**
     * Filter which CmsNews to update
     */
    where?: CmsNewsWhereInput
  }


  /**
   * CmsNews upsert
   */
  export type CmsNewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsNews to update in case it exists.
     */
    where: CmsNewsWhereUniqueInput
    /**
     * In case the CmsNews found by the `where` argument doesn't exist, create a new CmsNews with this data.
     */
    create: XOR<CmsNewsCreateInput, CmsNewsUncheckedCreateInput>
    /**
     * In case the CmsNews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsNewsUpdateInput, CmsNewsUncheckedUpdateInput>
  }


  /**
   * CmsNews delete
   */
  export type CmsNewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
    /**
     * Filter which CmsNews to delete.
     */
    where: CmsNewsWhereUniqueInput
  }


  /**
   * CmsNews deleteMany
   */
  export type CmsNewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsNews to delete
     */
    where?: CmsNewsWhereInput
  }


  /**
   * CmsNews without action
   */
  export type CmsNewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsNews
     */
    select?: CmsNewsSelect<ExtArgs> | null
  }



  /**
   * Model CmsStaff
   */

  export type AggregateCmsStaff = {
    _count: CmsStaffCountAggregateOutputType | null
    _avg: CmsStaffAvgAggregateOutputType | null
    _sum: CmsStaffSumAggregateOutputType | null
    _min: CmsStaffMinAggregateOutputType | null
    _max: CmsStaffMaxAggregateOutputType | null
  }

  export type CmsStaffAvgAggregateOutputType = {
    id: number | null
    userid: number | null
    rank: number | null
  }

  export type CmsStaffSumAggregateOutputType = {
    id: number | null
    userid: number | null
    rank: number | null
  }

  export type CmsStaffMinAggregateOutputType = {
    id: number | null
    userid: number | null
    rank: number | null
    function: string | null
    socialInsta: string | null
    socialDiscord: string | null
  }

  export type CmsStaffMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    rank: number | null
    function: string | null
    socialInsta: string | null
    socialDiscord: string | null
  }

  export type CmsStaffCountAggregateOutputType = {
    id: number
    userid: number
    rank: number
    function: number
    socialInsta: number
    socialDiscord: number
    _all: number
  }


  export type CmsStaffAvgAggregateInputType = {
    id?: true
    userid?: true
    rank?: true
  }

  export type CmsStaffSumAggregateInputType = {
    id?: true
    userid?: true
    rank?: true
  }

  export type CmsStaffMinAggregateInputType = {
    id?: true
    userid?: true
    rank?: true
    function?: true
    socialInsta?: true
    socialDiscord?: true
  }

  export type CmsStaffMaxAggregateInputType = {
    id?: true
    userid?: true
    rank?: true
    function?: true
    socialInsta?: true
    socialDiscord?: true
  }

  export type CmsStaffCountAggregateInputType = {
    id?: true
    userid?: true
    rank?: true
    function?: true
    socialInsta?: true
    socialDiscord?: true
    _all?: true
  }

  export type CmsStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsStaff to aggregate.
     */
    where?: CmsStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffs to fetch.
     */
    orderBy?: CmsStaffOrderByWithRelationInput | CmsStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsStaffs
    **/
    _count?: true | CmsStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsStaffMaxAggregateInputType
  }

  export type GetCmsStaffAggregateType<T extends CmsStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsStaff[P]>
      : GetScalarType<T[P], AggregateCmsStaff[P]>
  }




  export type CmsStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsStaffWhereInput
    orderBy?: CmsStaffOrderByWithAggregationInput | CmsStaffOrderByWithAggregationInput[]
    by: CmsStaffScalarFieldEnum[] | CmsStaffScalarFieldEnum
    having?: CmsStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsStaffCountAggregateInputType | true
    _avg?: CmsStaffAvgAggregateInputType
    _sum?: CmsStaffSumAggregateInputType
    _min?: CmsStaffMinAggregateInputType
    _max?: CmsStaffMaxAggregateInputType
  }

  export type CmsStaffGroupByOutputType = {
    id: number
    userid: number
    rank: number
    function: string | null
    socialInsta: string | null
    socialDiscord: string | null
    _count: CmsStaffCountAggregateOutputType | null
    _avg: CmsStaffAvgAggregateOutputType | null
    _sum: CmsStaffSumAggregateOutputType | null
    _min: CmsStaffMinAggregateOutputType | null
    _max: CmsStaffMaxAggregateOutputType | null
  }

  type GetCmsStaffGroupByPayload<T extends CmsStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsStaffGroupByOutputType[P]>
            : GetScalarType<T[P], CmsStaffGroupByOutputType[P]>
        }
      >
    >


  export type CmsStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    rank?: boolean
    function?: boolean
    socialInsta?: boolean
    socialDiscord?: boolean
  }, ExtArgs["result"]["cmsStaff"]>

  export type CmsStaffSelectScalar = {
    id?: boolean
    userid?: boolean
    rank?: boolean
    function?: boolean
    socialInsta?: boolean
    socialDiscord?: boolean
  }


  export type $CmsStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsStaff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userid: number
      rank: number
      function: string | null
      socialInsta: string | null
      socialDiscord: string | null
    }, ExtArgs["result"]["cmsStaff"]>
    composites: {}
  }


  type CmsStaffGetPayload<S extends boolean | null | undefined | CmsStaffDefaultArgs> = $Result.GetResult<Prisma.$CmsStaffPayload, S>

  type CmsStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsStaffCountAggregateInputType | true
    }

  export interface CmsStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsStaff'], meta: { name: 'CmsStaff' } }
    /**
     * Find zero or one CmsStaff that matches the filter.
     * @param {CmsStaffFindUniqueArgs} args - Arguments to find a CmsStaff
     * @example
     * // Get one CmsStaff
     * const cmsStaff = await prisma.cmsStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsStaffFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsStaff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsStaffFindUniqueOrThrowArgs} args - Arguments to find a CmsStaff
     * @example
     * // Get one CmsStaff
     * const cmsStaff = await prisma.cmsStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsStaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffFindFirstArgs} args - Arguments to find a CmsStaff
     * @example
     * // Get one CmsStaff
     * const cmsStaff = await prisma.cmsStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsStaffFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffFindFirstArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffFindFirstOrThrowArgs} args - Arguments to find a CmsStaff
     * @example
     * // Get one CmsStaff
     * const cmsStaff = await prisma.cmsStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsStaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsStaffs
     * const cmsStaffs = await prisma.cmsStaff.findMany()
     * 
     * // Get first 10 CmsStaffs
     * const cmsStaffs = await prisma.cmsStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsStaffWithIdOnly = await prisma.cmsStaff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsStaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsStaff.
     * @param {CmsStaffCreateArgs} args - Arguments to create a CmsStaff.
     * @example
     * // Create one CmsStaff
     * const CmsStaff = await prisma.cmsStaff.create({
     *   data: {
     *     // ... data to create a CmsStaff
     *   }
     * })
     * 
    **/
    create<T extends CmsStaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffCreateArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsStaffs.
     *     @param {CmsStaffCreateManyArgs} args - Arguments to create many CmsStaffs.
     *     @example
     *     // Create many CmsStaffs
     *     const cmsStaff = await prisma.cmsStaff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsStaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsStaff.
     * @param {CmsStaffDeleteArgs} args - Arguments to delete one CmsStaff.
     * @example
     * // Delete one CmsStaff
     * const CmsStaff = await prisma.cmsStaff.delete({
     *   where: {
     *     // ... filter to delete one CmsStaff
     *   }
     * })
     * 
    **/
    delete<T extends CmsStaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffDeleteArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsStaff.
     * @param {CmsStaffUpdateArgs} args - Arguments to update one CmsStaff.
     * @example
     * // Update one CmsStaff
     * const cmsStaff = await prisma.cmsStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsStaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffUpdateArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsStaffs.
     * @param {CmsStaffDeleteManyArgs} args - Arguments to filter CmsStaffs to delete.
     * @example
     * // Delete a few CmsStaffs
     * const { count } = await prisma.cmsStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsStaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsStaffs
     * const cmsStaff = await prisma.cmsStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsStaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsStaff.
     * @param {CmsStaffUpsertArgs} args - Arguments to update or create a CmsStaff.
     * @example
     * // Update or create a CmsStaff
     * const cmsStaff = await prisma.cmsStaff.upsert({
     *   create: {
     *     // ... data to create a CmsStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsStaff we want to update
     *   }
     * })
    **/
    upsert<T extends CmsStaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffUpsertArgs<ExtArgs>>
    ): Prisma__CmsStaffClient<$Result.GetResult<Prisma.$CmsStaffPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffCountArgs} args - Arguments to filter CmsStaffs to count.
     * @example
     * // Count the number of CmsStaffs
     * const count = await prisma.cmsStaff.count({
     *   where: {
     *     // ... the filter for the CmsStaffs we want to count
     *   }
     * })
    **/
    count<T extends CmsStaffCountArgs>(
      args?: Subset<T, CmsStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsStaffAggregateArgs>(args: Subset<T, CmsStaffAggregateArgs>): Prisma.PrismaPromise<GetCmsStaffAggregateType<T>>

    /**
     * Group by CmsStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsStaffGroupByArgs['orderBy'] }
        : { orderBy?: CmsStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsStaff model
   */
  readonly fields: CmsStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsStaff model
   */ 
  interface CmsStaffFieldRefs {
    readonly id: FieldRef<"CmsStaff", 'Int'>
    readonly userid: FieldRef<"CmsStaff", 'Int'>
    readonly rank: FieldRef<"CmsStaff", 'Int'>
    readonly function: FieldRef<"CmsStaff", 'String'>
    readonly socialInsta: FieldRef<"CmsStaff", 'String'>
    readonly socialDiscord: FieldRef<"CmsStaff", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CmsStaff findUnique
   */
  export type CmsStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaff to fetch.
     */
    where: CmsStaffWhereUniqueInput
  }


  /**
   * CmsStaff findUniqueOrThrow
   */
  export type CmsStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaff to fetch.
     */
    where: CmsStaffWhereUniqueInput
  }


  /**
   * CmsStaff findFirst
   */
  export type CmsStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaff to fetch.
     */
    where?: CmsStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffs to fetch.
     */
    orderBy?: CmsStaffOrderByWithRelationInput | CmsStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsStaffs.
     */
    cursor?: CmsStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsStaffs.
     */
    distinct?: CmsStaffScalarFieldEnum | CmsStaffScalarFieldEnum[]
  }


  /**
   * CmsStaff findFirstOrThrow
   */
  export type CmsStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaff to fetch.
     */
    where?: CmsStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffs to fetch.
     */
    orderBy?: CmsStaffOrderByWithRelationInput | CmsStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsStaffs.
     */
    cursor?: CmsStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsStaffs.
     */
    distinct?: CmsStaffScalarFieldEnum | CmsStaffScalarFieldEnum[]
  }


  /**
   * CmsStaff findMany
   */
  export type CmsStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaffs to fetch.
     */
    where?: CmsStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffs to fetch.
     */
    orderBy?: CmsStaffOrderByWithRelationInput | CmsStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsStaffs.
     */
    cursor?: CmsStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffs.
     */
    skip?: number
    distinct?: CmsStaffScalarFieldEnum | CmsStaffScalarFieldEnum[]
  }


  /**
   * CmsStaff create
   */
  export type CmsStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsStaff.
     */
    data: XOR<CmsStaffCreateInput, CmsStaffUncheckedCreateInput>
  }


  /**
   * CmsStaff createMany
   */
  export type CmsStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsStaffs.
     */
    data: CmsStaffCreateManyInput | CmsStaffCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsStaff update
   */
  export type CmsStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsStaff.
     */
    data: XOR<CmsStaffUpdateInput, CmsStaffUncheckedUpdateInput>
    /**
     * Choose, which CmsStaff to update.
     */
    where: CmsStaffWhereUniqueInput
  }


  /**
   * CmsStaff updateMany
   */
  export type CmsStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsStaffs.
     */
    data: XOR<CmsStaffUpdateManyMutationInput, CmsStaffUncheckedUpdateManyInput>
    /**
     * Filter which CmsStaffs to update
     */
    where?: CmsStaffWhereInput
  }


  /**
   * CmsStaff upsert
   */
  export type CmsStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsStaff to update in case it exists.
     */
    where: CmsStaffWhereUniqueInput
    /**
     * In case the CmsStaff found by the `where` argument doesn't exist, create a new CmsStaff with this data.
     */
    create: XOR<CmsStaffCreateInput, CmsStaffUncheckedCreateInput>
    /**
     * In case the CmsStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsStaffUpdateInput, CmsStaffUncheckedUpdateInput>
  }


  /**
   * CmsStaff delete
   */
  export type CmsStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
    /**
     * Filter which CmsStaff to delete.
     */
    where: CmsStaffWhereUniqueInput
  }


  /**
   * CmsStaff deleteMany
   */
  export type CmsStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsStaffs to delete
     */
    where?: CmsStaffWhereInput
  }


  /**
   * CmsStaff without action
   */
  export type CmsStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaff
     */
    select?: CmsStaffSelect<ExtArgs> | null
  }



  /**
   * Model CmsStaffProtect
   */

  export type AggregateCmsStaffProtect = {
    _count: CmsStaffProtectCountAggregateOutputType | null
    _avg: CmsStaffProtectAvgAggregateOutputType | null
    _sum: CmsStaffProtectSumAggregateOutputType | null
    _min: CmsStaffProtectMinAggregateOutputType | null
    _max: CmsStaffProtectMaxAggregateOutputType | null
  }

  export type CmsStaffProtectAvgAggregateOutputType = {
    id: number | null
  }

  export type CmsStaffProtectSumAggregateOutputType = {
    id: number | null
  }

  export type CmsStaffProtectMinAggregateOutputType = {
    id: number | null
    ip: string | null
    username: string | null
    hide: boolean | null
  }

  export type CmsStaffProtectMaxAggregateOutputType = {
    id: number | null
    ip: string | null
    username: string | null
    hide: boolean | null
  }

  export type CmsStaffProtectCountAggregateOutputType = {
    id: number
    ip: number
    username: number
    hide: number
    _all: number
  }


  export type CmsStaffProtectAvgAggregateInputType = {
    id?: true
  }

  export type CmsStaffProtectSumAggregateInputType = {
    id?: true
  }

  export type CmsStaffProtectMinAggregateInputType = {
    id?: true
    ip?: true
    username?: true
    hide?: true
  }

  export type CmsStaffProtectMaxAggregateInputType = {
    id?: true
    ip?: true
    username?: true
    hide?: true
  }

  export type CmsStaffProtectCountAggregateInputType = {
    id?: true
    ip?: true
    username?: true
    hide?: true
    _all?: true
  }

  export type CmsStaffProtectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsStaffProtect to aggregate.
     */
    where?: CmsStaffProtectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffProtects to fetch.
     */
    orderBy?: CmsStaffProtectOrderByWithRelationInput | CmsStaffProtectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CmsStaffProtectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffProtects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffProtects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CmsStaffProtects
    **/
    _count?: true | CmsStaffProtectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CmsStaffProtectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CmsStaffProtectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CmsStaffProtectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CmsStaffProtectMaxAggregateInputType
  }

  export type GetCmsStaffProtectAggregateType<T extends CmsStaffProtectAggregateArgs> = {
        [P in keyof T & keyof AggregateCmsStaffProtect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCmsStaffProtect[P]>
      : GetScalarType<T[P], AggregateCmsStaffProtect[P]>
  }




  export type CmsStaffProtectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CmsStaffProtectWhereInput
    orderBy?: CmsStaffProtectOrderByWithAggregationInput | CmsStaffProtectOrderByWithAggregationInput[]
    by: CmsStaffProtectScalarFieldEnum[] | CmsStaffProtectScalarFieldEnum
    having?: CmsStaffProtectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CmsStaffProtectCountAggregateInputType | true
    _avg?: CmsStaffProtectAvgAggregateInputType
    _sum?: CmsStaffProtectSumAggregateInputType
    _min?: CmsStaffProtectMinAggregateInputType
    _max?: CmsStaffProtectMaxAggregateInputType
  }

  export type CmsStaffProtectGroupByOutputType = {
    id: number
    ip: string | null
    username: string
    hide: boolean
    _count: CmsStaffProtectCountAggregateOutputType | null
    _avg: CmsStaffProtectAvgAggregateOutputType | null
    _sum: CmsStaffProtectSumAggregateOutputType | null
    _min: CmsStaffProtectMinAggregateOutputType | null
    _max: CmsStaffProtectMaxAggregateOutputType | null
  }

  type GetCmsStaffProtectGroupByPayload<T extends CmsStaffProtectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CmsStaffProtectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CmsStaffProtectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CmsStaffProtectGroupByOutputType[P]>
            : GetScalarType<T[P], CmsStaffProtectGroupByOutputType[P]>
        }
      >
    >


  export type CmsStaffProtectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    username?: boolean
    hide?: boolean
  }, ExtArgs["result"]["cmsStaffProtect"]>

  export type CmsStaffProtectSelectScalar = {
    id?: boolean
    ip?: boolean
    username?: boolean
    hide?: boolean
  }


  export type $CmsStaffProtectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CmsStaffProtect"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ip: string | null
      username: string
      hide: boolean
    }, ExtArgs["result"]["cmsStaffProtect"]>
    composites: {}
  }


  type CmsStaffProtectGetPayload<S extends boolean | null | undefined | CmsStaffProtectDefaultArgs> = $Result.GetResult<Prisma.$CmsStaffProtectPayload, S>

  type CmsStaffProtectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CmsStaffProtectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CmsStaffProtectCountAggregateInputType | true
    }

  export interface CmsStaffProtectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CmsStaffProtect'], meta: { name: 'CmsStaffProtect' } }
    /**
     * Find zero or one CmsStaffProtect that matches the filter.
     * @param {CmsStaffProtectFindUniqueArgs} args - Arguments to find a CmsStaffProtect
     * @example
     * // Get one CmsStaffProtect
     * const cmsStaffProtect = await prisma.cmsStaffProtect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CmsStaffProtectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffProtectFindUniqueArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CmsStaffProtect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CmsStaffProtectFindUniqueOrThrowArgs} args - Arguments to find a CmsStaffProtect
     * @example
     * // Get one CmsStaffProtect
     * const cmsStaffProtect = await prisma.cmsStaffProtect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CmsStaffProtectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffProtectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CmsStaffProtect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectFindFirstArgs} args - Arguments to find a CmsStaffProtect
     * @example
     * // Get one CmsStaffProtect
     * const cmsStaffProtect = await prisma.cmsStaffProtect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CmsStaffProtectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffProtectFindFirstArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CmsStaffProtect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectFindFirstOrThrowArgs} args - Arguments to find a CmsStaffProtect
     * @example
     * // Get one CmsStaffProtect
     * const cmsStaffProtect = await prisma.cmsStaffProtect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CmsStaffProtectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffProtectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CmsStaffProtects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CmsStaffProtects
     * const cmsStaffProtects = await prisma.cmsStaffProtect.findMany()
     * 
     * // Get first 10 CmsStaffProtects
     * const cmsStaffProtects = await prisma.cmsStaffProtect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cmsStaffProtectWithIdOnly = await prisma.cmsStaffProtect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CmsStaffProtectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffProtectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CmsStaffProtect.
     * @param {CmsStaffProtectCreateArgs} args - Arguments to create a CmsStaffProtect.
     * @example
     * // Create one CmsStaffProtect
     * const CmsStaffProtect = await prisma.cmsStaffProtect.create({
     *   data: {
     *     // ... data to create a CmsStaffProtect
     *   }
     * })
     * 
    **/
    create<T extends CmsStaffProtectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffProtectCreateArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CmsStaffProtects.
     *     @param {CmsStaffProtectCreateManyArgs} args - Arguments to create many CmsStaffProtects.
     *     @example
     *     // Create many CmsStaffProtects
     *     const cmsStaffProtect = await prisma.cmsStaffProtect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CmsStaffProtectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffProtectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CmsStaffProtect.
     * @param {CmsStaffProtectDeleteArgs} args - Arguments to delete one CmsStaffProtect.
     * @example
     * // Delete one CmsStaffProtect
     * const CmsStaffProtect = await prisma.cmsStaffProtect.delete({
     *   where: {
     *     // ... filter to delete one CmsStaffProtect
     *   }
     * })
     * 
    **/
    delete<T extends CmsStaffProtectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffProtectDeleteArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CmsStaffProtect.
     * @param {CmsStaffProtectUpdateArgs} args - Arguments to update one CmsStaffProtect.
     * @example
     * // Update one CmsStaffProtect
     * const cmsStaffProtect = await prisma.cmsStaffProtect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CmsStaffProtectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffProtectUpdateArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CmsStaffProtects.
     * @param {CmsStaffProtectDeleteManyArgs} args - Arguments to filter CmsStaffProtects to delete.
     * @example
     * // Delete a few CmsStaffProtects
     * const { count } = await prisma.cmsStaffProtect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CmsStaffProtectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CmsStaffProtectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CmsStaffProtects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CmsStaffProtects
     * const cmsStaffProtect = await prisma.cmsStaffProtect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CmsStaffProtectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffProtectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CmsStaffProtect.
     * @param {CmsStaffProtectUpsertArgs} args - Arguments to update or create a CmsStaffProtect.
     * @example
     * // Update or create a CmsStaffProtect
     * const cmsStaffProtect = await prisma.cmsStaffProtect.upsert({
     *   create: {
     *     // ... data to create a CmsStaffProtect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CmsStaffProtect we want to update
     *   }
     * })
    **/
    upsert<T extends CmsStaffProtectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CmsStaffProtectUpsertArgs<ExtArgs>>
    ): Prisma__CmsStaffProtectClient<$Result.GetResult<Prisma.$CmsStaffProtectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CmsStaffProtects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectCountArgs} args - Arguments to filter CmsStaffProtects to count.
     * @example
     * // Count the number of CmsStaffProtects
     * const count = await prisma.cmsStaffProtect.count({
     *   where: {
     *     // ... the filter for the CmsStaffProtects we want to count
     *   }
     * })
    **/
    count<T extends CmsStaffProtectCountArgs>(
      args?: Subset<T, CmsStaffProtectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CmsStaffProtectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CmsStaffProtect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CmsStaffProtectAggregateArgs>(args: Subset<T, CmsStaffProtectAggregateArgs>): Prisma.PrismaPromise<GetCmsStaffProtectAggregateType<T>>

    /**
     * Group by CmsStaffProtect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CmsStaffProtectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CmsStaffProtectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CmsStaffProtectGroupByArgs['orderBy'] }
        : { orderBy?: CmsStaffProtectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CmsStaffProtectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCmsStaffProtectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CmsStaffProtect model
   */
  readonly fields: CmsStaffProtectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CmsStaffProtect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CmsStaffProtectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CmsStaffProtect model
   */ 
  interface CmsStaffProtectFieldRefs {
    readonly id: FieldRef<"CmsStaffProtect", 'Int'>
    readonly ip: FieldRef<"CmsStaffProtect", 'String'>
    readonly username: FieldRef<"CmsStaffProtect", 'String'>
    readonly hide: FieldRef<"CmsStaffProtect", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CmsStaffProtect findUnique
   */
  export type CmsStaffProtectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaffProtect to fetch.
     */
    where: CmsStaffProtectWhereUniqueInput
  }


  /**
   * CmsStaffProtect findUniqueOrThrow
   */
  export type CmsStaffProtectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaffProtect to fetch.
     */
    where: CmsStaffProtectWhereUniqueInput
  }


  /**
   * CmsStaffProtect findFirst
   */
  export type CmsStaffProtectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaffProtect to fetch.
     */
    where?: CmsStaffProtectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffProtects to fetch.
     */
    orderBy?: CmsStaffProtectOrderByWithRelationInput | CmsStaffProtectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsStaffProtects.
     */
    cursor?: CmsStaffProtectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffProtects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffProtects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsStaffProtects.
     */
    distinct?: CmsStaffProtectScalarFieldEnum | CmsStaffProtectScalarFieldEnum[]
  }


  /**
   * CmsStaffProtect findFirstOrThrow
   */
  export type CmsStaffProtectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaffProtect to fetch.
     */
    where?: CmsStaffProtectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffProtects to fetch.
     */
    orderBy?: CmsStaffProtectOrderByWithRelationInput | CmsStaffProtectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CmsStaffProtects.
     */
    cursor?: CmsStaffProtectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffProtects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffProtects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CmsStaffProtects.
     */
    distinct?: CmsStaffProtectScalarFieldEnum | CmsStaffProtectScalarFieldEnum[]
  }


  /**
   * CmsStaffProtect findMany
   */
  export type CmsStaffProtectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * Filter, which CmsStaffProtects to fetch.
     */
    where?: CmsStaffProtectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CmsStaffProtects to fetch.
     */
    orderBy?: CmsStaffProtectOrderByWithRelationInput | CmsStaffProtectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CmsStaffProtects.
     */
    cursor?: CmsStaffProtectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CmsStaffProtects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CmsStaffProtects.
     */
    skip?: number
    distinct?: CmsStaffProtectScalarFieldEnum | CmsStaffProtectScalarFieldEnum[]
  }


  /**
   * CmsStaffProtect create
   */
  export type CmsStaffProtectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * The data needed to create a CmsStaffProtect.
     */
    data: XOR<CmsStaffProtectCreateInput, CmsStaffProtectUncheckedCreateInput>
  }


  /**
   * CmsStaffProtect createMany
   */
  export type CmsStaffProtectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CmsStaffProtects.
     */
    data: CmsStaffProtectCreateManyInput | CmsStaffProtectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CmsStaffProtect update
   */
  export type CmsStaffProtectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * The data needed to update a CmsStaffProtect.
     */
    data: XOR<CmsStaffProtectUpdateInput, CmsStaffProtectUncheckedUpdateInput>
    /**
     * Choose, which CmsStaffProtect to update.
     */
    where: CmsStaffProtectWhereUniqueInput
  }


  /**
   * CmsStaffProtect updateMany
   */
  export type CmsStaffProtectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CmsStaffProtects.
     */
    data: XOR<CmsStaffProtectUpdateManyMutationInput, CmsStaffProtectUncheckedUpdateManyInput>
    /**
     * Filter which CmsStaffProtects to update
     */
    where?: CmsStaffProtectWhereInput
  }


  /**
   * CmsStaffProtect upsert
   */
  export type CmsStaffProtectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * The filter to search for the CmsStaffProtect to update in case it exists.
     */
    where: CmsStaffProtectWhereUniqueInput
    /**
     * In case the CmsStaffProtect found by the `where` argument doesn't exist, create a new CmsStaffProtect with this data.
     */
    create: XOR<CmsStaffProtectCreateInput, CmsStaffProtectUncheckedCreateInput>
    /**
     * In case the CmsStaffProtect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CmsStaffProtectUpdateInput, CmsStaffProtectUncheckedUpdateInput>
  }


  /**
   * CmsStaffProtect delete
   */
  export type CmsStaffProtectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
    /**
     * Filter which CmsStaffProtect to delete.
     */
    where: CmsStaffProtectWhereUniqueInput
  }


  /**
   * CmsStaffProtect deleteMany
   */
  export type CmsStaffProtectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CmsStaffProtects to delete
     */
    where?: CmsStaffProtectWhereInput
  }


  /**
   * CmsStaffProtect without action
   */
  export type CmsStaffProtectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CmsStaffProtect
     */
    select?: CmsStaffProtectSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorAchievement
   */

  export type AggregateEmulatorAchievement = {
    _count: EmulatorAchievementCountAggregateOutputType | null
    _avg: EmulatorAchievementAvgAggregateOutputType | null
    _sum: EmulatorAchievementSumAggregateOutputType | null
    _min: EmulatorAchievementMinAggregateOutputType | null
    _max: EmulatorAchievementMaxAggregateOutputType | null
  }

  export type EmulatorAchievementAvgAggregateOutputType = {
    id: number | null
    level: number | null
    rewardPixels: number | null
    rewardPoints: number | null
    progressNeeded: number | null
  }

  export type EmulatorAchievementSumAggregateOutputType = {
    id: number | null
    level: number | null
    rewardPixels: number | null
    rewardPoints: number | null
    progressNeeded: number | null
  }

  export type EmulatorAchievementMinAggregateOutputType = {
    id: number | null
    groupName: string | null
    category: string | null
    level: number | null
    rewardPixels: number | null
    rewardPoints: number | null
    progressNeeded: number | null
  }

  export type EmulatorAchievementMaxAggregateOutputType = {
    id: number | null
    groupName: string | null
    category: string | null
    level: number | null
    rewardPixels: number | null
    rewardPoints: number | null
    progressNeeded: number | null
  }

  export type EmulatorAchievementCountAggregateOutputType = {
    id: number
    groupName: number
    category: number
    level: number
    rewardPixels: number
    rewardPoints: number
    progressNeeded: number
    _all: number
  }


  export type EmulatorAchievementAvgAggregateInputType = {
    id?: true
    level?: true
    rewardPixels?: true
    rewardPoints?: true
    progressNeeded?: true
  }

  export type EmulatorAchievementSumAggregateInputType = {
    id?: true
    level?: true
    rewardPixels?: true
    rewardPoints?: true
    progressNeeded?: true
  }

  export type EmulatorAchievementMinAggregateInputType = {
    id?: true
    groupName?: true
    category?: true
    level?: true
    rewardPixels?: true
    rewardPoints?: true
    progressNeeded?: true
  }

  export type EmulatorAchievementMaxAggregateInputType = {
    id?: true
    groupName?: true
    category?: true
    level?: true
    rewardPixels?: true
    rewardPoints?: true
    progressNeeded?: true
  }

  export type EmulatorAchievementCountAggregateInputType = {
    id?: true
    groupName?: true
    category?: true
    level?: true
    rewardPixels?: true
    rewardPoints?: true
    progressNeeded?: true
    _all?: true
  }

  export type EmulatorAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorAchievement to aggregate.
     */
    where?: EmulatorAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorAchievements to fetch.
     */
    orderBy?: EmulatorAchievementOrderByWithRelationInput | EmulatorAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorAchievements
    **/
    _count?: true | EmulatorAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorAchievementMaxAggregateInputType
  }

  export type GetEmulatorAchievementAggregateType<T extends EmulatorAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorAchievement[P]>
      : GetScalarType<T[P], AggregateEmulatorAchievement[P]>
  }




  export type EmulatorAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorAchievementWhereInput
    orderBy?: EmulatorAchievementOrderByWithAggregationInput | EmulatorAchievementOrderByWithAggregationInput[]
    by: EmulatorAchievementScalarFieldEnum[] | EmulatorAchievementScalarFieldEnum
    having?: EmulatorAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorAchievementCountAggregateInputType | true
    _avg?: EmulatorAchievementAvgAggregateInputType
    _sum?: EmulatorAchievementSumAggregateInputType
    _min?: EmulatorAchievementMinAggregateInputType
    _max?: EmulatorAchievementMaxAggregateInputType
  }

  export type EmulatorAchievementGroupByOutputType = {
    id: number
    groupName: string
    category: string
    level: number
    rewardPixels: number
    rewardPoints: number
    progressNeeded: number
    _count: EmulatorAchievementCountAggregateOutputType | null
    _avg: EmulatorAchievementAvgAggregateOutputType | null
    _sum: EmulatorAchievementSumAggregateOutputType | null
    _min: EmulatorAchievementMinAggregateOutputType | null
    _max: EmulatorAchievementMaxAggregateOutputType | null
  }

  type GetEmulatorAchievementGroupByPayload<T extends EmulatorAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorAchievementGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupName?: boolean
    category?: boolean
    level?: boolean
    rewardPixels?: boolean
    rewardPoints?: boolean
    progressNeeded?: boolean
  }, ExtArgs["result"]["emulatorAchievement"]>

  export type EmulatorAchievementSelectScalar = {
    id?: boolean
    groupName?: boolean
    category?: boolean
    level?: boolean
    rewardPixels?: boolean
    rewardPoints?: boolean
    progressNeeded?: boolean
  }


  export type $EmulatorAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorAchievement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupName: string
      category: string
      level: number
      rewardPixels: number
      rewardPoints: number
      progressNeeded: number
    }, ExtArgs["result"]["emulatorAchievement"]>
    composites: {}
  }


  type EmulatorAchievementGetPayload<S extends boolean | null | undefined | EmulatorAchievementDefaultArgs> = $Result.GetResult<Prisma.$EmulatorAchievementPayload, S>

  type EmulatorAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorAchievementCountAggregateInputType | true
    }

  export interface EmulatorAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorAchievement'], meta: { name: 'EmulatorAchievement' } }
    /**
     * Find zero or one EmulatorAchievement that matches the filter.
     * @param {EmulatorAchievementFindUniqueArgs} args - Arguments to find a EmulatorAchievement
     * @example
     * // Get one EmulatorAchievement
     * const emulatorAchievement = await prisma.emulatorAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorAchievementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorAchievementFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorAchievement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorAchievementFindUniqueOrThrowArgs} args - Arguments to find a EmulatorAchievement
     * @example
     * // Get one EmulatorAchievement
     * const emulatorAchievement = await prisma.emulatorAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorAchievementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorAchievementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementFindFirstArgs} args - Arguments to find a EmulatorAchievement
     * @example
     * // Get one EmulatorAchievement
     * const emulatorAchievement = await prisma.emulatorAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorAchievementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorAchievementFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementFindFirstOrThrowArgs} args - Arguments to find a EmulatorAchievement
     * @example
     * // Get one EmulatorAchievement
     * const emulatorAchievement = await prisma.emulatorAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorAchievementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorAchievementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorAchievements
     * const emulatorAchievements = await prisma.emulatorAchievement.findMany()
     * 
     * // Get first 10 EmulatorAchievements
     * const emulatorAchievements = await prisma.emulatorAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorAchievementWithIdOnly = await prisma.emulatorAchievement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorAchievementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorAchievementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorAchievement.
     * @param {EmulatorAchievementCreateArgs} args - Arguments to create a EmulatorAchievement.
     * @example
     * // Create one EmulatorAchievement
     * const EmulatorAchievement = await prisma.emulatorAchievement.create({
     *   data: {
     *     // ... data to create a EmulatorAchievement
     *   }
     * })
     * 
    **/
    create<T extends EmulatorAchievementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorAchievementCreateArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorAchievements.
     *     @param {EmulatorAchievementCreateManyArgs} args - Arguments to create many EmulatorAchievements.
     *     @example
     *     // Create many EmulatorAchievements
     *     const emulatorAchievement = await prisma.emulatorAchievement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorAchievementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorAchievementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorAchievement.
     * @param {EmulatorAchievementDeleteArgs} args - Arguments to delete one EmulatorAchievement.
     * @example
     * // Delete one EmulatorAchievement
     * const EmulatorAchievement = await prisma.emulatorAchievement.delete({
     *   where: {
     *     // ... filter to delete one EmulatorAchievement
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorAchievementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorAchievementDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorAchievement.
     * @param {EmulatorAchievementUpdateArgs} args - Arguments to update one EmulatorAchievement.
     * @example
     * // Update one EmulatorAchievement
     * const emulatorAchievement = await prisma.emulatorAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorAchievementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorAchievementUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorAchievements.
     * @param {EmulatorAchievementDeleteManyArgs} args - Arguments to filter EmulatorAchievements to delete.
     * @example
     * // Delete a few EmulatorAchievements
     * const { count } = await prisma.emulatorAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorAchievementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorAchievementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorAchievements
     * const emulatorAchievement = await prisma.emulatorAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorAchievementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorAchievementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorAchievement.
     * @param {EmulatorAchievementUpsertArgs} args - Arguments to update or create a EmulatorAchievement.
     * @example
     * // Update or create a EmulatorAchievement
     * const emulatorAchievement = await prisma.emulatorAchievement.upsert({
     *   create: {
     *     // ... data to create a EmulatorAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorAchievement we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorAchievementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorAchievementUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorAchievementClient<$Result.GetResult<Prisma.$EmulatorAchievementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementCountArgs} args - Arguments to filter EmulatorAchievements to count.
     * @example
     * // Count the number of EmulatorAchievements
     * const count = await prisma.emulatorAchievement.count({
     *   where: {
     *     // ... the filter for the EmulatorAchievements we want to count
     *   }
     * })
    **/
    count<T extends EmulatorAchievementCountArgs>(
      args?: Subset<T, EmulatorAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorAchievementAggregateArgs>(args: Subset<T, EmulatorAchievementAggregateArgs>): Prisma.PrismaPromise<GetEmulatorAchievementAggregateType<T>>

    /**
     * Group by EmulatorAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorAchievementGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorAchievement model
   */
  readonly fields: EmulatorAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorAchievement model
   */ 
  interface EmulatorAchievementFieldRefs {
    readonly id: FieldRef<"EmulatorAchievement", 'Int'>
    readonly groupName: FieldRef<"EmulatorAchievement", 'String'>
    readonly category: FieldRef<"EmulatorAchievement", 'String'>
    readonly level: FieldRef<"EmulatorAchievement", 'Int'>
    readonly rewardPixels: FieldRef<"EmulatorAchievement", 'Int'>
    readonly rewardPoints: FieldRef<"EmulatorAchievement", 'Int'>
    readonly progressNeeded: FieldRef<"EmulatorAchievement", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorAchievement findUnique
   */
  export type EmulatorAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorAchievement to fetch.
     */
    where: EmulatorAchievementWhereUniqueInput
  }


  /**
   * EmulatorAchievement findUniqueOrThrow
   */
  export type EmulatorAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorAchievement to fetch.
     */
    where: EmulatorAchievementWhereUniqueInput
  }


  /**
   * EmulatorAchievement findFirst
   */
  export type EmulatorAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorAchievement to fetch.
     */
    where?: EmulatorAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorAchievements to fetch.
     */
    orderBy?: EmulatorAchievementOrderByWithRelationInput | EmulatorAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorAchievements.
     */
    cursor?: EmulatorAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorAchievements.
     */
    distinct?: EmulatorAchievementScalarFieldEnum | EmulatorAchievementScalarFieldEnum[]
  }


  /**
   * EmulatorAchievement findFirstOrThrow
   */
  export type EmulatorAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorAchievement to fetch.
     */
    where?: EmulatorAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorAchievements to fetch.
     */
    orderBy?: EmulatorAchievementOrderByWithRelationInput | EmulatorAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorAchievements.
     */
    cursor?: EmulatorAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorAchievements.
     */
    distinct?: EmulatorAchievementScalarFieldEnum | EmulatorAchievementScalarFieldEnum[]
  }


  /**
   * EmulatorAchievement findMany
   */
  export type EmulatorAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorAchievements to fetch.
     */
    where?: EmulatorAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorAchievements to fetch.
     */
    orderBy?: EmulatorAchievementOrderByWithRelationInput | EmulatorAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorAchievements.
     */
    cursor?: EmulatorAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorAchievements.
     */
    skip?: number
    distinct?: EmulatorAchievementScalarFieldEnum | EmulatorAchievementScalarFieldEnum[]
  }


  /**
   * EmulatorAchievement create
   */
  export type EmulatorAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorAchievement.
     */
    data?: XOR<EmulatorAchievementCreateInput, EmulatorAchievementUncheckedCreateInput>
  }


  /**
   * EmulatorAchievement createMany
   */
  export type EmulatorAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorAchievements.
     */
    data: EmulatorAchievementCreateManyInput | EmulatorAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorAchievement update
   */
  export type EmulatorAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorAchievement.
     */
    data: XOR<EmulatorAchievementUpdateInput, EmulatorAchievementUncheckedUpdateInput>
    /**
     * Choose, which EmulatorAchievement to update.
     */
    where: EmulatorAchievementWhereUniqueInput
  }


  /**
   * EmulatorAchievement updateMany
   */
  export type EmulatorAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorAchievements.
     */
    data: XOR<EmulatorAchievementUpdateManyMutationInput, EmulatorAchievementUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorAchievements to update
     */
    where?: EmulatorAchievementWhereInput
  }


  /**
   * EmulatorAchievement upsert
   */
  export type EmulatorAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorAchievement to update in case it exists.
     */
    where: EmulatorAchievementWhereUniqueInput
    /**
     * In case the EmulatorAchievement found by the `where` argument doesn't exist, create a new EmulatorAchievement with this data.
     */
    create: XOR<EmulatorAchievementCreateInput, EmulatorAchievementUncheckedCreateInput>
    /**
     * In case the EmulatorAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorAchievementUpdateInput, EmulatorAchievementUncheckedUpdateInput>
  }


  /**
   * EmulatorAchievement delete
   */
  export type EmulatorAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
    /**
     * Filter which EmulatorAchievement to delete.
     */
    where: EmulatorAchievementWhereUniqueInput
  }


  /**
   * EmulatorAchievement deleteMany
   */
  export type EmulatorAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorAchievements to delete
     */
    where?: EmulatorAchievementWhereInput
  }


  /**
   * EmulatorAchievement without action
   */
  export type EmulatorAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorAchievement
     */
    select?: EmulatorAchievementSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorBanner
   */

  export type AggregateEmulatorBanner = {
    _count: EmulatorBannerCountAggregateOutputType | null
    _avg: EmulatorBannerAvgAggregateOutputType | null
    _sum: EmulatorBannerSumAggregateOutputType | null
    _min: EmulatorBannerMinAggregateOutputType | null
    _max: EmulatorBannerMaxAggregateOutputType | null
  }

  export type EmulatorBannerAvgAggregateOutputType = {
    id: number | null
  }

  export type EmulatorBannerSumAggregateOutputType = {
    id: number | null
  }

  export type EmulatorBannerMinAggregateOutputType = {
    id: number | null
    haveLayer: boolean | null
    canTrade: boolean | null
  }

  export type EmulatorBannerMaxAggregateOutputType = {
    id: number | null
    haveLayer: boolean | null
    canTrade: boolean | null
  }

  export type EmulatorBannerCountAggregateOutputType = {
    id: number
    haveLayer: number
    canTrade: number
    _all: number
  }


  export type EmulatorBannerAvgAggregateInputType = {
    id?: true
  }

  export type EmulatorBannerSumAggregateInputType = {
    id?: true
  }

  export type EmulatorBannerMinAggregateInputType = {
    id?: true
    haveLayer?: true
    canTrade?: true
  }

  export type EmulatorBannerMaxAggregateInputType = {
    id?: true
    haveLayer?: true
    canTrade?: true
  }

  export type EmulatorBannerCountAggregateInputType = {
    id?: true
    haveLayer?: true
    canTrade?: true
    _all?: true
  }

  export type EmulatorBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorBanner to aggregate.
     */
    where?: EmulatorBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorBanners to fetch.
     */
    orderBy?: EmulatorBannerOrderByWithRelationInput | EmulatorBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorBanners
    **/
    _count?: true | EmulatorBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorBannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorBannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorBannerMaxAggregateInputType
  }

  export type GetEmulatorBannerAggregateType<T extends EmulatorBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorBanner[P]>
      : GetScalarType<T[P], AggregateEmulatorBanner[P]>
  }




  export type EmulatorBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorBannerWhereInput
    orderBy?: EmulatorBannerOrderByWithAggregationInput | EmulatorBannerOrderByWithAggregationInput[]
    by: EmulatorBannerScalarFieldEnum[] | EmulatorBannerScalarFieldEnum
    having?: EmulatorBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorBannerCountAggregateInputType | true
    _avg?: EmulatorBannerAvgAggregateInputType
    _sum?: EmulatorBannerSumAggregateInputType
    _min?: EmulatorBannerMinAggregateInputType
    _max?: EmulatorBannerMaxAggregateInputType
  }

  export type EmulatorBannerGroupByOutputType = {
    id: number
    haveLayer: boolean
    canTrade: boolean
    _count: EmulatorBannerCountAggregateOutputType | null
    _avg: EmulatorBannerAvgAggregateOutputType | null
    _sum: EmulatorBannerSumAggregateOutputType | null
    _min: EmulatorBannerMinAggregateOutputType | null
    _max: EmulatorBannerMaxAggregateOutputType | null
  }

  type GetEmulatorBannerGroupByPayload<T extends EmulatorBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorBannerGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorBannerGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    haveLayer?: boolean
    canTrade?: boolean
  }, ExtArgs["result"]["emulatorBanner"]>

  export type EmulatorBannerSelectScalar = {
    id?: boolean
    haveLayer?: boolean
    canTrade?: boolean
  }


  export type $EmulatorBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorBanner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      haveLayer: boolean
      canTrade: boolean
    }, ExtArgs["result"]["emulatorBanner"]>
    composites: {}
  }


  type EmulatorBannerGetPayload<S extends boolean | null | undefined | EmulatorBannerDefaultArgs> = $Result.GetResult<Prisma.$EmulatorBannerPayload, S>

  type EmulatorBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorBannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorBannerCountAggregateInputType | true
    }

  export interface EmulatorBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorBanner'], meta: { name: 'EmulatorBanner' } }
    /**
     * Find zero or one EmulatorBanner that matches the filter.
     * @param {EmulatorBannerFindUniqueArgs} args - Arguments to find a EmulatorBanner
     * @example
     * // Get one EmulatorBanner
     * const emulatorBanner = await prisma.emulatorBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorBannerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorBannerFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorBanner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorBannerFindUniqueOrThrowArgs} args - Arguments to find a EmulatorBanner
     * @example
     * // Get one EmulatorBanner
     * const emulatorBanner = await prisma.emulatorBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorBannerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorBannerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerFindFirstArgs} args - Arguments to find a EmulatorBanner
     * @example
     * // Get one EmulatorBanner
     * const emulatorBanner = await prisma.emulatorBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorBannerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorBannerFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerFindFirstOrThrowArgs} args - Arguments to find a EmulatorBanner
     * @example
     * // Get one EmulatorBanner
     * const emulatorBanner = await prisma.emulatorBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorBannerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorBannerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorBanners
     * const emulatorBanners = await prisma.emulatorBanner.findMany()
     * 
     * // Get first 10 EmulatorBanners
     * const emulatorBanners = await prisma.emulatorBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorBannerWithIdOnly = await prisma.emulatorBanner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorBannerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorBannerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorBanner.
     * @param {EmulatorBannerCreateArgs} args - Arguments to create a EmulatorBanner.
     * @example
     * // Create one EmulatorBanner
     * const EmulatorBanner = await prisma.emulatorBanner.create({
     *   data: {
     *     // ... data to create a EmulatorBanner
     *   }
     * })
     * 
    **/
    create<T extends EmulatorBannerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorBannerCreateArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorBanners.
     *     @param {EmulatorBannerCreateManyArgs} args - Arguments to create many EmulatorBanners.
     *     @example
     *     // Create many EmulatorBanners
     *     const emulatorBanner = await prisma.emulatorBanner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorBannerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorBannerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorBanner.
     * @param {EmulatorBannerDeleteArgs} args - Arguments to delete one EmulatorBanner.
     * @example
     * // Delete one EmulatorBanner
     * const EmulatorBanner = await prisma.emulatorBanner.delete({
     *   where: {
     *     // ... filter to delete one EmulatorBanner
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorBannerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorBannerDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorBanner.
     * @param {EmulatorBannerUpdateArgs} args - Arguments to update one EmulatorBanner.
     * @example
     * // Update one EmulatorBanner
     * const emulatorBanner = await prisma.emulatorBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorBannerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorBannerUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorBanners.
     * @param {EmulatorBannerDeleteManyArgs} args - Arguments to filter EmulatorBanners to delete.
     * @example
     * // Delete a few EmulatorBanners
     * const { count } = await prisma.emulatorBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorBannerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorBannerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorBanners
     * const emulatorBanner = await prisma.emulatorBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorBannerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorBannerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorBanner.
     * @param {EmulatorBannerUpsertArgs} args - Arguments to update or create a EmulatorBanner.
     * @example
     * // Update or create a EmulatorBanner
     * const emulatorBanner = await prisma.emulatorBanner.upsert({
     *   create: {
     *     // ... data to create a EmulatorBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorBanner we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorBannerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorBannerUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorBannerClient<$Result.GetResult<Prisma.$EmulatorBannerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerCountArgs} args - Arguments to filter EmulatorBanners to count.
     * @example
     * // Count the number of EmulatorBanners
     * const count = await prisma.emulatorBanner.count({
     *   where: {
     *     // ... the filter for the EmulatorBanners we want to count
     *   }
     * })
    **/
    count<T extends EmulatorBannerCountArgs>(
      args?: Subset<T, EmulatorBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorBannerAggregateArgs>(args: Subset<T, EmulatorBannerAggregateArgs>): Prisma.PrismaPromise<GetEmulatorBannerAggregateType<T>>

    /**
     * Group by EmulatorBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorBannerGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorBanner model
   */
  readonly fields: EmulatorBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorBanner model
   */ 
  interface EmulatorBannerFieldRefs {
    readonly id: FieldRef<"EmulatorBanner", 'Int'>
    readonly haveLayer: FieldRef<"EmulatorBanner", 'Boolean'>
    readonly canTrade: FieldRef<"EmulatorBanner", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorBanner findUnique
   */
  export type EmulatorBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorBanner to fetch.
     */
    where: EmulatorBannerWhereUniqueInput
  }


  /**
   * EmulatorBanner findUniqueOrThrow
   */
  export type EmulatorBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorBanner to fetch.
     */
    where: EmulatorBannerWhereUniqueInput
  }


  /**
   * EmulatorBanner findFirst
   */
  export type EmulatorBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorBanner to fetch.
     */
    where?: EmulatorBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorBanners to fetch.
     */
    orderBy?: EmulatorBannerOrderByWithRelationInput | EmulatorBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorBanners.
     */
    cursor?: EmulatorBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorBanners.
     */
    distinct?: EmulatorBannerScalarFieldEnum | EmulatorBannerScalarFieldEnum[]
  }


  /**
   * EmulatorBanner findFirstOrThrow
   */
  export type EmulatorBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorBanner to fetch.
     */
    where?: EmulatorBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorBanners to fetch.
     */
    orderBy?: EmulatorBannerOrderByWithRelationInput | EmulatorBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorBanners.
     */
    cursor?: EmulatorBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorBanners.
     */
    distinct?: EmulatorBannerScalarFieldEnum | EmulatorBannerScalarFieldEnum[]
  }


  /**
   * EmulatorBanner findMany
   */
  export type EmulatorBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorBanners to fetch.
     */
    where?: EmulatorBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorBanners to fetch.
     */
    orderBy?: EmulatorBannerOrderByWithRelationInput | EmulatorBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorBanners.
     */
    cursor?: EmulatorBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorBanners.
     */
    skip?: number
    distinct?: EmulatorBannerScalarFieldEnum | EmulatorBannerScalarFieldEnum[]
  }


  /**
   * EmulatorBanner create
   */
  export type EmulatorBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorBanner.
     */
    data?: XOR<EmulatorBannerCreateInput, EmulatorBannerUncheckedCreateInput>
  }


  /**
   * EmulatorBanner createMany
   */
  export type EmulatorBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorBanners.
     */
    data: EmulatorBannerCreateManyInput | EmulatorBannerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorBanner update
   */
  export type EmulatorBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorBanner.
     */
    data: XOR<EmulatorBannerUpdateInput, EmulatorBannerUncheckedUpdateInput>
    /**
     * Choose, which EmulatorBanner to update.
     */
    where: EmulatorBannerWhereUniqueInput
  }


  /**
   * EmulatorBanner updateMany
   */
  export type EmulatorBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorBanners.
     */
    data: XOR<EmulatorBannerUpdateManyMutationInput, EmulatorBannerUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorBanners to update
     */
    where?: EmulatorBannerWhereInput
  }


  /**
   * EmulatorBanner upsert
   */
  export type EmulatorBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorBanner to update in case it exists.
     */
    where: EmulatorBannerWhereUniqueInput
    /**
     * In case the EmulatorBanner found by the `where` argument doesn't exist, create a new EmulatorBanner with this data.
     */
    create: XOR<EmulatorBannerCreateInput, EmulatorBannerUncheckedCreateInput>
    /**
     * In case the EmulatorBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorBannerUpdateInput, EmulatorBannerUncheckedUpdateInput>
  }


  /**
   * EmulatorBanner delete
   */
  export type EmulatorBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
    /**
     * Filter which EmulatorBanner to delete.
     */
    where: EmulatorBannerWhereUniqueInput
  }


  /**
   * EmulatorBanner deleteMany
   */
  export type EmulatorBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorBanners to delete
     */
    where?: EmulatorBannerWhereInput
  }


  /**
   * EmulatorBanner without action
   */
  export type EmulatorBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorBanner
     */
    select?: EmulatorBannerSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorChatStyle
   */

  export type AggregateEmulatorChatStyle = {
    _count: EmulatorChatStyleCountAggregateOutputType | null
    _avg: EmulatorChatStyleAvgAggregateOutputType | null
    _sum: EmulatorChatStyleSumAggregateOutputType | null
    _min: EmulatorChatStyleMinAggregateOutputType | null
    _max: EmulatorChatStyleMaxAggregateOutputType | null
  }

  export type EmulatorChatStyleAvgAggregateOutputType = {
    id: number | null
  }

  export type EmulatorChatStyleSumAggregateOutputType = {
    id: number | null
  }

  export type EmulatorChatStyleMinAggregateOutputType = {
    id: number | null
    name: string | null
    requiredRight: string | null
  }

  export type EmulatorChatStyleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    requiredRight: string | null
  }

  export type EmulatorChatStyleCountAggregateOutputType = {
    id: number
    name: number
    requiredRight: number
    _all: number
  }


  export type EmulatorChatStyleAvgAggregateInputType = {
    id?: true
  }

  export type EmulatorChatStyleSumAggregateInputType = {
    id?: true
  }

  export type EmulatorChatStyleMinAggregateInputType = {
    id?: true
    name?: true
    requiredRight?: true
  }

  export type EmulatorChatStyleMaxAggregateInputType = {
    id?: true
    name?: true
    requiredRight?: true
  }

  export type EmulatorChatStyleCountAggregateInputType = {
    id?: true
    name?: true
    requiredRight?: true
    _all?: true
  }

  export type EmulatorChatStyleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorChatStyle to aggregate.
     */
    where?: EmulatorChatStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorChatStyles to fetch.
     */
    orderBy?: EmulatorChatStyleOrderByWithRelationInput | EmulatorChatStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorChatStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorChatStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorChatStyles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorChatStyles
    **/
    _count?: true | EmulatorChatStyleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorChatStyleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorChatStyleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorChatStyleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorChatStyleMaxAggregateInputType
  }

  export type GetEmulatorChatStyleAggregateType<T extends EmulatorChatStyleAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorChatStyle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorChatStyle[P]>
      : GetScalarType<T[P], AggregateEmulatorChatStyle[P]>
  }




  export type EmulatorChatStyleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorChatStyleWhereInput
    orderBy?: EmulatorChatStyleOrderByWithAggregationInput | EmulatorChatStyleOrderByWithAggregationInput[]
    by: EmulatorChatStyleScalarFieldEnum[] | EmulatorChatStyleScalarFieldEnum
    having?: EmulatorChatStyleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorChatStyleCountAggregateInputType | true
    _avg?: EmulatorChatStyleAvgAggregateInputType
    _sum?: EmulatorChatStyleSumAggregateInputType
    _min?: EmulatorChatStyleMinAggregateInputType
    _max?: EmulatorChatStyleMaxAggregateInputType
  }

  export type EmulatorChatStyleGroupByOutputType = {
    id: number
    name: string
    requiredRight: string
    _count: EmulatorChatStyleCountAggregateOutputType | null
    _avg: EmulatorChatStyleAvgAggregateOutputType | null
    _sum: EmulatorChatStyleSumAggregateOutputType | null
    _min: EmulatorChatStyleMinAggregateOutputType | null
    _max: EmulatorChatStyleMaxAggregateOutputType | null
  }

  type GetEmulatorChatStyleGroupByPayload<T extends EmulatorChatStyleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorChatStyleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorChatStyleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorChatStyleGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorChatStyleGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorChatStyleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    requiredRight?: boolean
  }, ExtArgs["result"]["emulatorChatStyle"]>

  export type EmulatorChatStyleSelectScalar = {
    id?: boolean
    name?: boolean
    requiredRight?: boolean
  }


  export type $EmulatorChatStylePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorChatStyle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      requiredRight: string
    }, ExtArgs["result"]["emulatorChatStyle"]>
    composites: {}
  }


  type EmulatorChatStyleGetPayload<S extends boolean | null | undefined | EmulatorChatStyleDefaultArgs> = $Result.GetResult<Prisma.$EmulatorChatStylePayload, S>

  type EmulatorChatStyleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorChatStyleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorChatStyleCountAggregateInputType | true
    }

  export interface EmulatorChatStyleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorChatStyle'], meta: { name: 'EmulatorChatStyle' } }
    /**
     * Find zero or one EmulatorChatStyle that matches the filter.
     * @param {EmulatorChatStyleFindUniqueArgs} args - Arguments to find a EmulatorChatStyle
     * @example
     * // Get one EmulatorChatStyle
     * const emulatorChatStyle = await prisma.emulatorChatStyle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorChatStyleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorChatStyleFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorChatStyle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorChatStyleFindUniqueOrThrowArgs} args - Arguments to find a EmulatorChatStyle
     * @example
     * // Get one EmulatorChatStyle
     * const emulatorChatStyle = await prisma.emulatorChatStyle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorChatStyleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorChatStyleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorChatStyle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleFindFirstArgs} args - Arguments to find a EmulatorChatStyle
     * @example
     * // Get one EmulatorChatStyle
     * const emulatorChatStyle = await prisma.emulatorChatStyle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorChatStyleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorChatStyleFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorChatStyle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleFindFirstOrThrowArgs} args - Arguments to find a EmulatorChatStyle
     * @example
     * // Get one EmulatorChatStyle
     * const emulatorChatStyle = await prisma.emulatorChatStyle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorChatStyleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorChatStyleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorChatStyles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorChatStyles
     * const emulatorChatStyles = await prisma.emulatorChatStyle.findMany()
     * 
     * // Get first 10 EmulatorChatStyles
     * const emulatorChatStyles = await prisma.emulatorChatStyle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorChatStyleWithIdOnly = await prisma.emulatorChatStyle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorChatStyleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorChatStyleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorChatStyle.
     * @param {EmulatorChatStyleCreateArgs} args - Arguments to create a EmulatorChatStyle.
     * @example
     * // Create one EmulatorChatStyle
     * const EmulatorChatStyle = await prisma.emulatorChatStyle.create({
     *   data: {
     *     // ... data to create a EmulatorChatStyle
     *   }
     * })
     * 
    **/
    create<T extends EmulatorChatStyleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorChatStyleCreateArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorChatStyles.
     *     @param {EmulatorChatStyleCreateManyArgs} args - Arguments to create many EmulatorChatStyles.
     *     @example
     *     // Create many EmulatorChatStyles
     *     const emulatorChatStyle = await prisma.emulatorChatStyle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorChatStyleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorChatStyleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorChatStyle.
     * @param {EmulatorChatStyleDeleteArgs} args - Arguments to delete one EmulatorChatStyle.
     * @example
     * // Delete one EmulatorChatStyle
     * const EmulatorChatStyle = await prisma.emulatorChatStyle.delete({
     *   where: {
     *     // ... filter to delete one EmulatorChatStyle
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorChatStyleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorChatStyleDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorChatStyle.
     * @param {EmulatorChatStyleUpdateArgs} args - Arguments to update one EmulatorChatStyle.
     * @example
     * // Update one EmulatorChatStyle
     * const emulatorChatStyle = await prisma.emulatorChatStyle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorChatStyleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorChatStyleUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorChatStyles.
     * @param {EmulatorChatStyleDeleteManyArgs} args - Arguments to filter EmulatorChatStyles to delete.
     * @example
     * // Delete a few EmulatorChatStyles
     * const { count } = await prisma.emulatorChatStyle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorChatStyleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorChatStyleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorChatStyles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorChatStyles
     * const emulatorChatStyle = await prisma.emulatorChatStyle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorChatStyleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorChatStyleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorChatStyle.
     * @param {EmulatorChatStyleUpsertArgs} args - Arguments to update or create a EmulatorChatStyle.
     * @example
     * // Update or create a EmulatorChatStyle
     * const emulatorChatStyle = await prisma.emulatorChatStyle.upsert({
     *   create: {
     *     // ... data to create a EmulatorChatStyle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorChatStyle we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorChatStyleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorChatStyleUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorChatStyleClient<$Result.GetResult<Prisma.$EmulatorChatStylePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorChatStyles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleCountArgs} args - Arguments to filter EmulatorChatStyles to count.
     * @example
     * // Count the number of EmulatorChatStyles
     * const count = await prisma.emulatorChatStyle.count({
     *   where: {
     *     // ... the filter for the EmulatorChatStyles we want to count
     *   }
     * })
    **/
    count<T extends EmulatorChatStyleCountArgs>(
      args?: Subset<T, EmulatorChatStyleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorChatStyleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorChatStyle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorChatStyleAggregateArgs>(args: Subset<T, EmulatorChatStyleAggregateArgs>): Prisma.PrismaPromise<GetEmulatorChatStyleAggregateType<T>>

    /**
     * Group by EmulatorChatStyle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorChatStyleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorChatStyleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorChatStyleGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorChatStyleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorChatStyleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorChatStyleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorChatStyle model
   */
  readonly fields: EmulatorChatStyleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorChatStyle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorChatStyleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorChatStyle model
   */ 
  interface EmulatorChatStyleFieldRefs {
    readonly id: FieldRef<"EmulatorChatStyle", 'Int'>
    readonly name: FieldRef<"EmulatorChatStyle", 'String'>
    readonly requiredRight: FieldRef<"EmulatorChatStyle", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorChatStyle findUnique
   */
  export type EmulatorChatStyleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorChatStyle to fetch.
     */
    where: EmulatorChatStyleWhereUniqueInput
  }


  /**
   * EmulatorChatStyle findUniqueOrThrow
   */
  export type EmulatorChatStyleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorChatStyle to fetch.
     */
    where: EmulatorChatStyleWhereUniqueInput
  }


  /**
   * EmulatorChatStyle findFirst
   */
  export type EmulatorChatStyleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorChatStyle to fetch.
     */
    where?: EmulatorChatStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorChatStyles to fetch.
     */
    orderBy?: EmulatorChatStyleOrderByWithRelationInput | EmulatorChatStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorChatStyles.
     */
    cursor?: EmulatorChatStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorChatStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorChatStyles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorChatStyles.
     */
    distinct?: EmulatorChatStyleScalarFieldEnum | EmulatorChatStyleScalarFieldEnum[]
  }


  /**
   * EmulatorChatStyle findFirstOrThrow
   */
  export type EmulatorChatStyleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorChatStyle to fetch.
     */
    where?: EmulatorChatStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorChatStyles to fetch.
     */
    orderBy?: EmulatorChatStyleOrderByWithRelationInput | EmulatorChatStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorChatStyles.
     */
    cursor?: EmulatorChatStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorChatStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorChatStyles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorChatStyles.
     */
    distinct?: EmulatorChatStyleScalarFieldEnum | EmulatorChatStyleScalarFieldEnum[]
  }


  /**
   * EmulatorChatStyle findMany
   */
  export type EmulatorChatStyleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorChatStyles to fetch.
     */
    where?: EmulatorChatStyleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorChatStyles to fetch.
     */
    orderBy?: EmulatorChatStyleOrderByWithRelationInput | EmulatorChatStyleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorChatStyles.
     */
    cursor?: EmulatorChatStyleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorChatStyles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorChatStyles.
     */
    skip?: number
    distinct?: EmulatorChatStyleScalarFieldEnum | EmulatorChatStyleScalarFieldEnum[]
  }


  /**
   * EmulatorChatStyle create
   */
  export type EmulatorChatStyleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorChatStyle.
     */
    data: XOR<EmulatorChatStyleCreateInput, EmulatorChatStyleUncheckedCreateInput>
  }


  /**
   * EmulatorChatStyle createMany
   */
  export type EmulatorChatStyleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorChatStyles.
     */
    data: EmulatorChatStyleCreateManyInput | EmulatorChatStyleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorChatStyle update
   */
  export type EmulatorChatStyleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorChatStyle.
     */
    data: XOR<EmulatorChatStyleUpdateInput, EmulatorChatStyleUncheckedUpdateInput>
    /**
     * Choose, which EmulatorChatStyle to update.
     */
    where: EmulatorChatStyleWhereUniqueInput
  }


  /**
   * EmulatorChatStyle updateMany
   */
  export type EmulatorChatStyleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorChatStyles.
     */
    data: XOR<EmulatorChatStyleUpdateManyMutationInput, EmulatorChatStyleUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorChatStyles to update
     */
    where?: EmulatorChatStyleWhereInput
  }


  /**
   * EmulatorChatStyle upsert
   */
  export type EmulatorChatStyleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorChatStyle to update in case it exists.
     */
    where: EmulatorChatStyleWhereUniqueInput
    /**
     * In case the EmulatorChatStyle found by the `where` argument doesn't exist, create a new EmulatorChatStyle with this data.
     */
    create: XOR<EmulatorChatStyleCreateInput, EmulatorChatStyleUncheckedCreateInput>
    /**
     * In case the EmulatorChatStyle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorChatStyleUpdateInput, EmulatorChatStyleUncheckedUpdateInput>
  }


  /**
   * EmulatorChatStyle delete
   */
  export type EmulatorChatStyleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
    /**
     * Filter which EmulatorChatStyle to delete.
     */
    where: EmulatorChatStyleWhereUniqueInput
  }


  /**
   * EmulatorChatStyle deleteMany
   */
  export type EmulatorChatStyleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorChatStyles to delete
     */
    where?: EmulatorChatStyleWhereInput
  }


  /**
   * EmulatorChatStyle without action
   */
  export type EmulatorChatStyleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorChatStyle
     */
    select?: EmulatorChatStyleSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorCommand
   */

  export type AggregateEmulatorCommand = {
    _count: EmulatorCommandCountAggregateOutputType | null
    _avg: EmulatorCommandAvgAggregateOutputType | null
    _sum: EmulatorCommandSumAggregateOutputType | null
    _min: EmulatorCommandMinAggregateOutputType | null
    _max: EmulatorCommandMaxAggregateOutputType | null
  }

  export type EmulatorCommandAvgAggregateOutputType = {
    id: number | null
    minrank: number | null
  }

  export type EmulatorCommandSumAggregateOutputType = {
    id: number | null
    minrank: number | null
  }

  export type EmulatorCommandMinAggregateOutputType = {
    id: number | null
    input: string | null
    minrank: number | null
    descriptionFr: string | null
    descriptionEn: string | null
    descriptionBr: string | null
  }

  export type EmulatorCommandMaxAggregateOutputType = {
    id: number | null
    input: string | null
    minrank: number | null
    descriptionFr: string | null
    descriptionEn: string | null
    descriptionBr: string | null
  }

  export type EmulatorCommandCountAggregateOutputType = {
    id: number
    input: number
    minrank: number
    descriptionFr: number
    descriptionEn: number
    descriptionBr: number
    _all: number
  }


  export type EmulatorCommandAvgAggregateInputType = {
    id?: true
    minrank?: true
  }

  export type EmulatorCommandSumAggregateInputType = {
    id?: true
    minrank?: true
  }

  export type EmulatorCommandMinAggregateInputType = {
    id?: true
    input?: true
    minrank?: true
    descriptionFr?: true
    descriptionEn?: true
    descriptionBr?: true
  }

  export type EmulatorCommandMaxAggregateInputType = {
    id?: true
    input?: true
    minrank?: true
    descriptionFr?: true
    descriptionEn?: true
    descriptionBr?: true
  }

  export type EmulatorCommandCountAggregateInputType = {
    id?: true
    input?: true
    minrank?: true
    descriptionFr?: true
    descriptionEn?: true
    descriptionBr?: true
    _all?: true
  }

  export type EmulatorCommandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorCommand to aggregate.
     */
    where?: EmulatorCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommands to fetch.
     */
    orderBy?: EmulatorCommandOrderByWithRelationInput | EmulatorCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorCommands
    **/
    _count?: true | EmulatorCommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorCommandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorCommandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorCommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorCommandMaxAggregateInputType
  }

  export type GetEmulatorCommandAggregateType<T extends EmulatorCommandAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorCommand[P]>
      : GetScalarType<T[P], AggregateEmulatorCommand[P]>
  }




  export type EmulatorCommandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorCommandWhereInput
    orderBy?: EmulatorCommandOrderByWithAggregationInput | EmulatorCommandOrderByWithAggregationInput[]
    by: EmulatorCommandScalarFieldEnum[] | EmulatorCommandScalarFieldEnum
    having?: EmulatorCommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorCommandCountAggregateInputType | true
    _avg?: EmulatorCommandAvgAggregateInputType
    _sum?: EmulatorCommandSumAggregateInputType
    _min?: EmulatorCommandMinAggregateInputType
    _max?: EmulatorCommandMaxAggregateInputType
  }

  export type EmulatorCommandGroupByOutputType = {
    id: number
    input: string
    minrank: number
    descriptionFr: string | null
    descriptionEn: string | null
    descriptionBr: string | null
    _count: EmulatorCommandCountAggregateOutputType | null
    _avg: EmulatorCommandAvgAggregateOutputType | null
    _sum: EmulatorCommandSumAggregateOutputType | null
    _min: EmulatorCommandMinAggregateOutputType | null
    _max: EmulatorCommandMaxAggregateOutputType | null
  }

  type GetEmulatorCommandGroupByPayload<T extends EmulatorCommandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorCommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorCommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorCommandGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorCommandGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorCommandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    input?: boolean
    minrank?: boolean
    descriptionFr?: boolean
    descriptionEn?: boolean
    descriptionBr?: boolean
  }, ExtArgs["result"]["emulatorCommand"]>

  export type EmulatorCommandSelectScalar = {
    id?: boolean
    input?: boolean
    minrank?: boolean
    descriptionFr?: boolean
    descriptionEn?: boolean
    descriptionBr?: boolean
  }


  export type $EmulatorCommandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorCommand"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      input: string
      minrank: number
      descriptionFr: string | null
      descriptionEn: string | null
      descriptionBr: string | null
    }, ExtArgs["result"]["emulatorCommand"]>
    composites: {}
  }


  type EmulatorCommandGetPayload<S extends boolean | null | undefined | EmulatorCommandDefaultArgs> = $Result.GetResult<Prisma.$EmulatorCommandPayload, S>

  type EmulatorCommandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorCommandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorCommandCountAggregateInputType | true
    }

  export interface EmulatorCommandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorCommand'], meta: { name: 'EmulatorCommand' } }
    /**
     * Find zero or one EmulatorCommand that matches the filter.
     * @param {EmulatorCommandFindUniqueArgs} args - Arguments to find a EmulatorCommand
     * @example
     * // Get one EmulatorCommand
     * const emulatorCommand = await prisma.emulatorCommand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorCommandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorCommand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorCommandFindUniqueOrThrowArgs} args - Arguments to find a EmulatorCommand
     * @example
     * // Get one EmulatorCommand
     * const emulatorCommand = await prisma.emulatorCommand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorCommandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorCommand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandFindFirstArgs} args - Arguments to find a EmulatorCommand
     * @example
     * // Get one EmulatorCommand
     * const emulatorCommand = await prisma.emulatorCommand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorCommandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorCommand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandFindFirstOrThrowArgs} args - Arguments to find a EmulatorCommand
     * @example
     * // Get one EmulatorCommand
     * const emulatorCommand = await prisma.emulatorCommand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorCommandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorCommands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorCommands
     * const emulatorCommands = await prisma.emulatorCommand.findMany()
     * 
     * // Get first 10 EmulatorCommands
     * const emulatorCommands = await prisma.emulatorCommand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorCommandWithIdOnly = await prisma.emulatorCommand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorCommandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorCommand.
     * @param {EmulatorCommandCreateArgs} args - Arguments to create a EmulatorCommand.
     * @example
     * // Create one EmulatorCommand
     * const EmulatorCommand = await prisma.emulatorCommand.create({
     *   data: {
     *     // ... data to create a EmulatorCommand
     *   }
     * })
     * 
    **/
    create<T extends EmulatorCommandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandCreateArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorCommands.
     *     @param {EmulatorCommandCreateManyArgs} args - Arguments to create many EmulatorCommands.
     *     @example
     *     // Create many EmulatorCommands
     *     const emulatorCommand = await prisma.emulatorCommand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorCommandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorCommand.
     * @param {EmulatorCommandDeleteArgs} args - Arguments to delete one EmulatorCommand.
     * @example
     * // Delete one EmulatorCommand
     * const EmulatorCommand = await prisma.emulatorCommand.delete({
     *   where: {
     *     // ... filter to delete one EmulatorCommand
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorCommandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorCommand.
     * @param {EmulatorCommandUpdateArgs} args - Arguments to update one EmulatorCommand.
     * @example
     * // Update one EmulatorCommand
     * const emulatorCommand = await prisma.emulatorCommand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorCommandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorCommands.
     * @param {EmulatorCommandDeleteManyArgs} args - Arguments to filter EmulatorCommands to delete.
     * @example
     * // Delete a few EmulatorCommands
     * const { count } = await prisma.emulatorCommand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorCommandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorCommands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorCommands
     * const emulatorCommand = await prisma.emulatorCommand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorCommandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorCommand.
     * @param {EmulatorCommandUpsertArgs} args - Arguments to update or create a EmulatorCommand.
     * @example
     * // Update or create a EmulatorCommand
     * const emulatorCommand = await prisma.emulatorCommand.upsert({
     *   create: {
     *     // ... data to create a EmulatorCommand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorCommand we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorCommandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorCommandClient<$Result.GetResult<Prisma.$EmulatorCommandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorCommands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandCountArgs} args - Arguments to filter EmulatorCommands to count.
     * @example
     * // Count the number of EmulatorCommands
     * const count = await prisma.emulatorCommand.count({
     *   where: {
     *     // ... the filter for the EmulatorCommands we want to count
     *   }
     * })
    **/
    count<T extends EmulatorCommandCountArgs>(
      args?: Subset<T, EmulatorCommandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorCommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorCommand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorCommandAggregateArgs>(args: Subset<T, EmulatorCommandAggregateArgs>): Prisma.PrismaPromise<GetEmulatorCommandAggregateType<T>>

    /**
     * Group by EmulatorCommand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorCommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorCommandGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorCommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorCommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorCommandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorCommand model
   */
  readonly fields: EmulatorCommandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorCommand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorCommandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorCommand model
   */ 
  interface EmulatorCommandFieldRefs {
    readonly id: FieldRef<"EmulatorCommand", 'Int'>
    readonly input: FieldRef<"EmulatorCommand", 'String'>
    readonly minrank: FieldRef<"EmulatorCommand", 'Int'>
    readonly descriptionFr: FieldRef<"EmulatorCommand", 'String'>
    readonly descriptionEn: FieldRef<"EmulatorCommand", 'String'>
    readonly descriptionBr: FieldRef<"EmulatorCommand", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorCommand findUnique
   */
  export type EmulatorCommandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommand to fetch.
     */
    where: EmulatorCommandWhereUniqueInput
  }


  /**
   * EmulatorCommand findUniqueOrThrow
   */
  export type EmulatorCommandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommand to fetch.
     */
    where: EmulatorCommandWhereUniqueInput
  }


  /**
   * EmulatorCommand findFirst
   */
  export type EmulatorCommandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommand to fetch.
     */
    where?: EmulatorCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommands to fetch.
     */
    orderBy?: EmulatorCommandOrderByWithRelationInput | EmulatorCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorCommands.
     */
    cursor?: EmulatorCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorCommands.
     */
    distinct?: EmulatorCommandScalarFieldEnum | EmulatorCommandScalarFieldEnum[]
  }


  /**
   * EmulatorCommand findFirstOrThrow
   */
  export type EmulatorCommandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommand to fetch.
     */
    where?: EmulatorCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommands to fetch.
     */
    orderBy?: EmulatorCommandOrderByWithRelationInput | EmulatorCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorCommands.
     */
    cursor?: EmulatorCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorCommands.
     */
    distinct?: EmulatorCommandScalarFieldEnum | EmulatorCommandScalarFieldEnum[]
  }


  /**
   * EmulatorCommand findMany
   */
  export type EmulatorCommandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommands to fetch.
     */
    where?: EmulatorCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommands to fetch.
     */
    orderBy?: EmulatorCommandOrderByWithRelationInput | EmulatorCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorCommands.
     */
    cursor?: EmulatorCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommands.
     */
    skip?: number
    distinct?: EmulatorCommandScalarFieldEnum | EmulatorCommandScalarFieldEnum[]
  }


  /**
   * EmulatorCommand create
   */
  export type EmulatorCommandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorCommand.
     */
    data: XOR<EmulatorCommandCreateInput, EmulatorCommandUncheckedCreateInput>
  }


  /**
   * EmulatorCommand createMany
   */
  export type EmulatorCommandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorCommands.
     */
    data: EmulatorCommandCreateManyInput | EmulatorCommandCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorCommand update
   */
  export type EmulatorCommandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorCommand.
     */
    data: XOR<EmulatorCommandUpdateInput, EmulatorCommandUncheckedUpdateInput>
    /**
     * Choose, which EmulatorCommand to update.
     */
    where: EmulatorCommandWhereUniqueInput
  }


  /**
   * EmulatorCommand updateMany
   */
  export type EmulatorCommandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorCommands.
     */
    data: XOR<EmulatorCommandUpdateManyMutationInput, EmulatorCommandUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorCommands to update
     */
    where?: EmulatorCommandWhereInput
  }


  /**
   * EmulatorCommand upsert
   */
  export type EmulatorCommandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorCommand to update in case it exists.
     */
    where: EmulatorCommandWhereUniqueInput
    /**
     * In case the EmulatorCommand found by the `where` argument doesn't exist, create a new EmulatorCommand with this data.
     */
    create: XOR<EmulatorCommandCreateInput, EmulatorCommandUncheckedCreateInput>
    /**
     * In case the EmulatorCommand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorCommandUpdateInput, EmulatorCommandUncheckedUpdateInput>
  }


  /**
   * EmulatorCommand delete
   */
  export type EmulatorCommandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
    /**
     * Filter which EmulatorCommand to delete.
     */
    where: EmulatorCommandWhereUniqueInput
  }


  /**
   * EmulatorCommand deleteMany
   */
  export type EmulatorCommandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorCommands to delete
     */
    where?: EmulatorCommandWhereInput
  }


  /**
   * EmulatorCommand without action
   */
  export type EmulatorCommandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommand
     */
    select?: EmulatorCommandSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorCommandPet
   */

  export type AggregateEmulatorCommandPet = {
    _count: EmulatorCommandPetCountAggregateOutputType | null
    _avg: EmulatorCommandPetAvgAggregateOutputType | null
    _sum: EmulatorCommandPetSumAggregateOutputType | null
    _min: EmulatorCommandPetMinAggregateOutputType | null
    _max: EmulatorCommandPetMaxAggregateOutputType | null
  }

  export type EmulatorCommandPetAvgAggregateOutputType = {
    id: number | null
  }

  export type EmulatorCommandPetSumAggregateOutputType = {
    id: number | null
  }

  export type EmulatorCommandPetMinAggregateOutputType = {
    id: number | null
    command: string | null
  }

  export type EmulatorCommandPetMaxAggregateOutputType = {
    id: number | null
    command: string | null
  }

  export type EmulatorCommandPetCountAggregateOutputType = {
    id: number
    command: number
    _all: number
  }


  export type EmulatorCommandPetAvgAggregateInputType = {
    id?: true
  }

  export type EmulatorCommandPetSumAggregateInputType = {
    id?: true
  }

  export type EmulatorCommandPetMinAggregateInputType = {
    id?: true
    command?: true
  }

  export type EmulatorCommandPetMaxAggregateInputType = {
    id?: true
    command?: true
  }

  export type EmulatorCommandPetCountAggregateInputType = {
    id?: true
    command?: true
    _all?: true
  }

  export type EmulatorCommandPetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorCommandPet to aggregate.
     */
    where?: EmulatorCommandPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommandPets to fetch.
     */
    orderBy?: EmulatorCommandPetOrderByWithRelationInput | EmulatorCommandPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorCommandPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommandPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommandPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorCommandPets
    **/
    _count?: true | EmulatorCommandPetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorCommandPetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorCommandPetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorCommandPetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorCommandPetMaxAggregateInputType
  }

  export type GetEmulatorCommandPetAggregateType<T extends EmulatorCommandPetAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorCommandPet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorCommandPet[P]>
      : GetScalarType<T[P], AggregateEmulatorCommandPet[P]>
  }




  export type EmulatorCommandPetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorCommandPetWhereInput
    orderBy?: EmulatorCommandPetOrderByWithAggregationInput | EmulatorCommandPetOrderByWithAggregationInput[]
    by: EmulatorCommandPetScalarFieldEnum[] | EmulatorCommandPetScalarFieldEnum
    having?: EmulatorCommandPetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorCommandPetCountAggregateInputType | true
    _avg?: EmulatorCommandPetAvgAggregateInputType
    _sum?: EmulatorCommandPetSumAggregateInputType
    _min?: EmulatorCommandPetMinAggregateInputType
    _max?: EmulatorCommandPetMaxAggregateInputType
  }

  export type EmulatorCommandPetGroupByOutputType = {
    id: number
    command: string
    _count: EmulatorCommandPetCountAggregateOutputType | null
    _avg: EmulatorCommandPetAvgAggregateOutputType | null
    _sum: EmulatorCommandPetSumAggregateOutputType | null
    _min: EmulatorCommandPetMinAggregateOutputType | null
    _max: EmulatorCommandPetMaxAggregateOutputType | null
  }

  type GetEmulatorCommandPetGroupByPayload<T extends EmulatorCommandPetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorCommandPetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorCommandPetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorCommandPetGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorCommandPetGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorCommandPetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    command?: boolean
  }, ExtArgs["result"]["emulatorCommandPet"]>

  export type EmulatorCommandPetSelectScalar = {
    id?: boolean
    command?: boolean
  }


  export type $EmulatorCommandPetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorCommandPet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      command: string
    }, ExtArgs["result"]["emulatorCommandPet"]>
    composites: {}
  }


  type EmulatorCommandPetGetPayload<S extends boolean | null | undefined | EmulatorCommandPetDefaultArgs> = $Result.GetResult<Prisma.$EmulatorCommandPetPayload, S>

  type EmulatorCommandPetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorCommandPetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorCommandPetCountAggregateInputType | true
    }

  export interface EmulatorCommandPetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorCommandPet'], meta: { name: 'EmulatorCommandPet' } }
    /**
     * Find zero or one EmulatorCommandPet that matches the filter.
     * @param {EmulatorCommandPetFindUniqueArgs} args - Arguments to find a EmulatorCommandPet
     * @example
     * // Get one EmulatorCommandPet
     * const emulatorCommandPet = await prisma.emulatorCommandPet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorCommandPetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandPetFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorCommandPet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorCommandPetFindUniqueOrThrowArgs} args - Arguments to find a EmulatorCommandPet
     * @example
     * // Get one EmulatorCommandPet
     * const emulatorCommandPet = await prisma.emulatorCommandPet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorCommandPetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandPetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorCommandPet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetFindFirstArgs} args - Arguments to find a EmulatorCommandPet
     * @example
     * // Get one EmulatorCommandPet
     * const emulatorCommandPet = await prisma.emulatorCommandPet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorCommandPetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandPetFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorCommandPet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetFindFirstOrThrowArgs} args - Arguments to find a EmulatorCommandPet
     * @example
     * // Get one EmulatorCommandPet
     * const emulatorCommandPet = await prisma.emulatorCommandPet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorCommandPetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandPetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorCommandPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorCommandPets
     * const emulatorCommandPets = await prisma.emulatorCommandPet.findMany()
     * 
     * // Get first 10 EmulatorCommandPets
     * const emulatorCommandPets = await prisma.emulatorCommandPet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorCommandPetWithIdOnly = await prisma.emulatorCommandPet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorCommandPetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandPetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorCommandPet.
     * @param {EmulatorCommandPetCreateArgs} args - Arguments to create a EmulatorCommandPet.
     * @example
     * // Create one EmulatorCommandPet
     * const EmulatorCommandPet = await prisma.emulatorCommandPet.create({
     *   data: {
     *     // ... data to create a EmulatorCommandPet
     *   }
     * })
     * 
    **/
    create<T extends EmulatorCommandPetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandPetCreateArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorCommandPets.
     *     @param {EmulatorCommandPetCreateManyArgs} args - Arguments to create many EmulatorCommandPets.
     *     @example
     *     // Create many EmulatorCommandPets
     *     const emulatorCommandPet = await prisma.emulatorCommandPet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorCommandPetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandPetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorCommandPet.
     * @param {EmulatorCommandPetDeleteArgs} args - Arguments to delete one EmulatorCommandPet.
     * @example
     * // Delete one EmulatorCommandPet
     * const EmulatorCommandPet = await prisma.emulatorCommandPet.delete({
     *   where: {
     *     // ... filter to delete one EmulatorCommandPet
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorCommandPetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandPetDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorCommandPet.
     * @param {EmulatorCommandPetUpdateArgs} args - Arguments to update one EmulatorCommandPet.
     * @example
     * // Update one EmulatorCommandPet
     * const emulatorCommandPet = await prisma.emulatorCommandPet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorCommandPetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandPetUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorCommandPets.
     * @param {EmulatorCommandPetDeleteManyArgs} args - Arguments to filter EmulatorCommandPets to delete.
     * @example
     * // Delete a few EmulatorCommandPets
     * const { count } = await prisma.emulatorCommandPet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorCommandPetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorCommandPetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorCommandPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorCommandPets
     * const emulatorCommandPet = await prisma.emulatorCommandPet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorCommandPetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandPetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorCommandPet.
     * @param {EmulatorCommandPetUpsertArgs} args - Arguments to update or create a EmulatorCommandPet.
     * @example
     * // Update or create a EmulatorCommandPet
     * const emulatorCommandPet = await prisma.emulatorCommandPet.upsert({
     *   create: {
     *     // ... data to create a EmulatorCommandPet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorCommandPet we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorCommandPetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorCommandPetUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorCommandPetClient<$Result.GetResult<Prisma.$EmulatorCommandPetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorCommandPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetCountArgs} args - Arguments to filter EmulatorCommandPets to count.
     * @example
     * // Count the number of EmulatorCommandPets
     * const count = await prisma.emulatorCommandPet.count({
     *   where: {
     *     // ... the filter for the EmulatorCommandPets we want to count
     *   }
     * })
    **/
    count<T extends EmulatorCommandPetCountArgs>(
      args?: Subset<T, EmulatorCommandPetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorCommandPetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorCommandPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorCommandPetAggregateArgs>(args: Subset<T, EmulatorCommandPetAggregateArgs>): Prisma.PrismaPromise<GetEmulatorCommandPetAggregateType<T>>

    /**
     * Group by EmulatorCommandPet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorCommandPetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorCommandPetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorCommandPetGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorCommandPetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorCommandPetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorCommandPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorCommandPet model
   */
  readonly fields: EmulatorCommandPetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorCommandPet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorCommandPetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorCommandPet model
   */ 
  interface EmulatorCommandPetFieldRefs {
    readonly id: FieldRef<"EmulatorCommandPet", 'Int'>
    readonly command: FieldRef<"EmulatorCommandPet", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorCommandPet findUnique
   */
  export type EmulatorCommandPetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommandPet to fetch.
     */
    where: EmulatorCommandPetWhereUniqueInput
  }


  /**
   * EmulatorCommandPet findUniqueOrThrow
   */
  export type EmulatorCommandPetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommandPet to fetch.
     */
    where: EmulatorCommandPetWhereUniqueInput
  }


  /**
   * EmulatorCommandPet findFirst
   */
  export type EmulatorCommandPetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommandPet to fetch.
     */
    where?: EmulatorCommandPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommandPets to fetch.
     */
    orderBy?: EmulatorCommandPetOrderByWithRelationInput | EmulatorCommandPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorCommandPets.
     */
    cursor?: EmulatorCommandPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommandPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommandPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorCommandPets.
     */
    distinct?: EmulatorCommandPetScalarFieldEnum | EmulatorCommandPetScalarFieldEnum[]
  }


  /**
   * EmulatorCommandPet findFirstOrThrow
   */
  export type EmulatorCommandPetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommandPet to fetch.
     */
    where?: EmulatorCommandPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommandPets to fetch.
     */
    orderBy?: EmulatorCommandPetOrderByWithRelationInput | EmulatorCommandPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorCommandPets.
     */
    cursor?: EmulatorCommandPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommandPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommandPets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorCommandPets.
     */
    distinct?: EmulatorCommandPetScalarFieldEnum | EmulatorCommandPetScalarFieldEnum[]
  }


  /**
   * EmulatorCommandPet findMany
   */
  export type EmulatorCommandPetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorCommandPets to fetch.
     */
    where?: EmulatorCommandPetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorCommandPets to fetch.
     */
    orderBy?: EmulatorCommandPetOrderByWithRelationInput | EmulatorCommandPetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorCommandPets.
     */
    cursor?: EmulatorCommandPetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorCommandPets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorCommandPets.
     */
    skip?: number
    distinct?: EmulatorCommandPetScalarFieldEnum | EmulatorCommandPetScalarFieldEnum[]
  }


  /**
   * EmulatorCommandPet create
   */
  export type EmulatorCommandPetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorCommandPet.
     */
    data: XOR<EmulatorCommandPetCreateInput, EmulatorCommandPetUncheckedCreateInput>
  }


  /**
   * EmulatorCommandPet createMany
   */
  export type EmulatorCommandPetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorCommandPets.
     */
    data: EmulatorCommandPetCreateManyInput | EmulatorCommandPetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorCommandPet update
   */
  export type EmulatorCommandPetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorCommandPet.
     */
    data: XOR<EmulatorCommandPetUpdateInput, EmulatorCommandPetUncheckedUpdateInput>
    /**
     * Choose, which EmulatorCommandPet to update.
     */
    where: EmulatorCommandPetWhereUniqueInput
  }


  /**
   * EmulatorCommandPet updateMany
   */
  export type EmulatorCommandPetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorCommandPets.
     */
    data: XOR<EmulatorCommandPetUpdateManyMutationInput, EmulatorCommandPetUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorCommandPets to update
     */
    where?: EmulatorCommandPetWhereInput
  }


  /**
   * EmulatorCommandPet upsert
   */
  export type EmulatorCommandPetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorCommandPet to update in case it exists.
     */
    where: EmulatorCommandPetWhereUniqueInput
    /**
     * In case the EmulatorCommandPet found by the `where` argument doesn't exist, create a new EmulatorCommandPet with this data.
     */
    create: XOR<EmulatorCommandPetCreateInput, EmulatorCommandPetUncheckedCreateInput>
    /**
     * In case the EmulatorCommandPet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorCommandPetUpdateInput, EmulatorCommandPetUncheckedUpdateInput>
  }


  /**
   * EmulatorCommandPet delete
   */
  export type EmulatorCommandPetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
    /**
     * Filter which EmulatorCommandPet to delete.
     */
    where: EmulatorCommandPetWhereUniqueInput
  }


  /**
   * EmulatorCommandPet deleteMany
   */
  export type EmulatorCommandPetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorCommandPets to delete
     */
    where?: EmulatorCommandPetWhereInput
  }


  /**
   * EmulatorCommandPet without action
   */
  export type EmulatorCommandPetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorCommandPet
     */
    select?: EmulatorCommandPetSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorEffect
   */

  export type AggregateEmulatorEffect = {
    _count: EmulatorEffectCountAggregateOutputType | null
    _avg: EmulatorEffectAvgAggregateOutputType | null
    _sum: EmulatorEffectSumAggregateOutputType | null
    _min: EmulatorEffectMinAggregateOutputType | null
    _max: EmulatorEffectMaxAggregateOutputType | null
  }

  export type EmulatorEffectAvgAggregateOutputType = {
    id: number | null
  }

  export type EmulatorEffectSumAggregateOutputType = {
    id: number | null
  }

  export type EmulatorEffectMinAggregateOutputType = {
    id: number | null
    onlyStaff: boolean | null
  }

  export type EmulatorEffectMaxAggregateOutputType = {
    id: number | null
    onlyStaff: boolean | null
  }

  export type EmulatorEffectCountAggregateOutputType = {
    id: number
    onlyStaff: number
    _all: number
  }


  export type EmulatorEffectAvgAggregateInputType = {
    id?: true
  }

  export type EmulatorEffectSumAggregateInputType = {
    id?: true
  }

  export type EmulatorEffectMinAggregateInputType = {
    id?: true
    onlyStaff?: true
  }

  export type EmulatorEffectMaxAggregateInputType = {
    id?: true
    onlyStaff?: true
  }

  export type EmulatorEffectCountAggregateInputType = {
    id?: true
    onlyStaff?: true
    _all?: true
  }

  export type EmulatorEffectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorEffect to aggregate.
     */
    where?: EmulatorEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorEffects to fetch.
     */
    orderBy?: EmulatorEffectOrderByWithRelationInput | EmulatorEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorEffects
    **/
    _count?: true | EmulatorEffectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorEffectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorEffectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorEffectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorEffectMaxAggregateInputType
  }

  export type GetEmulatorEffectAggregateType<T extends EmulatorEffectAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorEffect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorEffect[P]>
      : GetScalarType<T[P], AggregateEmulatorEffect[P]>
  }




  export type EmulatorEffectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorEffectWhereInput
    orderBy?: EmulatorEffectOrderByWithAggregationInput | EmulatorEffectOrderByWithAggregationInput[]
    by: EmulatorEffectScalarFieldEnum[] | EmulatorEffectScalarFieldEnum
    having?: EmulatorEffectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorEffectCountAggregateInputType | true
    _avg?: EmulatorEffectAvgAggregateInputType
    _sum?: EmulatorEffectSumAggregateInputType
    _min?: EmulatorEffectMinAggregateInputType
    _max?: EmulatorEffectMaxAggregateInputType
  }

  export type EmulatorEffectGroupByOutputType = {
    id: number
    onlyStaff: boolean
    _count: EmulatorEffectCountAggregateOutputType | null
    _avg: EmulatorEffectAvgAggregateOutputType | null
    _sum: EmulatorEffectSumAggregateOutputType | null
    _min: EmulatorEffectMinAggregateOutputType | null
    _max: EmulatorEffectMaxAggregateOutputType | null
  }

  type GetEmulatorEffectGroupByPayload<T extends EmulatorEffectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorEffectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorEffectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorEffectGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorEffectGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorEffectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onlyStaff?: boolean
  }, ExtArgs["result"]["emulatorEffect"]>

  export type EmulatorEffectSelectScalar = {
    id?: boolean
    onlyStaff?: boolean
  }


  export type $EmulatorEffectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorEffect"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      onlyStaff: boolean
    }, ExtArgs["result"]["emulatorEffect"]>
    composites: {}
  }


  type EmulatorEffectGetPayload<S extends boolean | null | undefined | EmulatorEffectDefaultArgs> = $Result.GetResult<Prisma.$EmulatorEffectPayload, S>

  type EmulatorEffectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorEffectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorEffectCountAggregateInputType | true
    }

  export interface EmulatorEffectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorEffect'], meta: { name: 'EmulatorEffect' } }
    /**
     * Find zero or one EmulatorEffect that matches the filter.
     * @param {EmulatorEffectFindUniqueArgs} args - Arguments to find a EmulatorEffect
     * @example
     * // Get one EmulatorEffect
     * const emulatorEffect = await prisma.emulatorEffect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorEffectFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorEffectFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorEffect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorEffectFindUniqueOrThrowArgs} args - Arguments to find a EmulatorEffect
     * @example
     * // Get one EmulatorEffect
     * const emulatorEffect = await prisma.emulatorEffect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorEffectFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorEffectFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorEffect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectFindFirstArgs} args - Arguments to find a EmulatorEffect
     * @example
     * // Get one EmulatorEffect
     * const emulatorEffect = await prisma.emulatorEffect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorEffectFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorEffectFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorEffect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectFindFirstOrThrowArgs} args - Arguments to find a EmulatorEffect
     * @example
     * // Get one EmulatorEffect
     * const emulatorEffect = await prisma.emulatorEffect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorEffectFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorEffectFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorEffects
     * const emulatorEffects = await prisma.emulatorEffect.findMany()
     * 
     * // Get first 10 EmulatorEffects
     * const emulatorEffects = await prisma.emulatorEffect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorEffectWithIdOnly = await prisma.emulatorEffect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorEffectFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorEffectFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorEffect.
     * @param {EmulatorEffectCreateArgs} args - Arguments to create a EmulatorEffect.
     * @example
     * // Create one EmulatorEffect
     * const EmulatorEffect = await prisma.emulatorEffect.create({
     *   data: {
     *     // ... data to create a EmulatorEffect
     *   }
     * })
     * 
    **/
    create<T extends EmulatorEffectCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorEffectCreateArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorEffects.
     *     @param {EmulatorEffectCreateManyArgs} args - Arguments to create many EmulatorEffects.
     *     @example
     *     // Create many EmulatorEffects
     *     const emulatorEffect = await prisma.emulatorEffect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorEffectCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorEffectCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorEffect.
     * @param {EmulatorEffectDeleteArgs} args - Arguments to delete one EmulatorEffect.
     * @example
     * // Delete one EmulatorEffect
     * const EmulatorEffect = await prisma.emulatorEffect.delete({
     *   where: {
     *     // ... filter to delete one EmulatorEffect
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorEffectDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorEffectDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorEffect.
     * @param {EmulatorEffectUpdateArgs} args - Arguments to update one EmulatorEffect.
     * @example
     * // Update one EmulatorEffect
     * const emulatorEffect = await prisma.emulatorEffect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorEffectUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorEffectUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorEffects.
     * @param {EmulatorEffectDeleteManyArgs} args - Arguments to filter EmulatorEffects to delete.
     * @example
     * // Delete a few EmulatorEffects
     * const { count } = await prisma.emulatorEffect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorEffectDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorEffectDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorEffects
     * const emulatorEffect = await prisma.emulatorEffect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorEffectUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorEffectUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorEffect.
     * @param {EmulatorEffectUpsertArgs} args - Arguments to update or create a EmulatorEffect.
     * @example
     * // Update or create a EmulatorEffect
     * const emulatorEffect = await prisma.emulatorEffect.upsert({
     *   create: {
     *     // ... data to create a EmulatorEffect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorEffect we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorEffectUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorEffectUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorEffectClient<$Result.GetResult<Prisma.$EmulatorEffectPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectCountArgs} args - Arguments to filter EmulatorEffects to count.
     * @example
     * // Count the number of EmulatorEffects
     * const count = await prisma.emulatorEffect.count({
     *   where: {
     *     // ... the filter for the EmulatorEffects we want to count
     *   }
     * })
    **/
    count<T extends EmulatorEffectCountArgs>(
      args?: Subset<T, EmulatorEffectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorEffectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorEffectAggregateArgs>(args: Subset<T, EmulatorEffectAggregateArgs>): Prisma.PrismaPromise<GetEmulatorEffectAggregateType<T>>

    /**
     * Group by EmulatorEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorEffectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorEffectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorEffectGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorEffectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorEffectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorEffectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorEffect model
   */
  readonly fields: EmulatorEffectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorEffect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorEffectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorEffect model
   */ 
  interface EmulatorEffectFieldRefs {
    readonly id: FieldRef<"EmulatorEffect", 'Int'>
    readonly onlyStaff: FieldRef<"EmulatorEffect", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorEffect findUnique
   */
  export type EmulatorEffectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorEffect to fetch.
     */
    where: EmulatorEffectWhereUniqueInput
  }


  /**
   * EmulatorEffect findUniqueOrThrow
   */
  export type EmulatorEffectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorEffect to fetch.
     */
    where: EmulatorEffectWhereUniqueInput
  }


  /**
   * EmulatorEffect findFirst
   */
  export type EmulatorEffectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorEffect to fetch.
     */
    where?: EmulatorEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorEffects to fetch.
     */
    orderBy?: EmulatorEffectOrderByWithRelationInput | EmulatorEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorEffects.
     */
    cursor?: EmulatorEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorEffects.
     */
    distinct?: EmulatorEffectScalarFieldEnum | EmulatorEffectScalarFieldEnum[]
  }


  /**
   * EmulatorEffect findFirstOrThrow
   */
  export type EmulatorEffectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorEffect to fetch.
     */
    where?: EmulatorEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorEffects to fetch.
     */
    orderBy?: EmulatorEffectOrderByWithRelationInput | EmulatorEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorEffects.
     */
    cursor?: EmulatorEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorEffects.
     */
    distinct?: EmulatorEffectScalarFieldEnum | EmulatorEffectScalarFieldEnum[]
  }


  /**
   * EmulatorEffect findMany
   */
  export type EmulatorEffectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorEffects to fetch.
     */
    where?: EmulatorEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorEffects to fetch.
     */
    orderBy?: EmulatorEffectOrderByWithRelationInput | EmulatorEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorEffects.
     */
    cursor?: EmulatorEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorEffects.
     */
    skip?: number
    distinct?: EmulatorEffectScalarFieldEnum | EmulatorEffectScalarFieldEnum[]
  }


  /**
   * EmulatorEffect create
   */
  export type EmulatorEffectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorEffect.
     */
    data: XOR<EmulatorEffectCreateInput, EmulatorEffectUncheckedCreateInput>
  }


  /**
   * EmulatorEffect createMany
   */
  export type EmulatorEffectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorEffects.
     */
    data: EmulatorEffectCreateManyInput | EmulatorEffectCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorEffect update
   */
  export type EmulatorEffectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorEffect.
     */
    data: XOR<EmulatorEffectUpdateInput, EmulatorEffectUncheckedUpdateInput>
    /**
     * Choose, which EmulatorEffect to update.
     */
    where: EmulatorEffectWhereUniqueInput
  }


  /**
   * EmulatorEffect updateMany
   */
  export type EmulatorEffectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorEffects.
     */
    data: XOR<EmulatorEffectUpdateManyMutationInput, EmulatorEffectUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorEffects to update
     */
    where?: EmulatorEffectWhereInput
  }


  /**
   * EmulatorEffect upsert
   */
  export type EmulatorEffectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorEffect to update in case it exists.
     */
    where: EmulatorEffectWhereUniqueInput
    /**
     * In case the EmulatorEffect found by the `where` argument doesn't exist, create a new EmulatorEffect with this data.
     */
    create: XOR<EmulatorEffectCreateInput, EmulatorEffectUncheckedCreateInput>
    /**
     * In case the EmulatorEffect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorEffectUpdateInput, EmulatorEffectUncheckedUpdateInput>
  }


  /**
   * EmulatorEffect delete
   */
  export type EmulatorEffectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
    /**
     * Filter which EmulatorEffect to delete.
     */
    where: EmulatorEffectWhereUniqueInput
  }


  /**
   * EmulatorEffect deleteMany
   */
  export type EmulatorEffectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorEffects to delete
     */
    where?: EmulatorEffectWhereInput
  }


  /**
   * EmulatorEffect without action
   */
  export type EmulatorEffectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorEffect
     */
    select?: EmulatorEffectSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorLandingview
   */

  export type AggregateEmulatorLandingview = {
    _count: EmulatorLandingviewCountAggregateOutputType | null
    _avg: EmulatorLandingviewAvgAggregateOutputType | null
    _sum: EmulatorLandingviewSumAggregateOutputType | null
    _min: EmulatorLandingviewMinAggregateOutputType | null
    _max: EmulatorLandingviewMaxAggregateOutputType | null
  }

  export type EmulatorLandingviewAvgAggregateOutputType = {
    index: number | null
  }

  export type EmulatorLandingviewSumAggregateOutputType = {
    index: number | null
  }

  export type EmulatorLandingviewMinAggregateOutputType = {
    index: number | null
    header: string | null
    body: string | null
    button: string | null
    inGamePromo: boolean | null
    specialAction: string | null
    image: string | null
    enabled: boolean | null
  }

  export type EmulatorLandingviewMaxAggregateOutputType = {
    index: number | null
    header: string | null
    body: string | null
    button: string | null
    inGamePromo: boolean | null
    specialAction: string | null
    image: string | null
    enabled: boolean | null
  }

  export type EmulatorLandingviewCountAggregateOutputType = {
    index: number
    header: number
    body: number
    button: number
    inGamePromo: number
    specialAction: number
    image: number
    enabled: number
    _all: number
  }


  export type EmulatorLandingviewAvgAggregateInputType = {
    index?: true
  }

  export type EmulatorLandingviewSumAggregateInputType = {
    index?: true
  }

  export type EmulatorLandingviewMinAggregateInputType = {
    index?: true
    header?: true
    body?: true
    button?: true
    inGamePromo?: true
    specialAction?: true
    image?: true
    enabled?: true
  }

  export type EmulatorLandingviewMaxAggregateInputType = {
    index?: true
    header?: true
    body?: true
    button?: true
    inGamePromo?: true
    specialAction?: true
    image?: true
    enabled?: true
  }

  export type EmulatorLandingviewCountAggregateInputType = {
    index?: true
    header?: true
    body?: true
    button?: true
    inGamePromo?: true
    specialAction?: true
    image?: true
    enabled?: true
    _all?: true
  }

  export type EmulatorLandingviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorLandingview to aggregate.
     */
    where?: EmulatorLandingviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLandingviews to fetch.
     */
    orderBy?: EmulatorLandingviewOrderByWithRelationInput | EmulatorLandingviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorLandingviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLandingviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLandingviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorLandingviews
    **/
    _count?: true | EmulatorLandingviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorLandingviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorLandingviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorLandingviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorLandingviewMaxAggregateInputType
  }

  export type GetEmulatorLandingviewAggregateType<T extends EmulatorLandingviewAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorLandingview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorLandingview[P]>
      : GetScalarType<T[P], AggregateEmulatorLandingview[P]>
  }




  export type EmulatorLandingviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorLandingviewWhereInput
    orderBy?: EmulatorLandingviewOrderByWithAggregationInput | EmulatorLandingviewOrderByWithAggregationInput[]
    by: EmulatorLandingviewScalarFieldEnum[] | EmulatorLandingviewScalarFieldEnum
    having?: EmulatorLandingviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorLandingviewCountAggregateInputType | true
    _avg?: EmulatorLandingviewAvgAggregateInputType
    _sum?: EmulatorLandingviewSumAggregateInputType
    _min?: EmulatorLandingviewMinAggregateInputType
    _max?: EmulatorLandingviewMaxAggregateInputType
  }

  export type EmulatorLandingviewGroupByOutputType = {
    index: number
    header: string
    body: string
    button: string
    inGamePromo: boolean
    specialAction: string
    image: string
    enabled: boolean
    _count: EmulatorLandingviewCountAggregateOutputType | null
    _avg: EmulatorLandingviewAvgAggregateOutputType | null
    _sum: EmulatorLandingviewSumAggregateOutputType | null
    _min: EmulatorLandingviewMinAggregateOutputType | null
    _max: EmulatorLandingviewMaxAggregateOutputType | null
  }

  type GetEmulatorLandingviewGroupByPayload<T extends EmulatorLandingviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorLandingviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorLandingviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorLandingviewGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorLandingviewGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorLandingviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    header?: boolean
    body?: boolean
    button?: boolean
    inGamePromo?: boolean
    specialAction?: boolean
    image?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["emulatorLandingview"]>

  export type EmulatorLandingviewSelectScalar = {
    index?: boolean
    header?: boolean
    body?: boolean
    button?: boolean
    inGamePromo?: boolean
    specialAction?: boolean
    image?: boolean
    enabled?: boolean
  }


  export type $EmulatorLandingviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorLandingview"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      header: string
      body: string
      button: string
      inGamePromo: boolean
      specialAction: string
      image: string
      enabled: boolean
    }, ExtArgs["result"]["emulatorLandingview"]>
    composites: {}
  }


  type EmulatorLandingviewGetPayload<S extends boolean | null | undefined | EmulatorLandingviewDefaultArgs> = $Result.GetResult<Prisma.$EmulatorLandingviewPayload, S>

  type EmulatorLandingviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorLandingviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorLandingviewCountAggregateInputType | true
    }

  export interface EmulatorLandingviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorLandingview'], meta: { name: 'EmulatorLandingview' } }
    /**
     * Find zero or one EmulatorLandingview that matches the filter.
     * @param {EmulatorLandingviewFindUniqueArgs} args - Arguments to find a EmulatorLandingview
     * @example
     * // Get one EmulatorLandingview
     * const emulatorLandingview = await prisma.emulatorLandingview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorLandingviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLandingviewFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorLandingview that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorLandingviewFindUniqueOrThrowArgs} args - Arguments to find a EmulatorLandingview
     * @example
     * // Get one EmulatorLandingview
     * const emulatorLandingview = await prisma.emulatorLandingview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorLandingviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLandingviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorLandingview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewFindFirstArgs} args - Arguments to find a EmulatorLandingview
     * @example
     * // Get one EmulatorLandingview
     * const emulatorLandingview = await prisma.emulatorLandingview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorLandingviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLandingviewFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorLandingview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewFindFirstOrThrowArgs} args - Arguments to find a EmulatorLandingview
     * @example
     * // Get one EmulatorLandingview
     * const emulatorLandingview = await prisma.emulatorLandingview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorLandingviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLandingviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorLandingviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorLandingviews
     * const emulatorLandingviews = await prisma.emulatorLandingview.findMany()
     * 
     * // Get first 10 EmulatorLandingviews
     * const emulatorLandingviews = await prisma.emulatorLandingview.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const emulatorLandingviewWithIndexOnly = await prisma.emulatorLandingview.findMany({ select: { index: true } })
     * 
    **/
    findMany<T extends EmulatorLandingviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLandingviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorLandingview.
     * @param {EmulatorLandingviewCreateArgs} args - Arguments to create a EmulatorLandingview.
     * @example
     * // Create one EmulatorLandingview
     * const EmulatorLandingview = await prisma.emulatorLandingview.create({
     *   data: {
     *     // ... data to create a EmulatorLandingview
     *   }
     * })
     * 
    **/
    create<T extends EmulatorLandingviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLandingviewCreateArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorLandingviews.
     *     @param {EmulatorLandingviewCreateManyArgs} args - Arguments to create many EmulatorLandingviews.
     *     @example
     *     // Create many EmulatorLandingviews
     *     const emulatorLandingview = await prisma.emulatorLandingview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorLandingviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLandingviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorLandingview.
     * @param {EmulatorLandingviewDeleteArgs} args - Arguments to delete one EmulatorLandingview.
     * @example
     * // Delete one EmulatorLandingview
     * const EmulatorLandingview = await prisma.emulatorLandingview.delete({
     *   where: {
     *     // ... filter to delete one EmulatorLandingview
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorLandingviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLandingviewDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorLandingview.
     * @param {EmulatorLandingviewUpdateArgs} args - Arguments to update one EmulatorLandingview.
     * @example
     * // Update one EmulatorLandingview
     * const emulatorLandingview = await prisma.emulatorLandingview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorLandingviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLandingviewUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorLandingviews.
     * @param {EmulatorLandingviewDeleteManyArgs} args - Arguments to filter EmulatorLandingviews to delete.
     * @example
     * // Delete a few EmulatorLandingviews
     * const { count } = await prisma.emulatorLandingview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorLandingviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLandingviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorLandingviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorLandingviews
     * const emulatorLandingview = await prisma.emulatorLandingview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorLandingviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLandingviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorLandingview.
     * @param {EmulatorLandingviewUpsertArgs} args - Arguments to update or create a EmulatorLandingview.
     * @example
     * // Update or create a EmulatorLandingview
     * const emulatorLandingview = await prisma.emulatorLandingview.upsert({
     *   create: {
     *     // ... data to create a EmulatorLandingview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorLandingview we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorLandingviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLandingviewUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorLandingviewClient<$Result.GetResult<Prisma.$EmulatorLandingviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorLandingviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewCountArgs} args - Arguments to filter EmulatorLandingviews to count.
     * @example
     * // Count the number of EmulatorLandingviews
     * const count = await prisma.emulatorLandingview.count({
     *   where: {
     *     // ... the filter for the EmulatorLandingviews we want to count
     *   }
     * })
    **/
    count<T extends EmulatorLandingviewCountArgs>(
      args?: Subset<T, EmulatorLandingviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorLandingviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorLandingview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorLandingviewAggregateArgs>(args: Subset<T, EmulatorLandingviewAggregateArgs>): Prisma.PrismaPromise<GetEmulatorLandingviewAggregateType<T>>

    /**
     * Group by EmulatorLandingview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLandingviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorLandingviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorLandingviewGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorLandingviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorLandingviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorLandingviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorLandingview model
   */
  readonly fields: EmulatorLandingviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorLandingview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorLandingviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorLandingview model
   */ 
  interface EmulatorLandingviewFieldRefs {
    readonly index: FieldRef<"EmulatorLandingview", 'Int'>
    readonly header: FieldRef<"EmulatorLandingview", 'String'>
    readonly body: FieldRef<"EmulatorLandingview", 'String'>
    readonly button: FieldRef<"EmulatorLandingview", 'String'>
    readonly inGamePromo: FieldRef<"EmulatorLandingview", 'Boolean'>
    readonly specialAction: FieldRef<"EmulatorLandingview", 'String'>
    readonly image: FieldRef<"EmulatorLandingview", 'String'>
    readonly enabled: FieldRef<"EmulatorLandingview", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorLandingview findUnique
   */
  export type EmulatorLandingviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLandingview to fetch.
     */
    where: EmulatorLandingviewWhereUniqueInput
  }


  /**
   * EmulatorLandingview findUniqueOrThrow
   */
  export type EmulatorLandingviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLandingview to fetch.
     */
    where: EmulatorLandingviewWhereUniqueInput
  }


  /**
   * EmulatorLandingview findFirst
   */
  export type EmulatorLandingviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLandingview to fetch.
     */
    where?: EmulatorLandingviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLandingviews to fetch.
     */
    orderBy?: EmulatorLandingviewOrderByWithRelationInput | EmulatorLandingviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorLandingviews.
     */
    cursor?: EmulatorLandingviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLandingviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLandingviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorLandingviews.
     */
    distinct?: EmulatorLandingviewScalarFieldEnum | EmulatorLandingviewScalarFieldEnum[]
  }


  /**
   * EmulatorLandingview findFirstOrThrow
   */
  export type EmulatorLandingviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLandingview to fetch.
     */
    where?: EmulatorLandingviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLandingviews to fetch.
     */
    orderBy?: EmulatorLandingviewOrderByWithRelationInput | EmulatorLandingviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorLandingviews.
     */
    cursor?: EmulatorLandingviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLandingviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLandingviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorLandingviews.
     */
    distinct?: EmulatorLandingviewScalarFieldEnum | EmulatorLandingviewScalarFieldEnum[]
  }


  /**
   * EmulatorLandingview findMany
   */
  export type EmulatorLandingviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLandingviews to fetch.
     */
    where?: EmulatorLandingviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLandingviews to fetch.
     */
    orderBy?: EmulatorLandingviewOrderByWithRelationInput | EmulatorLandingviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorLandingviews.
     */
    cursor?: EmulatorLandingviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLandingviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLandingviews.
     */
    skip?: number
    distinct?: EmulatorLandingviewScalarFieldEnum | EmulatorLandingviewScalarFieldEnum[]
  }


  /**
   * EmulatorLandingview create
   */
  export type EmulatorLandingviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorLandingview.
     */
    data?: XOR<EmulatorLandingviewCreateInput, EmulatorLandingviewUncheckedCreateInput>
  }


  /**
   * EmulatorLandingview createMany
   */
  export type EmulatorLandingviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorLandingviews.
     */
    data: EmulatorLandingviewCreateManyInput | EmulatorLandingviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorLandingview update
   */
  export type EmulatorLandingviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorLandingview.
     */
    data: XOR<EmulatorLandingviewUpdateInput, EmulatorLandingviewUncheckedUpdateInput>
    /**
     * Choose, which EmulatorLandingview to update.
     */
    where: EmulatorLandingviewWhereUniqueInput
  }


  /**
   * EmulatorLandingview updateMany
   */
  export type EmulatorLandingviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorLandingviews.
     */
    data: XOR<EmulatorLandingviewUpdateManyMutationInput, EmulatorLandingviewUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorLandingviews to update
     */
    where?: EmulatorLandingviewWhereInput
  }


  /**
   * EmulatorLandingview upsert
   */
  export type EmulatorLandingviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorLandingview to update in case it exists.
     */
    where: EmulatorLandingviewWhereUniqueInput
    /**
     * In case the EmulatorLandingview found by the `where` argument doesn't exist, create a new EmulatorLandingview with this data.
     */
    create: XOR<EmulatorLandingviewCreateInput, EmulatorLandingviewUncheckedCreateInput>
    /**
     * In case the EmulatorLandingview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorLandingviewUpdateInput, EmulatorLandingviewUncheckedUpdateInput>
  }


  /**
   * EmulatorLandingview delete
   */
  export type EmulatorLandingviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
    /**
     * Filter which EmulatorLandingview to delete.
     */
    where: EmulatorLandingviewWhereUniqueInput
  }


  /**
   * EmulatorLandingview deleteMany
   */
  export type EmulatorLandingviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorLandingviews to delete
     */
    where?: EmulatorLandingviewWhereInput
  }


  /**
   * EmulatorLandingview without action
   */
  export type EmulatorLandingviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLandingview
     */
    select?: EmulatorLandingviewSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorLootbox
   */

  export type AggregateEmulatorLootbox = {
    _count: EmulatorLootboxCountAggregateOutputType | null
    _avg: EmulatorLootboxAvgAggregateOutputType | null
    _sum: EmulatorLootboxSumAggregateOutputType | null
    _min: EmulatorLootboxMinAggregateOutputType | null
    _max: EmulatorLootboxMaxAggregateOutputType | null
  }

  export type EmulatorLootboxAvgAggregateOutputType = {
    id: number | null
    probability: number | null
    pageId: number | null
    itemId: number | null
    amount: number | null
  }

  export type EmulatorLootboxSumAggregateOutputType = {
    id: number | null
    probability: number | null
    pageId: number | null
    itemId: number | null
    amount: number | null
  }

  export type EmulatorLootboxMinAggregateOutputType = {
    id: number | null
    interactionType: string | null
    probability: number | null
    pageId: number | null
    itemId: number | null
    category: $Enums.EmulatorLootboxCategory | null
    amount: number | null
  }

  export type EmulatorLootboxMaxAggregateOutputType = {
    id: number | null
    interactionType: string | null
    probability: number | null
    pageId: number | null
    itemId: number | null
    category: $Enums.EmulatorLootboxCategory | null
    amount: number | null
  }

  export type EmulatorLootboxCountAggregateOutputType = {
    id: number
    interactionType: number
    probability: number
    pageId: number
    itemId: number
    category: number
    amount: number
    _all: number
  }


  export type EmulatorLootboxAvgAggregateInputType = {
    id?: true
    probability?: true
    pageId?: true
    itemId?: true
    amount?: true
  }

  export type EmulatorLootboxSumAggregateInputType = {
    id?: true
    probability?: true
    pageId?: true
    itemId?: true
    amount?: true
  }

  export type EmulatorLootboxMinAggregateInputType = {
    id?: true
    interactionType?: true
    probability?: true
    pageId?: true
    itemId?: true
    category?: true
    amount?: true
  }

  export type EmulatorLootboxMaxAggregateInputType = {
    id?: true
    interactionType?: true
    probability?: true
    pageId?: true
    itemId?: true
    category?: true
    amount?: true
  }

  export type EmulatorLootboxCountAggregateInputType = {
    id?: true
    interactionType?: true
    probability?: true
    pageId?: true
    itemId?: true
    category?: true
    amount?: true
    _all?: true
  }

  export type EmulatorLootboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorLootbox to aggregate.
     */
    where?: EmulatorLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLootboxes to fetch.
     */
    orderBy?: EmulatorLootboxOrderByWithRelationInput | EmulatorLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLootboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorLootboxes
    **/
    _count?: true | EmulatorLootboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorLootboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorLootboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorLootboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorLootboxMaxAggregateInputType
  }

  export type GetEmulatorLootboxAggregateType<T extends EmulatorLootboxAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorLootbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorLootbox[P]>
      : GetScalarType<T[P], AggregateEmulatorLootbox[P]>
  }




  export type EmulatorLootboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorLootboxWhereInput
    orderBy?: EmulatorLootboxOrderByWithAggregationInput | EmulatorLootboxOrderByWithAggregationInput[]
    by: EmulatorLootboxScalarFieldEnum[] | EmulatorLootboxScalarFieldEnum
    having?: EmulatorLootboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorLootboxCountAggregateInputType | true
    _avg?: EmulatorLootboxAvgAggregateInputType
    _sum?: EmulatorLootboxSumAggregateInputType
    _min?: EmulatorLootboxMinAggregateInputType
    _max?: EmulatorLootboxMaxAggregateInputType
  }

  export type EmulatorLootboxGroupByOutputType = {
    id: number
    interactionType: string
    probability: number
    pageId: number
    itemId: number
    category: $Enums.EmulatorLootboxCategory
    amount: number
    _count: EmulatorLootboxCountAggregateOutputType | null
    _avg: EmulatorLootboxAvgAggregateOutputType | null
    _sum: EmulatorLootboxSumAggregateOutputType | null
    _min: EmulatorLootboxMinAggregateOutputType | null
    _max: EmulatorLootboxMaxAggregateOutputType | null
  }

  type GetEmulatorLootboxGroupByPayload<T extends EmulatorLootboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorLootboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorLootboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorLootboxGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorLootboxGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorLootboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interactionType?: boolean
    probability?: boolean
    pageId?: boolean
    itemId?: boolean
    category?: boolean
    amount?: boolean
  }, ExtArgs["result"]["emulatorLootbox"]>

  export type EmulatorLootboxSelectScalar = {
    id?: boolean
    interactionType?: boolean
    probability?: boolean
    pageId?: boolean
    itemId?: boolean
    category?: boolean
    amount?: boolean
  }


  export type $EmulatorLootboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorLootbox"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      interactionType: string
      probability: number
      pageId: number
      itemId: number
      category: $Enums.EmulatorLootboxCategory
      amount: number
    }, ExtArgs["result"]["emulatorLootbox"]>
    composites: {}
  }


  type EmulatorLootboxGetPayload<S extends boolean | null | undefined | EmulatorLootboxDefaultArgs> = $Result.GetResult<Prisma.$EmulatorLootboxPayload, S>

  type EmulatorLootboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorLootboxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorLootboxCountAggregateInputType | true
    }

  export interface EmulatorLootboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorLootbox'], meta: { name: 'EmulatorLootbox' } }
    /**
     * Find zero or one EmulatorLootbox that matches the filter.
     * @param {EmulatorLootboxFindUniqueArgs} args - Arguments to find a EmulatorLootbox
     * @example
     * // Get one EmulatorLootbox
     * const emulatorLootbox = await prisma.emulatorLootbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorLootboxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLootboxFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorLootbox that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorLootboxFindUniqueOrThrowArgs} args - Arguments to find a EmulatorLootbox
     * @example
     * // Get one EmulatorLootbox
     * const emulatorLootbox = await prisma.emulatorLootbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorLootboxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLootboxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorLootbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxFindFirstArgs} args - Arguments to find a EmulatorLootbox
     * @example
     * // Get one EmulatorLootbox
     * const emulatorLootbox = await prisma.emulatorLootbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorLootboxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLootboxFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorLootbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxFindFirstOrThrowArgs} args - Arguments to find a EmulatorLootbox
     * @example
     * // Get one EmulatorLootbox
     * const emulatorLootbox = await prisma.emulatorLootbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorLootboxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLootboxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorLootboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorLootboxes
     * const emulatorLootboxes = await prisma.emulatorLootbox.findMany()
     * 
     * // Get first 10 EmulatorLootboxes
     * const emulatorLootboxes = await prisma.emulatorLootbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorLootboxWithIdOnly = await prisma.emulatorLootbox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorLootboxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLootboxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorLootbox.
     * @param {EmulatorLootboxCreateArgs} args - Arguments to create a EmulatorLootbox.
     * @example
     * // Create one EmulatorLootbox
     * const EmulatorLootbox = await prisma.emulatorLootbox.create({
     *   data: {
     *     // ... data to create a EmulatorLootbox
     *   }
     * })
     * 
    **/
    create<T extends EmulatorLootboxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLootboxCreateArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorLootboxes.
     *     @param {EmulatorLootboxCreateManyArgs} args - Arguments to create many EmulatorLootboxes.
     *     @example
     *     // Create many EmulatorLootboxes
     *     const emulatorLootbox = await prisma.emulatorLootbox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorLootboxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLootboxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorLootbox.
     * @param {EmulatorLootboxDeleteArgs} args - Arguments to delete one EmulatorLootbox.
     * @example
     * // Delete one EmulatorLootbox
     * const EmulatorLootbox = await prisma.emulatorLootbox.delete({
     *   where: {
     *     // ... filter to delete one EmulatorLootbox
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorLootboxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLootboxDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorLootbox.
     * @param {EmulatorLootboxUpdateArgs} args - Arguments to update one EmulatorLootbox.
     * @example
     * // Update one EmulatorLootbox
     * const emulatorLootbox = await prisma.emulatorLootbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorLootboxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLootboxUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorLootboxes.
     * @param {EmulatorLootboxDeleteManyArgs} args - Arguments to filter EmulatorLootboxes to delete.
     * @example
     * // Delete a few EmulatorLootboxes
     * const { count } = await prisma.emulatorLootbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorLootboxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorLootboxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorLootboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorLootboxes
     * const emulatorLootbox = await prisma.emulatorLootbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorLootboxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLootboxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorLootbox.
     * @param {EmulatorLootboxUpsertArgs} args - Arguments to update or create a EmulatorLootbox.
     * @example
     * // Update or create a EmulatorLootbox
     * const emulatorLootbox = await prisma.emulatorLootbox.upsert({
     *   create: {
     *     // ... data to create a EmulatorLootbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorLootbox we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorLootboxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorLootboxUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorLootboxClient<$Result.GetResult<Prisma.$EmulatorLootboxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorLootboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxCountArgs} args - Arguments to filter EmulatorLootboxes to count.
     * @example
     * // Count the number of EmulatorLootboxes
     * const count = await prisma.emulatorLootbox.count({
     *   where: {
     *     // ... the filter for the EmulatorLootboxes we want to count
     *   }
     * })
    **/
    count<T extends EmulatorLootboxCountArgs>(
      args?: Subset<T, EmulatorLootboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorLootboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorLootbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorLootboxAggregateArgs>(args: Subset<T, EmulatorLootboxAggregateArgs>): Prisma.PrismaPromise<GetEmulatorLootboxAggregateType<T>>

    /**
     * Group by EmulatorLootbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorLootboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorLootboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorLootboxGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorLootboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorLootboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorLootboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorLootbox model
   */
  readonly fields: EmulatorLootboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorLootbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorLootboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorLootbox model
   */ 
  interface EmulatorLootboxFieldRefs {
    readonly id: FieldRef<"EmulatorLootbox", 'Int'>
    readonly interactionType: FieldRef<"EmulatorLootbox", 'String'>
    readonly probability: FieldRef<"EmulatorLootbox", 'Int'>
    readonly pageId: FieldRef<"EmulatorLootbox", 'Int'>
    readonly itemId: FieldRef<"EmulatorLootbox", 'Int'>
    readonly category: FieldRef<"EmulatorLootbox", 'EmulatorLootboxCategory'>
    readonly amount: FieldRef<"EmulatorLootbox", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorLootbox findUnique
   */
  export type EmulatorLootboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLootbox to fetch.
     */
    where: EmulatorLootboxWhereUniqueInput
  }


  /**
   * EmulatorLootbox findUniqueOrThrow
   */
  export type EmulatorLootboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLootbox to fetch.
     */
    where: EmulatorLootboxWhereUniqueInput
  }


  /**
   * EmulatorLootbox findFirst
   */
  export type EmulatorLootboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLootbox to fetch.
     */
    where?: EmulatorLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLootboxes to fetch.
     */
    orderBy?: EmulatorLootboxOrderByWithRelationInput | EmulatorLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorLootboxes.
     */
    cursor?: EmulatorLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLootboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorLootboxes.
     */
    distinct?: EmulatorLootboxScalarFieldEnum | EmulatorLootboxScalarFieldEnum[]
  }


  /**
   * EmulatorLootbox findFirstOrThrow
   */
  export type EmulatorLootboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLootbox to fetch.
     */
    where?: EmulatorLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLootboxes to fetch.
     */
    orderBy?: EmulatorLootboxOrderByWithRelationInput | EmulatorLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorLootboxes.
     */
    cursor?: EmulatorLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLootboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorLootboxes.
     */
    distinct?: EmulatorLootboxScalarFieldEnum | EmulatorLootboxScalarFieldEnum[]
  }


  /**
   * EmulatorLootbox findMany
   */
  export type EmulatorLootboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorLootboxes to fetch.
     */
    where?: EmulatorLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorLootboxes to fetch.
     */
    orderBy?: EmulatorLootboxOrderByWithRelationInput | EmulatorLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorLootboxes.
     */
    cursor?: EmulatorLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorLootboxes.
     */
    skip?: number
    distinct?: EmulatorLootboxScalarFieldEnum | EmulatorLootboxScalarFieldEnum[]
  }


  /**
   * EmulatorLootbox create
   */
  export type EmulatorLootboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorLootbox.
     */
    data: XOR<EmulatorLootboxCreateInput, EmulatorLootboxUncheckedCreateInput>
  }


  /**
   * EmulatorLootbox createMany
   */
  export type EmulatorLootboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorLootboxes.
     */
    data: EmulatorLootboxCreateManyInput | EmulatorLootboxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorLootbox update
   */
  export type EmulatorLootboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorLootbox.
     */
    data: XOR<EmulatorLootboxUpdateInput, EmulatorLootboxUncheckedUpdateInput>
    /**
     * Choose, which EmulatorLootbox to update.
     */
    where: EmulatorLootboxWhereUniqueInput
  }


  /**
   * EmulatorLootbox updateMany
   */
  export type EmulatorLootboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorLootboxes.
     */
    data: XOR<EmulatorLootboxUpdateManyMutationInput, EmulatorLootboxUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorLootboxes to update
     */
    where?: EmulatorLootboxWhereInput
  }


  /**
   * EmulatorLootbox upsert
   */
  export type EmulatorLootboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorLootbox to update in case it exists.
     */
    where: EmulatorLootboxWhereUniqueInput
    /**
     * In case the EmulatorLootbox found by the `where` argument doesn't exist, create a new EmulatorLootbox with this data.
     */
    create: XOR<EmulatorLootboxCreateInput, EmulatorLootboxUncheckedCreateInput>
    /**
     * In case the EmulatorLootbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorLootboxUpdateInput, EmulatorLootboxUncheckedUpdateInput>
  }


  /**
   * EmulatorLootbox delete
   */
  export type EmulatorLootboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
    /**
     * Filter which EmulatorLootbox to delete.
     */
    where: EmulatorLootboxWhereUniqueInput
  }


  /**
   * EmulatorLootbox deleteMany
   */
  export type EmulatorLootboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorLootboxes to delete
     */
    where?: EmulatorLootboxWhereInput
  }


  /**
   * EmulatorLootbox without action
   */
  export type EmulatorLootboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorLootbox
     */
    select?: EmulatorLootboxSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorPermission
   */

  export type AggregateEmulatorPermission = {
    _count: EmulatorPermissionCountAggregateOutputType | null
    _avg: EmulatorPermissionAvgAggregateOutputType | null
    _sum: EmulatorPermissionSumAggregateOutputType | null
    _min: EmulatorPermissionMinAggregateOutputType | null
    _max: EmulatorPermissionMaxAggregateOutputType | null
  }

  export type EmulatorPermissionAvgAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type EmulatorPermissionSumAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type EmulatorPermissionMinAggregateOutputType = {
    id: number | null
    rank: number | null
    permission: string | null
  }

  export type EmulatorPermissionMaxAggregateOutputType = {
    id: number | null
    rank: number | null
    permission: string | null
  }

  export type EmulatorPermissionCountAggregateOutputType = {
    id: number
    rank: number
    permission: number
    _all: number
  }


  export type EmulatorPermissionAvgAggregateInputType = {
    id?: true
    rank?: true
  }

  export type EmulatorPermissionSumAggregateInputType = {
    id?: true
    rank?: true
  }

  export type EmulatorPermissionMinAggregateInputType = {
    id?: true
    rank?: true
    permission?: true
  }

  export type EmulatorPermissionMaxAggregateInputType = {
    id?: true
    rank?: true
    permission?: true
  }

  export type EmulatorPermissionCountAggregateInputType = {
    id?: true
    rank?: true
    permission?: true
    _all?: true
  }

  export type EmulatorPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorPermission to aggregate.
     */
    where?: EmulatorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorPermissions to fetch.
     */
    orderBy?: EmulatorPermissionOrderByWithRelationInput | EmulatorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorPermissions
    **/
    _count?: true | EmulatorPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorPermissionMaxAggregateInputType
  }

  export type GetEmulatorPermissionAggregateType<T extends EmulatorPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorPermission[P]>
      : GetScalarType<T[P], AggregateEmulatorPermission[P]>
  }




  export type EmulatorPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorPermissionWhereInput
    orderBy?: EmulatorPermissionOrderByWithAggregationInput | EmulatorPermissionOrderByWithAggregationInput[]
    by: EmulatorPermissionScalarFieldEnum[] | EmulatorPermissionScalarFieldEnum
    having?: EmulatorPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorPermissionCountAggregateInputType | true
    _avg?: EmulatorPermissionAvgAggregateInputType
    _sum?: EmulatorPermissionSumAggregateInputType
    _min?: EmulatorPermissionMinAggregateInputType
    _max?: EmulatorPermissionMaxAggregateInputType
  }

  export type EmulatorPermissionGroupByOutputType = {
    id: number
    rank: number
    permission: string
    _count: EmulatorPermissionCountAggregateOutputType | null
    _avg: EmulatorPermissionAvgAggregateOutputType | null
    _sum: EmulatorPermissionSumAggregateOutputType | null
    _min: EmulatorPermissionMinAggregateOutputType | null
    _max: EmulatorPermissionMaxAggregateOutputType | null
  }

  type GetEmulatorPermissionGroupByPayload<T extends EmulatorPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorPermissionGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rank?: boolean
    permission?: boolean
  }, ExtArgs["result"]["emulatorPermission"]>

  export type EmulatorPermissionSelectScalar = {
    id?: boolean
    rank?: boolean
    permission?: boolean
  }


  export type $EmulatorPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorPermission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rank: number
      permission: string
    }, ExtArgs["result"]["emulatorPermission"]>
    composites: {}
  }


  type EmulatorPermissionGetPayload<S extends boolean | null | undefined | EmulatorPermissionDefaultArgs> = $Result.GetResult<Prisma.$EmulatorPermissionPayload, S>

  type EmulatorPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorPermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorPermissionCountAggregateInputType | true
    }

  export interface EmulatorPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorPermission'], meta: { name: 'EmulatorPermission' } }
    /**
     * Find zero or one EmulatorPermission that matches the filter.
     * @param {EmulatorPermissionFindUniqueArgs} args - Arguments to find a EmulatorPermission
     * @example
     * // Get one EmulatorPermission
     * const emulatorPermission = await prisma.emulatorPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorPermissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorPermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorPermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorPermissionFindUniqueOrThrowArgs} args - Arguments to find a EmulatorPermission
     * @example
     * // Get one EmulatorPermission
     * const emulatorPermission = await prisma.emulatorPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorPermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorPermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionFindFirstArgs} args - Arguments to find a EmulatorPermission
     * @example
     * // Get one EmulatorPermission
     * const emulatorPermission = await prisma.emulatorPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorPermissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorPermissionFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionFindFirstOrThrowArgs} args - Arguments to find a EmulatorPermission
     * @example
     * // Get one EmulatorPermission
     * const emulatorPermission = await prisma.emulatorPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorPermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorPermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorPermissions
     * const emulatorPermissions = await prisma.emulatorPermission.findMany()
     * 
     * // Get first 10 EmulatorPermissions
     * const emulatorPermissions = await prisma.emulatorPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorPermissionWithIdOnly = await prisma.emulatorPermission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorPermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorPermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorPermission.
     * @param {EmulatorPermissionCreateArgs} args - Arguments to create a EmulatorPermission.
     * @example
     * // Create one EmulatorPermission
     * const EmulatorPermission = await prisma.emulatorPermission.create({
     *   data: {
     *     // ... data to create a EmulatorPermission
     *   }
     * })
     * 
    **/
    create<T extends EmulatorPermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorPermissionCreateArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorPermissions.
     *     @param {EmulatorPermissionCreateManyArgs} args - Arguments to create many EmulatorPermissions.
     *     @example
     *     // Create many EmulatorPermissions
     *     const emulatorPermission = await prisma.emulatorPermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorPermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorPermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorPermission.
     * @param {EmulatorPermissionDeleteArgs} args - Arguments to delete one EmulatorPermission.
     * @example
     * // Delete one EmulatorPermission
     * const EmulatorPermission = await prisma.emulatorPermission.delete({
     *   where: {
     *     // ... filter to delete one EmulatorPermission
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorPermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorPermissionDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorPermission.
     * @param {EmulatorPermissionUpdateArgs} args - Arguments to update one EmulatorPermission.
     * @example
     * // Update one EmulatorPermission
     * const emulatorPermission = await prisma.emulatorPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorPermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorPermissionUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorPermissions.
     * @param {EmulatorPermissionDeleteManyArgs} args - Arguments to filter EmulatorPermissions to delete.
     * @example
     * // Delete a few EmulatorPermissions
     * const { count } = await prisma.emulatorPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorPermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorPermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorPermissions
     * const emulatorPermission = await prisma.emulatorPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorPermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorPermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorPermission.
     * @param {EmulatorPermissionUpsertArgs} args - Arguments to update or create a EmulatorPermission.
     * @example
     * // Update or create a EmulatorPermission
     * const emulatorPermission = await prisma.emulatorPermission.upsert({
     *   create: {
     *     // ... data to create a EmulatorPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorPermission we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorPermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorPermissionUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorPermissionClient<$Result.GetResult<Prisma.$EmulatorPermissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionCountArgs} args - Arguments to filter EmulatorPermissions to count.
     * @example
     * // Count the number of EmulatorPermissions
     * const count = await prisma.emulatorPermission.count({
     *   where: {
     *     // ... the filter for the EmulatorPermissions we want to count
     *   }
     * })
    **/
    count<T extends EmulatorPermissionCountArgs>(
      args?: Subset<T, EmulatorPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorPermissionAggregateArgs>(args: Subset<T, EmulatorPermissionAggregateArgs>): Prisma.PrismaPromise<GetEmulatorPermissionAggregateType<T>>

    /**
     * Group by EmulatorPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorPermissionGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorPermission model
   */
  readonly fields: EmulatorPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorPermission model
   */ 
  interface EmulatorPermissionFieldRefs {
    readonly id: FieldRef<"EmulatorPermission", 'Int'>
    readonly rank: FieldRef<"EmulatorPermission", 'Int'>
    readonly permission: FieldRef<"EmulatorPermission", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorPermission findUnique
   */
  export type EmulatorPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorPermission to fetch.
     */
    where: EmulatorPermissionWhereUniqueInput
  }


  /**
   * EmulatorPermission findUniqueOrThrow
   */
  export type EmulatorPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorPermission to fetch.
     */
    where: EmulatorPermissionWhereUniqueInput
  }


  /**
   * EmulatorPermission findFirst
   */
  export type EmulatorPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorPermission to fetch.
     */
    where?: EmulatorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorPermissions to fetch.
     */
    orderBy?: EmulatorPermissionOrderByWithRelationInput | EmulatorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorPermissions.
     */
    cursor?: EmulatorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorPermissions.
     */
    distinct?: EmulatorPermissionScalarFieldEnum | EmulatorPermissionScalarFieldEnum[]
  }


  /**
   * EmulatorPermission findFirstOrThrow
   */
  export type EmulatorPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorPermission to fetch.
     */
    where?: EmulatorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorPermissions to fetch.
     */
    orderBy?: EmulatorPermissionOrderByWithRelationInput | EmulatorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorPermissions.
     */
    cursor?: EmulatorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorPermissions.
     */
    distinct?: EmulatorPermissionScalarFieldEnum | EmulatorPermissionScalarFieldEnum[]
  }


  /**
   * EmulatorPermission findMany
   */
  export type EmulatorPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorPermissions to fetch.
     */
    where?: EmulatorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorPermissions to fetch.
     */
    orderBy?: EmulatorPermissionOrderByWithRelationInput | EmulatorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorPermissions.
     */
    cursor?: EmulatorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorPermissions.
     */
    skip?: number
    distinct?: EmulatorPermissionScalarFieldEnum | EmulatorPermissionScalarFieldEnum[]
  }


  /**
   * EmulatorPermission create
   */
  export type EmulatorPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorPermission.
     */
    data: XOR<EmulatorPermissionCreateInput, EmulatorPermissionUncheckedCreateInput>
  }


  /**
   * EmulatorPermission createMany
   */
  export type EmulatorPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorPermissions.
     */
    data: EmulatorPermissionCreateManyInput | EmulatorPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorPermission update
   */
  export type EmulatorPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorPermission.
     */
    data: XOR<EmulatorPermissionUpdateInput, EmulatorPermissionUncheckedUpdateInput>
    /**
     * Choose, which EmulatorPermission to update.
     */
    where: EmulatorPermissionWhereUniqueInput
  }


  /**
   * EmulatorPermission updateMany
   */
  export type EmulatorPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorPermissions.
     */
    data: XOR<EmulatorPermissionUpdateManyMutationInput, EmulatorPermissionUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorPermissions to update
     */
    where?: EmulatorPermissionWhereInput
  }


  /**
   * EmulatorPermission upsert
   */
  export type EmulatorPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorPermission to update in case it exists.
     */
    where: EmulatorPermissionWhereUniqueInput
    /**
     * In case the EmulatorPermission found by the `where` argument doesn't exist, create a new EmulatorPermission with this data.
     */
    create: XOR<EmulatorPermissionCreateInput, EmulatorPermissionUncheckedCreateInput>
    /**
     * In case the EmulatorPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorPermissionUpdateInput, EmulatorPermissionUncheckedUpdateInput>
  }


  /**
   * EmulatorPermission delete
   */
  export type EmulatorPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
    /**
     * Filter which EmulatorPermission to delete.
     */
    where: EmulatorPermissionWhereUniqueInput
  }


  /**
   * EmulatorPermission deleteMany
   */
  export type EmulatorPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorPermissions to delete
     */
    where?: EmulatorPermissionWhereInput
  }


  /**
   * EmulatorPermission without action
   */
  export type EmulatorPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorPermission
     */
    select?: EmulatorPermissionSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorQuest
   */

  export type AggregateEmulatorQuest = {
    _count: EmulatorQuestCountAggregateOutputType | null
    _avg: EmulatorQuestAvgAggregateOutputType | null
    _sum: EmulatorQuestSumAggregateOutputType | null
    _min: EmulatorQuestMinAggregateOutputType | null
    _max: EmulatorQuestMaxAggregateOutputType | null
  }

  export type EmulatorQuestAvgAggregateOutputType = {
    id: number | null
    seriesNumber: number | null
    goalType: number | null
    goalData: number | null
    reward: number | null
  }

  export type EmulatorQuestSumAggregateOutputType = {
    id: number | null
    seriesNumber: number | null
    goalType: number | null
    goalData: number | null
    reward: number | null
  }

  export type EmulatorQuestMinAggregateOutputType = {
    id: number | null
    category: string | null
    seriesNumber: number | null
    goalType: number | null
    goalData: number | null
    name: string | null
    reward: number | null
    dataBit: string | null
  }

  export type EmulatorQuestMaxAggregateOutputType = {
    id: number | null
    category: string | null
    seriesNumber: number | null
    goalType: number | null
    goalData: number | null
    name: string | null
    reward: number | null
    dataBit: string | null
  }

  export type EmulatorQuestCountAggregateOutputType = {
    id: number
    category: number
    seriesNumber: number
    goalType: number
    goalData: number
    name: number
    reward: number
    dataBit: number
    _all: number
  }


  export type EmulatorQuestAvgAggregateInputType = {
    id?: true
    seriesNumber?: true
    goalType?: true
    goalData?: true
    reward?: true
  }

  export type EmulatorQuestSumAggregateInputType = {
    id?: true
    seriesNumber?: true
    goalType?: true
    goalData?: true
    reward?: true
  }

  export type EmulatorQuestMinAggregateInputType = {
    id?: true
    category?: true
    seriesNumber?: true
    goalType?: true
    goalData?: true
    name?: true
    reward?: true
    dataBit?: true
  }

  export type EmulatorQuestMaxAggregateInputType = {
    id?: true
    category?: true
    seriesNumber?: true
    goalType?: true
    goalData?: true
    name?: true
    reward?: true
    dataBit?: true
  }

  export type EmulatorQuestCountAggregateInputType = {
    id?: true
    category?: true
    seriesNumber?: true
    goalType?: true
    goalData?: true
    name?: true
    reward?: true
    dataBit?: true
    _all?: true
  }

  export type EmulatorQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorQuest to aggregate.
     */
    where?: EmulatorQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorQuests to fetch.
     */
    orderBy?: EmulatorQuestOrderByWithRelationInput | EmulatorQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorQuests
    **/
    _count?: true | EmulatorQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorQuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorQuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorQuestMaxAggregateInputType
  }

  export type GetEmulatorQuestAggregateType<T extends EmulatorQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorQuest[P]>
      : GetScalarType<T[P], AggregateEmulatorQuest[P]>
  }




  export type EmulatorQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorQuestWhereInput
    orderBy?: EmulatorQuestOrderByWithAggregationInput | EmulatorQuestOrderByWithAggregationInput[]
    by: EmulatorQuestScalarFieldEnum[] | EmulatorQuestScalarFieldEnum
    having?: EmulatorQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorQuestCountAggregateInputType | true
    _avg?: EmulatorQuestAvgAggregateInputType
    _sum?: EmulatorQuestSumAggregateInputType
    _min?: EmulatorQuestMinAggregateInputType
    _max?: EmulatorQuestMaxAggregateInputType
  }

  export type EmulatorQuestGroupByOutputType = {
    id: number
    category: string
    seriesNumber: number
    goalType: number
    goalData: number
    name: string
    reward: number
    dataBit: string
    _count: EmulatorQuestCountAggregateOutputType | null
    _avg: EmulatorQuestAvgAggregateOutputType | null
    _sum: EmulatorQuestSumAggregateOutputType | null
    _min: EmulatorQuestMinAggregateOutputType | null
    _max: EmulatorQuestMaxAggregateOutputType | null
  }

  type GetEmulatorQuestGroupByPayload<T extends EmulatorQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorQuestGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorQuestGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    seriesNumber?: boolean
    goalType?: boolean
    goalData?: boolean
    name?: boolean
    reward?: boolean
    dataBit?: boolean
  }, ExtArgs["result"]["emulatorQuest"]>

  export type EmulatorQuestSelectScalar = {
    id?: boolean
    category?: boolean
    seriesNumber?: boolean
    goalType?: boolean
    goalData?: boolean
    name?: boolean
    reward?: boolean
    dataBit?: boolean
  }


  export type $EmulatorQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorQuest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      seriesNumber: number
      goalType: number
      goalData: number
      name: string
      reward: number
      dataBit: string
    }, ExtArgs["result"]["emulatorQuest"]>
    composites: {}
  }


  type EmulatorQuestGetPayload<S extends boolean | null | undefined | EmulatorQuestDefaultArgs> = $Result.GetResult<Prisma.$EmulatorQuestPayload, S>

  type EmulatorQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorQuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorQuestCountAggregateInputType | true
    }

  export interface EmulatorQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorQuest'], meta: { name: 'EmulatorQuest' } }
    /**
     * Find zero or one EmulatorQuest that matches the filter.
     * @param {EmulatorQuestFindUniqueArgs} args - Arguments to find a EmulatorQuest
     * @example
     * // Get one EmulatorQuest
     * const emulatorQuest = await prisma.emulatorQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorQuestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorQuestFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorQuest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorQuestFindUniqueOrThrowArgs} args - Arguments to find a EmulatorQuest
     * @example
     * // Get one EmulatorQuest
     * const emulatorQuest = await prisma.emulatorQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorQuestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorQuestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestFindFirstArgs} args - Arguments to find a EmulatorQuest
     * @example
     * // Get one EmulatorQuest
     * const emulatorQuest = await prisma.emulatorQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorQuestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorQuestFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestFindFirstOrThrowArgs} args - Arguments to find a EmulatorQuest
     * @example
     * // Get one EmulatorQuest
     * const emulatorQuest = await prisma.emulatorQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorQuestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorQuestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorQuests
     * const emulatorQuests = await prisma.emulatorQuest.findMany()
     * 
     * // Get first 10 EmulatorQuests
     * const emulatorQuests = await prisma.emulatorQuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorQuestWithIdOnly = await prisma.emulatorQuest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorQuestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorQuestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorQuest.
     * @param {EmulatorQuestCreateArgs} args - Arguments to create a EmulatorQuest.
     * @example
     * // Create one EmulatorQuest
     * const EmulatorQuest = await prisma.emulatorQuest.create({
     *   data: {
     *     // ... data to create a EmulatorQuest
     *   }
     * })
     * 
    **/
    create<T extends EmulatorQuestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorQuestCreateArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorQuests.
     *     @param {EmulatorQuestCreateManyArgs} args - Arguments to create many EmulatorQuests.
     *     @example
     *     // Create many EmulatorQuests
     *     const emulatorQuest = await prisma.emulatorQuest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorQuestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorQuestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorQuest.
     * @param {EmulatorQuestDeleteArgs} args - Arguments to delete one EmulatorQuest.
     * @example
     * // Delete one EmulatorQuest
     * const EmulatorQuest = await prisma.emulatorQuest.delete({
     *   where: {
     *     // ... filter to delete one EmulatorQuest
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorQuestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorQuestDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorQuest.
     * @param {EmulatorQuestUpdateArgs} args - Arguments to update one EmulatorQuest.
     * @example
     * // Update one EmulatorQuest
     * const emulatorQuest = await prisma.emulatorQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorQuestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorQuestUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorQuests.
     * @param {EmulatorQuestDeleteManyArgs} args - Arguments to filter EmulatorQuests to delete.
     * @example
     * // Delete a few EmulatorQuests
     * const { count } = await prisma.emulatorQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorQuestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorQuestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorQuests
     * const emulatorQuest = await prisma.emulatorQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorQuestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorQuestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorQuest.
     * @param {EmulatorQuestUpsertArgs} args - Arguments to update or create a EmulatorQuest.
     * @example
     * // Update or create a EmulatorQuest
     * const emulatorQuest = await prisma.emulatorQuest.upsert({
     *   create: {
     *     // ... data to create a EmulatorQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorQuest we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorQuestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorQuestUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorQuestClient<$Result.GetResult<Prisma.$EmulatorQuestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestCountArgs} args - Arguments to filter EmulatorQuests to count.
     * @example
     * // Count the number of EmulatorQuests
     * const count = await prisma.emulatorQuest.count({
     *   where: {
     *     // ... the filter for the EmulatorQuests we want to count
     *   }
     * })
    **/
    count<T extends EmulatorQuestCountArgs>(
      args?: Subset<T, EmulatorQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorQuestAggregateArgs>(args: Subset<T, EmulatorQuestAggregateArgs>): Prisma.PrismaPromise<GetEmulatorQuestAggregateType<T>>

    /**
     * Group by EmulatorQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorQuestGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorQuest model
   */
  readonly fields: EmulatorQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorQuest model
   */ 
  interface EmulatorQuestFieldRefs {
    readonly id: FieldRef<"EmulatorQuest", 'Int'>
    readonly category: FieldRef<"EmulatorQuest", 'String'>
    readonly seriesNumber: FieldRef<"EmulatorQuest", 'Int'>
    readonly goalType: FieldRef<"EmulatorQuest", 'Int'>
    readonly goalData: FieldRef<"EmulatorQuest", 'Int'>
    readonly name: FieldRef<"EmulatorQuest", 'String'>
    readonly reward: FieldRef<"EmulatorQuest", 'Int'>
    readonly dataBit: FieldRef<"EmulatorQuest", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorQuest findUnique
   */
  export type EmulatorQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorQuest to fetch.
     */
    where: EmulatorQuestWhereUniqueInput
  }


  /**
   * EmulatorQuest findUniqueOrThrow
   */
  export type EmulatorQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorQuest to fetch.
     */
    where: EmulatorQuestWhereUniqueInput
  }


  /**
   * EmulatorQuest findFirst
   */
  export type EmulatorQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorQuest to fetch.
     */
    where?: EmulatorQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorQuests to fetch.
     */
    orderBy?: EmulatorQuestOrderByWithRelationInput | EmulatorQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorQuests.
     */
    cursor?: EmulatorQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorQuests.
     */
    distinct?: EmulatorQuestScalarFieldEnum | EmulatorQuestScalarFieldEnum[]
  }


  /**
   * EmulatorQuest findFirstOrThrow
   */
  export type EmulatorQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorQuest to fetch.
     */
    where?: EmulatorQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorQuests to fetch.
     */
    orderBy?: EmulatorQuestOrderByWithRelationInput | EmulatorQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorQuests.
     */
    cursor?: EmulatorQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorQuests.
     */
    distinct?: EmulatorQuestScalarFieldEnum | EmulatorQuestScalarFieldEnum[]
  }


  /**
   * EmulatorQuest findMany
   */
  export type EmulatorQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorQuests to fetch.
     */
    where?: EmulatorQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorQuests to fetch.
     */
    orderBy?: EmulatorQuestOrderByWithRelationInput | EmulatorQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorQuests.
     */
    cursor?: EmulatorQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorQuests.
     */
    skip?: number
    distinct?: EmulatorQuestScalarFieldEnum | EmulatorQuestScalarFieldEnum[]
  }


  /**
   * EmulatorQuest create
   */
  export type EmulatorQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorQuest.
     */
    data?: XOR<EmulatorQuestCreateInput, EmulatorQuestUncheckedCreateInput>
  }


  /**
   * EmulatorQuest createMany
   */
  export type EmulatorQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorQuests.
     */
    data: EmulatorQuestCreateManyInput | EmulatorQuestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorQuest update
   */
  export type EmulatorQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorQuest.
     */
    data: XOR<EmulatorQuestUpdateInput, EmulatorQuestUncheckedUpdateInput>
    /**
     * Choose, which EmulatorQuest to update.
     */
    where: EmulatorQuestWhereUniqueInput
  }


  /**
   * EmulatorQuest updateMany
   */
  export type EmulatorQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorQuests.
     */
    data: XOR<EmulatorQuestUpdateManyMutationInput, EmulatorQuestUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorQuests to update
     */
    where?: EmulatorQuestWhereInput
  }


  /**
   * EmulatorQuest upsert
   */
  export type EmulatorQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorQuest to update in case it exists.
     */
    where: EmulatorQuestWhereUniqueInput
    /**
     * In case the EmulatorQuest found by the `where` argument doesn't exist, create a new EmulatorQuest with this data.
     */
    create: XOR<EmulatorQuestCreateInput, EmulatorQuestUncheckedCreateInput>
    /**
     * In case the EmulatorQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorQuestUpdateInput, EmulatorQuestUncheckedUpdateInput>
  }


  /**
   * EmulatorQuest delete
   */
  export type EmulatorQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
    /**
     * Filter which EmulatorQuest to delete.
     */
    where: EmulatorQuestWhereUniqueInput
  }


  /**
   * EmulatorQuest deleteMany
   */
  export type EmulatorQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorQuests to delete
     */
    where?: EmulatorQuestWhereInput
  }


  /**
   * EmulatorQuest without action
   */
  export type EmulatorQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorQuest
     */
    select?: EmulatorQuestSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorSetting
   */

  export type AggregateEmulatorSetting = {
    _count: EmulatorSettingCountAggregateOutputType | null
    _avg: EmulatorSettingAvgAggregateOutputType | null
    _sum: EmulatorSettingSumAggregateOutputType | null
    _min: EmulatorSettingMinAggregateOutputType | null
    _max: EmulatorSettingMaxAggregateOutputType | null
  }

  export type EmulatorSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type EmulatorSettingSumAggregateOutputType = {
    id: number | null
  }

  export type EmulatorSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type EmulatorSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
  }

  export type EmulatorSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type EmulatorSettingAvgAggregateInputType = {
    id?: true
  }

  export type EmulatorSettingSumAggregateInputType = {
    id?: true
  }

  export type EmulatorSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type EmulatorSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type EmulatorSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type EmulatorSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorSetting to aggregate.
     */
    where?: EmulatorSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorSettings to fetch.
     */
    orderBy?: EmulatorSettingOrderByWithRelationInput | EmulatorSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorSettings
    **/
    _count?: true | EmulatorSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorSettingMaxAggregateInputType
  }

  export type GetEmulatorSettingAggregateType<T extends EmulatorSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorSetting[P]>
      : GetScalarType<T[P], AggregateEmulatorSetting[P]>
  }




  export type EmulatorSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorSettingWhereInput
    orderBy?: EmulatorSettingOrderByWithAggregationInput | EmulatorSettingOrderByWithAggregationInput[]
    by: EmulatorSettingScalarFieldEnum[] | EmulatorSettingScalarFieldEnum
    having?: EmulatorSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorSettingCountAggregateInputType | true
    _avg?: EmulatorSettingAvgAggregateInputType
    _sum?: EmulatorSettingSumAggregateInputType
    _min?: EmulatorSettingMinAggregateInputType
    _max?: EmulatorSettingMaxAggregateInputType
  }

  export type EmulatorSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    _count: EmulatorSettingCountAggregateOutputType | null
    _avg: EmulatorSettingAvgAggregateOutputType | null
    _sum: EmulatorSettingSumAggregateOutputType | null
    _min: EmulatorSettingMinAggregateOutputType | null
    _max: EmulatorSettingMaxAggregateOutputType | null
  }

  type GetEmulatorSettingGroupByPayload<T extends EmulatorSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorSettingGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorSettingGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["emulatorSetting"]>

  export type EmulatorSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }


  export type $EmulatorSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
    }, ExtArgs["result"]["emulatorSetting"]>
    composites: {}
  }


  type EmulatorSettingGetPayload<S extends boolean | null | undefined | EmulatorSettingDefaultArgs> = $Result.GetResult<Prisma.$EmulatorSettingPayload, S>

  type EmulatorSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorSettingCountAggregateInputType | true
    }

  export interface EmulatorSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorSetting'], meta: { name: 'EmulatorSetting' } }
    /**
     * Find zero or one EmulatorSetting that matches the filter.
     * @param {EmulatorSettingFindUniqueArgs} args - Arguments to find a EmulatorSetting
     * @example
     * // Get one EmulatorSetting
     * const emulatorSetting = await prisma.emulatorSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorSettingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorSettingFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorSetting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorSettingFindUniqueOrThrowArgs} args - Arguments to find a EmulatorSetting
     * @example
     * // Get one EmulatorSetting
     * const emulatorSetting = await prisma.emulatorSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorSettingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorSettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingFindFirstArgs} args - Arguments to find a EmulatorSetting
     * @example
     * // Get one EmulatorSetting
     * const emulatorSetting = await prisma.emulatorSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorSettingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorSettingFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingFindFirstOrThrowArgs} args - Arguments to find a EmulatorSetting
     * @example
     * // Get one EmulatorSetting
     * const emulatorSetting = await prisma.emulatorSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorSettingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorSettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorSettings
     * const emulatorSettings = await prisma.emulatorSetting.findMany()
     * 
     * // Get first 10 EmulatorSettings
     * const emulatorSettings = await prisma.emulatorSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorSettingWithIdOnly = await prisma.emulatorSetting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorSettingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorSettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorSetting.
     * @param {EmulatorSettingCreateArgs} args - Arguments to create a EmulatorSetting.
     * @example
     * // Create one EmulatorSetting
     * const EmulatorSetting = await prisma.emulatorSetting.create({
     *   data: {
     *     // ... data to create a EmulatorSetting
     *   }
     * })
     * 
    **/
    create<T extends EmulatorSettingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorSettingCreateArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorSettings.
     *     @param {EmulatorSettingCreateManyArgs} args - Arguments to create many EmulatorSettings.
     *     @example
     *     // Create many EmulatorSettings
     *     const emulatorSetting = await prisma.emulatorSetting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorSettingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorSettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorSetting.
     * @param {EmulatorSettingDeleteArgs} args - Arguments to delete one EmulatorSetting.
     * @example
     * // Delete one EmulatorSetting
     * const EmulatorSetting = await prisma.emulatorSetting.delete({
     *   where: {
     *     // ... filter to delete one EmulatorSetting
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorSettingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorSettingDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorSetting.
     * @param {EmulatorSettingUpdateArgs} args - Arguments to update one EmulatorSetting.
     * @example
     * // Update one EmulatorSetting
     * const emulatorSetting = await prisma.emulatorSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorSettingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorSettingUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorSettings.
     * @param {EmulatorSettingDeleteManyArgs} args - Arguments to filter EmulatorSettings to delete.
     * @example
     * // Delete a few EmulatorSettings
     * const { count } = await prisma.emulatorSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorSettingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorSettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorSettings
     * const emulatorSetting = await prisma.emulatorSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorSettingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorSettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorSetting.
     * @param {EmulatorSettingUpsertArgs} args - Arguments to update or create a EmulatorSetting.
     * @example
     * // Update or create a EmulatorSetting
     * const emulatorSetting = await prisma.emulatorSetting.upsert({
     *   create: {
     *     // ... data to create a EmulatorSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorSetting we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorSettingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorSettingUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorSettingClient<$Result.GetResult<Prisma.$EmulatorSettingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingCountArgs} args - Arguments to filter EmulatorSettings to count.
     * @example
     * // Count the number of EmulatorSettings
     * const count = await prisma.emulatorSetting.count({
     *   where: {
     *     // ... the filter for the EmulatorSettings we want to count
     *   }
     * })
    **/
    count<T extends EmulatorSettingCountArgs>(
      args?: Subset<T, EmulatorSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorSettingAggregateArgs>(args: Subset<T, EmulatorSettingAggregateArgs>): Prisma.PrismaPromise<GetEmulatorSettingAggregateType<T>>

    /**
     * Group by EmulatorSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorSettingGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorSetting model
   */
  readonly fields: EmulatorSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorSetting model
   */ 
  interface EmulatorSettingFieldRefs {
    readonly id: FieldRef<"EmulatorSetting", 'Int'>
    readonly key: FieldRef<"EmulatorSetting", 'String'>
    readonly value: FieldRef<"EmulatorSetting", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorSetting findUnique
   */
  export type EmulatorSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorSetting to fetch.
     */
    where: EmulatorSettingWhereUniqueInput
  }


  /**
   * EmulatorSetting findUniqueOrThrow
   */
  export type EmulatorSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorSetting to fetch.
     */
    where: EmulatorSettingWhereUniqueInput
  }


  /**
   * EmulatorSetting findFirst
   */
  export type EmulatorSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorSetting to fetch.
     */
    where?: EmulatorSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorSettings to fetch.
     */
    orderBy?: EmulatorSettingOrderByWithRelationInput | EmulatorSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorSettings.
     */
    cursor?: EmulatorSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorSettings.
     */
    distinct?: EmulatorSettingScalarFieldEnum | EmulatorSettingScalarFieldEnum[]
  }


  /**
   * EmulatorSetting findFirstOrThrow
   */
  export type EmulatorSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorSetting to fetch.
     */
    where?: EmulatorSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorSettings to fetch.
     */
    orderBy?: EmulatorSettingOrderByWithRelationInput | EmulatorSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorSettings.
     */
    cursor?: EmulatorSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorSettings.
     */
    distinct?: EmulatorSettingScalarFieldEnum | EmulatorSettingScalarFieldEnum[]
  }


  /**
   * EmulatorSetting findMany
   */
  export type EmulatorSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorSettings to fetch.
     */
    where?: EmulatorSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorSettings to fetch.
     */
    orderBy?: EmulatorSettingOrderByWithRelationInput | EmulatorSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorSettings.
     */
    cursor?: EmulatorSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorSettings.
     */
    skip?: number
    distinct?: EmulatorSettingScalarFieldEnum | EmulatorSettingScalarFieldEnum[]
  }


  /**
   * EmulatorSetting create
   */
  export type EmulatorSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorSetting.
     */
    data: XOR<EmulatorSettingCreateInput, EmulatorSettingUncheckedCreateInput>
  }


  /**
   * EmulatorSetting createMany
   */
  export type EmulatorSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorSettings.
     */
    data: EmulatorSettingCreateManyInput | EmulatorSettingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorSetting update
   */
  export type EmulatorSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorSetting.
     */
    data: XOR<EmulatorSettingUpdateInput, EmulatorSettingUncheckedUpdateInput>
    /**
     * Choose, which EmulatorSetting to update.
     */
    where: EmulatorSettingWhereUniqueInput
  }


  /**
   * EmulatorSetting updateMany
   */
  export type EmulatorSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorSettings.
     */
    data: XOR<EmulatorSettingUpdateManyMutationInput, EmulatorSettingUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorSettings to update
     */
    where?: EmulatorSettingWhereInput
  }


  /**
   * EmulatorSetting upsert
   */
  export type EmulatorSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorSetting to update in case it exists.
     */
    where: EmulatorSettingWhereUniqueInput
    /**
     * In case the EmulatorSetting found by the `where` argument doesn't exist, create a new EmulatorSetting with this data.
     */
    create: XOR<EmulatorSettingCreateInput, EmulatorSettingUncheckedCreateInput>
    /**
     * In case the EmulatorSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorSettingUpdateInput, EmulatorSettingUncheckedUpdateInput>
  }


  /**
   * EmulatorSetting delete
   */
  export type EmulatorSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
    /**
     * Filter which EmulatorSetting to delete.
     */
    where: EmulatorSettingWhereUniqueInput
  }


  /**
   * EmulatorSetting deleteMany
   */
  export type EmulatorSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorSettings to delete
     */
    where?: EmulatorSettingWhereInput
  }


  /**
   * EmulatorSetting without action
   */
  export type EmulatorSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorSetting
     */
    select?: EmulatorSettingSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorStats
   */

  export type AggregateEmulatorStats = {
    _count: EmulatorStatsCountAggregateOutputType | null
    _avg: EmulatorStatsAvgAggregateOutputType | null
    _sum: EmulatorStatsSumAggregateOutputType | null
    _min: EmulatorStatsMinAggregateOutputType | null
    _max: EmulatorStatsMaxAggregateOutputType | null
  }

  export type EmulatorStatsAvgAggregateOutputType = {
    id: number | null
    online: number | null
    time: number | null
    room: number | null
  }

  export type EmulatorStatsSumAggregateOutputType = {
    id: number | null
    online: number | null
    time: number | null
    room: number | null
  }

  export type EmulatorStatsMinAggregateOutputType = {
    id: number | null
    online: number | null
    time: number | null
    room: number | null
  }

  export type EmulatorStatsMaxAggregateOutputType = {
    id: number | null
    online: number | null
    time: number | null
    room: number | null
  }

  export type EmulatorStatsCountAggregateOutputType = {
    id: number
    online: number
    time: number
    room: number
    _all: number
  }


  export type EmulatorStatsAvgAggregateInputType = {
    id?: true
    online?: true
    time?: true
    room?: true
  }

  export type EmulatorStatsSumAggregateInputType = {
    id?: true
    online?: true
    time?: true
    room?: true
  }

  export type EmulatorStatsMinAggregateInputType = {
    id?: true
    online?: true
    time?: true
    room?: true
  }

  export type EmulatorStatsMaxAggregateInputType = {
    id?: true
    online?: true
    time?: true
    room?: true
  }

  export type EmulatorStatsCountAggregateInputType = {
    id?: true
    online?: true
    time?: true
    room?: true
    _all?: true
  }

  export type EmulatorStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorStats to aggregate.
     */
    where?: EmulatorStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStats to fetch.
     */
    orderBy?: EmulatorStatsOrderByWithRelationInput | EmulatorStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorStats
    **/
    _count?: true | EmulatorStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorStatsMaxAggregateInputType
  }

  export type GetEmulatorStatsAggregateType<T extends EmulatorStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorStats[P]>
      : GetScalarType<T[P], AggregateEmulatorStats[P]>
  }




  export type EmulatorStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorStatsWhereInput
    orderBy?: EmulatorStatsOrderByWithAggregationInput | EmulatorStatsOrderByWithAggregationInput[]
    by: EmulatorStatsScalarFieldEnum[] | EmulatorStatsScalarFieldEnum
    having?: EmulatorStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorStatsCountAggregateInputType | true
    _avg?: EmulatorStatsAvgAggregateInputType
    _sum?: EmulatorStatsSumAggregateInputType
    _min?: EmulatorStatsMinAggregateInputType
    _max?: EmulatorStatsMaxAggregateInputType
  }

  export type EmulatorStatsGroupByOutputType = {
    id: number
    online: number
    time: number
    room: number
    _count: EmulatorStatsCountAggregateOutputType | null
    _avg: EmulatorStatsAvgAggregateOutputType | null
    _sum: EmulatorStatsSumAggregateOutputType | null
    _min: EmulatorStatsMinAggregateOutputType | null
    _max: EmulatorStatsMaxAggregateOutputType | null
  }

  type GetEmulatorStatsGroupByPayload<T extends EmulatorStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorStatsGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorStatsGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    online?: boolean
    time?: boolean
    room?: boolean
  }, ExtArgs["result"]["emulatorStats"]>

  export type EmulatorStatsSelectScalar = {
    id?: boolean
    online?: boolean
    time?: boolean
    room?: boolean
  }


  export type $EmulatorStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      online: number
      time: number
      room: number
    }, ExtArgs["result"]["emulatorStats"]>
    composites: {}
  }


  type EmulatorStatsGetPayload<S extends boolean | null | undefined | EmulatorStatsDefaultArgs> = $Result.GetResult<Prisma.$EmulatorStatsPayload, S>

  type EmulatorStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorStatsCountAggregateInputType | true
    }

  export interface EmulatorStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorStats'], meta: { name: 'EmulatorStats' } }
    /**
     * Find zero or one EmulatorStats that matches the filter.
     * @param {EmulatorStatsFindUniqueArgs} args - Arguments to find a EmulatorStats
     * @example
     * // Get one EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorStatsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatsFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorStats that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorStatsFindUniqueOrThrowArgs} args - Arguments to find a EmulatorStats
     * @example
     * // Get one EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorStatsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsFindFirstArgs} args - Arguments to find a EmulatorStats
     * @example
     * // Get one EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorStatsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatsFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsFindFirstOrThrowArgs} args - Arguments to find a EmulatorStats
     * @example
     * // Get one EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorStatsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.findMany()
     * 
     * // Get first 10 EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorStatsWithIdOnly = await prisma.emulatorStats.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorStatsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorStats.
     * @param {EmulatorStatsCreateArgs} args - Arguments to create a EmulatorStats.
     * @example
     * // Create one EmulatorStats
     * const EmulatorStats = await prisma.emulatorStats.create({
     *   data: {
     *     // ... data to create a EmulatorStats
     *   }
     * })
     * 
    **/
    create<T extends EmulatorStatsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatsCreateArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorStats.
     *     @param {EmulatorStatsCreateManyArgs} args - Arguments to create many EmulatorStats.
     *     @example
     *     // Create many EmulatorStats
     *     const emulatorStats = await prisma.emulatorStats.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorStatsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorStats.
     * @param {EmulatorStatsDeleteArgs} args - Arguments to delete one EmulatorStats.
     * @example
     * // Delete one EmulatorStats
     * const EmulatorStats = await prisma.emulatorStats.delete({
     *   where: {
     *     // ... filter to delete one EmulatorStats
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorStatsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatsDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorStats.
     * @param {EmulatorStatsUpdateArgs} args - Arguments to update one EmulatorStats.
     * @example
     * // Update one EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorStatsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatsUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorStats.
     * @param {EmulatorStatsDeleteManyArgs} args - Arguments to filter EmulatorStats to delete.
     * @example
     * // Delete a few EmulatorStats
     * const { count } = await prisma.emulatorStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorStatsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorStatsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorStats.
     * @param {EmulatorStatsUpsertArgs} args - Arguments to update or create a EmulatorStats.
     * @example
     * // Update or create a EmulatorStats
     * const emulatorStats = await prisma.emulatorStats.upsert({
     *   create: {
     *     // ... data to create a EmulatorStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorStats we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorStatsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatsUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorStatsClient<$Result.GetResult<Prisma.$EmulatorStatsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsCountArgs} args - Arguments to filter EmulatorStats to count.
     * @example
     * // Count the number of EmulatorStats
     * const count = await prisma.emulatorStats.count({
     *   where: {
     *     // ... the filter for the EmulatorStats we want to count
     *   }
     * })
    **/
    count<T extends EmulatorStatsCountArgs>(
      args?: Subset<T, EmulatorStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorStatsAggregateArgs>(args: Subset<T, EmulatorStatsAggregateArgs>): Prisma.PrismaPromise<GetEmulatorStatsAggregateType<T>>

    /**
     * Group by EmulatorStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorStatsGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorStats model
   */
  readonly fields: EmulatorStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorStats model
   */ 
  interface EmulatorStatsFieldRefs {
    readonly id: FieldRef<"EmulatorStats", 'Int'>
    readonly online: FieldRef<"EmulatorStats", 'Int'>
    readonly time: FieldRef<"EmulatorStats", 'Int'>
    readonly room: FieldRef<"EmulatorStats", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorStats findUnique
   */
  export type EmulatorStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStats to fetch.
     */
    where: EmulatorStatsWhereUniqueInput
  }


  /**
   * EmulatorStats findUniqueOrThrow
   */
  export type EmulatorStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStats to fetch.
     */
    where: EmulatorStatsWhereUniqueInput
  }


  /**
   * EmulatorStats findFirst
   */
  export type EmulatorStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStats to fetch.
     */
    where?: EmulatorStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStats to fetch.
     */
    orderBy?: EmulatorStatsOrderByWithRelationInput | EmulatorStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorStats.
     */
    cursor?: EmulatorStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorStats.
     */
    distinct?: EmulatorStatsScalarFieldEnum | EmulatorStatsScalarFieldEnum[]
  }


  /**
   * EmulatorStats findFirstOrThrow
   */
  export type EmulatorStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStats to fetch.
     */
    where?: EmulatorStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStats to fetch.
     */
    orderBy?: EmulatorStatsOrderByWithRelationInput | EmulatorStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorStats.
     */
    cursor?: EmulatorStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorStats.
     */
    distinct?: EmulatorStatsScalarFieldEnum | EmulatorStatsScalarFieldEnum[]
  }


  /**
   * EmulatorStats findMany
   */
  export type EmulatorStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStats to fetch.
     */
    where?: EmulatorStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStats to fetch.
     */
    orderBy?: EmulatorStatsOrderByWithRelationInput | EmulatorStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorStats.
     */
    cursor?: EmulatorStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStats.
     */
    skip?: number
    distinct?: EmulatorStatsScalarFieldEnum | EmulatorStatsScalarFieldEnum[]
  }


  /**
   * EmulatorStats create
   */
  export type EmulatorStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorStats.
     */
    data: XOR<EmulatorStatsCreateInput, EmulatorStatsUncheckedCreateInput>
  }


  /**
   * EmulatorStats createMany
   */
  export type EmulatorStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorStats.
     */
    data: EmulatorStatsCreateManyInput | EmulatorStatsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorStats update
   */
  export type EmulatorStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorStats.
     */
    data: XOR<EmulatorStatsUpdateInput, EmulatorStatsUncheckedUpdateInput>
    /**
     * Choose, which EmulatorStats to update.
     */
    where: EmulatorStatsWhereUniqueInput
  }


  /**
   * EmulatorStats updateMany
   */
  export type EmulatorStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorStats.
     */
    data: XOR<EmulatorStatsUpdateManyMutationInput, EmulatorStatsUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorStats to update
     */
    where?: EmulatorStatsWhereInput
  }


  /**
   * EmulatorStats upsert
   */
  export type EmulatorStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorStats to update in case it exists.
     */
    where: EmulatorStatsWhereUniqueInput
    /**
     * In case the EmulatorStats found by the `where` argument doesn't exist, create a new EmulatorStats with this data.
     */
    create: XOR<EmulatorStatsCreateInput, EmulatorStatsUncheckedCreateInput>
    /**
     * In case the EmulatorStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorStatsUpdateInput, EmulatorStatsUncheckedUpdateInput>
  }


  /**
   * EmulatorStats delete
   */
  export type EmulatorStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
    /**
     * Filter which EmulatorStats to delete.
     */
    where: EmulatorStatsWhereUniqueInput
  }


  /**
   * EmulatorStats deleteMany
   */
  export type EmulatorStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorStats to delete
     */
    where?: EmulatorStatsWhereInput
  }


  /**
   * EmulatorStats without action
   */
  export type EmulatorStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStats
     */
    select?: EmulatorStatsSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorStatus
   */

  export type AggregateEmulatorStatus = {
    _count: EmulatorStatusCountAggregateOutputType | null
    _avg: EmulatorStatusAvgAggregateOutputType | null
    _sum: EmulatorStatusSumAggregateOutputType | null
    _min: EmulatorStatusMinAggregateOutputType | null
    _max: EmulatorStatusMaxAggregateOutputType | null
  }

  export type EmulatorStatusAvgAggregateOutputType = {
    id: number | null
    status: number | null
    usersOnline: number | null
    roomsLoaded: number | null
    stamp: number | null
    userpeak: number | null
  }

  export type EmulatorStatusSumAggregateOutputType = {
    id: number | null
    status: number | null
    usersOnline: number | null
    roomsLoaded: number | null
    stamp: number | null
    userpeak: number | null
  }

  export type EmulatorStatusMinAggregateOutputType = {
    id: number | null
    status: number | null
    usersOnline: number | null
    roomsLoaded: number | null
    stamp: number | null
    userpeak: number | null
  }

  export type EmulatorStatusMaxAggregateOutputType = {
    id: number | null
    status: number | null
    usersOnline: number | null
    roomsLoaded: number | null
    stamp: number | null
    userpeak: number | null
  }

  export type EmulatorStatusCountAggregateOutputType = {
    id: number
    status: number
    usersOnline: number
    roomsLoaded: number
    stamp: number
    userpeak: number
    _all: number
  }


  export type EmulatorStatusAvgAggregateInputType = {
    id?: true
    status?: true
    usersOnline?: true
    roomsLoaded?: true
    stamp?: true
    userpeak?: true
  }

  export type EmulatorStatusSumAggregateInputType = {
    id?: true
    status?: true
    usersOnline?: true
    roomsLoaded?: true
    stamp?: true
    userpeak?: true
  }

  export type EmulatorStatusMinAggregateInputType = {
    id?: true
    status?: true
    usersOnline?: true
    roomsLoaded?: true
    stamp?: true
    userpeak?: true
  }

  export type EmulatorStatusMaxAggregateInputType = {
    id?: true
    status?: true
    usersOnline?: true
    roomsLoaded?: true
    stamp?: true
    userpeak?: true
  }

  export type EmulatorStatusCountAggregateInputType = {
    id?: true
    status?: true
    usersOnline?: true
    roomsLoaded?: true
    stamp?: true
    userpeak?: true
    _all?: true
  }

  export type EmulatorStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorStatus to aggregate.
     */
    where?: EmulatorStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStatuses to fetch.
     */
    orderBy?: EmulatorStatusOrderByWithRelationInput | EmulatorStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorStatuses
    **/
    _count?: true | EmulatorStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorStatusMaxAggregateInputType
  }

  export type GetEmulatorStatusAggregateType<T extends EmulatorStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorStatus[P]>
      : GetScalarType<T[P], AggregateEmulatorStatus[P]>
  }




  export type EmulatorStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorStatusWhereInput
    orderBy?: EmulatorStatusOrderByWithAggregationInput | EmulatorStatusOrderByWithAggregationInput[]
    by: EmulatorStatusScalarFieldEnum[] | EmulatorStatusScalarFieldEnum
    having?: EmulatorStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorStatusCountAggregateInputType | true
    _avg?: EmulatorStatusAvgAggregateInputType
    _sum?: EmulatorStatusSumAggregateInputType
    _min?: EmulatorStatusMinAggregateInputType
    _max?: EmulatorStatusMaxAggregateInputType
  }

  export type EmulatorStatusGroupByOutputType = {
    id: number
    status: number
    usersOnline: number
    roomsLoaded: number
    stamp: number
    userpeak: number
    _count: EmulatorStatusCountAggregateOutputType | null
    _avg: EmulatorStatusAvgAggregateOutputType | null
    _sum: EmulatorStatusSumAggregateOutputType | null
    _min: EmulatorStatusMinAggregateOutputType | null
    _max: EmulatorStatusMaxAggregateOutputType | null
  }

  type GetEmulatorStatusGroupByPayload<T extends EmulatorStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorStatusGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorStatusGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    usersOnline?: boolean
    roomsLoaded?: boolean
    stamp?: boolean
    userpeak?: boolean
  }, ExtArgs["result"]["emulatorStatus"]>

  export type EmulatorStatusSelectScalar = {
    id?: boolean
    status?: boolean
    usersOnline?: boolean
    roomsLoaded?: boolean
    stamp?: boolean
    userpeak?: boolean
  }


  export type $EmulatorStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: number
      usersOnline: number
      roomsLoaded: number
      stamp: number
      userpeak: number
    }, ExtArgs["result"]["emulatorStatus"]>
    composites: {}
  }


  type EmulatorStatusGetPayload<S extends boolean | null | undefined | EmulatorStatusDefaultArgs> = $Result.GetResult<Prisma.$EmulatorStatusPayload, S>

  type EmulatorStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorStatusCountAggregateInputType | true
    }

  export interface EmulatorStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorStatus'], meta: { name: 'EmulatorStatus' } }
    /**
     * Find zero or one EmulatorStatus that matches the filter.
     * @param {EmulatorStatusFindUniqueArgs} args - Arguments to find a EmulatorStatus
     * @example
     * // Get one EmulatorStatus
     * const emulatorStatus = await prisma.emulatorStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorStatusFindUniqueOrThrowArgs} args - Arguments to find a EmulatorStatus
     * @example
     * // Get one EmulatorStatus
     * const emulatorStatus = await prisma.emulatorStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusFindFirstArgs} args - Arguments to find a EmulatorStatus
     * @example
     * // Get one EmulatorStatus
     * const emulatorStatus = await prisma.emulatorStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatusFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusFindFirstOrThrowArgs} args - Arguments to find a EmulatorStatus
     * @example
     * // Get one EmulatorStatus
     * const emulatorStatus = await prisma.emulatorStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorStatuses
     * const emulatorStatuses = await prisma.emulatorStatus.findMany()
     * 
     * // Get first 10 EmulatorStatuses
     * const emulatorStatuses = await prisma.emulatorStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorStatusWithIdOnly = await prisma.emulatorStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorStatus.
     * @param {EmulatorStatusCreateArgs} args - Arguments to create a EmulatorStatus.
     * @example
     * // Create one EmulatorStatus
     * const EmulatorStatus = await prisma.emulatorStatus.create({
     *   data: {
     *     // ... data to create a EmulatorStatus
     *   }
     * })
     * 
    **/
    create<T extends EmulatorStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatusCreateArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorStatuses.
     *     @param {EmulatorStatusCreateManyArgs} args - Arguments to create many EmulatorStatuses.
     *     @example
     *     // Create many EmulatorStatuses
     *     const emulatorStatus = await prisma.emulatorStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorStatus.
     * @param {EmulatorStatusDeleteArgs} args - Arguments to delete one EmulatorStatus.
     * @example
     * // Delete one EmulatorStatus
     * const EmulatorStatus = await prisma.emulatorStatus.delete({
     *   where: {
     *     // ... filter to delete one EmulatorStatus
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatusDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorStatus.
     * @param {EmulatorStatusUpdateArgs} args - Arguments to update one EmulatorStatus.
     * @example
     * // Update one EmulatorStatus
     * const emulatorStatus = await prisma.emulatorStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatusUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorStatuses.
     * @param {EmulatorStatusDeleteManyArgs} args - Arguments to filter EmulatorStatuses to delete.
     * @example
     * // Delete a few EmulatorStatuses
     * const { count } = await prisma.emulatorStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorStatuses
     * const emulatorStatus = await prisma.emulatorStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorStatus.
     * @param {EmulatorStatusUpsertArgs} args - Arguments to update or create a EmulatorStatus.
     * @example
     * // Update or create a EmulatorStatus
     * const emulatorStatus = await prisma.emulatorStatus.upsert({
     *   create: {
     *     // ... data to create a EmulatorStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorStatus we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorStatusUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorStatusClient<$Result.GetResult<Prisma.$EmulatorStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusCountArgs} args - Arguments to filter EmulatorStatuses to count.
     * @example
     * // Count the number of EmulatorStatuses
     * const count = await prisma.emulatorStatus.count({
     *   where: {
     *     // ... the filter for the EmulatorStatuses we want to count
     *   }
     * })
    **/
    count<T extends EmulatorStatusCountArgs>(
      args?: Subset<T, EmulatorStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorStatusAggregateArgs>(args: Subset<T, EmulatorStatusAggregateArgs>): Prisma.PrismaPromise<GetEmulatorStatusAggregateType<T>>

    /**
     * Group by EmulatorStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorStatusGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorStatus model
   */
  readonly fields: EmulatorStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorStatus model
   */ 
  interface EmulatorStatusFieldRefs {
    readonly id: FieldRef<"EmulatorStatus", 'Int'>
    readonly status: FieldRef<"EmulatorStatus", 'Int'>
    readonly usersOnline: FieldRef<"EmulatorStatus", 'Int'>
    readonly roomsLoaded: FieldRef<"EmulatorStatus", 'Int'>
    readonly stamp: FieldRef<"EmulatorStatus", 'Int'>
    readonly userpeak: FieldRef<"EmulatorStatus", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorStatus findUnique
   */
  export type EmulatorStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStatus to fetch.
     */
    where: EmulatorStatusWhereUniqueInput
  }


  /**
   * EmulatorStatus findUniqueOrThrow
   */
  export type EmulatorStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStatus to fetch.
     */
    where: EmulatorStatusWhereUniqueInput
  }


  /**
   * EmulatorStatus findFirst
   */
  export type EmulatorStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStatus to fetch.
     */
    where?: EmulatorStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStatuses to fetch.
     */
    orderBy?: EmulatorStatusOrderByWithRelationInput | EmulatorStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorStatuses.
     */
    cursor?: EmulatorStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorStatuses.
     */
    distinct?: EmulatorStatusScalarFieldEnum | EmulatorStatusScalarFieldEnum[]
  }


  /**
   * EmulatorStatus findFirstOrThrow
   */
  export type EmulatorStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStatus to fetch.
     */
    where?: EmulatorStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStatuses to fetch.
     */
    orderBy?: EmulatorStatusOrderByWithRelationInput | EmulatorStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorStatuses.
     */
    cursor?: EmulatorStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorStatuses.
     */
    distinct?: EmulatorStatusScalarFieldEnum | EmulatorStatusScalarFieldEnum[]
  }


  /**
   * EmulatorStatus findMany
   */
  export type EmulatorStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorStatuses to fetch.
     */
    where?: EmulatorStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorStatuses to fetch.
     */
    orderBy?: EmulatorStatusOrderByWithRelationInput | EmulatorStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorStatuses.
     */
    cursor?: EmulatorStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorStatuses.
     */
    skip?: number
    distinct?: EmulatorStatusScalarFieldEnum | EmulatorStatusScalarFieldEnum[]
  }


  /**
   * EmulatorStatus create
   */
  export type EmulatorStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorStatus.
     */
    data: XOR<EmulatorStatusCreateInput, EmulatorStatusUncheckedCreateInput>
  }


  /**
   * EmulatorStatus createMany
   */
  export type EmulatorStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorStatuses.
     */
    data: EmulatorStatusCreateManyInput | EmulatorStatusCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorStatus update
   */
  export type EmulatorStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorStatus.
     */
    data: XOR<EmulatorStatusUpdateInput, EmulatorStatusUncheckedUpdateInput>
    /**
     * Choose, which EmulatorStatus to update.
     */
    where: EmulatorStatusWhereUniqueInput
  }


  /**
   * EmulatorStatus updateMany
   */
  export type EmulatorStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorStatuses.
     */
    data: XOR<EmulatorStatusUpdateManyMutationInput, EmulatorStatusUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorStatuses to update
     */
    where?: EmulatorStatusWhereInput
  }


  /**
   * EmulatorStatus upsert
   */
  export type EmulatorStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorStatus to update in case it exists.
     */
    where: EmulatorStatusWhereUniqueInput
    /**
     * In case the EmulatorStatus found by the `where` argument doesn't exist, create a new EmulatorStatus with this data.
     */
    create: XOR<EmulatorStatusCreateInput, EmulatorStatusUncheckedCreateInput>
    /**
     * In case the EmulatorStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorStatusUpdateInput, EmulatorStatusUncheckedUpdateInput>
  }


  /**
   * EmulatorStatus delete
   */
  export type EmulatorStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
    /**
     * Filter which EmulatorStatus to delete.
     */
    where: EmulatorStatusWhereUniqueInput
  }


  /**
   * EmulatorStatus deleteMany
   */
  export type EmulatorStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorStatuses to delete
     */
    where?: EmulatorStatusWhereInput
  }


  /**
   * EmulatorStatus without action
   */
  export type EmulatorStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorStatus
     */
    select?: EmulatorStatusSelect<ExtArgs> | null
  }



  /**
   * Model EmulatorText
   */

  export type AggregateEmulatorText = {
    _count: EmulatorTextCountAggregateOutputType | null
    _avg: EmulatorTextAvgAggregateOutputType | null
    _sum: EmulatorTextSumAggregateOutputType | null
    _min: EmulatorTextMinAggregateOutputType | null
    _max: EmulatorTextMaxAggregateOutputType | null
  }

  export type EmulatorTextAvgAggregateOutputType = {
    id: number | null
  }

  export type EmulatorTextSumAggregateOutputType = {
    id: number | null
  }

  export type EmulatorTextMinAggregateOutputType = {
    id: number | null
    identifiant: string | null
    valueFr: string | null
    valueEn: string | null
    valueBr: string | null
  }

  export type EmulatorTextMaxAggregateOutputType = {
    id: number | null
    identifiant: string | null
    valueFr: string | null
    valueEn: string | null
    valueBr: string | null
  }

  export type EmulatorTextCountAggregateOutputType = {
    id: number
    identifiant: number
    valueFr: number
    valueEn: number
    valueBr: number
    _all: number
  }


  export type EmulatorTextAvgAggregateInputType = {
    id?: true
  }

  export type EmulatorTextSumAggregateInputType = {
    id?: true
  }

  export type EmulatorTextMinAggregateInputType = {
    id?: true
    identifiant?: true
    valueFr?: true
    valueEn?: true
    valueBr?: true
  }

  export type EmulatorTextMaxAggregateInputType = {
    id?: true
    identifiant?: true
    valueFr?: true
    valueEn?: true
    valueBr?: true
  }

  export type EmulatorTextCountAggregateInputType = {
    id?: true
    identifiant?: true
    valueFr?: true
    valueEn?: true
    valueBr?: true
    _all?: true
  }

  export type EmulatorTextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorText to aggregate.
     */
    where?: EmulatorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorTexts to fetch.
     */
    orderBy?: EmulatorTextOrderByWithRelationInput | EmulatorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmulatorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmulatorTexts
    **/
    _count?: true | EmulatorTextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmulatorTextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmulatorTextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmulatorTextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmulatorTextMaxAggregateInputType
  }

  export type GetEmulatorTextAggregateType<T extends EmulatorTextAggregateArgs> = {
        [P in keyof T & keyof AggregateEmulatorText]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmulatorText[P]>
      : GetScalarType<T[P], AggregateEmulatorText[P]>
  }




  export type EmulatorTextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmulatorTextWhereInput
    orderBy?: EmulatorTextOrderByWithAggregationInput | EmulatorTextOrderByWithAggregationInput[]
    by: EmulatorTextScalarFieldEnum[] | EmulatorTextScalarFieldEnum
    having?: EmulatorTextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmulatorTextCountAggregateInputType | true
    _avg?: EmulatorTextAvgAggregateInputType
    _sum?: EmulatorTextSumAggregateInputType
    _min?: EmulatorTextMinAggregateInputType
    _max?: EmulatorTextMaxAggregateInputType
  }

  export type EmulatorTextGroupByOutputType = {
    id: number
    identifiant: string
    valueFr: string | null
    valueEn: string | null
    valueBr: string | null
    _count: EmulatorTextCountAggregateOutputType | null
    _avg: EmulatorTextAvgAggregateOutputType | null
    _sum: EmulatorTextSumAggregateOutputType | null
    _min: EmulatorTextMinAggregateOutputType | null
    _max: EmulatorTextMaxAggregateOutputType | null
  }

  type GetEmulatorTextGroupByPayload<T extends EmulatorTextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmulatorTextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmulatorTextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmulatorTextGroupByOutputType[P]>
            : GetScalarType<T[P], EmulatorTextGroupByOutputType[P]>
        }
      >
    >


  export type EmulatorTextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifiant?: boolean
    valueFr?: boolean
    valueEn?: boolean
    valueBr?: boolean
  }, ExtArgs["result"]["emulatorText"]>

  export type EmulatorTextSelectScalar = {
    id?: boolean
    identifiant?: boolean
    valueFr?: boolean
    valueEn?: boolean
    valueBr?: boolean
  }


  export type $EmulatorTextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmulatorText"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      identifiant: string
      valueFr: string | null
      valueEn: string | null
      valueBr: string | null
    }, ExtArgs["result"]["emulatorText"]>
    composites: {}
  }


  type EmulatorTextGetPayload<S extends boolean | null | undefined | EmulatorTextDefaultArgs> = $Result.GetResult<Prisma.$EmulatorTextPayload, S>

  type EmulatorTextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmulatorTextFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmulatorTextCountAggregateInputType | true
    }

  export interface EmulatorTextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmulatorText'], meta: { name: 'EmulatorText' } }
    /**
     * Find zero or one EmulatorText that matches the filter.
     * @param {EmulatorTextFindUniqueArgs} args - Arguments to find a EmulatorText
     * @example
     * // Get one EmulatorText
     * const emulatorText = await prisma.emulatorText.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmulatorTextFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorTextFindUniqueArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmulatorText that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmulatorTextFindUniqueOrThrowArgs} args - Arguments to find a EmulatorText
     * @example
     * // Get one EmulatorText
     * const emulatorText = await prisma.emulatorText.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmulatorTextFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorTextFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmulatorText that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextFindFirstArgs} args - Arguments to find a EmulatorText
     * @example
     * // Get one EmulatorText
     * const emulatorText = await prisma.emulatorText.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmulatorTextFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorTextFindFirstArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmulatorText that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextFindFirstOrThrowArgs} args - Arguments to find a EmulatorText
     * @example
     * // Get one EmulatorText
     * const emulatorText = await prisma.emulatorText.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmulatorTextFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorTextFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmulatorTexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmulatorTexts
     * const emulatorTexts = await prisma.emulatorText.findMany()
     * 
     * // Get first 10 EmulatorTexts
     * const emulatorTexts = await prisma.emulatorText.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emulatorTextWithIdOnly = await prisma.emulatorText.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmulatorTextFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorTextFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmulatorText.
     * @param {EmulatorTextCreateArgs} args - Arguments to create a EmulatorText.
     * @example
     * // Create one EmulatorText
     * const EmulatorText = await prisma.emulatorText.create({
     *   data: {
     *     // ... data to create a EmulatorText
     *   }
     * })
     * 
    **/
    create<T extends EmulatorTextCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorTextCreateArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmulatorTexts.
     *     @param {EmulatorTextCreateManyArgs} args - Arguments to create many EmulatorTexts.
     *     @example
     *     // Create many EmulatorTexts
     *     const emulatorText = await prisma.emulatorText.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmulatorTextCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorTextCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmulatorText.
     * @param {EmulatorTextDeleteArgs} args - Arguments to delete one EmulatorText.
     * @example
     * // Delete one EmulatorText
     * const EmulatorText = await prisma.emulatorText.delete({
     *   where: {
     *     // ... filter to delete one EmulatorText
     *   }
     * })
     * 
    **/
    delete<T extends EmulatorTextDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorTextDeleteArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmulatorText.
     * @param {EmulatorTextUpdateArgs} args - Arguments to update one EmulatorText.
     * @example
     * // Update one EmulatorText
     * const emulatorText = await prisma.emulatorText.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmulatorTextUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorTextUpdateArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmulatorTexts.
     * @param {EmulatorTextDeleteManyArgs} args - Arguments to filter EmulatorTexts to delete.
     * @example
     * // Delete a few EmulatorTexts
     * const { count } = await prisma.emulatorText.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmulatorTextDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmulatorTextDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmulatorTexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmulatorTexts
     * const emulatorText = await prisma.emulatorText.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmulatorTextUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorTextUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmulatorText.
     * @param {EmulatorTextUpsertArgs} args - Arguments to update or create a EmulatorText.
     * @example
     * // Update or create a EmulatorText
     * const emulatorText = await prisma.emulatorText.upsert({
     *   create: {
     *     // ... data to create a EmulatorText
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmulatorText we want to update
     *   }
     * })
    **/
    upsert<T extends EmulatorTextUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmulatorTextUpsertArgs<ExtArgs>>
    ): Prisma__EmulatorTextClient<$Result.GetResult<Prisma.$EmulatorTextPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmulatorTexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextCountArgs} args - Arguments to filter EmulatorTexts to count.
     * @example
     * // Count the number of EmulatorTexts
     * const count = await prisma.emulatorText.count({
     *   where: {
     *     // ... the filter for the EmulatorTexts we want to count
     *   }
     * })
    **/
    count<T extends EmulatorTextCountArgs>(
      args?: Subset<T, EmulatorTextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmulatorTextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmulatorText.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmulatorTextAggregateArgs>(args: Subset<T, EmulatorTextAggregateArgs>): Prisma.PrismaPromise<GetEmulatorTextAggregateType<T>>

    /**
     * Group by EmulatorText.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmulatorTextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmulatorTextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmulatorTextGroupByArgs['orderBy'] }
        : { orderBy?: EmulatorTextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmulatorTextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmulatorTextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmulatorText model
   */
  readonly fields: EmulatorTextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmulatorText.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmulatorTextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmulatorText model
   */ 
  interface EmulatorTextFieldRefs {
    readonly id: FieldRef<"EmulatorText", 'Int'>
    readonly identifiant: FieldRef<"EmulatorText", 'String'>
    readonly valueFr: FieldRef<"EmulatorText", 'String'>
    readonly valueEn: FieldRef<"EmulatorText", 'String'>
    readonly valueBr: FieldRef<"EmulatorText", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmulatorText findUnique
   */
  export type EmulatorTextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorText to fetch.
     */
    where: EmulatorTextWhereUniqueInput
  }


  /**
   * EmulatorText findUniqueOrThrow
   */
  export type EmulatorTextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorText to fetch.
     */
    where: EmulatorTextWhereUniqueInput
  }


  /**
   * EmulatorText findFirst
   */
  export type EmulatorTextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorText to fetch.
     */
    where?: EmulatorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorTexts to fetch.
     */
    orderBy?: EmulatorTextOrderByWithRelationInput | EmulatorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorTexts.
     */
    cursor?: EmulatorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorTexts.
     */
    distinct?: EmulatorTextScalarFieldEnum | EmulatorTextScalarFieldEnum[]
  }


  /**
   * EmulatorText findFirstOrThrow
   */
  export type EmulatorTextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorText to fetch.
     */
    where?: EmulatorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorTexts to fetch.
     */
    orderBy?: EmulatorTextOrderByWithRelationInput | EmulatorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmulatorTexts.
     */
    cursor?: EmulatorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmulatorTexts.
     */
    distinct?: EmulatorTextScalarFieldEnum | EmulatorTextScalarFieldEnum[]
  }


  /**
   * EmulatorText findMany
   */
  export type EmulatorTextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * Filter, which EmulatorTexts to fetch.
     */
    where?: EmulatorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmulatorTexts to fetch.
     */
    orderBy?: EmulatorTextOrderByWithRelationInput | EmulatorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmulatorTexts.
     */
    cursor?: EmulatorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmulatorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmulatorTexts.
     */
    skip?: number
    distinct?: EmulatorTextScalarFieldEnum | EmulatorTextScalarFieldEnum[]
  }


  /**
   * EmulatorText create
   */
  export type EmulatorTextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * The data needed to create a EmulatorText.
     */
    data: XOR<EmulatorTextCreateInput, EmulatorTextUncheckedCreateInput>
  }


  /**
   * EmulatorText createMany
   */
  export type EmulatorTextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmulatorTexts.
     */
    data: EmulatorTextCreateManyInput | EmulatorTextCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmulatorText update
   */
  export type EmulatorTextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * The data needed to update a EmulatorText.
     */
    data: XOR<EmulatorTextUpdateInput, EmulatorTextUncheckedUpdateInput>
    /**
     * Choose, which EmulatorText to update.
     */
    where: EmulatorTextWhereUniqueInput
  }


  /**
   * EmulatorText updateMany
   */
  export type EmulatorTextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmulatorTexts.
     */
    data: XOR<EmulatorTextUpdateManyMutationInput, EmulatorTextUncheckedUpdateManyInput>
    /**
     * Filter which EmulatorTexts to update
     */
    where?: EmulatorTextWhereInput
  }


  /**
   * EmulatorText upsert
   */
  export type EmulatorTextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * The filter to search for the EmulatorText to update in case it exists.
     */
    where: EmulatorTextWhereUniqueInput
    /**
     * In case the EmulatorText found by the `where` argument doesn't exist, create a new EmulatorText with this data.
     */
    create: XOR<EmulatorTextCreateInput, EmulatorTextUncheckedCreateInput>
    /**
     * In case the EmulatorText was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmulatorTextUpdateInput, EmulatorTextUncheckedUpdateInput>
  }


  /**
   * EmulatorText delete
   */
  export type EmulatorTextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
    /**
     * Filter which EmulatorText to delete.
     */
    where: EmulatorTextWhereUniqueInput
  }


  /**
   * EmulatorText deleteMany
   */
  export type EmulatorTextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmulatorTexts to delete
     */
    where?: EmulatorTextWhereInput
  }


  /**
   * EmulatorText without action
   */
  export type EmulatorTextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmulatorText
     */
    select?: EmulatorTextSelect<ExtArgs> | null
  }



  /**
   * Model Guild
   */

  export type AggregateGuild = {
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  export type GuildAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    created: number | null
    roomId: number | null
    state: number | null
    colour1: number | null
    colour2: number | null
  }

  export type GuildSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    created: number | null
    roomId: number | null
    state: number | null
    colour1: number | null
    colour2: number | null
  }

  export type GuildMinAggregateOutputType = {
    id: number | null
    name: string | null
    desc: string | null
    badge: string | null
    ownerId: number | null
    created: number | null
    roomId: number | null
    state: number | null
    colour1: number | null
    colour2: number | null
    admindeco: boolean | null
    hasForum: boolean | null
  }

  export type GuildMaxAggregateOutputType = {
    id: number | null
    name: string | null
    desc: string | null
    badge: string | null
    ownerId: number | null
    created: number | null
    roomId: number | null
    state: number | null
    colour1: number | null
    colour2: number | null
    admindeco: boolean | null
    hasForum: boolean | null
  }

  export type GuildCountAggregateOutputType = {
    id: number
    name: number
    desc: number
    badge: number
    ownerId: number
    created: number
    roomId: number
    state: number
    colour1: number
    colour2: number
    admindeco: number
    hasForum: number
    _all: number
  }


  export type GuildAvgAggregateInputType = {
    id?: true
    ownerId?: true
    created?: true
    roomId?: true
    state?: true
    colour1?: true
    colour2?: true
  }

  export type GuildSumAggregateInputType = {
    id?: true
    ownerId?: true
    created?: true
    roomId?: true
    state?: true
    colour1?: true
    colour2?: true
  }

  export type GuildMinAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    badge?: true
    ownerId?: true
    created?: true
    roomId?: true
    state?: true
    colour1?: true
    colour2?: true
    admindeco?: true
    hasForum?: true
  }

  export type GuildMaxAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    badge?: true
    ownerId?: true
    created?: true
    roomId?: true
    state?: true
    colour1?: true
    colour2?: true
    admindeco?: true
    hasForum?: true
  }

  export type GuildCountAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    badge?: true
    ownerId?: true
    created?: true
    roomId?: true
    state?: true
    colour1?: true
    colour2?: true
    admindeco?: true
    hasForum?: true
    _all?: true
  }

  export type GuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guild to aggregate.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guilds
    **/
    _count?: true | GuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMaxAggregateInputType
  }

  export type GetGuildAggregateType<T extends GuildAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild[P]>
      : GetScalarType<T[P], AggregateGuild[P]>
  }




  export type GuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildWhereInput
    orderBy?: GuildOrderByWithAggregationInput | GuildOrderByWithAggregationInput[]
    by: GuildScalarFieldEnum[] | GuildScalarFieldEnum
    having?: GuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildCountAggregateInputType | true
    _avg?: GuildAvgAggregateInputType
    _sum?: GuildSumAggregateInputType
    _min?: GuildMinAggregateInputType
    _max?: GuildMaxAggregateInputType
  }

  export type GuildGroupByOutputType = {
    id: number
    name: string
    desc: string
    badge: string
    ownerId: number
    created: number
    roomId: number
    state: number
    colour1: number
    colour2: number
    admindeco: boolean
    hasForum: boolean
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  type GetGuildGroupByPayload<T extends GuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildGroupByOutputType[P]>
            : GetScalarType<T[P], GuildGroupByOutputType[P]>
        }
      >
    >


  export type GuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    desc?: boolean
    badge?: boolean
    ownerId?: boolean
    created?: boolean
    roomId?: boolean
    state?: boolean
    colour1?: boolean
    colour2?: boolean
    admindeco?: boolean
    hasForum?: boolean
  }, ExtArgs["result"]["guild"]>

  export type GuildSelectScalar = {
    id?: boolean
    name?: boolean
    desc?: boolean
    badge?: boolean
    ownerId?: boolean
    created?: boolean
    roomId?: boolean
    state?: boolean
    colour1?: boolean
    colour2?: boolean
    admindeco?: boolean
    hasForum?: boolean
  }


  export type $GuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guild"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      desc: string
      badge: string
      ownerId: number
      created: number
      roomId: number
      state: number
      colour1: number
      colour2: number
      admindeco: boolean
      hasForum: boolean
    }, ExtArgs["result"]["guild"]>
    composites: {}
  }


  type GuildGetPayload<S extends boolean | null | undefined | GuildDefaultArgs> = $Result.GetResult<Prisma.$GuildPayload, S>

  type GuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildCountAggregateInputType | true
    }

  export interface GuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guild'], meta: { name: 'Guild' } }
    /**
     * Find zero or one Guild that matches the filter.
     * @param {GuildFindUniqueArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GuildFindUniqueArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Guild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildFindUniqueOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Guild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindFirstArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Guild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guild.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildWithIdOnly = await prisma.guild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Guild.
     * @param {GuildCreateArgs} args - Arguments to create a Guild.
     * @example
     * // Create one Guild
     * const Guild = await prisma.guild.create({
     *   data: {
     *     // ... data to create a Guild
     *   }
     * })
     * 
    **/
    create<T extends GuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildCreateArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Guilds.
     *     @param {GuildCreateManyArgs} args - Arguments to create many Guilds.
     *     @example
     *     // Create many Guilds
     *     const guild = await prisma.guild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild.
     * @param {GuildDeleteArgs} args - Arguments to delete one Guild.
     * @example
     * // Delete one Guild
     * const Guild = await prisma.guild.delete({
     *   where: {
     *     // ... filter to delete one Guild
     *   }
     * })
     * 
    **/
    delete<T extends GuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GuildDeleteArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Guild.
     * @param {GuildUpdateArgs} args - Arguments to update one Guild.
     * @example
     * // Update one Guild
     * const guild = await prisma.guild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildUpdateArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Guilds.
     * @param {GuildDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild.
     * @param {GuildUpsertArgs} args - Arguments to update or create a Guild.
     * @example
     * // Update or create a Guild
     * const guild = await prisma.guild.upsert({
     *   create: {
     *     // ... data to create a Guild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild we want to update
     *   }
     * })
    **/
    upsert<T extends GuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GuildUpsertArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guild.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends GuildCountArgs>(
      args?: Subset<T, GuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildAggregateArgs>(args: Subset<T, GuildAggregateArgs>): Prisma.PrismaPromise<GetGuildAggregateType<T>>

    /**
     * Group by Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildGroupByArgs['orderBy'] }
        : { orderBy?: GuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guild model
   */
  readonly fields: GuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Guild model
   */ 
  interface GuildFieldRefs {
    readonly id: FieldRef<"Guild", 'Int'>
    readonly name: FieldRef<"Guild", 'String'>
    readonly desc: FieldRef<"Guild", 'String'>
    readonly badge: FieldRef<"Guild", 'String'>
    readonly ownerId: FieldRef<"Guild", 'Int'>
    readonly created: FieldRef<"Guild", 'Int'>
    readonly roomId: FieldRef<"Guild", 'Int'>
    readonly state: FieldRef<"Guild", 'Int'>
    readonly colour1: FieldRef<"Guild", 'Int'>
    readonly colour2: FieldRef<"Guild", 'Int'>
    readonly admindeco: FieldRef<"Guild", 'Boolean'>
    readonly hasForum: FieldRef<"Guild", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Guild findUnique
   */
  export type GuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild findUniqueOrThrow
   */
  export type GuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild findFirst
   */
  export type GuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }


  /**
   * Guild findFirstOrThrow
   */
  export type GuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }


  /**
   * Guild findMany
   */
  export type GuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }


  /**
   * Guild create
   */
  export type GuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * The data needed to create a Guild.
     */
    data: XOR<GuildCreateInput, GuildUncheckedCreateInput>
  }


  /**
   * Guild createMany
   */
  export type GuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guilds.
     */
    data: GuildCreateManyInput | GuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Guild update
   */
  export type GuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * The data needed to update a Guild.
     */
    data: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
    /**
     * Choose, which Guild to update.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild updateMany
   */
  export type GuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guilds.
     */
    data: XOR<GuildUpdateManyMutationInput, GuildUncheckedUpdateManyInput>
    /**
     * Filter which Guilds to update
     */
    where?: GuildWhereInput
  }


  /**
   * Guild upsert
   */
  export type GuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * The filter to search for the Guild to update in case it exists.
     */
    where: GuildWhereUniqueInput
    /**
     * In case the Guild found by the `where` argument doesn't exist, create a new Guild with this data.
     */
    create: XOR<GuildCreateInput, GuildUncheckedCreateInput>
    /**
     * In case the Guild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
  }


  /**
   * Guild delete
   */
  export type GuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter which Guild to delete.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild deleteMany
   */
  export type GuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guilds to delete
     */
    where?: GuildWhereInput
  }


  /**
   * Guild without action
   */
  export type GuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
  }



  /**
   * Model GuildItem
   */

  export type AggregateGuildItem = {
    _count: GuildItemCountAggregateOutputType | null
    _avg: GuildItemAvgAggregateOutputType | null
    _sum: GuildItemSumAggregateOutputType | null
    _min: GuildItemMinAggregateOutputType | null
    _max: GuildItemMaxAggregateOutputType | null
  }

  export type GuildItemAvgAggregateOutputType = {
    id: number | null
  }

  export type GuildItemSumAggregateOutputType = {
    id: number | null
  }

  export type GuildItemMinAggregateOutputType = {
    id: number | null
    type: $Enums.GuildItemType | null
    firstvalue: string | null
    secondvalue: string | null
    enabled: boolean | null
  }

  export type GuildItemMaxAggregateOutputType = {
    id: number | null
    type: $Enums.GuildItemType | null
    firstvalue: string | null
    secondvalue: string | null
    enabled: boolean | null
  }

  export type GuildItemCountAggregateOutputType = {
    id: number
    type: number
    firstvalue: number
    secondvalue: number
    enabled: number
    _all: number
  }


  export type GuildItemAvgAggregateInputType = {
    id?: true
  }

  export type GuildItemSumAggregateInputType = {
    id?: true
  }

  export type GuildItemMinAggregateInputType = {
    id?: true
    type?: true
    firstvalue?: true
    secondvalue?: true
    enabled?: true
  }

  export type GuildItemMaxAggregateInputType = {
    id?: true
    type?: true
    firstvalue?: true
    secondvalue?: true
    enabled?: true
  }

  export type GuildItemCountAggregateInputType = {
    id?: true
    type?: true
    firstvalue?: true
    secondvalue?: true
    enabled?: true
    _all?: true
  }

  export type GuildItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildItem to aggregate.
     */
    where?: GuildItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildItems to fetch.
     */
    orderBy?: GuildItemOrderByWithRelationInput | GuildItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildItems
    **/
    _count?: true | GuildItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildItemMaxAggregateInputType
  }

  export type GetGuildItemAggregateType<T extends GuildItemAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildItem[P]>
      : GetScalarType<T[P], AggregateGuildItem[P]>
  }




  export type GuildItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildItemWhereInput
    orderBy?: GuildItemOrderByWithAggregationInput | GuildItemOrderByWithAggregationInput[]
    by: GuildItemScalarFieldEnum[] | GuildItemScalarFieldEnum
    having?: GuildItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildItemCountAggregateInputType | true
    _avg?: GuildItemAvgAggregateInputType
    _sum?: GuildItemSumAggregateInputType
    _min?: GuildItemMinAggregateInputType
    _max?: GuildItemMaxAggregateInputType
  }

  export type GuildItemGroupByOutputType = {
    id: number
    type: $Enums.GuildItemType
    firstvalue: string
    secondvalue: string
    enabled: boolean
    _count: GuildItemCountAggregateOutputType | null
    _avg: GuildItemAvgAggregateOutputType | null
    _sum: GuildItemSumAggregateOutputType | null
    _min: GuildItemMinAggregateOutputType | null
    _max: GuildItemMaxAggregateOutputType | null
  }

  type GetGuildItemGroupByPayload<T extends GuildItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildItemGroupByOutputType[P]>
            : GetScalarType<T[P], GuildItemGroupByOutputType[P]>
        }
      >
    >


  export type GuildItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    firstvalue?: boolean
    secondvalue?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["guildItem"]>

  export type GuildItemSelectScalar = {
    id?: boolean
    type?: boolean
    firstvalue?: boolean
    secondvalue?: boolean
    enabled?: boolean
  }


  export type $GuildItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.GuildItemType
      firstvalue: string
      secondvalue: string
      enabled: boolean
    }, ExtArgs["result"]["guildItem"]>
    composites: {}
  }


  type GuildItemGetPayload<S extends boolean | null | undefined | GuildItemDefaultArgs> = $Result.GetResult<Prisma.$GuildItemPayload, S>

  type GuildItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildItemCountAggregateInputType | true
    }

  export interface GuildItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildItem'], meta: { name: 'GuildItem' } }
    /**
     * Find zero or one GuildItem that matches the filter.
     * @param {GuildItemFindUniqueArgs} args - Arguments to find a GuildItem
     * @example
     * // Get one GuildItem
     * const guildItem = await prisma.guildItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GuildItemFindUniqueArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GuildItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildItemFindUniqueOrThrowArgs} args - Arguments to find a GuildItem
     * @example
     * // Get one GuildItem
     * const guildItem = await prisma.guildItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GuildItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemFindFirstArgs} args - Arguments to find a GuildItem
     * @example
     * // Get one GuildItem
     * const guildItem = await prisma.guildItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildItemFindFirstArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GuildItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemFindFirstOrThrowArgs} args - Arguments to find a GuildItem
     * @example
     * // Get one GuildItem
     * const guildItem = await prisma.guildItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GuildItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildItems
     * const guildItems = await prisma.guildItem.findMany()
     * 
     * // Get first 10 GuildItems
     * const guildItems = await prisma.guildItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildItemWithIdOnly = await prisma.guildItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GuildItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GuildItem.
     * @param {GuildItemCreateArgs} args - Arguments to create a GuildItem.
     * @example
     * // Create one GuildItem
     * const GuildItem = await prisma.guildItem.create({
     *   data: {
     *     // ... data to create a GuildItem
     *   }
     * })
     * 
    **/
    create<T extends GuildItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildItemCreateArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GuildItems.
     *     @param {GuildItemCreateManyArgs} args - Arguments to create many GuildItems.
     *     @example
     *     // Create many GuildItems
     *     const guildItem = await prisma.guildItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildItem.
     * @param {GuildItemDeleteArgs} args - Arguments to delete one GuildItem.
     * @example
     * // Delete one GuildItem
     * const GuildItem = await prisma.guildItem.delete({
     *   where: {
     *     // ... filter to delete one GuildItem
     *   }
     * })
     * 
    **/
    delete<T extends GuildItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GuildItemDeleteArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GuildItem.
     * @param {GuildItemUpdateArgs} args - Arguments to update one GuildItem.
     * @example
     * // Update one GuildItem
     * const guildItem = await prisma.guildItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildItemUpdateArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GuildItems.
     * @param {GuildItemDeleteManyArgs} args - Arguments to filter GuildItems to delete.
     * @example
     * // Delete a few GuildItems
     * const { count } = await prisma.guildItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildItems
     * const guildItem = await prisma.guildItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GuildItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildItem.
     * @param {GuildItemUpsertArgs} args - Arguments to update or create a GuildItem.
     * @example
     * // Update or create a GuildItem
     * const guildItem = await prisma.guildItem.upsert({
     *   create: {
     *     // ... data to create a GuildItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildItem we want to update
     *   }
     * })
    **/
    upsert<T extends GuildItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GuildItemUpsertArgs<ExtArgs>>
    ): Prisma__GuildItemClient<$Result.GetResult<Prisma.$GuildItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GuildItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemCountArgs} args - Arguments to filter GuildItems to count.
     * @example
     * // Count the number of GuildItems
     * const count = await prisma.guildItem.count({
     *   where: {
     *     // ... the filter for the GuildItems we want to count
     *   }
     * })
    **/
    count<T extends GuildItemCountArgs>(
      args?: Subset<T, GuildItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildItemAggregateArgs>(args: Subset<T, GuildItemAggregateArgs>): Prisma.PrismaPromise<GetGuildItemAggregateType<T>>

    /**
     * Group by GuildItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildItemGroupByArgs['orderBy'] }
        : { orderBy?: GuildItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildItem model
   */
  readonly fields: GuildItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GuildItem model
   */ 
  interface GuildItemFieldRefs {
    readonly id: FieldRef<"GuildItem", 'Int'>
    readonly type: FieldRef<"GuildItem", 'GuildItemType'>
    readonly firstvalue: FieldRef<"GuildItem", 'String'>
    readonly secondvalue: FieldRef<"GuildItem", 'String'>
    readonly enabled: FieldRef<"GuildItem", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * GuildItem findUnique
   */
  export type GuildItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * Filter, which GuildItem to fetch.
     */
    where: GuildItemWhereUniqueInput
  }


  /**
   * GuildItem findUniqueOrThrow
   */
  export type GuildItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * Filter, which GuildItem to fetch.
     */
    where: GuildItemWhereUniqueInput
  }


  /**
   * GuildItem findFirst
   */
  export type GuildItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * Filter, which GuildItem to fetch.
     */
    where?: GuildItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildItems to fetch.
     */
    orderBy?: GuildItemOrderByWithRelationInput | GuildItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildItems.
     */
    cursor?: GuildItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildItems.
     */
    distinct?: GuildItemScalarFieldEnum | GuildItemScalarFieldEnum[]
  }


  /**
   * GuildItem findFirstOrThrow
   */
  export type GuildItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * Filter, which GuildItem to fetch.
     */
    where?: GuildItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildItems to fetch.
     */
    orderBy?: GuildItemOrderByWithRelationInput | GuildItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildItems.
     */
    cursor?: GuildItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildItems.
     */
    distinct?: GuildItemScalarFieldEnum | GuildItemScalarFieldEnum[]
  }


  /**
   * GuildItem findMany
   */
  export type GuildItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * Filter, which GuildItems to fetch.
     */
    where?: GuildItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildItems to fetch.
     */
    orderBy?: GuildItemOrderByWithRelationInput | GuildItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildItems.
     */
    cursor?: GuildItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildItems.
     */
    skip?: number
    distinct?: GuildItemScalarFieldEnum | GuildItemScalarFieldEnum[]
  }


  /**
   * GuildItem create
   */
  export type GuildItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * The data needed to create a GuildItem.
     */
    data: XOR<GuildItemCreateInput, GuildItemUncheckedCreateInput>
  }


  /**
   * GuildItem createMany
   */
  export type GuildItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildItems.
     */
    data: GuildItemCreateManyInput | GuildItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GuildItem update
   */
  export type GuildItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * The data needed to update a GuildItem.
     */
    data: XOR<GuildItemUpdateInput, GuildItemUncheckedUpdateInput>
    /**
     * Choose, which GuildItem to update.
     */
    where: GuildItemWhereUniqueInput
  }


  /**
   * GuildItem updateMany
   */
  export type GuildItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildItems.
     */
    data: XOR<GuildItemUpdateManyMutationInput, GuildItemUncheckedUpdateManyInput>
    /**
     * Filter which GuildItems to update
     */
    where?: GuildItemWhereInput
  }


  /**
   * GuildItem upsert
   */
  export type GuildItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * The filter to search for the GuildItem to update in case it exists.
     */
    where: GuildItemWhereUniqueInput
    /**
     * In case the GuildItem found by the `where` argument doesn't exist, create a new GuildItem with this data.
     */
    create: XOR<GuildItemCreateInput, GuildItemUncheckedCreateInput>
    /**
     * In case the GuildItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildItemUpdateInput, GuildItemUncheckedUpdateInput>
  }


  /**
   * GuildItem delete
   */
  export type GuildItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
    /**
     * Filter which GuildItem to delete.
     */
    where: GuildItemWhereUniqueInput
  }


  /**
   * GuildItem deleteMany
   */
  export type GuildItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildItems to delete
     */
    where?: GuildItemWhereInput
  }


  /**
   * GuildItem without action
   */
  export type GuildItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildItem
     */
    select?: GuildItemSelect<ExtArgs> | null
  }



  /**
   * Model GuildMembership
   */

  export type AggregateGuildMembership = {
    _count: GuildMembershipCountAggregateOutputType | null
    _avg: GuildMembershipAvgAggregateOutputType | null
    _sum: GuildMembershipSumAggregateOutputType | null
    _min: GuildMembershipMinAggregateOutputType | null
    _max: GuildMembershipMaxAggregateOutputType | null
  }

  export type GuildMembershipAvgAggregateOutputType = {
    groupId: number | null
    userId: number | null
    rank: number | null
  }

  export type GuildMembershipSumAggregateOutputType = {
    groupId: number | null
    userId: number | null
    rank: number | null
  }

  export type GuildMembershipMinAggregateOutputType = {
    groupId: number | null
    userId: number | null
    rank: number | null
  }

  export type GuildMembershipMaxAggregateOutputType = {
    groupId: number | null
    userId: number | null
    rank: number | null
  }

  export type GuildMembershipCountAggregateOutputType = {
    groupId: number
    userId: number
    rank: number
    _all: number
  }


  export type GuildMembershipAvgAggregateInputType = {
    groupId?: true
    userId?: true
    rank?: true
  }

  export type GuildMembershipSumAggregateInputType = {
    groupId?: true
    userId?: true
    rank?: true
  }

  export type GuildMembershipMinAggregateInputType = {
    groupId?: true
    userId?: true
    rank?: true
  }

  export type GuildMembershipMaxAggregateInputType = {
    groupId?: true
    userId?: true
    rank?: true
  }

  export type GuildMembershipCountAggregateInputType = {
    groupId?: true
    userId?: true
    rank?: true
    _all?: true
  }

  export type GuildMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildMembership to aggregate.
     */
    where?: GuildMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMemberships to fetch.
     */
    orderBy?: GuildMembershipOrderByWithRelationInput | GuildMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildMemberships
    **/
    _count?: true | GuildMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMembershipMaxAggregateInputType
  }

  export type GetGuildMembershipAggregateType<T extends GuildMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildMembership[P]>
      : GetScalarType<T[P], AggregateGuildMembership[P]>
  }




  export type GuildMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildMembershipWhereInput
    orderBy?: GuildMembershipOrderByWithAggregationInput | GuildMembershipOrderByWithAggregationInput[]
    by: GuildMembershipScalarFieldEnum[] | GuildMembershipScalarFieldEnum
    having?: GuildMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildMembershipCountAggregateInputType | true
    _avg?: GuildMembershipAvgAggregateInputType
    _sum?: GuildMembershipSumAggregateInputType
    _min?: GuildMembershipMinAggregateInputType
    _max?: GuildMembershipMaxAggregateInputType
  }

  export type GuildMembershipGroupByOutputType = {
    groupId: number
    userId: number
    rank: number
    _count: GuildMembershipCountAggregateOutputType | null
    _avg: GuildMembershipAvgAggregateOutputType | null
    _sum: GuildMembershipSumAggregateOutputType | null
    _min: GuildMembershipMinAggregateOutputType | null
    _max: GuildMembershipMaxAggregateOutputType | null
  }

  type GetGuildMembershipGroupByPayload<T extends GuildMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], GuildMembershipGroupByOutputType[P]>
        }
      >
    >


  export type GuildMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    userId?: boolean
    rank?: boolean
  }, ExtArgs["result"]["guildMembership"]>

  export type GuildMembershipSelectScalar = {
    groupId?: boolean
    userId?: boolean
    rank?: boolean
  }


  export type $GuildMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildMembership"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      groupId: number
      userId: number
      rank: number
    }, ExtArgs["result"]["guildMembership"]>
    composites: {}
  }


  type GuildMembershipGetPayload<S extends boolean | null | undefined | GuildMembershipDefaultArgs> = $Result.GetResult<Prisma.$GuildMembershipPayload, S>

  type GuildMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildMembershipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildMembershipCountAggregateInputType | true
    }

  export interface GuildMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildMembership'], meta: { name: 'GuildMembership' } }
    /**
     * Find zero or one GuildMembership that matches the filter.
     * @param {GuildMembershipFindUniqueArgs} args - Arguments to find a GuildMembership
     * @example
     * // Get one GuildMembership
     * const guildMembership = await prisma.guildMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildMembershipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMembershipFindUniqueArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GuildMembership that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildMembershipFindUniqueOrThrowArgs} args - Arguments to find a GuildMembership
     * @example
     * // Get one GuildMembership
     * const guildMembership = await prisma.guildMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildMembershipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMembershipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GuildMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipFindFirstArgs} args - Arguments to find a GuildMembership
     * @example
     * // Get one GuildMembership
     * const guildMembership = await prisma.guildMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildMembershipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMembershipFindFirstArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GuildMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipFindFirstOrThrowArgs} args - Arguments to find a GuildMembership
     * @example
     * // Get one GuildMembership
     * const guildMembership = await prisma.guildMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildMembershipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMembershipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GuildMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildMemberships
     * const guildMemberships = await prisma.guildMembership.findMany()
     * 
     * // Get first 10 GuildMemberships
     * const guildMemberships = await prisma.guildMembership.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const guildMembershipWithGroupIdOnly = await prisma.guildMembership.findMany({ select: { groupId: true } })
     * 
    **/
    findMany<T extends GuildMembershipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMembershipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GuildMembership.
     * @param {GuildMembershipCreateArgs} args - Arguments to create a GuildMembership.
     * @example
     * // Create one GuildMembership
     * const GuildMembership = await prisma.guildMembership.create({
     *   data: {
     *     // ... data to create a GuildMembership
     *   }
     * })
     * 
    **/
    create<T extends GuildMembershipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMembershipCreateArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GuildMemberships.
     *     @param {GuildMembershipCreateManyArgs} args - Arguments to create many GuildMemberships.
     *     @example
     *     // Create many GuildMemberships
     *     const guildMembership = await prisma.guildMembership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildMembershipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMembershipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildMembership.
     * @param {GuildMembershipDeleteArgs} args - Arguments to delete one GuildMembership.
     * @example
     * // Delete one GuildMembership
     * const GuildMembership = await prisma.guildMembership.delete({
     *   where: {
     *     // ... filter to delete one GuildMembership
     *   }
     * })
     * 
    **/
    delete<T extends GuildMembershipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMembershipDeleteArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GuildMembership.
     * @param {GuildMembershipUpdateArgs} args - Arguments to update one GuildMembership.
     * @example
     * // Update one GuildMembership
     * const guildMembership = await prisma.guildMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildMembershipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMembershipUpdateArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GuildMemberships.
     * @param {GuildMembershipDeleteManyArgs} args - Arguments to filter GuildMemberships to delete.
     * @example
     * // Delete a few GuildMemberships
     * const { count } = await prisma.guildMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildMembershipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMembershipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildMemberships
     * const guildMembership = await prisma.guildMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildMembershipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMembershipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildMembership.
     * @param {GuildMembershipUpsertArgs} args - Arguments to update or create a GuildMembership.
     * @example
     * // Update or create a GuildMembership
     * const guildMembership = await prisma.guildMembership.upsert({
     *   create: {
     *     // ... data to create a GuildMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildMembership we want to update
     *   }
     * })
    **/
    upsert<T extends GuildMembershipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMembershipUpsertArgs<ExtArgs>>
    ): Prisma__GuildMembershipClient<$Result.GetResult<Prisma.$GuildMembershipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GuildMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipCountArgs} args - Arguments to filter GuildMemberships to count.
     * @example
     * // Count the number of GuildMemberships
     * const count = await prisma.guildMembership.count({
     *   where: {
     *     // ... the filter for the GuildMemberships we want to count
     *   }
     * })
    **/
    count<T extends GuildMembershipCountArgs>(
      args?: Subset<T, GuildMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildMembershipAggregateArgs>(args: Subset<T, GuildMembershipAggregateArgs>): Prisma.PrismaPromise<GetGuildMembershipAggregateType<T>>

    /**
     * Group by GuildMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildMembershipGroupByArgs['orderBy'] }
        : { orderBy?: GuildMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildMembership model
   */
  readonly fields: GuildMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GuildMembership model
   */ 
  interface GuildMembershipFieldRefs {
    readonly groupId: FieldRef<"GuildMembership", 'Int'>
    readonly userId: FieldRef<"GuildMembership", 'Int'>
    readonly rank: FieldRef<"GuildMembership", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * GuildMembership findUnique
   */
  export type GuildMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * Filter, which GuildMembership to fetch.
     */
    where: GuildMembershipWhereUniqueInput
  }


  /**
   * GuildMembership findUniqueOrThrow
   */
  export type GuildMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * Filter, which GuildMembership to fetch.
     */
    where: GuildMembershipWhereUniqueInput
  }


  /**
   * GuildMembership findFirst
   */
  export type GuildMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * Filter, which GuildMembership to fetch.
     */
    where?: GuildMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMemberships to fetch.
     */
    orderBy?: GuildMembershipOrderByWithRelationInput | GuildMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildMemberships.
     */
    cursor?: GuildMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildMemberships.
     */
    distinct?: GuildMembershipScalarFieldEnum | GuildMembershipScalarFieldEnum[]
  }


  /**
   * GuildMembership findFirstOrThrow
   */
  export type GuildMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * Filter, which GuildMembership to fetch.
     */
    where?: GuildMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMemberships to fetch.
     */
    orderBy?: GuildMembershipOrderByWithRelationInput | GuildMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildMemberships.
     */
    cursor?: GuildMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildMemberships.
     */
    distinct?: GuildMembershipScalarFieldEnum | GuildMembershipScalarFieldEnum[]
  }


  /**
   * GuildMembership findMany
   */
  export type GuildMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * Filter, which GuildMemberships to fetch.
     */
    where?: GuildMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMemberships to fetch.
     */
    orderBy?: GuildMembershipOrderByWithRelationInput | GuildMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildMemberships.
     */
    cursor?: GuildMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMemberships.
     */
    skip?: number
    distinct?: GuildMembershipScalarFieldEnum | GuildMembershipScalarFieldEnum[]
  }


  /**
   * GuildMembership create
   */
  export type GuildMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * The data needed to create a GuildMembership.
     */
    data: XOR<GuildMembershipCreateInput, GuildMembershipUncheckedCreateInput>
  }


  /**
   * GuildMembership createMany
   */
  export type GuildMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildMemberships.
     */
    data: GuildMembershipCreateManyInput | GuildMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GuildMembership update
   */
  export type GuildMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * The data needed to update a GuildMembership.
     */
    data: XOR<GuildMembershipUpdateInput, GuildMembershipUncheckedUpdateInput>
    /**
     * Choose, which GuildMembership to update.
     */
    where: GuildMembershipWhereUniqueInput
  }


  /**
   * GuildMembership updateMany
   */
  export type GuildMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildMemberships.
     */
    data: XOR<GuildMembershipUpdateManyMutationInput, GuildMembershipUncheckedUpdateManyInput>
    /**
     * Filter which GuildMemberships to update
     */
    where?: GuildMembershipWhereInput
  }


  /**
   * GuildMembership upsert
   */
  export type GuildMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * The filter to search for the GuildMembership to update in case it exists.
     */
    where: GuildMembershipWhereUniqueInput
    /**
     * In case the GuildMembership found by the `where` argument doesn't exist, create a new GuildMembership with this data.
     */
    create: XOR<GuildMembershipCreateInput, GuildMembershipUncheckedCreateInput>
    /**
     * In case the GuildMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildMembershipUpdateInput, GuildMembershipUncheckedUpdateInput>
  }


  /**
   * GuildMembership delete
   */
  export type GuildMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
    /**
     * Filter which GuildMembership to delete.
     */
    where: GuildMembershipWhereUniqueInput
  }


  /**
   * GuildMembership deleteMany
   */
  export type GuildMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildMemberships to delete
     */
    where?: GuildMembershipWhereInput
  }


  /**
   * GuildMembership without action
   */
  export type GuildMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMembership
     */
    select?: GuildMembershipSelect<ExtArgs> | null
  }



  /**
   * Model GuildRequest
   */

  export type AggregateGuildRequest = {
    _count: GuildRequestCountAggregateOutputType | null
    _avg: GuildRequestAvgAggregateOutputType | null
    _sum: GuildRequestSumAggregateOutputType | null
    _min: GuildRequestMinAggregateOutputType | null
    _max: GuildRequestMaxAggregateOutputType | null
  }

  export type GuildRequestAvgAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type GuildRequestSumAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type GuildRequestMinAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type GuildRequestMaxAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type GuildRequestCountAggregateOutputType = {
    groupId: number
    userId: number
    _all: number
  }


  export type GuildRequestAvgAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type GuildRequestSumAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type GuildRequestMinAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type GuildRequestMaxAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type GuildRequestCountAggregateInputType = {
    groupId?: true
    userId?: true
    _all?: true
  }

  export type GuildRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildRequest to aggregate.
     */
    where?: GuildRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildRequests to fetch.
     */
    orderBy?: GuildRequestOrderByWithRelationInput | GuildRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildRequests
    **/
    _count?: true | GuildRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildRequestMaxAggregateInputType
  }

  export type GetGuildRequestAggregateType<T extends GuildRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildRequest[P]>
      : GetScalarType<T[P], AggregateGuildRequest[P]>
  }




  export type GuildRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildRequestWhereInput
    orderBy?: GuildRequestOrderByWithAggregationInput | GuildRequestOrderByWithAggregationInput[]
    by: GuildRequestScalarFieldEnum[] | GuildRequestScalarFieldEnum
    having?: GuildRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildRequestCountAggregateInputType | true
    _avg?: GuildRequestAvgAggregateInputType
    _sum?: GuildRequestSumAggregateInputType
    _min?: GuildRequestMinAggregateInputType
    _max?: GuildRequestMaxAggregateInputType
  }

  export type GuildRequestGroupByOutputType = {
    groupId: number
    userId: number
    _count: GuildRequestCountAggregateOutputType | null
    _avg: GuildRequestAvgAggregateOutputType | null
    _sum: GuildRequestSumAggregateOutputType | null
    _min: GuildRequestMinAggregateOutputType | null
    _max: GuildRequestMaxAggregateOutputType | null
  }

  type GetGuildRequestGroupByPayload<T extends GuildRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildRequestGroupByOutputType[P]>
            : GetScalarType<T[P], GuildRequestGroupByOutputType[P]>
        }
      >
    >


  export type GuildRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    userId?: boolean
  }, ExtArgs["result"]["guildRequest"]>

  export type GuildRequestSelectScalar = {
    groupId?: boolean
    userId?: boolean
  }


  export type $GuildRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      groupId: number
      userId: number
    }, ExtArgs["result"]["guildRequest"]>
    composites: {}
  }


  type GuildRequestGetPayload<S extends boolean | null | undefined | GuildRequestDefaultArgs> = $Result.GetResult<Prisma.$GuildRequestPayload, S>

  type GuildRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuildRequestCountAggregateInputType | true
    }

  export interface GuildRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildRequest'], meta: { name: 'GuildRequest' } }
    /**
     * Find zero or one GuildRequest that matches the filter.
     * @param {GuildRequestFindUniqueArgs} args - Arguments to find a GuildRequest
     * @example
     * // Get one GuildRequest
     * const guildRequest = await prisma.guildRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GuildRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GuildRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildRequestFindUniqueOrThrowArgs} args - Arguments to find a GuildRequest
     * @example
     * // Get one GuildRequest
     * const guildRequest = await prisma.guildRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GuildRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestFindFirstArgs} args - Arguments to find a GuildRequest
     * @example
     * // Get one GuildRequest
     * const guildRequest = await prisma.guildRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildRequestFindFirstArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GuildRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestFindFirstOrThrowArgs} args - Arguments to find a GuildRequest
     * @example
     * // Get one GuildRequest
     * const guildRequest = await prisma.guildRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GuildRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildRequests
     * const guildRequests = await prisma.guildRequest.findMany()
     * 
     * // Get first 10 GuildRequests
     * const guildRequests = await prisma.guildRequest.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const guildRequestWithGroupIdOnly = await prisma.guildRequest.findMany({ select: { groupId: true } })
     * 
    **/
    findMany<T extends GuildRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GuildRequest.
     * @param {GuildRequestCreateArgs} args - Arguments to create a GuildRequest.
     * @example
     * // Create one GuildRequest
     * const GuildRequest = await prisma.guildRequest.create({
     *   data: {
     *     // ... data to create a GuildRequest
     *   }
     * })
     * 
    **/
    create<T extends GuildRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildRequestCreateArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GuildRequests.
     *     @param {GuildRequestCreateManyArgs} args - Arguments to create many GuildRequests.
     *     @example
     *     // Create many GuildRequests
     *     const guildRequest = await prisma.guildRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildRequest.
     * @param {GuildRequestDeleteArgs} args - Arguments to delete one GuildRequest.
     * @example
     * // Delete one GuildRequest
     * const GuildRequest = await prisma.guildRequest.delete({
     *   where: {
     *     // ... filter to delete one GuildRequest
     *   }
     * })
     * 
    **/
    delete<T extends GuildRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GuildRequestDeleteArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GuildRequest.
     * @param {GuildRequestUpdateArgs} args - Arguments to update one GuildRequest.
     * @example
     * // Update one GuildRequest
     * const guildRequest = await prisma.guildRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildRequestUpdateArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GuildRequests.
     * @param {GuildRequestDeleteManyArgs} args - Arguments to filter GuildRequests to delete.
     * @example
     * // Delete a few GuildRequests
     * const { count } = await prisma.guildRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildRequests
     * const guildRequest = await prisma.guildRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GuildRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildRequest.
     * @param {GuildRequestUpsertArgs} args - Arguments to update or create a GuildRequest.
     * @example
     * // Update or create a GuildRequest
     * const guildRequest = await prisma.guildRequest.upsert({
     *   create: {
     *     // ... data to create a GuildRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildRequest we want to update
     *   }
     * })
    **/
    upsert<T extends GuildRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GuildRequestUpsertArgs<ExtArgs>>
    ): Prisma__GuildRequestClient<$Result.GetResult<Prisma.$GuildRequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GuildRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestCountArgs} args - Arguments to filter GuildRequests to count.
     * @example
     * // Count the number of GuildRequests
     * const count = await prisma.guildRequest.count({
     *   where: {
     *     // ... the filter for the GuildRequests we want to count
     *   }
     * })
    **/
    count<T extends GuildRequestCountArgs>(
      args?: Subset<T, GuildRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildRequestAggregateArgs>(args: Subset<T, GuildRequestAggregateArgs>): Prisma.PrismaPromise<GetGuildRequestAggregateType<T>>

    /**
     * Group by GuildRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildRequestGroupByArgs['orderBy'] }
        : { orderBy?: GuildRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildRequest model
   */
  readonly fields: GuildRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GuildRequest model
   */ 
  interface GuildRequestFieldRefs {
    readonly groupId: FieldRef<"GuildRequest", 'Int'>
    readonly userId: FieldRef<"GuildRequest", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * GuildRequest findUnique
   */
  export type GuildRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * Filter, which GuildRequest to fetch.
     */
    where: GuildRequestWhereUniqueInput
  }


  /**
   * GuildRequest findUniqueOrThrow
   */
  export type GuildRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * Filter, which GuildRequest to fetch.
     */
    where: GuildRequestWhereUniqueInput
  }


  /**
   * GuildRequest findFirst
   */
  export type GuildRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * Filter, which GuildRequest to fetch.
     */
    where?: GuildRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildRequests to fetch.
     */
    orderBy?: GuildRequestOrderByWithRelationInput | GuildRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildRequests.
     */
    cursor?: GuildRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildRequests.
     */
    distinct?: GuildRequestScalarFieldEnum | GuildRequestScalarFieldEnum[]
  }


  /**
   * GuildRequest findFirstOrThrow
   */
  export type GuildRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * Filter, which GuildRequest to fetch.
     */
    where?: GuildRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildRequests to fetch.
     */
    orderBy?: GuildRequestOrderByWithRelationInput | GuildRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildRequests.
     */
    cursor?: GuildRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildRequests.
     */
    distinct?: GuildRequestScalarFieldEnum | GuildRequestScalarFieldEnum[]
  }


  /**
   * GuildRequest findMany
   */
  export type GuildRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * Filter, which GuildRequests to fetch.
     */
    where?: GuildRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildRequests to fetch.
     */
    orderBy?: GuildRequestOrderByWithRelationInput | GuildRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildRequests.
     */
    cursor?: GuildRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildRequests.
     */
    skip?: number
    distinct?: GuildRequestScalarFieldEnum | GuildRequestScalarFieldEnum[]
  }


  /**
   * GuildRequest create
   */
  export type GuildRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a GuildRequest.
     */
    data: XOR<GuildRequestCreateInput, GuildRequestUncheckedCreateInput>
  }


  /**
   * GuildRequest createMany
   */
  export type GuildRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildRequests.
     */
    data: GuildRequestCreateManyInput | GuildRequestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * GuildRequest update
   */
  export type GuildRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a GuildRequest.
     */
    data: XOR<GuildRequestUpdateInput, GuildRequestUncheckedUpdateInput>
    /**
     * Choose, which GuildRequest to update.
     */
    where: GuildRequestWhereUniqueInput
  }


  /**
   * GuildRequest updateMany
   */
  export type GuildRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildRequests.
     */
    data: XOR<GuildRequestUpdateManyMutationInput, GuildRequestUncheckedUpdateManyInput>
    /**
     * Filter which GuildRequests to update
     */
    where?: GuildRequestWhereInput
  }


  /**
   * GuildRequest upsert
   */
  export type GuildRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the GuildRequest to update in case it exists.
     */
    where: GuildRequestWhereUniqueInput
    /**
     * In case the GuildRequest found by the `where` argument doesn't exist, create a new GuildRequest with this data.
     */
    create: XOR<GuildRequestCreateInput, GuildRequestUncheckedCreateInput>
    /**
     * In case the GuildRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildRequestUpdateInput, GuildRequestUncheckedUpdateInput>
  }


  /**
   * GuildRequest delete
   */
  export type GuildRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
    /**
     * Filter which GuildRequest to delete.
     */
    where: GuildRequestWhereUniqueInput
  }


  /**
   * GuildRequest deleteMany
   */
  export type GuildRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildRequests to delete
     */
    where?: GuildRequestWhereInput
  }


  /**
   * GuildRequest without action
   */
  export type GuildRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildRequest
     */
    select?: GuildRequestSelect<ExtArgs> | null
  }



  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    baseItem: number | null
    x: number | null
    y: number | null
    z: number | null
    rot: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    baseItem: number | null
    x: number | null
    y: number | null
    z: number | null
    rot: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    baseItem: number | null
    extraData: string | null
    x: number | null
    y: number | null
    z: number | null
    rot: number | null
    wallPos: string | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    baseItem: number | null
    extraData: string | null
    x: number | null
    y: number | null
    z: number | null
    rot: number | null
    wallPos: string | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    userId: number
    roomId: number
    baseItem: number
    extraData: number
    x: number
    y: number
    z: number
    rot: number
    wallPos: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    baseItem?: true
    x?: true
    y?: true
    z?: true
    rot?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    baseItem?: true
    x?: true
    y?: true
    z?: true
    rot?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    baseItem?: true
    extraData?: true
    x?: true
    y?: true
    z?: true
    rot?: true
    wallPos?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    baseItem?: true
    extraData?: true
    x?: true
    y?: true
    z?: true
    rot?: true
    wallPos?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    baseItem?: true
    extraData?: true
    x?: true
    y?: true
    z?: true
    rot?: true
    wallPos?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    userId: number
    roomId: number
    baseItem: number
    extraData: string | null
    x: number
    y: number
    z: number
    rot: number
    wallPos: string | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomId?: boolean
    baseItem?: boolean
    extraData?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    rot?: boolean
    wallPos?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    userId?: boolean
    roomId?: boolean
    baseItem?: boolean
    extraData?: boolean
    x?: boolean
    y?: boolean
    z?: boolean
    rot?: boolean
    wallPos?: boolean
  }


  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roomId: number
      baseItem: number
      extraData: string | null
      x: number
      y: number
      z: number
      rot: number
      wallPos: string | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }


  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemCreateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>
    ): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly userId: FieldRef<"Item", 'Int'>
    readonly roomId: FieldRef<"Item", 'Int'>
    readonly baseItem: FieldRef<"Item", 'Int'>
    readonly extraData: FieldRef<"Item", 'String'>
    readonly x: FieldRef<"Item", 'Int'>
    readonly y: FieldRef<"Item", 'Int'>
    readonly z: FieldRef<"Item", 'Float'>
    readonly rot: FieldRef<"Item", 'Int'>
    readonly wallPos: FieldRef<"Item", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }


  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }


  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
  }



  /**
   * Model ItemBase
   */

  export type AggregateItemBase = {
    _count: ItemBaseCountAggregateOutputType | null
    _avg: ItemBaseAvgAggregateOutputType | null
    _sum: ItemBaseSumAggregateOutputType | null
    _min: ItemBaseMinAggregateOutputType | null
    _max: ItemBaseMaxAggregateOutputType | null
  }

  export type ItemBaseAvgAggregateOutputType = {
    id: number | null
    width: number | null
    length: number | null
    stackHeight: number | null
    spriteId: number | null
    interactionModesCount: number | null
    effectId: number | null
    rarityLevel: number | null
  }

  export type ItemBaseSumAggregateOutputType = {
    id: number | null
    width: number | null
    length: number | null
    stackHeight: number | null
    spriteId: number | null
    interactionModesCount: number | null
    effectId: number | null
    rarityLevel: number | null
  }

  export type ItemBaseMinAggregateOutputType = {
    id: number | null
    itemName: string | null
    type: $Enums.ItemBaseType | null
    width: number | null
    length: number | null
    stackHeight: number | null
    canStack: boolean | null
    canSit: boolean | null
    isWalkable: boolean | null
    spriteId: number | null
    allowRecycle: boolean | null
    allowTrade: boolean | null
    allowMarketplaceSell: boolean | null
    allowGift: boolean | null
    allowInventoryStack: boolean | null
    interactionType: string | null
    interactionModesCount: number | null
    vendingIds: string | null
    heightAdjustable: string | null
    effectId: number | null
    isRare: boolean | null
    rarityLevel: number | null
  }

  export type ItemBaseMaxAggregateOutputType = {
    id: number | null
    itemName: string | null
    type: $Enums.ItemBaseType | null
    width: number | null
    length: number | null
    stackHeight: number | null
    canStack: boolean | null
    canSit: boolean | null
    isWalkable: boolean | null
    spriteId: number | null
    allowRecycle: boolean | null
    allowTrade: boolean | null
    allowMarketplaceSell: boolean | null
    allowGift: boolean | null
    allowInventoryStack: boolean | null
    interactionType: string | null
    interactionModesCount: number | null
    vendingIds: string | null
    heightAdjustable: string | null
    effectId: number | null
    isRare: boolean | null
    rarityLevel: number | null
  }

  export type ItemBaseCountAggregateOutputType = {
    id: number
    itemName: number
    type: number
    width: number
    length: number
    stackHeight: number
    canStack: number
    canSit: number
    isWalkable: number
    spriteId: number
    allowRecycle: number
    allowTrade: number
    allowMarketplaceSell: number
    allowGift: number
    allowInventoryStack: number
    interactionType: number
    interactionModesCount: number
    vendingIds: number
    heightAdjustable: number
    effectId: number
    isRare: number
    rarityLevel: number
    _all: number
  }


  export type ItemBaseAvgAggregateInputType = {
    id?: true
    width?: true
    length?: true
    stackHeight?: true
    spriteId?: true
    interactionModesCount?: true
    effectId?: true
    rarityLevel?: true
  }

  export type ItemBaseSumAggregateInputType = {
    id?: true
    width?: true
    length?: true
    stackHeight?: true
    spriteId?: true
    interactionModesCount?: true
    effectId?: true
    rarityLevel?: true
  }

  export type ItemBaseMinAggregateInputType = {
    id?: true
    itemName?: true
    type?: true
    width?: true
    length?: true
    stackHeight?: true
    canStack?: true
    canSit?: true
    isWalkable?: true
    spriteId?: true
    allowRecycle?: true
    allowTrade?: true
    allowMarketplaceSell?: true
    allowGift?: true
    allowInventoryStack?: true
    interactionType?: true
    interactionModesCount?: true
    vendingIds?: true
    heightAdjustable?: true
    effectId?: true
    isRare?: true
    rarityLevel?: true
  }

  export type ItemBaseMaxAggregateInputType = {
    id?: true
    itemName?: true
    type?: true
    width?: true
    length?: true
    stackHeight?: true
    canStack?: true
    canSit?: true
    isWalkable?: true
    spriteId?: true
    allowRecycle?: true
    allowTrade?: true
    allowMarketplaceSell?: true
    allowGift?: true
    allowInventoryStack?: true
    interactionType?: true
    interactionModesCount?: true
    vendingIds?: true
    heightAdjustable?: true
    effectId?: true
    isRare?: true
    rarityLevel?: true
  }

  export type ItemBaseCountAggregateInputType = {
    id?: true
    itemName?: true
    type?: true
    width?: true
    length?: true
    stackHeight?: true
    canStack?: true
    canSit?: true
    isWalkable?: true
    spriteId?: true
    allowRecycle?: true
    allowTrade?: true
    allowMarketplaceSell?: true
    allowGift?: true
    allowInventoryStack?: true
    interactionType?: true
    interactionModesCount?: true
    vendingIds?: true
    heightAdjustable?: true
    effectId?: true
    isRare?: true
    rarityLevel?: true
    _all?: true
  }

  export type ItemBaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemBase to aggregate.
     */
    where?: ItemBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBases to fetch.
     */
    orderBy?: ItemBaseOrderByWithRelationInput | ItemBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemBases
    **/
    _count?: true | ItemBaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemBaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemBaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemBaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemBaseMaxAggregateInputType
  }

  export type GetItemBaseAggregateType<T extends ItemBaseAggregateArgs> = {
        [P in keyof T & keyof AggregateItemBase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemBase[P]>
      : GetScalarType<T[P], AggregateItemBase[P]>
  }




  export type ItemBaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemBaseWhereInput
    orderBy?: ItemBaseOrderByWithAggregationInput | ItemBaseOrderByWithAggregationInput[]
    by: ItemBaseScalarFieldEnum[] | ItemBaseScalarFieldEnum
    having?: ItemBaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemBaseCountAggregateInputType | true
    _avg?: ItemBaseAvgAggregateInputType
    _sum?: ItemBaseSumAggregateInputType
    _min?: ItemBaseMinAggregateInputType
    _max?: ItemBaseMaxAggregateInputType
  }

  export type ItemBaseGroupByOutputType = {
    id: number
    itemName: string
    type: $Enums.ItemBaseType
    width: number
    length: number
    stackHeight: number
    canStack: boolean
    canSit: boolean
    isWalkable: boolean
    spriteId: number
    allowRecycle: boolean
    allowTrade: boolean
    allowMarketplaceSell: boolean
    allowGift: boolean
    allowInventoryStack: boolean
    interactionType: string
    interactionModesCount: number
    vendingIds: string
    heightAdjustable: string
    effectId: number
    isRare: boolean
    rarityLevel: number
    _count: ItemBaseCountAggregateOutputType | null
    _avg: ItemBaseAvgAggregateOutputType | null
    _sum: ItemBaseSumAggregateOutputType | null
    _min: ItemBaseMinAggregateOutputType | null
    _max: ItemBaseMaxAggregateOutputType | null
  }

  type GetItemBaseGroupByPayload<T extends ItemBaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemBaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemBaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemBaseGroupByOutputType[P]>
            : GetScalarType<T[P], ItemBaseGroupByOutputType[P]>
        }
      >
    >


  export type ItemBaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    type?: boolean
    width?: boolean
    length?: boolean
    stackHeight?: boolean
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId?: boolean
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: boolean
    interactionModesCount?: boolean
    vendingIds?: boolean
    heightAdjustable?: boolean
    effectId?: boolean
    isRare?: boolean
    rarityLevel?: boolean
    itemStat?: boolean | ItemBase$itemStatArgs<ExtArgs>
    logLootbox?: boolean | ItemBase$logLootboxArgs<ExtArgs>
    catalogItem?: boolean | ItemBase$catalogItemArgs<ExtArgs>
    _count?: boolean | ItemBaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemBase"]>

  export type ItemBaseSelectScalar = {
    id?: boolean
    itemName?: boolean
    type?: boolean
    width?: boolean
    length?: boolean
    stackHeight?: boolean
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId?: boolean
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: boolean
    interactionModesCount?: boolean
    vendingIds?: boolean
    heightAdjustable?: boolean
    effectId?: boolean
    isRare?: boolean
    rarityLevel?: boolean
  }

  export type ItemBaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemStat?: boolean | ItemBase$itemStatArgs<ExtArgs>
    logLootbox?: boolean | ItemBase$logLootboxArgs<ExtArgs>
    catalogItem?: boolean | ItemBase$catalogItemArgs<ExtArgs>
    _count?: boolean | ItemBaseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemBasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemBase"
    objects: {
      itemStat: Prisma.$ItemStatPayload<ExtArgs> | null
      logLootbox: Prisma.$LogLootboxPayload<ExtArgs>[]
      catalogItem: Prisma.$CatalogItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemName: string
      type: $Enums.ItemBaseType
      width: number
      length: number
      stackHeight: number
      canStack: boolean
      canSit: boolean
      isWalkable: boolean
      spriteId: number
      allowRecycle: boolean
      allowTrade: boolean
      allowMarketplaceSell: boolean
      allowGift: boolean
      allowInventoryStack: boolean
      interactionType: string
      interactionModesCount: number
      vendingIds: string
      heightAdjustable: string
      effectId: number
      isRare: boolean
      rarityLevel: number
    }, ExtArgs["result"]["itemBase"]>
    composites: {}
  }


  type ItemBaseGetPayload<S extends boolean | null | undefined | ItemBaseDefaultArgs> = $Result.GetResult<Prisma.$ItemBasePayload, S>

  type ItemBaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemBaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemBaseCountAggregateInputType | true
    }

  export interface ItemBaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemBase'], meta: { name: 'ItemBase' } }
    /**
     * Find zero or one ItemBase that matches the filter.
     * @param {ItemBaseFindUniqueArgs} args - Arguments to find a ItemBase
     * @example
     * // Get one ItemBase
     * const itemBase = await prisma.itemBase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemBaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemBaseFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemBase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemBaseFindUniqueOrThrowArgs} args - Arguments to find a ItemBase
     * @example
     * // Get one ItemBase
     * const itemBase = await prisma.itemBase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemBaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemBaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemBase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseFindFirstArgs} args - Arguments to find a ItemBase
     * @example
     * // Get one ItemBase
     * const itemBase = await prisma.itemBase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemBaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemBaseFindFirstArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemBase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseFindFirstOrThrowArgs} args - Arguments to find a ItemBase
     * @example
     * // Get one ItemBase
     * const itemBase = await prisma.itemBase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemBaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemBaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemBases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemBases
     * const itemBases = await prisma.itemBase.findMany()
     * 
     * // Get first 10 ItemBases
     * const itemBases = await prisma.itemBase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemBaseWithIdOnly = await prisma.itemBase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemBaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemBaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemBase.
     * @param {ItemBaseCreateArgs} args - Arguments to create a ItemBase.
     * @example
     * // Create one ItemBase
     * const ItemBase = await prisma.itemBase.create({
     *   data: {
     *     // ... data to create a ItemBase
     *   }
     * })
     * 
    **/
    create<T extends ItemBaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemBaseCreateArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemBases.
     *     @param {ItemBaseCreateManyArgs} args - Arguments to create many ItemBases.
     *     @example
     *     // Create many ItemBases
     *     const itemBase = await prisma.itemBase.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemBaseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemBaseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemBase.
     * @param {ItemBaseDeleteArgs} args - Arguments to delete one ItemBase.
     * @example
     * // Delete one ItemBase
     * const ItemBase = await prisma.itemBase.delete({
     *   where: {
     *     // ... filter to delete one ItemBase
     *   }
     * })
     * 
    **/
    delete<T extends ItemBaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemBaseDeleteArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemBase.
     * @param {ItemBaseUpdateArgs} args - Arguments to update one ItemBase.
     * @example
     * // Update one ItemBase
     * const itemBase = await prisma.itemBase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemBaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemBaseUpdateArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemBases.
     * @param {ItemBaseDeleteManyArgs} args - Arguments to filter ItemBases to delete.
     * @example
     * // Delete a few ItemBases
     * const { count } = await prisma.itemBase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemBaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemBaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemBases
     * const itemBase = await prisma.itemBase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemBaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemBaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemBase.
     * @param {ItemBaseUpsertArgs} args - Arguments to update or create a ItemBase.
     * @example
     * // Update or create a ItemBase
     * const itemBase = await prisma.itemBase.upsert({
     *   create: {
     *     // ... data to create a ItemBase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemBase we want to update
     *   }
     * })
    **/
    upsert<T extends ItemBaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemBaseUpsertArgs<ExtArgs>>
    ): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseCountArgs} args - Arguments to filter ItemBases to count.
     * @example
     * // Count the number of ItemBases
     * const count = await prisma.itemBase.count({
     *   where: {
     *     // ... the filter for the ItemBases we want to count
     *   }
     * })
    **/
    count<T extends ItemBaseCountArgs>(
      args?: Subset<T, ItemBaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemBaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemBaseAggregateArgs>(args: Subset<T, ItemBaseAggregateArgs>): Prisma.PrismaPromise<GetItemBaseAggregateType<T>>

    /**
     * Group by ItemBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemBaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemBaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemBaseGroupByArgs['orderBy'] }
        : { orderBy?: ItemBaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemBaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemBaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemBase model
   */
  readonly fields: ItemBaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemBase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemBaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    itemStat<T extends ItemBase$itemStatArgs<ExtArgs> = {}>(args?: Subset<T, ItemBase$itemStatArgs<ExtArgs>>): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    logLootbox<T extends ItemBase$logLootboxArgs<ExtArgs> = {}>(args?: Subset<T, ItemBase$logLootboxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findMany'> | Null>;

    catalogItem<T extends ItemBase$catalogItemArgs<ExtArgs> = {}>(args?: Subset<T, ItemBase$catalogItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemBase model
   */ 
  interface ItemBaseFieldRefs {
    readonly id: FieldRef<"ItemBase", 'Int'>
    readonly itemName: FieldRef<"ItemBase", 'String'>
    readonly type: FieldRef<"ItemBase", 'ItemBaseType'>
    readonly width: FieldRef<"ItemBase", 'Int'>
    readonly length: FieldRef<"ItemBase", 'Int'>
    readonly stackHeight: FieldRef<"ItemBase", 'Float'>
    readonly canStack: FieldRef<"ItemBase", 'Boolean'>
    readonly canSit: FieldRef<"ItemBase", 'Boolean'>
    readonly isWalkable: FieldRef<"ItemBase", 'Boolean'>
    readonly spriteId: FieldRef<"ItemBase", 'Int'>
    readonly allowRecycle: FieldRef<"ItemBase", 'Boolean'>
    readonly allowTrade: FieldRef<"ItemBase", 'Boolean'>
    readonly allowMarketplaceSell: FieldRef<"ItemBase", 'Boolean'>
    readonly allowGift: FieldRef<"ItemBase", 'Boolean'>
    readonly allowInventoryStack: FieldRef<"ItemBase", 'Boolean'>
    readonly interactionType: FieldRef<"ItemBase", 'String'>
    readonly interactionModesCount: FieldRef<"ItemBase", 'Int'>
    readonly vendingIds: FieldRef<"ItemBase", 'String'>
    readonly heightAdjustable: FieldRef<"ItemBase", 'String'>
    readonly effectId: FieldRef<"ItemBase", 'Int'>
    readonly isRare: FieldRef<"ItemBase", 'Boolean'>
    readonly rarityLevel: FieldRef<"ItemBase", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemBase findUnique
   */
  export type ItemBaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * Filter, which ItemBase to fetch.
     */
    where: ItemBaseWhereUniqueInput
  }


  /**
   * ItemBase findUniqueOrThrow
   */
  export type ItemBaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * Filter, which ItemBase to fetch.
     */
    where: ItemBaseWhereUniqueInput
  }


  /**
   * ItemBase findFirst
   */
  export type ItemBaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * Filter, which ItemBase to fetch.
     */
    where?: ItemBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBases to fetch.
     */
    orderBy?: ItemBaseOrderByWithRelationInput | ItemBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemBases.
     */
    cursor?: ItemBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemBases.
     */
    distinct?: ItemBaseScalarFieldEnum | ItemBaseScalarFieldEnum[]
  }


  /**
   * ItemBase findFirstOrThrow
   */
  export type ItemBaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * Filter, which ItemBase to fetch.
     */
    where?: ItemBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBases to fetch.
     */
    orderBy?: ItemBaseOrderByWithRelationInput | ItemBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemBases.
     */
    cursor?: ItemBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemBases.
     */
    distinct?: ItemBaseScalarFieldEnum | ItemBaseScalarFieldEnum[]
  }


  /**
   * ItemBase findMany
   */
  export type ItemBaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * Filter, which ItemBases to fetch.
     */
    where?: ItemBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemBases to fetch.
     */
    orderBy?: ItemBaseOrderByWithRelationInput | ItemBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemBases.
     */
    cursor?: ItemBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemBases.
     */
    skip?: number
    distinct?: ItemBaseScalarFieldEnum | ItemBaseScalarFieldEnum[]
  }


  /**
   * ItemBase create
   */
  export type ItemBaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemBase.
     */
    data: XOR<ItemBaseCreateInput, ItemBaseUncheckedCreateInput>
  }


  /**
   * ItemBase createMany
   */
  export type ItemBaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemBases.
     */
    data: ItemBaseCreateManyInput | ItemBaseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemBase update
   */
  export type ItemBaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemBase.
     */
    data: XOR<ItemBaseUpdateInput, ItemBaseUncheckedUpdateInput>
    /**
     * Choose, which ItemBase to update.
     */
    where: ItemBaseWhereUniqueInput
  }


  /**
   * ItemBase updateMany
   */
  export type ItemBaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemBases.
     */
    data: XOR<ItemBaseUpdateManyMutationInput, ItemBaseUncheckedUpdateManyInput>
    /**
     * Filter which ItemBases to update
     */
    where?: ItemBaseWhereInput
  }


  /**
   * ItemBase upsert
   */
  export type ItemBaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemBase to update in case it exists.
     */
    where: ItemBaseWhereUniqueInput
    /**
     * In case the ItemBase found by the `where` argument doesn't exist, create a new ItemBase with this data.
     */
    create: XOR<ItemBaseCreateInput, ItemBaseUncheckedCreateInput>
    /**
     * In case the ItemBase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemBaseUpdateInput, ItemBaseUncheckedUpdateInput>
  }


  /**
   * ItemBase delete
   */
  export type ItemBaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
    /**
     * Filter which ItemBase to delete.
     */
    where: ItemBaseWhereUniqueInput
  }


  /**
   * ItemBase deleteMany
   */
  export type ItemBaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemBases to delete
     */
    where?: ItemBaseWhereInput
  }


  /**
   * ItemBase.itemStat
   */
  export type ItemBase$itemStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    where?: ItemStatWhereInput
  }


  /**
   * ItemBase.logLootbox
   */
  export type ItemBase$logLootboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    where?: LogLootboxWhereInput
    orderBy?: LogLootboxOrderByWithRelationInput | LogLootboxOrderByWithRelationInput[]
    cursor?: LogLootboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogLootboxScalarFieldEnum | LogLootboxScalarFieldEnum[]
  }


  /**
   * ItemBase.catalogItem
   */
  export type ItemBase$catalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogItem
     */
    select?: CatalogItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CatalogItemInclude<ExtArgs> | null
    where?: CatalogItemWhereInput
    orderBy?: CatalogItemOrderByWithRelationInput | CatalogItemOrderByWithRelationInput[]
    cursor?: CatalogItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatalogItemScalarFieldEnum | CatalogItemScalarFieldEnum[]
  }


  /**
   * ItemBase without action
   */
  export type ItemBaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemBase
     */
    select?: ItemBaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemBaseInclude<ExtArgs> | null
  }



  /**
   * Model ItemLimited
   */

  export type AggregateItemLimited = {
    _count: ItemLimitedCountAggregateOutputType | null
    _avg: ItemLimitedAvgAggregateOutputType | null
    _sum: ItemLimitedSumAggregateOutputType | null
    _min: ItemLimitedMinAggregateOutputType | null
    _max: ItemLimitedMaxAggregateOutputType | null
  }

  export type ItemLimitedAvgAggregateOutputType = {
    itemId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type ItemLimitedSumAggregateOutputType = {
    itemId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type ItemLimitedMinAggregateOutputType = {
    itemId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type ItemLimitedMaxAggregateOutputType = {
    itemId: number | null
    limitedNumber: number | null
    limitedStack: number | null
  }

  export type ItemLimitedCountAggregateOutputType = {
    itemId: number
    limitedNumber: number
    limitedStack: number
    _all: number
  }


  export type ItemLimitedAvgAggregateInputType = {
    itemId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type ItemLimitedSumAggregateInputType = {
    itemId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type ItemLimitedMinAggregateInputType = {
    itemId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type ItemLimitedMaxAggregateInputType = {
    itemId?: true
    limitedNumber?: true
    limitedStack?: true
  }

  export type ItemLimitedCountAggregateInputType = {
    itemId?: true
    limitedNumber?: true
    limitedStack?: true
    _all?: true
  }

  export type ItemLimitedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLimited to aggregate.
     */
    where?: ItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLimiteds to fetch.
     */
    orderBy?: ItemLimitedOrderByWithRelationInput | ItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLimiteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemLimiteds
    **/
    _count?: true | ItemLimitedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemLimitedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemLimitedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemLimitedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemLimitedMaxAggregateInputType
  }

  export type GetItemLimitedAggregateType<T extends ItemLimitedAggregateArgs> = {
        [P in keyof T & keyof AggregateItemLimited]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemLimited[P]>
      : GetScalarType<T[P], AggregateItemLimited[P]>
  }




  export type ItemLimitedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLimitedWhereInput
    orderBy?: ItemLimitedOrderByWithAggregationInput | ItemLimitedOrderByWithAggregationInput[]
    by: ItemLimitedScalarFieldEnum[] | ItemLimitedScalarFieldEnum
    having?: ItemLimitedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemLimitedCountAggregateInputType | true
    _avg?: ItemLimitedAvgAggregateInputType
    _sum?: ItemLimitedSumAggregateInputType
    _min?: ItemLimitedMinAggregateInputType
    _max?: ItemLimitedMaxAggregateInputType
  }

  export type ItemLimitedGroupByOutputType = {
    itemId: number
    limitedNumber: number
    limitedStack: number
    _count: ItemLimitedCountAggregateOutputType | null
    _avg: ItemLimitedAvgAggregateOutputType | null
    _sum: ItemLimitedSumAggregateOutputType | null
    _min: ItemLimitedMinAggregateOutputType | null
    _max: ItemLimitedMaxAggregateOutputType | null
  }

  type GetItemLimitedGroupByPayload<T extends ItemLimitedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemLimitedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemLimitedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemLimitedGroupByOutputType[P]>
            : GetScalarType<T[P], ItemLimitedGroupByOutputType[P]>
        }
      >
    >


  export type ItemLimitedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    limitedNumber?: boolean
    limitedStack?: boolean
  }, ExtArgs["result"]["itemLimited"]>

  export type ItemLimitedSelectScalar = {
    itemId?: boolean
    limitedNumber?: boolean
    limitedStack?: boolean
  }


  export type $ItemLimitedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemLimited"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      itemId: number
      limitedNumber: number
      limitedStack: number
    }, ExtArgs["result"]["itemLimited"]>
    composites: {}
  }


  type ItemLimitedGetPayload<S extends boolean | null | undefined | ItemLimitedDefaultArgs> = $Result.GetResult<Prisma.$ItemLimitedPayload, S>

  type ItemLimitedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemLimitedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemLimitedCountAggregateInputType | true
    }

  export interface ItemLimitedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemLimited'], meta: { name: 'ItemLimited' } }
    /**
     * Find zero or one ItemLimited that matches the filter.
     * @param {ItemLimitedFindUniqueArgs} args - Arguments to find a ItemLimited
     * @example
     * // Get one ItemLimited
     * const itemLimited = await prisma.itemLimited.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemLimitedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLimitedFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemLimited that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemLimitedFindUniqueOrThrowArgs} args - Arguments to find a ItemLimited
     * @example
     * // Get one ItemLimited
     * const itemLimited = await prisma.itemLimited.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemLimitedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLimitedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemLimited that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedFindFirstArgs} args - Arguments to find a ItemLimited
     * @example
     * // Get one ItemLimited
     * const itemLimited = await prisma.itemLimited.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemLimitedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLimitedFindFirstArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemLimited that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedFindFirstOrThrowArgs} args - Arguments to find a ItemLimited
     * @example
     * // Get one ItemLimited
     * const itemLimited = await prisma.itemLimited.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemLimitedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLimitedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemLimiteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemLimiteds
     * const itemLimiteds = await prisma.itemLimited.findMany()
     * 
     * // Get first 10 ItemLimiteds
     * const itemLimiteds = await prisma.itemLimited.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemLimitedWithItemIdOnly = await prisma.itemLimited.findMany({ select: { itemId: true } })
     * 
    **/
    findMany<T extends ItemLimitedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLimitedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemLimited.
     * @param {ItemLimitedCreateArgs} args - Arguments to create a ItemLimited.
     * @example
     * // Create one ItemLimited
     * const ItemLimited = await prisma.itemLimited.create({
     *   data: {
     *     // ... data to create a ItemLimited
     *   }
     * })
     * 
    **/
    create<T extends ItemLimitedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLimitedCreateArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemLimiteds.
     *     @param {ItemLimitedCreateManyArgs} args - Arguments to create many ItemLimiteds.
     *     @example
     *     // Create many ItemLimiteds
     *     const itemLimited = await prisma.itemLimited.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemLimitedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLimitedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemLimited.
     * @param {ItemLimitedDeleteArgs} args - Arguments to delete one ItemLimited.
     * @example
     * // Delete one ItemLimited
     * const ItemLimited = await prisma.itemLimited.delete({
     *   where: {
     *     // ... filter to delete one ItemLimited
     *   }
     * })
     * 
    **/
    delete<T extends ItemLimitedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLimitedDeleteArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemLimited.
     * @param {ItemLimitedUpdateArgs} args - Arguments to update one ItemLimited.
     * @example
     * // Update one ItemLimited
     * const itemLimited = await prisma.itemLimited.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemLimitedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLimitedUpdateArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemLimiteds.
     * @param {ItemLimitedDeleteManyArgs} args - Arguments to filter ItemLimiteds to delete.
     * @example
     * // Delete a few ItemLimiteds
     * const { count } = await prisma.itemLimited.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemLimitedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemLimitedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemLimiteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemLimiteds
     * const itemLimited = await prisma.itemLimited.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemLimitedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLimitedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemLimited.
     * @param {ItemLimitedUpsertArgs} args - Arguments to update or create a ItemLimited.
     * @example
     * // Update or create a ItemLimited
     * const itemLimited = await prisma.itemLimited.upsert({
     *   create: {
     *     // ... data to create a ItemLimited
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemLimited we want to update
     *   }
     * })
    **/
    upsert<T extends ItemLimitedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemLimitedUpsertArgs<ExtArgs>>
    ): Prisma__ItemLimitedClient<$Result.GetResult<Prisma.$ItemLimitedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemLimiteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedCountArgs} args - Arguments to filter ItemLimiteds to count.
     * @example
     * // Count the number of ItemLimiteds
     * const count = await prisma.itemLimited.count({
     *   where: {
     *     // ... the filter for the ItemLimiteds we want to count
     *   }
     * })
    **/
    count<T extends ItemLimitedCountArgs>(
      args?: Subset<T, ItemLimitedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemLimitedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemLimited.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemLimitedAggregateArgs>(args: Subset<T, ItemLimitedAggregateArgs>): Prisma.PrismaPromise<GetItemLimitedAggregateType<T>>

    /**
     * Group by ItemLimited.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLimitedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemLimitedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemLimitedGroupByArgs['orderBy'] }
        : { orderBy?: ItemLimitedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemLimitedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemLimitedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemLimited model
   */
  readonly fields: ItemLimitedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemLimited.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemLimitedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemLimited model
   */ 
  interface ItemLimitedFieldRefs {
    readonly itemId: FieldRef<"ItemLimited", 'Int'>
    readonly limitedNumber: FieldRef<"ItemLimited", 'Int'>
    readonly limitedStack: FieldRef<"ItemLimited", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemLimited findUnique
   */
  export type ItemLimitedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * Filter, which ItemLimited to fetch.
     */
    where: ItemLimitedWhereUniqueInput
  }


  /**
   * ItemLimited findUniqueOrThrow
   */
  export type ItemLimitedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * Filter, which ItemLimited to fetch.
     */
    where: ItemLimitedWhereUniqueInput
  }


  /**
   * ItemLimited findFirst
   */
  export type ItemLimitedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * Filter, which ItemLimited to fetch.
     */
    where?: ItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLimiteds to fetch.
     */
    orderBy?: ItemLimitedOrderByWithRelationInput | ItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLimiteds.
     */
    cursor?: ItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLimiteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLimiteds.
     */
    distinct?: ItemLimitedScalarFieldEnum | ItemLimitedScalarFieldEnum[]
  }


  /**
   * ItemLimited findFirstOrThrow
   */
  export type ItemLimitedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * Filter, which ItemLimited to fetch.
     */
    where?: ItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLimiteds to fetch.
     */
    orderBy?: ItemLimitedOrderByWithRelationInput | ItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLimiteds.
     */
    cursor?: ItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLimiteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLimiteds.
     */
    distinct?: ItemLimitedScalarFieldEnum | ItemLimitedScalarFieldEnum[]
  }


  /**
   * ItemLimited findMany
   */
  export type ItemLimitedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * Filter, which ItemLimiteds to fetch.
     */
    where?: ItemLimitedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLimiteds to fetch.
     */
    orderBy?: ItemLimitedOrderByWithRelationInput | ItemLimitedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemLimiteds.
     */
    cursor?: ItemLimitedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLimiteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLimiteds.
     */
    skip?: number
    distinct?: ItemLimitedScalarFieldEnum | ItemLimitedScalarFieldEnum[]
  }


  /**
   * ItemLimited create
   */
  export type ItemLimitedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * The data needed to create a ItemLimited.
     */
    data: XOR<ItemLimitedCreateInput, ItemLimitedUncheckedCreateInput>
  }


  /**
   * ItemLimited createMany
   */
  export type ItemLimitedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemLimiteds.
     */
    data: ItemLimitedCreateManyInput | ItemLimitedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemLimited update
   */
  export type ItemLimitedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * The data needed to update a ItemLimited.
     */
    data: XOR<ItemLimitedUpdateInput, ItemLimitedUncheckedUpdateInput>
    /**
     * Choose, which ItemLimited to update.
     */
    where: ItemLimitedWhereUniqueInput
  }


  /**
   * ItemLimited updateMany
   */
  export type ItemLimitedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemLimiteds.
     */
    data: XOR<ItemLimitedUpdateManyMutationInput, ItemLimitedUncheckedUpdateManyInput>
    /**
     * Filter which ItemLimiteds to update
     */
    where?: ItemLimitedWhereInput
  }


  /**
   * ItemLimited upsert
   */
  export type ItemLimitedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * The filter to search for the ItemLimited to update in case it exists.
     */
    where: ItemLimitedWhereUniqueInput
    /**
     * In case the ItemLimited found by the `where` argument doesn't exist, create a new ItemLimited with this data.
     */
    create: XOR<ItemLimitedCreateInput, ItemLimitedUncheckedCreateInput>
    /**
     * In case the ItemLimited was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemLimitedUpdateInput, ItemLimitedUncheckedUpdateInput>
  }


  /**
   * ItemLimited delete
   */
  export type ItemLimitedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
    /**
     * Filter which ItemLimited to delete.
     */
    where: ItemLimitedWhereUniqueInput
  }


  /**
   * ItemLimited deleteMany
   */
  export type ItemLimitedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLimiteds to delete
     */
    where?: ItemLimitedWhereInput
  }


  /**
   * ItemLimited without action
   */
  export type ItemLimitedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLimited
     */
    select?: ItemLimitedSelect<ExtArgs> | null
  }



  /**
   * Model ItemMoodlight
   */

  export type AggregateItemMoodlight = {
    _count: ItemMoodlightCountAggregateOutputType | null
    _avg: ItemMoodlightAvgAggregateOutputType | null
    _sum: ItemMoodlightSumAggregateOutputType | null
    _min: ItemMoodlightMinAggregateOutputType | null
    _max: ItemMoodlightMaxAggregateOutputType | null
  }

  export type ItemMoodlightAvgAggregateOutputType = {
    itemId: number | null
    currentPreset: number | null
  }

  export type ItemMoodlightSumAggregateOutputType = {
    itemId: number | null
    currentPreset: number | null
  }

  export type ItemMoodlightMinAggregateOutputType = {
    itemId: number | null
    enabled: boolean | null
    currentPreset: number | null
    presetOne: string | null
    presetTwo: string | null
    presetThree: string | null
  }

  export type ItemMoodlightMaxAggregateOutputType = {
    itemId: number | null
    enabled: boolean | null
    currentPreset: number | null
    presetOne: string | null
    presetTwo: string | null
    presetThree: string | null
  }

  export type ItemMoodlightCountAggregateOutputType = {
    itemId: number
    enabled: number
    currentPreset: number
    presetOne: number
    presetTwo: number
    presetThree: number
    _all: number
  }


  export type ItemMoodlightAvgAggregateInputType = {
    itemId?: true
    currentPreset?: true
  }

  export type ItemMoodlightSumAggregateInputType = {
    itemId?: true
    currentPreset?: true
  }

  export type ItemMoodlightMinAggregateInputType = {
    itemId?: true
    enabled?: true
    currentPreset?: true
    presetOne?: true
    presetTwo?: true
    presetThree?: true
  }

  export type ItemMoodlightMaxAggregateInputType = {
    itemId?: true
    enabled?: true
    currentPreset?: true
    presetOne?: true
    presetTwo?: true
    presetThree?: true
  }

  export type ItemMoodlightCountAggregateInputType = {
    itemId?: true
    enabled?: true
    currentPreset?: true
    presetOne?: true
    presetTwo?: true
    presetThree?: true
    _all?: true
  }

  export type ItemMoodlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemMoodlight to aggregate.
     */
    where?: ItemMoodlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMoodlights to fetch.
     */
    orderBy?: ItemMoodlightOrderByWithRelationInput | ItemMoodlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemMoodlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMoodlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMoodlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemMoodlights
    **/
    _count?: true | ItemMoodlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemMoodlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemMoodlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMoodlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMoodlightMaxAggregateInputType
  }

  export type GetItemMoodlightAggregateType<T extends ItemMoodlightAggregateArgs> = {
        [P in keyof T & keyof AggregateItemMoodlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemMoodlight[P]>
      : GetScalarType<T[P], AggregateItemMoodlight[P]>
  }




  export type ItemMoodlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMoodlightWhereInput
    orderBy?: ItemMoodlightOrderByWithAggregationInput | ItemMoodlightOrderByWithAggregationInput[]
    by: ItemMoodlightScalarFieldEnum[] | ItemMoodlightScalarFieldEnum
    having?: ItemMoodlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemMoodlightCountAggregateInputType | true
    _avg?: ItemMoodlightAvgAggregateInputType
    _sum?: ItemMoodlightSumAggregateInputType
    _min?: ItemMoodlightMinAggregateInputType
    _max?: ItemMoodlightMaxAggregateInputType
  }

  export type ItemMoodlightGroupByOutputType = {
    itemId: number
    enabled: boolean
    currentPreset: number
    presetOne: string
    presetTwo: string
    presetThree: string
    _count: ItemMoodlightCountAggregateOutputType | null
    _avg: ItemMoodlightAvgAggregateOutputType | null
    _sum: ItemMoodlightSumAggregateOutputType | null
    _min: ItemMoodlightMinAggregateOutputType | null
    _max: ItemMoodlightMaxAggregateOutputType | null
  }

  type GetItemMoodlightGroupByPayload<T extends ItemMoodlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemMoodlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemMoodlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemMoodlightGroupByOutputType[P]>
            : GetScalarType<T[P], ItemMoodlightGroupByOutputType[P]>
        }
      >
    >


  export type ItemMoodlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    enabled?: boolean
    currentPreset?: boolean
    presetOne?: boolean
    presetTwo?: boolean
    presetThree?: boolean
  }, ExtArgs["result"]["itemMoodlight"]>

  export type ItemMoodlightSelectScalar = {
    itemId?: boolean
    enabled?: boolean
    currentPreset?: boolean
    presetOne?: boolean
    presetTwo?: boolean
    presetThree?: boolean
  }


  export type $ItemMoodlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemMoodlight"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      itemId: number
      enabled: boolean
      currentPreset: number
      presetOne: string
      presetTwo: string
      presetThree: string
    }, ExtArgs["result"]["itemMoodlight"]>
    composites: {}
  }


  type ItemMoodlightGetPayload<S extends boolean | null | undefined | ItemMoodlightDefaultArgs> = $Result.GetResult<Prisma.$ItemMoodlightPayload, S>

  type ItemMoodlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemMoodlightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemMoodlightCountAggregateInputType | true
    }

  export interface ItemMoodlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemMoodlight'], meta: { name: 'ItemMoodlight' } }
    /**
     * Find zero or one ItemMoodlight that matches the filter.
     * @param {ItemMoodlightFindUniqueArgs} args - Arguments to find a ItemMoodlight
     * @example
     * // Get one ItemMoodlight
     * const itemMoodlight = await prisma.itemMoodlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemMoodlightFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMoodlightFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemMoodlight that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemMoodlightFindUniqueOrThrowArgs} args - Arguments to find a ItemMoodlight
     * @example
     * // Get one ItemMoodlight
     * const itemMoodlight = await prisma.itemMoodlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemMoodlightFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMoodlightFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemMoodlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightFindFirstArgs} args - Arguments to find a ItemMoodlight
     * @example
     * // Get one ItemMoodlight
     * const itemMoodlight = await prisma.itemMoodlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemMoodlightFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMoodlightFindFirstArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemMoodlight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightFindFirstOrThrowArgs} args - Arguments to find a ItemMoodlight
     * @example
     * // Get one ItemMoodlight
     * const itemMoodlight = await prisma.itemMoodlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemMoodlightFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMoodlightFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemMoodlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemMoodlights
     * const itemMoodlights = await prisma.itemMoodlight.findMany()
     * 
     * // Get first 10 ItemMoodlights
     * const itemMoodlights = await prisma.itemMoodlight.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemMoodlightWithItemIdOnly = await prisma.itemMoodlight.findMany({ select: { itemId: true } })
     * 
    **/
    findMany<T extends ItemMoodlightFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMoodlightFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemMoodlight.
     * @param {ItemMoodlightCreateArgs} args - Arguments to create a ItemMoodlight.
     * @example
     * // Create one ItemMoodlight
     * const ItemMoodlight = await prisma.itemMoodlight.create({
     *   data: {
     *     // ... data to create a ItemMoodlight
     *   }
     * })
     * 
    **/
    create<T extends ItemMoodlightCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMoodlightCreateArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemMoodlights.
     *     @param {ItemMoodlightCreateManyArgs} args - Arguments to create many ItemMoodlights.
     *     @example
     *     // Create many ItemMoodlights
     *     const itemMoodlight = await prisma.itemMoodlight.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemMoodlightCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMoodlightCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemMoodlight.
     * @param {ItemMoodlightDeleteArgs} args - Arguments to delete one ItemMoodlight.
     * @example
     * // Delete one ItemMoodlight
     * const ItemMoodlight = await prisma.itemMoodlight.delete({
     *   where: {
     *     // ... filter to delete one ItemMoodlight
     *   }
     * })
     * 
    **/
    delete<T extends ItemMoodlightDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMoodlightDeleteArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemMoodlight.
     * @param {ItemMoodlightUpdateArgs} args - Arguments to update one ItemMoodlight.
     * @example
     * // Update one ItemMoodlight
     * const itemMoodlight = await prisma.itemMoodlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemMoodlightUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMoodlightUpdateArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemMoodlights.
     * @param {ItemMoodlightDeleteManyArgs} args - Arguments to filter ItemMoodlights to delete.
     * @example
     * // Delete a few ItemMoodlights
     * const { count } = await prisma.itemMoodlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemMoodlightDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemMoodlightDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemMoodlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemMoodlights
     * const itemMoodlight = await prisma.itemMoodlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemMoodlightUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMoodlightUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemMoodlight.
     * @param {ItemMoodlightUpsertArgs} args - Arguments to update or create a ItemMoodlight.
     * @example
     * // Update or create a ItemMoodlight
     * const itemMoodlight = await prisma.itemMoodlight.upsert({
     *   create: {
     *     // ... data to create a ItemMoodlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemMoodlight we want to update
     *   }
     * })
    **/
    upsert<T extends ItemMoodlightUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemMoodlightUpsertArgs<ExtArgs>>
    ): Prisma__ItemMoodlightClient<$Result.GetResult<Prisma.$ItemMoodlightPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemMoodlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightCountArgs} args - Arguments to filter ItemMoodlights to count.
     * @example
     * // Count the number of ItemMoodlights
     * const count = await prisma.itemMoodlight.count({
     *   where: {
     *     // ... the filter for the ItemMoodlights we want to count
     *   }
     * })
    **/
    count<T extends ItemMoodlightCountArgs>(
      args?: Subset<T, ItemMoodlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemMoodlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemMoodlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemMoodlightAggregateArgs>(args: Subset<T, ItemMoodlightAggregateArgs>): Prisma.PrismaPromise<GetItemMoodlightAggregateType<T>>

    /**
     * Group by ItemMoodlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMoodlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemMoodlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemMoodlightGroupByArgs['orderBy'] }
        : { orderBy?: ItemMoodlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemMoodlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemMoodlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemMoodlight model
   */
  readonly fields: ItemMoodlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemMoodlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemMoodlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemMoodlight model
   */ 
  interface ItemMoodlightFieldRefs {
    readonly itemId: FieldRef<"ItemMoodlight", 'Int'>
    readonly enabled: FieldRef<"ItemMoodlight", 'Boolean'>
    readonly currentPreset: FieldRef<"ItemMoodlight", 'Int'>
    readonly presetOne: FieldRef<"ItemMoodlight", 'String'>
    readonly presetTwo: FieldRef<"ItemMoodlight", 'String'>
    readonly presetThree: FieldRef<"ItemMoodlight", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ItemMoodlight findUnique
   */
  export type ItemMoodlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * Filter, which ItemMoodlight to fetch.
     */
    where: ItemMoodlightWhereUniqueInput
  }


  /**
   * ItemMoodlight findUniqueOrThrow
   */
  export type ItemMoodlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * Filter, which ItemMoodlight to fetch.
     */
    where: ItemMoodlightWhereUniqueInput
  }


  /**
   * ItemMoodlight findFirst
   */
  export type ItemMoodlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * Filter, which ItemMoodlight to fetch.
     */
    where?: ItemMoodlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMoodlights to fetch.
     */
    orderBy?: ItemMoodlightOrderByWithRelationInput | ItemMoodlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemMoodlights.
     */
    cursor?: ItemMoodlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMoodlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMoodlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemMoodlights.
     */
    distinct?: ItemMoodlightScalarFieldEnum | ItemMoodlightScalarFieldEnum[]
  }


  /**
   * ItemMoodlight findFirstOrThrow
   */
  export type ItemMoodlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * Filter, which ItemMoodlight to fetch.
     */
    where?: ItemMoodlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMoodlights to fetch.
     */
    orderBy?: ItemMoodlightOrderByWithRelationInput | ItemMoodlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemMoodlights.
     */
    cursor?: ItemMoodlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMoodlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMoodlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemMoodlights.
     */
    distinct?: ItemMoodlightScalarFieldEnum | ItemMoodlightScalarFieldEnum[]
  }


  /**
   * ItemMoodlight findMany
   */
  export type ItemMoodlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * Filter, which ItemMoodlights to fetch.
     */
    where?: ItemMoodlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMoodlights to fetch.
     */
    orderBy?: ItemMoodlightOrderByWithRelationInput | ItemMoodlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemMoodlights.
     */
    cursor?: ItemMoodlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMoodlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMoodlights.
     */
    skip?: number
    distinct?: ItemMoodlightScalarFieldEnum | ItemMoodlightScalarFieldEnum[]
  }


  /**
   * ItemMoodlight create
   */
  export type ItemMoodlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * The data needed to create a ItemMoodlight.
     */
    data: XOR<ItemMoodlightCreateInput, ItemMoodlightUncheckedCreateInput>
  }


  /**
   * ItemMoodlight createMany
   */
  export type ItemMoodlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemMoodlights.
     */
    data: ItemMoodlightCreateManyInput | ItemMoodlightCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemMoodlight update
   */
  export type ItemMoodlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * The data needed to update a ItemMoodlight.
     */
    data: XOR<ItemMoodlightUpdateInput, ItemMoodlightUncheckedUpdateInput>
    /**
     * Choose, which ItemMoodlight to update.
     */
    where: ItemMoodlightWhereUniqueInput
  }


  /**
   * ItemMoodlight updateMany
   */
  export type ItemMoodlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemMoodlights.
     */
    data: XOR<ItemMoodlightUpdateManyMutationInput, ItemMoodlightUncheckedUpdateManyInput>
    /**
     * Filter which ItemMoodlights to update
     */
    where?: ItemMoodlightWhereInput
  }


  /**
   * ItemMoodlight upsert
   */
  export type ItemMoodlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * The filter to search for the ItemMoodlight to update in case it exists.
     */
    where: ItemMoodlightWhereUniqueInput
    /**
     * In case the ItemMoodlight found by the `where` argument doesn't exist, create a new ItemMoodlight with this data.
     */
    create: XOR<ItemMoodlightCreateInput, ItemMoodlightUncheckedCreateInput>
    /**
     * In case the ItemMoodlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemMoodlightUpdateInput, ItemMoodlightUncheckedUpdateInput>
  }


  /**
   * ItemMoodlight delete
   */
  export type ItemMoodlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
    /**
     * Filter which ItemMoodlight to delete.
     */
    where: ItemMoodlightWhereUniqueInput
  }


  /**
   * ItemMoodlight deleteMany
   */
  export type ItemMoodlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemMoodlights to delete
     */
    where?: ItemMoodlightWhereInput
  }


  /**
   * ItemMoodlight without action
   */
  export type ItemMoodlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMoodlight
     */
    select?: ItemMoodlightSelect<ExtArgs> | null
  }



  /**
   * Model ItemPresent
   */

  export type AggregateItemPresent = {
    _count: ItemPresentCountAggregateOutputType | null
    _avg: ItemPresentAvgAggregateOutputType | null
    _sum: ItemPresentSumAggregateOutputType | null
    _min: ItemPresentMinAggregateOutputType | null
    _max: ItemPresentMaxAggregateOutputType | null
  }

  export type ItemPresentAvgAggregateOutputType = {
    itemId: number | null
    baseId: number | null
  }

  export type ItemPresentSumAggregateOutputType = {
    itemId: number | null
    baseId: number | null
  }

  export type ItemPresentMinAggregateOutputType = {
    itemId: number | null
    baseId: number | null
    extraData: string | null
  }

  export type ItemPresentMaxAggregateOutputType = {
    itemId: number | null
    baseId: number | null
    extraData: string | null
  }

  export type ItemPresentCountAggregateOutputType = {
    itemId: number
    baseId: number
    extraData: number
    _all: number
  }


  export type ItemPresentAvgAggregateInputType = {
    itemId?: true
    baseId?: true
  }

  export type ItemPresentSumAggregateInputType = {
    itemId?: true
    baseId?: true
  }

  export type ItemPresentMinAggregateInputType = {
    itemId?: true
    baseId?: true
    extraData?: true
  }

  export type ItemPresentMaxAggregateInputType = {
    itemId?: true
    baseId?: true
    extraData?: true
  }

  export type ItemPresentCountAggregateInputType = {
    itemId?: true
    baseId?: true
    extraData?: true
    _all?: true
  }

  export type ItemPresentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemPresent to aggregate.
     */
    where?: ItemPresentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPresents to fetch.
     */
    orderBy?: ItemPresentOrderByWithRelationInput | ItemPresentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemPresentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPresents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPresents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemPresents
    **/
    _count?: true | ItemPresentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemPresentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemPresentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemPresentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemPresentMaxAggregateInputType
  }

  export type GetItemPresentAggregateType<T extends ItemPresentAggregateArgs> = {
        [P in keyof T & keyof AggregateItemPresent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemPresent[P]>
      : GetScalarType<T[P], AggregateItemPresent[P]>
  }




  export type ItemPresentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemPresentWhereInput
    orderBy?: ItemPresentOrderByWithAggregationInput | ItemPresentOrderByWithAggregationInput[]
    by: ItemPresentScalarFieldEnum[] | ItemPresentScalarFieldEnum
    having?: ItemPresentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemPresentCountAggregateInputType | true
    _avg?: ItemPresentAvgAggregateInputType
    _sum?: ItemPresentSumAggregateInputType
    _min?: ItemPresentMinAggregateInputType
    _max?: ItemPresentMaxAggregateInputType
  }

  export type ItemPresentGroupByOutputType = {
    itemId: number
    baseId: number
    extraData: string | null
    _count: ItemPresentCountAggregateOutputType | null
    _avg: ItemPresentAvgAggregateOutputType | null
    _sum: ItemPresentSumAggregateOutputType | null
    _min: ItemPresentMinAggregateOutputType | null
    _max: ItemPresentMaxAggregateOutputType | null
  }

  type GetItemPresentGroupByPayload<T extends ItemPresentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemPresentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemPresentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemPresentGroupByOutputType[P]>
            : GetScalarType<T[P], ItemPresentGroupByOutputType[P]>
        }
      >
    >


  export type ItemPresentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    baseId?: boolean
    extraData?: boolean
  }, ExtArgs["result"]["itemPresent"]>

  export type ItemPresentSelectScalar = {
    itemId?: boolean
    baseId?: boolean
    extraData?: boolean
  }


  export type $ItemPresentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemPresent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      itemId: number
      baseId: number
      extraData: string | null
    }, ExtArgs["result"]["itemPresent"]>
    composites: {}
  }


  type ItemPresentGetPayload<S extends boolean | null | undefined | ItemPresentDefaultArgs> = $Result.GetResult<Prisma.$ItemPresentPayload, S>

  type ItemPresentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemPresentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemPresentCountAggregateInputType | true
    }

  export interface ItemPresentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemPresent'], meta: { name: 'ItemPresent' } }
    /**
     * Find zero or one ItemPresent that matches the filter.
     * @param {ItemPresentFindUniqueArgs} args - Arguments to find a ItemPresent
     * @example
     * // Get one ItemPresent
     * const itemPresent = await prisma.itemPresent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemPresentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemPresentFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemPresent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemPresentFindUniqueOrThrowArgs} args - Arguments to find a ItemPresent
     * @example
     * // Get one ItemPresent
     * const itemPresent = await prisma.itemPresent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemPresentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemPresentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemPresent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentFindFirstArgs} args - Arguments to find a ItemPresent
     * @example
     * // Get one ItemPresent
     * const itemPresent = await prisma.itemPresent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemPresentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemPresentFindFirstArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemPresent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentFindFirstOrThrowArgs} args - Arguments to find a ItemPresent
     * @example
     * // Get one ItemPresent
     * const itemPresent = await prisma.itemPresent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemPresentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemPresentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemPresents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemPresents
     * const itemPresents = await prisma.itemPresent.findMany()
     * 
     * // Get first 10 ItemPresents
     * const itemPresents = await prisma.itemPresent.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemPresentWithItemIdOnly = await prisma.itemPresent.findMany({ select: { itemId: true } })
     * 
    **/
    findMany<T extends ItemPresentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemPresentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemPresent.
     * @param {ItemPresentCreateArgs} args - Arguments to create a ItemPresent.
     * @example
     * // Create one ItemPresent
     * const ItemPresent = await prisma.itemPresent.create({
     *   data: {
     *     // ... data to create a ItemPresent
     *   }
     * })
     * 
    **/
    create<T extends ItemPresentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemPresentCreateArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemPresents.
     *     @param {ItemPresentCreateManyArgs} args - Arguments to create many ItemPresents.
     *     @example
     *     // Create many ItemPresents
     *     const itemPresent = await prisma.itemPresent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemPresentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemPresentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemPresent.
     * @param {ItemPresentDeleteArgs} args - Arguments to delete one ItemPresent.
     * @example
     * // Delete one ItemPresent
     * const ItemPresent = await prisma.itemPresent.delete({
     *   where: {
     *     // ... filter to delete one ItemPresent
     *   }
     * })
     * 
    **/
    delete<T extends ItemPresentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemPresentDeleteArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemPresent.
     * @param {ItemPresentUpdateArgs} args - Arguments to update one ItemPresent.
     * @example
     * // Update one ItemPresent
     * const itemPresent = await prisma.itemPresent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemPresentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemPresentUpdateArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemPresents.
     * @param {ItemPresentDeleteManyArgs} args - Arguments to filter ItemPresents to delete.
     * @example
     * // Delete a few ItemPresents
     * const { count } = await prisma.itemPresent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemPresentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemPresentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemPresents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemPresents
     * const itemPresent = await prisma.itemPresent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemPresentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemPresentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemPresent.
     * @param {ItemPresentUpsertArgs} args - Arguments to update or create a ItemPresent.
     * @example
     * // Update or create a ItemPresent
     * const itemPresent = await prisma.itemPresent.upsert({
     *   create: {
     *     // ... data to create a ItemPresent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemPresent we want to update
     *   }
     * })
    **/
    upsert<T extends ItemPresentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemPresentUpsertArgs<ExtArgs>>
    ): Prisma__ItemPresentClient<$Result.GetResult<Prisma.$ItemPresentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemPresents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentCountArgs} args - Arguments to filter ItemPresents to count.
     * @example
     * // Count the number of ItemPresents
     * const count = await prisma.itemPresent.count({
     *   where: {
     *     // ... the filter for the ItemPresents we want to count
     *   }
     * })
    **/
    count<T extends ItemPresentCountArgs>(
      args?: Subset<T, ItemPresentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemPresentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemPresent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemPresentAggregateArgs>(args: Subset<T, ItemPresentAggregateArgs>): Prisma.PrismaPromise<GetItemPresentAggregateType<T>>

    /**
     * Group by ItemPresent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemPresentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemPresentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemPresentGroupByArgs['orderBy'] }
        : { orderBy?: ItemPresentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemPresentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemPresentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemPresent model
   */
  readonly fields: ItemPresentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemPresent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemPresentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemPresent model
   */ 
  interface ItemPresentFieldRefs {
    readonly itemId: FieldRef<"ItemPresent", 'Int'>
    readonly baseId: FieldRef<"ItemPresent", 'Int'>
    readonly extraData: FieldRef<"ItemPresent", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ItemPresent findUnique
   */
  export type ItemPresentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * Filter, which ItemPresent to fetch.
     */
    where: ItemPresentWhereUniqueInput
  }


  /**
   * ItemPresent findUniqueOrThrow
   */
  export type ItemPresentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * Filter, which ItemPresent to fetch.
     */
    where: ItemPresentWhereUniqueInput
  }


  /**
   * ItemPresent findFirst
   */
  export type ItemPresentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * Filter, which ItemPresent to fetch.
     */
    where?: ItemPresentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPresents to fetch.
     */
    orderBy?: ItemPresentOrderByWithRelationInput | ItemPresentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemPresents.
     */
    cursor?: ItemPresentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPresents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPresents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemPresents.
     */
    distinct?: ItemPresentScalarFieldEnum | ItemPresentScalarFieldEnum[]
  }


  /**
   * ItemPresent findFirstOrThrow
   */
  export type ItemPresentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * Filter, which ItemPresent to fetch.
     */
    where?: ItemPresentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPresents to fetch.
     */
    orderBy?: ItemPresentOrderByWithRelationInput | ItemPresentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemPresents.
     */
    cursor?: ItemPresentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPresents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPresents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemPresents.
     */
    distinct?: ItemPresentScalarFieldEnum | ItemPresentScalarFieldEnum[]
  }


  /**
   * ItemPresent findMany
   */
  export type ItemPresentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * Filter, which ItemPresents to fetch.
     */
    where?: ItemPresentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemPresents to fetch.
     */
    orderBy?: ItemPresentOrderByWithRelationInput | ItemPresentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemPresents.
     */
    cursor?: ItemPresentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemPresents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemPresents.
     */
    skip?: number
    distinct?: ItemPresentScalarFieldEnum | ItemPresentScalarFieldEnum[]
  }


  /**
   * ItemPresent create
   */
  export type ItemPresentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * The data needed to create a ItemPresent.
     */
    data: XOR<ItemPresentCreateInput, ItemPresentUncheckedCreateInput>
  }


  /**
   * ItemPresent createMany
   */
  export type ItemPresentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemPresents.
     */
    data: ItemPresentCreateManyInput | ItemPresentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemPresent update
   */
  export type ItemPresentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * The data needed to update a ItemPresent.
     */
    data: XOR<ItemPresentUpdateInput, ItemPresentUncheckedUpdateInput>
    /**
     * Choose, which ItemPresent to update.
     */
    where: ItemPresentWhereUniqueInput
  }


  /**
   * ItemPresent updateMany
   */
  export type ItemPresentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemPresents.
     */
    data: XOR<ItemPresentUpdateManyMutationInput, ItemPresentUncheckedUpdateManyInput>
    /**
     * Filter which ItemPresents to update
     */
    where?: ItemPresentWhereInput
  }


  /**
   * ItemPresent upsert
   */
  export type ItemPresentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * The filter to search for the ItemPresent to update in case it exists.
     */
    where: ItemPresentWhereUniqueInput
    /**
     * In case the ItemPresent found by the `where` argument doesn't exist, create a new ItemPresent with this data.
     */
    create: XOR<ItemPresentCreateInput, ItemPresentUncheckedCreateInput>
    /**
     * In case the ItemPresent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemPresentUpdateInput, ItemPresentUncheckedUpdateInput>
  }


  /**
   * ItemPresent delete
   */
  export type ItemPresentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
    /**
     * Filter which ItemPresent to delete.
     */
    where: ItemPresentWhereUniqueInput
  }


  /**
   * ItemPresent deleteMany
   */
  export type ItemPresentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemPresents to delete
     */
    where?: ItemPresentWhereInput
  }


  /**
   * ItemPresent without action
   */
  export type ItemPresentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemPresent
     */
    select?: ItemPresentSelect<ExtArgs> | null
  }



  /**
   * Model ItemStat
   */

  export type AggregateItemStat = {
    _count: ItemStatCountAggregateOutputType | null
    _avg: ItemStatAvgAggregateOutputType | null
    _sum: ItemStatSumAggregateOutputType | null
    _min: ItemStatMinAggregateOutputType | null
    _max: ItemStatMaxAggregateOutputType | null
  }

  export type ItemStatAvgAggregateOutputType = {
    baseId: number | null
    amount: number | null
  }

  export type ItemStatSumAggregateOutputType = {
    baseId: number | null
    amount: number | null
  }

  export type ItemStatMinAggregateOutputType = {
    baseId: number | null
    amount: number | null
  }

  export type ItemStatMaxAggregateOutputType = {
    baseId: number | null
    amount: number | null
  }

  export type ItemStatCountAggregateOutputType = {
    baseId: number
    amount: number
    _all: number
  }


  export type ItemStatAvgAggregateInputType = {
    baseId?: true
    amount?: true
  }

  export type ItemStatSumAggregateInputType = {
    baseId?: true
    amount?: true
  }

  export type ItemStatMinAggregateInputType = {
    baseId?: true
    amount?: true
  }

  export type ItemStatMaxAggregateInputType = {
    baseId?: true
    amount?: true
  }

  export type ItemStatCountAggregateInputType = {
    baseId?: true
    amount?: true
    _all?: true
  }

  export type ItemStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemStat to aggregate.
     */
    where?: ItemStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemStats to fetch.
     */
    orderBy?: ItemStatOrderByWithRelationInput | ItemStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemStats
    **/
    _count?: true | ItemStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemStatMaxAggregateInputType
  }

  export type GetItemStatAggregateType<T extends ItemStatAggregateArgs> = {
        [P in keyof T & keyof AggregateItemStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemStat[P]>
      : GetScalarType<T[P], AggregateItemStat[P]>
  }




  export type ItemStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemStatWhereInput
    orderBy?: ItemStatOrderByWithAggregationInput | ItemStatOrderByWithAggregationInput[]
    by: ItemStatScalarFieldEnum[] | ItemStatScalarFieldEnum
    having?: ItemStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemStatCountAggregateInputType | true
    _avg?: ItemStatAvgAggregateInputType
    _sum?: ItemStatSumAggregateInputType
    _min?: ItemStatMinAggregateInputType
    _max?: ItemStatMaxAggregateInputType
  }

  export type ItemStatGroupByOutputType = {
    baseId: number
    amount: number
    _count: ItemStatCountAggregateOutputType | null
    _avg: ItemStatAvgAggregateOutputType | null
    _sum: ItemStatSumAggregateOutputType | null
    _min: ItemStatMinAggregateOutputType | null
    _max: ItemStatMaxAggregateOutputType | null
  }

  type GetItemStatGroupByPayload<T extends ItemStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemStatGroupByOutputType[P]>
            : GetScalarType<T[P], ItemStatGroupByOutputType[P]>
        }
      >
    >


  export type ItemStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    baseId?: boolean
    amount?: boolean
    itemBase?: boolean | ItemBaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemStat"]>

  export type ItemStatSelectScalar = {
    baseId?: boolean
    amount?: boolean
  }

  export type ItemStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemBase?: boolean | ItemBaseDefaultArgs<ExtArgs>
  }


  export type $ItemStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemStat"
    objects: {
      itemBase: Prisma.$ItemBasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      baseId: number
      amount: number
    }, ExtArgs["result"]["itemStat"]>
    composites: {}
  }


  type ItemStatGetPayload<S extends boolean | null | undefined | ItemStatDefaultArgs> = $Result.GetResult<Prisma.$ItemStatPayload, S>

  type ItemStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemStatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemStatCountAggregateInputType | true
    }

  export interface ItemStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemStat'], meta: { name: 'ItemStat' } }
    /**
     * Find zero or one ItemStat that matches the filter.
     * @param {ItemStatFindUniqueArgs} args - Arguments to find a ItemStat
     * @example
     * // Get one ItemStat
     * const itemStat = await prisma.itemStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemStatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemStatFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemStat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemStatFindUniqueOrThrowArgs} args - Arguments to find a ItemStat
     * @example
     * // Get one ItemStat
     * const itemStat = await prisma.itemStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemStatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemStatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatFindFirstArgs} args - Arguments to find a ItemStat
     * @example
     * // Get one ItemStat
     * const itemStat = await prisma.itemStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemStatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemStatFindFirstArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatFindFirstOrThrowArgs} args - Arguments to find a ItemStat
     * @example
     * // Get one ItemStat
     * const itemStat = await prisma.itemStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemStatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemStatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemStats
     * const itemStats = await prisma.itemStat.findMany()
     * 
     * // Get first 10 ItemStats
     * const itemStats = await prisma.itemStat.findMany({ take: 10 })
     * 
     * // Only select the `baseId`
     * const itemStatWithBaseIdOnly = await prisma.itemStat.findMany({ select: { baseId: true } })
     * 
    **/
    findMany<T extends ItemStatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemStatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemStat.
     * @param {ItemStatCreateArgs} args - Arguments to create a ItemStat.
     * @example
     * // Create one ItemStat
     * const ItemStat = await prisma.itemStat.create({
     *   data: {
     *     // ... data to create a ItemStat
     *   }
     * })
     * 
    **/
    create<T extends ItemStatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemStatCreateArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemStats.
     *     @param {ItemStatCreateManyArgs} args - Arguments to create many ItemStats.
     *     @example
     *     // Create many ItemStats
     *     const itemStat = await prisma.itemStat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemStatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemStatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemStat.
     * @param {ItemStatDeleteArgs} args - Arguments to delete one ItemStat.
     * @example
     * // Delete one ItemStat
     * const ItemStat = await prisma.itemStat.delete({
     *   where: {
     *     // ... filter to delete one ItemStat
     *   }
     * })
     * 
    **/
    delete<T extends ItemStatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemStatDeleteArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemStat.
     * @param {ItemStatUpdateArgs} args - Arguments to update one ItemStat.
     * @example
     * // Update one ItemStat
     * const itemStat = await prisma.itemStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemStatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemStatUpdateArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemStats.
     * @param {ItemStatDeleteManyArgs} args - Arguments to filter ItemStats to delete.
     * @example
     * // Delete a few ItemStats
     * const { count } = await prisma.itemStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemStatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemStatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemStats
     * const itemStat = await prisma.itemStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemStatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemStatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemStat.
     * @param {ItemStatUpsertArgs} args - Arguments to update or create a ItemStat.
     * @example
     * // Update or create a ItemStat
     * const itemStat = await prisma.itemStat.upsert({
     *   create: {
     *     // ... data to create a ItemStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemStat we want to update
     *   }
     * })
    **/
    upsert<T extends ItemStatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemStatUpsertArgs<ExtArgs>>
    ): Prisma__ItemStatClient<$Result.GetResult<Prisma.$ItemStatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatCountArgs} args - Arguments to filter ItemStats to count.
     * @example
     * // Count the number of ItemStats
     * const count = await prisma.itemStat.count({
     *   where: {
     *     // ... the filter for the ItemStats we want to count
     *   }
     * })
    **/
    count<T extends ItemStatCountArgs>(
      args?: Subset<T, ItemStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemStatAggregateArgs>(args: Subset<T, ItemStatAggregateArgs>): Prisma.PrismaPromise<GetItemStatAggregateType<T>>

    /**
     * Group by ItemStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemStatGroupByArgs['orderBy'] }
        : { orderBy?: ItemStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemStat model
   */
  readonly fields: ItemStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    itemBase<T extends ItemBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemBaseDefaultArgs<ExtArgs>>): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemStat model
   */ 
  interface ItemStatFieldRefs {
    readonly baseId: FieldRef<"ItemStat", 'Int'>
    readonly amount: FieldRef<"ItemStat", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemStat findUnique
   */
  export type ItemStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * Filter, which ItemStat to fetch.
     */
    where: ItemStatWhereUniqueInput
  }


  /**
   * ItemStat findUniqueOrThrow
   */
  export type ItemStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * Filter, which ItemStat to fetch.
     */
    where: ItemStatWhereUniqueInput
  }


  /**
   * ItemStat findFirst
   */
  export type ItemStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * Filter, which ItemStat to fetch.
     */
    where?: ItemStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemStats to fetch.
     */
    orderBy?: ItemStatOrderByWithRelationInput | ItemStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemStats.
     */
    cursor?: ItemStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemStats.
     */
    distinct?: ItemStatScalarFieldEnum | ItemStatScalarFieldEnum[]
  }


  /**
   * ItemStat findFirstOrThrow
   */
  export type ItemStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * Filter, which ItemStat to fetch.
     */
    where?: ItemStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemStats to fetch.
     */
    orderBy?: ItemStatOrderByWithRelationInput | ItemStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemStats.
     */
    cursor?: ItemStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemStats.
     */
    distinct?: ItemStatScalarFieldEnum | ItemStatScalarFieldEnum[]
  }


  /**
   * ItemStat findMany
   */
  export type ItemStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * Filter, which ItemStats to fetch.
     */
    where?: ItemStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemStats to fetch.
     */
    orderBy?: ItemStatOrderByWithRelationInput | ItemStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemStats.
     */
    cursor?: ItemStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemStats.
     */
    skip?: number
    distinct?: ItemStatScalarFieldEnum | ItemStatScalarFieldEnum[]
  }


  /**
   * ItemStat create
   */
  export type ItemStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemStat.
     */
    data: XOR<ItemStatCreateInput, ItemStatUncheckedCreateInput>
  }


  /**
   * ItemStat createMany
   */
  export type ItemStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemStats.
     */
    data: ItemStatCreateManyInput | ItemStatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemStat update
   */
  export type ItemStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemStat.
     */
    data: XOR<ItemStatUpdateInput, ItemStatUncheckedUpdateInput>
    /**
     * Choose, which ItemStat to update.
     */
    where: ItemStatWhereUniqueInput
  }


  /**
   * ItemStat updateMany
   */
  export type ItemStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemStats.
     */
    data: XOR<ItemStatUpdateManyMutationInput, ItemStatUncheckedUpdateManyInput>
    /**
     * Filter which ItemStats to update
     */
    where?: ItemStatWhereInput
  }


  /**
   * ItemStat upsert
   */
  export type ItemStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemStat to update in case it exists.
     */
    where: ItemStatWhereUniqueInput
    /**
     * In case the ItemStat found by the `where` argument doesn't exist, create a new ItemStat with this data.
     */
    create: XOR<ItemStatCreateInput, ItemStatUncheckedCreateInput>
    /**
     * In case the ItemStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemStatUpdateInput, ItemStatUncheckedUpdateInput>
  }


  /**
   * ItemStat delete
   */
  export type ItemStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
    /**
     * Filter which ItemStat to delete.
     */
    where: ItemStatWhereUniqueInput
  }


  /**
   * ItemStat deleteMany
   */
  export type ItemStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemStats to delete
     */
    where?: ItemStatWhereInput
  }


  /**
   * ItemStat without action
   */
  export type ItemStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemStat
     */
    select?: ItemStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemStatInclude<ExtArgs> | null
  }



  /**
   * Model ItemTeleport
   */

  export type AggregateItemTeleport = {
    _count: ItemTeleportCountAggregateOutputType | null
    _avg: ItemTeleportAvgAggregateOutputType | null
    _sum: ItemTeleportSumAggregateOutputType | null
    _min: ItemTeleportMinAggregateOutputType | null
    _max: ItemTeleportMaxAggregateOutputType | null
  }

  export type ItemTeleportAvgAggregateOutputType = {
    teleOneId: number | null
    teleTwoId: number | null
  }

  export type ItemTeleportSumAggregateOutputType = {
    teleOneId: number | null
    teleTwoId: number | null
  }

  export type ItemTeleportMinAggregateOutputType = {
    teleOneId: number | null
    teleTwoId: number | null
  }

  export type ItemTeleportMaxAggregateOutputType = {
    teleOneId: number | null
    teleTwoId: number | null
  }

  export type ItemTeleportCountAggregateOutputType = {
    teleOneId: number
    teleTwoId: number
    _all: number
  }


  export type ItemTeleportAvgAggregateInputType = {
    teleOneId?: true
    teleTwoId?: true
  }

  export type ItemTeleportSumAggregateInputType = {
    teleOneId?: true
    teleTwoId?: true
  }

  export type ItemTeleportMinAggregateInputType = {
    teleOneId?: true
    teleTwoId?: true
  }

  export type ItemTeleportMaxAggregateInputType = {
    teleOneId?: true
    teleTwoId?: true
  }

  export type ItemTeleportCountAggregateInputType = {
    teleOneId?: true
    teleTwoId?: true
    _all?: true
  }

  export type ItemTeleportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTeleport to aggregate.
     */
    where?: ItemTeleportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTeleports to fetch.
     */
    orderBy?: ItemTeleportOrderByWithRelationInput | ItemTeleportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTeleportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTeleports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTeleports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTeleports
    **/
    _count?: true | ItemTeleportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTeleportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTeleportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTeleportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTeleportMaxAggregateInputType
  }

  export type GetItemTeleportAggregateType<T extends ItemTeleportAggregateArgs> = {
        [P in keyof T & keyof AggregateItemTeleport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemTeleport[P]>
      : GetScalarType<T[P], AggregateItemTeleport[P]>
  }




  export type ItemTeleportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTeleportWhereInput
    orderBy?: ItemTeleportOrderByWithAggregationInput | ItemTeleportOrderByWithAggregationInput[]
    by: ItemTeleportScalarFieldEnum[] | ItemTeleportScalarFieldEnum
    having?: ItemTeleportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTeleportCountAggregateInputType | true
    _avg?: ItemTeleportAvgAggregateInputType
    _sum?: ItemTeleportSumAggregateInputType
    _min?: ItemTeleportMinAggregateInputType
    _max?: ItemTeleportMaxAggregateInputType
  }

  export type ItemTeleportGroupByOutputType = {
    teleOneId: number
    teleTwoId: number
    _count: ItemTeleportCountAggregateOutputType | null
    _avg: ItemTeleportAvgAggregateOutputType | null
    _sum: ItemTeleportSumAggregateOutputType | null
    _min: ItemTeleportMinAggregateOutputType | null
    _max: ItemTeleportMaxAggregateOutputType | null
  }

  type GetItemTeleportGroupByPayload<T extends ItemTeleportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTeleportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTeleportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTeleportGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTeleportGroupByOutputType[P]>
        }
      >
    >


  export type ItemTeleportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teleOneId?: boolean
    teleTwoId?: boolean
  }, ExtArgs["result"]["itemTeleport"]>

  export type ItemTeleportSelectScalar = {
    teleOneId?: boolean
    teleTwoId?: boolean
  }


  export type $ItemTeleportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemTeleport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      teleOneId: number
      teleTwoId: number
    }, ExtArgs["result"]["itemTeleport"]>
    composites: {}
  }


  type ItemTeleportGetPayload<S extends boolean | null | undefined | ItemTeleportDefaultArgs> = $Result.GetResult<Prisma.$ItemTeleportPayload, S>

  type ItemTeleportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemTeleportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemTeleportCountAggregateInputType | true
    }

  export interface ItemTeleportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemTeleport'], meta: { name: 'ItemTeleport' } }
    /**
     * Find zero or one ItemTeleport that matches the filter.
     * @param {ItemTeleportFindUniqueArgs} args - Arguments to find a ItemTeleport
     * @example
     * // Get one ItemTeleport
     * const itemTeleport = await prisma.itemTeleport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemTeleportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTeleportFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemTeleport that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemTeleportFindUniqueOrThrowArgs} args - Arguments to find a ItemTeleport
     * @example
     * // Get one ItemTeleport
     * const itemTeleport = await prisma.itemTeleport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemTeleportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTeleportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemTeleport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportFindFirstArgs} args - Arguments to find a ItemTeleport
     * @example
     * // Get one ItemTeleport
     * const itemTeleport = await prisma.itemTeleport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemTeleportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTeleportFindFirstArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemTeleport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportFindFirstOrThrowArgs} args - Arguments to find a ItemTeleport
     * @example
     * // Get one ItemTeleport
     * const itemTeleport = await prisma.itemTeleport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemTeleportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTeleportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemTeleports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTeleports
     * const itemTeleports = await prisma.itemTeleport.findMany()
     * 
     * // Get first 10 ItemTeleports
     * const itemTeleports = await prisma.itemTeleport.findMany({ take: 10 })
     * 
     * // Only select the `teleOneId`
     * const itemTeleportWithTeleOneIdOnly = await prisma.itemTeleport.findMany({ select: { teleOneId: true } })
     * 
    **/
    findMany<T extends ItemTeleportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTeleportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemTeleport.
     * @param {ItemTeleportCreateArgs} args - Arguments to create a ItemTeleport.
     * @example
     * // Create one ItemTeleport
     * const ItemTeleport = await prisma.itemTeleport.create({
     *   data: {
     *     // ... data to create a ItemTeleport
     *   }
     * })
     * 
    **/
    create<T extends ItemTeleportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTeleportCreateArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemTeleports.
     *     @param {ItemTeleportCreateManyArgs} args - Arguments to create many ItemTeleports.
     *     @example
     *     // Create many ItemTeleports
     *     const itemTeleport = await prisma.itemTeleport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemTeleportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTeleportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemTeleport.
     * @param {ItemTeleportDeleteArgs} args - Arguments to delete one ItemTeleport.
     * @example
     * // Delete one ItemTeleport
     * const ItemTeleport = await prisma.itemTeleport.delete({
     *   where: {
     *     // ... filter to delete one ItemTeleport
     *   }
     * })
     * 
    **/
    delete<T extends ItemTeleportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTeleportDeleteArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemTeleport.
     * @param {ItemTeleportUpdateArgs} args - Arguments to update one ItemTeleport.
     * @example
     * // Update one ItemTeleport
     * const itemTeleport = await prisma.itemTeleport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemTeleportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTeleportUpdateArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemTeleports.
     * @param {ItemTeleportDeleteManyArgs} args - Arguments to filter ItemTeleports to delete.
     * @example
     * // Delete a few ItemTeleports
     * const { count } = await prisma.itemTeleport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemTeleportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemTeleportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTeleports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTeleports
     * const itemTeleport = await prisma.itemTeleport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemTeleportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTeleportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemTeleport.
     * @param {ItemTeleportUpsertArgs} args - Arguments to update or create a ItemTeleport.
     * @example
     * // Update or create a ItemTeleport
     * const itemTeleport = await prisma.itemTeleport.upsert({
     *   create: {
     *     // ... data to create a ItemTeleport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemTeleport we want to update
     *   }
     * })
    **/
    upsert<T extends ItemTeleportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemTeleportUpsertArgs<ExtArgs>>
    ): Prisma__ItemTeleportClient<$Result.GetResult<Prisma.$ItemTeleportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemTeleports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportCountArgs} args - Arguments to filter ItemTeleports to count.
     * @example
     * // Count the number of ItemTeleports
     * const count = await prisma.itemTeleport.count({
     *   where: {
     *     // ... the filter for the ItemTeleports we want to count
     *   }
     * })
    **/
    count<T extends ItemTeleportCountArgs>(
      args?: Subset<T, ItemTeleportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTeleportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemTeleport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTeleportAggregateArgs>(args: Subset<T, ItemTeleportAggregateArgs>): Prisma.PrismaPromise<GetItemTeleportAggregateType<T>>

    /**
     * Group by ItemTeleport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTeleportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTeleportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTeleportGroupByArgs['orderBy'] }
        : { orderBy?: ItemTeleportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTeleportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTeleportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemTeleport model
   */
  readonly fields: ItemTeleportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemTeleport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTeleportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemTeleport model
   */ 
  interface ItemTeleportFieldRefs {
    readonly teleOneId: FieldRef<"ItemTeleport", 'Int'>
    readonly teleTwoId: FieldRef<"ItemTeleport", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemTeleport findUnique
   */
  export type ItemTeleportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * Filter, which ItemTeleport to fetch.
     */
    where: ItemTeleportWhereUniqueInput
  }


  /**
   * ItemTeleport findUniqueOrThrow
   */
  export type ItemTeleportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * Filter, which ItemTeleport to fetch.
     */
    where: ItemTeleportWhereUniqueInput
  }


  /**
   * ItemTeleport findFirst
   */
  export type ItemTeleportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * Filter, which ItemTeleport to fetch.
     */
    where?: ItemTeleportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTeleports to fetch.
     */
    orderBy?: ItemTeleportOrderByWithRelationInput | ItemTeleportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTeleports.
     */
    cursor?: ItemTeleportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTeleports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTeleports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTeleports.
     */
    distinct?: ItemTeleportScalarFieldEnum | ItemTeleportScalarFieldEnum[]
  }


  /**
   * ItemTeleport findFirstOrThrow
   */
  export type ItemTeleportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * Filter, which ItemTeleport to fetch.
     */
    where?: ItemTeleportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTeleports to fetch.
     */
    orderBy?: ItemTeleportOrderByWithRelationInput | ItemTeleportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTeleports.
     */
    cursor?: ItemTeleportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTeleports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTeleports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTeleports.
     */
    distinct?: ItemTeleportScalarFieldEnum | ItemTeleportScalarFieldEnum[]
  }


  /**
   * ItemTeleport findMany
   */
  export type ItemTeleportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * Filter, which ItemTeleports to fetch.
     */
    where?: ItemTeleportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTeleports to fetch.
     */
    orderBy?: ItemTeleportOrderByWithRelationInput | ItemTeleportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTeleports.
     */
    cursor?: ItemTeleportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTeleports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTeleports.
     */
    skip?: number
    distinct?: ItemTeleportScalarFieldEnum | ItemTeleportScalarFieldEnum[]
  }


  /**
   * ItemTeleport create
   */
  export type ItemTeleportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * The data needed to create a ItemTeleport.
     */
    data: XOR<ItemTeleportCreateInput, ItemTeleportUncheckedCreateInput>
  }


  /**
   * ItemTeleport createMany
   */
  export type ItemTeleportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTeleports.
     */
    data: ItemTeleportCreateManyInput | ItemTeleportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemTeleport update
   */
  export type ItemTeleportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * The data needed to update a ItemTeleport.
     */
    data: XOR<ItemTeleportUpdateInput, ItemTeleportUncheckedUpdateInput>
    /**
     * Choose, which ItemTeleport to update.
     */
    where: ItemTeleportWhereUniqueInput
  }


  /**
   * ItemTeleport updateMany
   */
  export type ItemTeleportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTeleports.
     */
    data: XOR<ItemTeleportUpdateManyMutationInput, ItemTeleportUncheckedUpdateManyInput>
    /**
     * Filter which ItemTeleports to update
     */
    where?: ItemTeleportWhereInput
  }


  /**
   * ItemTeleport upsert
   */
  export type ItemTeleportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * The filter to search for the ItemTeleport to update in case it exists.
     */
    where: ItemTeleportWhereUniqueInput
    /**
     * In case the ItemTeleport found by the `where` argument doesn't exist, create a new ItemTeleport with this data.
     */
    create: XOR<ItemTeleportCreateInput, ItemTeleportUncheckedCreateInput>
    /**
     * In case the ItemTeleport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTeleportUpdateInput, ItemTeleportUncheckedUpdateInput>
  }


  /**
   * ItemTeleport delete
   */
  export type ItemTeleportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
    /**
     * Filter which ItemTeleport to delete.
     */
    where: ItemTeleportWhereUniqueInput
  }


  /**
   * ItemTeleport deleteMany
   */
  export type ItemTeleportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTeleports to delete
     */
    where?: ItemTeleportWhereInput
  }


  /**
   * ItemTeleport without action
   */
  export type ItemTeleportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTeleport
     */
    select?: ItemTeleportSelect<ExtArgs> | null
  }



  /**
   * Model ItemWired
   */

  export type AggregateItemWired = {
    _count: ItemWiredCountAggregateOutputType | null
    _avg: ItemWiredAvgAggregateOutputType | null
    _sum: ItemWiredSumAggregateOutputType | null
    _min: ItemWiredMinAggregateOutputType | null
    _max: ItemWiredMaxAggregateOutputType | null
  }

  export type ItemWiredAvgAggregateOutputType = {
    triggerId: number | null
    delay: number | null
  }

  export type ItemWiredSumAggregateOutputType = {
    triggerId: number | null
    delay: number | null
  }

  export type ItemWiredMinAggregateOutputType = {
    triggerId: number | null
    triggerData2: string | null
    triggerData: string | null
    allUserTriggerable: boolean | null
    triggersItem: string | null
    delay: number | null
  }

  export type ItemWiredMaxAggregateOutputType = {
    triggerId: number | null
    triggerData2: string | null
    triggerData: string | null
    allUserTriggerable: boolean | null
    triggersItem: string | null
    delay: number | null
  }

  export type ItemWiredCountAggregateOutputType = {
    triggerId: number
    triggerData2: number
    triggerData: number
    allUserTriggerable: number
    triggersItem: number
    delay: number
    _all: number
  }


  export type ItemWiredAvgAggregateInputType = {
    triggerId?: true
    delay?: true
  }

  export type ItemWiredSumAggregateInputType = {
    triggerId?: true
    delay?: true
  }

  export type ItemWiredMinAggregateInputType = {
    triggerId?: true
    triggerData2?: true
    triggerData?: true
    allUserTriggerable?: true
    triggersItem?: true
    delay?: true
  }

  export type ItemWiredMaxAggregateInputType = {
    triggerId?: true
    triggerData2?: true
    triggerData?: true
    allUserTriggerable?: true
    triggersItem?: true
    delay?: true
  }

  export type ItemWiredCountAggregateInputType = {
    triggerId?: true
    triggerData2?: true
    triggerData?: true
    allUserTriggerable?: true
    triggersItem?: true
    delay?: true
    _all?: true
  }

  export type ItemWiredAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemWired to aggregate.
     */
    where?: ItemWiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWireds to fetch.
     */
    orderBy?: ItemWiredOrderByWithRelationInput | ItemWiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemWireds
    **/
    _count?: true | ItemWiredCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemWiredAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemWiredSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemWiredMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemWiredMaxAggregateInputType
  }

  export type GetItemWiredAggregateType<T extends ItemWiredAggregateArgs> = {
        [P in keyof T & keyof AggregateItemWired]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemWired[P]>
      : GetScalarType<T[P], AggregateItemWired[P]>
  }




  export type ItemWiredGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWiredWhereInput
    orderBy?: ItemWiredOrderByWithAggregationInput | ItemWiredOrderByWithAggregationInput[]
    by: ItemWiredScalarFieldEnum[] | ItemWiredScalarFieldEnum
    having?: ItemWiredScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemWiredCountAggregateInputType | true
    _avg?: ItemWiredAvgAggregateInputType
    _sum?: ItemWiredSumAggregateInputType
    _min?: ItemWiredMinAggregateInputType
    _max?: ItemWiredMaxAggregateInputType
  }

  export type ItemWiredGroupByOutputType = {
    triggerId: number
    triggerData2: string | null
    triggerData: string | null
    allUserTriggerable: boolean
    triggersItem: string | null
    delay: number
    _count: ItemWiredCountAggregateOutputType | null
    _avg: ItemWiredAvgAggregateOutputType | null
    _sum: ItemWiredSumAggregateOutputType | null
    _min: ItemWiredMinAggregateOutputType | null
    _max: ItemWiredMaxAggregateOutputType | null
  }

  type GetItemWiredGroupByPayload<T extends ItemWiredGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemWiredGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemWiredGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemWiredGroupByOutputType[P]>
            : GetScalarType<T[P], ItemWiredGroupByOutputType[P]>
        }
      >
    >


  export type ItemWiredSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    triggerId?: boolean
    triggerData2?: boolean
    triggerData?: boolean
    allUserTriggerable?: boolean
    triggersItem?: boolean
    delay?: boolean
  }, ExtArgs["result"]["itemWired"]>

  export type ItemWiredSelectScalar = {
    triggerId?: boolean
    triggerData2?: boolean
    triggerData?: boolean
    allUserTriggerable?: boolean
    triggersItem?: boolean
    delay?: boolean
  }


  export type $ItemWiredPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemWired"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      triggerId: number
      triggerData2: string | null
      triggerData: string | null
      allUserTriggerable: boolean
      triggersItem: string | null
      delay: number
    }, ExtArgs["result"]["itemWired"]>
    composites: {}
  }


  type ItemWiredGetPayload<S extends boolean | null | undefined | ItemWiredDefaultArgs> = $Result.GetResult<Prisma.$ItemWiredPayload, S>

  type ItemWiredCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemWiredFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemWiredCountAggregateInputType | true
    }

  export interface ItemWiredDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemWired'], meta: { name: 'ItemWired' } }
    /**
     * Find zero or one ItemWired that matches the filter.
     * @param {ItemWiredFindUniqueArgs} args - Arguments to find a ItemWired
     * @example
     * // Get one ItemWired
     * const itemWired = await prisma.itemWired.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemWiredFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWiredFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ItemWired that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemWiredFindUniqueOrThrowArgs} args - Arguments to find a ItemWired
     * @example
     * // Get one ItemWired
     * const itemWired = await prisma.itemWired.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemWiredFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWiredFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ItemWired that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredFindFirstArgs} args - Arguments to find a ItemWired
     * @example
     * // Get one ItemWired
     * const itemWired = await prisma.itemWired.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemWiredFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWiredFindFirstArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ItemWired that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredFindFirstOrThrowArgs} args - Arguments to find a ItemWired
     * @example
     * // Get one ItemWired
     * const itemWired = await prisma.itemWired.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemWiredFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWiredFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ItemWireds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemWireds
     * const itemWireds = await prisma.itemWired.findMany()
     * 
     * // Get first 10 ItemWireds
     * const itemWireds = await prisma.itemWired.findMany({ take: 10 })
     * 
     * // Only select the `triggerId`
     * const itemWiredWithTriggerIdOnly = await prisma.itemWired.findMany({ select: { triggerId: true } })
     * 
    **/
    findMany<T extends ItemWiredFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWiredFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ItemWired.
     * @param {ItemWiredCreateArgs} args - Arguments to create a ItemWired.
     * @example
     * // Create one ItemWired
     * const ItemWired = await prisma.itemWired.create({
     *   data: {
     *     // ... data to create a ItemWired
     *   }
     * })
     * 
    **/
    create<T extends ItemWiredCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWiredCreateArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ItemWireds.
     *     @param {ItemWiredCreateManyArgs} args - Arguments to create many ItemWireds.
     *     @example
     *     // Create many ItemWireds
     *     const itemWired = await prisma.itemWired.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemWiredCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWiredCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemWired.
     * @param {ItemWiredDeleteArgs} args - Arguments to delete one ItemWired.
     * @example
     * // Delete one ItemWired
     * const ItemWired = await prisma.itemWired.delete({
     *   where: {
     *     // ... filter to delete one ItemWired
     *   }
     * })
     * 
    **/
    delete<T extends ItemWiredDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWiredDeleteArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ItemWired.
     * @param {ItemWiredUpdateArgs} args - Arguments to update one ItemWired.
     * @example
     * // Update one ItemWired
     * const itemWired = await prisma.itemWired.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemWiredUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWiredUpdateArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ItemWireds.
     * @param {ItemWiredDeleteManyArgs} args - Arguments to filter ItemWireds to delete.
     * @example
     * // Delete a few ItemWireds
     * const { count } = await prisma.itemWired.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemWiredDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemWiredDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemWireds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemWireds
     * const itemWired = await prisma.itemWired.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemWiredUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWiredUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemWired.
     * @param {ItemWiredUpsertArgs} args - Arguments to update or create a ItemWired.
     * @example
     * // Update or create a ItemWired
     * const itemWired = await prisma.itemWired.upsert({
     *   create: {
     *     // ... data to create a ItemWired
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemWired we want to update
     *   }
     * })
    **/
    upsert<T extends ItemWiredUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemWiredUpsertArgs<ExtArgs>>
    ): Prisma__ItemWiredClient<$Result.GetResult<Prisma.$ItemWiredPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ItemWireds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredCountArgs} args - Arguments to filter ItemWireds to count.
     * @example
     * // Count the number of ItemWireds
     * const count = await prisma.itemWired.count({
     *   where: {
     *     // ... the filter for the ItemWireds we want to count
     *   }
     * })
    **/
    count<T extends ItemWiredCountArgs>(
      args?: Subset<T, ItemWiredCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemWiredCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemWired.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemWiredAggregateArgs>(args: Subset<T, ItemWiredAggregateArgs>): Prisma.PrismaPromise<GetItemWiredAggregateType<T>>

    /**
     * Group by ItemWired.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemWiredGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemWiredGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemWiredGroupByArgs['orderBy'] }
        : { orderBy?: ItemWiredGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemWiredGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemWiredGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemWired model
   */
  readonly fields: ItemWiredFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemWired.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemWiredClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ItemWired model
   */ 
  interface ItemWiredFieldRefs {
    readonly triggerId: FieldRef<"ItemWired", 'Int'>
    readonly triggerData2: FieldRef<"ItemWired", 'String'>
    readonly triggerData: FieldRef<"ItemWired", 'String'>
    readonly allUserTriggerable: FieldRef<"ItemWired", 'Boolean'>
    readonly triggersItem: FieldRef<"ItemWired", 'String'>
    readonly delay: FieldRef<"ItemWired", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ItemWired findUnique
   */
  export type ItemWiredFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * Filter, which ItemWired to fetch.
     */
    where: ItemWiredWhereUniqueInput
  }


  /**
   * ItemWired findUniqueOrThrow
   */
  export type ItemWiredFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * Filter, which ItemWired to fetch.
     */
    where: ItemWiredWhereUniqueInput
  }


  /**
   * ItemWired findFirst
   */
  export type ItemWiredFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * Filter, which ItemWired to fetch.
     */
    where?: ItemWiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWireds to fetch.
     */
    orderBy?: ItemWiredOrderByWithRelationInput | ItemWiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemWireds.
     */
    cursor?: ItemWiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemWireds.
     */
    distinct?: ItemWiredScalarFieldEnum | ItemWiredScalarFieldEnum[]
  }


  /**
   * ItemWired findFirstOrThrow
   */
  export type ItemWiredFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * Filter, which ItemWired to fetch.
     */
    where?: ItemWiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWireds to fetch.
     */
    orderBy?: ItemWiredOrderByWithRelationInput | ItemWiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemWireds.
     */
    cursor?: ItemWiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemWireds.
     */
    distinct?: ItemWiredScalarFieldEnum | ItemWiredScalarFieldEnum[]
  }


  /**
   * ItemWired findMany
   */
  export type ItemWiredFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * Filter, which ItemWireds to fetch.
     */
    where?: ItemWiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemWireds to fetch.
     */
    orderBy?: ItemWiredOrderByWithRelationInput | ItemWiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemWireds.
     */
    cursor?: ItemWiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemWireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemWireds.
     */
    skip?: number
    distinct?: ItemWiredScalarFieldEnum | ItemWiredScalarFieldEnum[]
  }


  /**
   * ItemWired create
   */
  export type ItemWiredCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * The data needed to create a ItemWired.
     */
    data: XOR<ItemWiredCreateInput, ItemWiredUncheckedCreateInput>
  }


  /**
   * ItemWired createMany
   */
  export type ItemWiredCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemWireds.
     */
    data: ItemWiredCreateManyInput | ItemWiredCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ItemWired update
   */
  export type ItemWiredUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * The data needed to update a ItemWired.
     */
    data: XOR<ItemWiredUpdateInput, ItemWiredUncheckedUpdateInput>
    /**
     * Choose, which ItemWired to update.
     */
    where: ItemWiredWhereUniqueInput
  }


  /**
   * ItemWired updateMany
   */
  export type ItemWiredUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemWireds.
     */
    data: XOR<ItemWiredUpdateManyMutationInput, ItemWiredUncheckedUpdateManyInput>
    /**
     * Filter which ItemWireds to update
     */
    where?: ItemWiredWhereInput
  }


  /**
   * ItemWired upsert
   */
  export type ItemWiredUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * The filter to search for the ItemWired to update in case it exists.
     */
    where: ItemWiredWhereUniqueInput
    /**
     * In case the ItemWired found by the `where` argument doesn't exist, create a new ItemWired with this data.
     */
    create: XOR<ItemWiredCreateInput, ItemWiredUncheckedCreateInput>
    /**
     * In case the ItemWired was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemWiredUpdateInput, ItemWiredUncheckedUpdateInput>
  }


  /**
   * ItemWired delete
   */
  export type ItemWiredDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
    /**
     * Filter which ItemWired to delete.
     */
    where: ItemWiredWhereUniqueInput
  }


  /**
   * ItemWired deleteMany
   */
  export type ItemWiredDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemWireds to delete
     */
    where?: ItemWiredWhereInput
  }


  /**
   * ItemWired without action
   */
  export type ItemWiredDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemWired
     */
    select?: ItemWiredSelect<ExtArgs> | null
  }



  /**
   * Model LogChat
   */

  export type AggregateLogChat = {
    _count: LogChatCountAggregateOutputType | null
    _avg: LogChatAvgAggregateOutputType | null
    _sum: LogChatSumAggregateOutputType | null
    _min: LogChatMinAggregateOutputType | null
    _max: LogChatMaxAggregateOutputType | null
  }

  export type LogChatAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    timestamp: number | null
  }

  export type LogChatSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    timestamp: number | null
  }

  export type LogChatMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    userName: string | null
    timestamp: number | null
    message: string | null
    type: string | null
  }

  export type LogChatMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
    userName: string | null
    timestamp: number | null
    message: string | null
    type: string | null
  }

  export type LogChatCountAggregateOutputType = {
    id: number
    userId: number
    roomId: number
    userName: number
    timestamp: number
    message: number
    type: number
    _all: number
  }


  export type LogChatAvgAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    timestamp?: true
  }

  export type LogChatSumAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    timestamp?: true
  }

  export type LogChatMinAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    userName?: true
    timestamp?: true
    message?: true
    type?: true
  }

  export type LogChatMaxAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    userName?: true
    timestamp?: true
    message?: true
    type?: true
  }

  export type LogChatCountAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
    userName?: true
    timestamp?: true
    message?: true
    type?: true
    _all?: true
  }

  export type LogChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogChat to aggregate.
     */
    where?: LogChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChats to fetch.
     */
    orderBy?: LogChatOrderByWithRelationInput | LogChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogChats
    **/
    _count?: true | LogChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogChatMaxAggregateInputType
  }

  export type GetLogChatAggregateType<T extends LogChatAggregateArgs> = {
        [P in keyof T & keyof AggregateLogChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogChat[P]>
      : GetScalarType<T[P], AggregateLogChat[P]>
  }




  export type LogChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogChatWhereInput
    orderBy?: LogChatOrderByWithAggregationInput | LogChatOrderByWithAggregationInput[]
    by: LogChatScalarFieldEnum[] | LogChatScalarFieldEnum
    having?: LogChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogChatCountAggregateInputType | true
    _avg?: LogChatAvgAggregateInputType
    _sum?: LogChatSumAggregateInputType
    _min?: LogChatMinAggregateInputType
    _max?: LogChatMaxAggregateInputType
  }

  export type LogChatGroupByOutputType = {
    id: number
    userId: number
    roomId: number | null
    userName: string
    timestamp: number
    message: string
    type: string
    _count: LogChatCountAggregateOutputType | null
    _avg: LogChatAvgAggregateOutputType | null
    _sum: LogChatSumAggregateOutputType | null
    _min: LogChatMinAggregateOutputType | null
    _max: LogChatMaxAggregateOutputType | null
  }

  type GetLogChatGroupByPayload<T extends LogChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogChatGroupByOutputType[P]>
            : GetScalarType<T[P], LogChatGroupByOutputType[P]>
        }
      >
    >


  export type LogChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomId?: boolean
    userName?: boolean
    timestamp?: boolean
    message?: boolean
    type?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | LogChat$roomArgs<ExtArgs>
  }, ExtArgs["result"]["logChat"]>

  export type LogChatSelectScalar = {
    id?: boolean
    userId?: boolean
    roomId?: boolean
    userName?: boolean
    timestamp?: boolean
    message?: boolean
    type?: boolean
  }

  export type LogChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | LogChat$roomArgs<ExtArgs>
  }


  export type $LogChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogChat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roomId: number | null
      userName: string
      timestamp: number
      message: string
      type: string
    }, ExtArgs["result"]["logChat"]>
    composites: {}
  }


  type LogChatGetPayload<S extends boolean | null | undefined | LogChatDefaultArgs> = $Result.GetResult<Prisma.$LogChatPayload, S>

  type LogChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogChatCountAggregateInputType | true
    }

  export interface LogChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogChat'], meta: { name: 'LogChat' } }
    /**
     * Find zero or one LogChat that matches the filter.
     * @param {LogChatFindUniqueArgs} args - Arguments to find a LogChat
     * @example
     * // Get one LogChat
     * const logChat = await prisma.logChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogChatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatFindUniqueArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogChat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogChatFindUniqueOrThrowArgs} args - Arguments to find a LogChat
     * @example
     * // Get one LogChat
     * const logChat = await prisma.logChat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogChatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatFindFirstArgs} args - Arguments to find a LogChat
     * @example
     * // Get one LogChat
     * const logChat = await prisma.logChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogChatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatFindFirstArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogChat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatFindFirstOrThrowArgs} args - Arguments to find a LogChat
     * @example
     * // Get one LogChat
     * const logChat = await prisma.logChat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogChatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogChats
     * const logChats = await prisma.logChat.findMany()
     * 
     * // Get first 10 LogChats
     * const logChats = await prisma.logChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logChatWithIdOnly = await prisma.logChat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogChatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogChat.
     * @param {LogChatCreateArgs} args - Arguments to create a LogChat.
     * @example
     * // Create one LogChat
     * const LogChat = await prisma.logChat.create({
     *   data: {
     *     // ... data to create a LogChat
     *   }
     * })
     * 
    **/
    create<T extends LogChatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatCreateArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogChats.
     *     @param {LogChatCreateManyArgs} args - Arguments to create many LogChats.
     *     @example
     *     // Create many LogChats
     *     const logChat = await prisma.logChat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogChatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogChat.
     * @param {LogChatDeleteArgs} args - Arguments to delete one LogChat.
     * @example
     * // Delete one LogChat
     * const LogChat = await prisma.logChat.delete({
     *   where: {
     *     // ... filter to delete one LogChat
     *   }
     * })
     * 
    **/
    delete<T extends LogChatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatDeleteArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogChat.
     * @param {LogChatUpdateArgs} args - Arguments to update one LogChat.
     * @example
     * // Update one LogChat
     * const logChat = await prisma.logChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogChatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatUpdateArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogChats.
     * @param {LogChatDeleteManyArgs} args - Arguments to filter LogChats to delete.
     * @example
     * // Delete a few LogChats
     * const { count } = await prisma.logChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogChatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogChats
     * const logChat = await prisma.logChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogChatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogChat.
     * @param {LogChatUpsertArgs} args - Arguments to update or create a LogChat.
     * @example
     * // Update or create a LogChat
     * const logChat = await prisma.logChat.upsert({
     *   create: {
     *     // ... data to create a LogChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogChat we want to update
     *   }
     * })
    **/
    upsert<T extends LogChatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatUpsertArgs<ExtArgs>>
    ): Prisma__LogChatClient<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatCountArgs} args - Arguments to filter LogChats to count.
     * @example
     * // Count the number of LogChats
     * const count = await prisma.logChat.count({
     *   where: {
     *     // ... the filter for the LogChats we want to count
     *   }
     * })
    **/
    count<T extends LogChatCountArgs>(
      args?: Subset<T, LogChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogChatAggregateArgs>(args: Subset<T, LogChatAggregateArgs>): Prisma.PrismaPromise<GetLogChatAggregateType<T>>

    /**
     * Group by LogChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogChatGroupByArgs['orderBy'] }
        : { orderBy?: LogChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogChat model
   */
  readonly fields: LogChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    room<T extends LogChat$roomArgs<ExtArgs> = {}>(args?: Subset<T, LogChat$roomArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogChat model
   */ 
  interface LogChatFieldRefs {
    readonly id: FieldRef<"LogChat", 'Int'>
    readonly userId: FieldRef<"LogChat", 'Int'>
    readonly roomId: FieldRef<"LogChat", 'Int'>
    readonly userName: FieldRef<"LogChat", 'String'>
    readonly timestamp: FieldRef<"LogChat", 'Int'>
    readonly message: FieldRef<"LogChat", 'String'>
    readonly type: FieldRef<"LogChat", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LogChat findUnique
   */
  export type LogChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * Filter, which LogChat to fetch.
     */
    where: LogChatWhereUniqueInput
  }


  /**
   * LogChat findUniqueOrThrow
   */
  export type LogChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * Filter, which LogChat to fetch.
     */
    where: LogChatWhereUniqueInput
  }


  /**
   * LogChat findFirst
   */
  export type LogChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * Filter, which LogChat to fetch.
     */
    where?: LogChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChats to fetch.
     */
    orderBy?: LogChatOrderByWithRelationInput | LogChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogChats.
     */
    cursor?: LogChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogChats.
     */
    distinct?: LogChatScalarFieldEnum | LogChatScalarFieldEnum[]
  }


  /**
   * LogChat findFirstOrThrow
   */
  export type LogChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * Filter, which LogChat to fetch.
     */
    where?: LogChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChats to fetch.
     */
    orderBy?: LogChatOrderByWithRelationInput | LogChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogChats.
     */
    cursor?: LogChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogChats.
     */
    distinct?: LogChatScalarFieldEnum | LogChatScalarFieldEnum[]
  }


  /**
   * LogChat findMany
   */
  export type LogChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * Filter, which LogChats to fetch.
     */
    where?: LogChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChats to fetch.
     */
    orderBy?: LogChatOrderByWithRelationInput | LogChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogChats.
     */
    cursor?: LogChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChats.
     */
    skip?: number
    distinct?: LogChatScalarFieldEnum | LogChatScalarFieldEnum[]
  }


  /**
   * LogChat create
   */
  export type LogChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * The data needed to create a LogChat.
     */
    data: XOR<LogChatCreateInput, LogChatUncheckedCreateInput>
  }


  /**
   * LogChat createMany
   */
  export type LogChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogChats.
     */
    data: LogChatCreateManyInput | LogChatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogChat update
   */
  export type LogChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * The data needed to update a LogChat.
     */
    data: XOR<LogChatUpdateInput, LogChatUncheckedUpdateInput>
    /**
     * Choose, which LogChat to update.
     */
    where: LogChatWhereUniqueInput
  }


  /**
   * LogChat updateMany
   */
  export type LogChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogChats.
     */
    data: XOR<LogChatUpdateManyMutationInput, LogChatUncheckedUpdateManyInput>
    /**
     * Filter which LogChats to update
     */
    where?: LogChatWhereInput
  }


  /**
   * LogChat upsert
   */
  export type LogChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * The filter to search for the LogChat to update in case it exists.
     */
    where: LogChatWhereUniqueInput
    /**
     * In case the LogChat found by the `where` argument doesn't exist, create a new LogChat with this data.
     */
    create: XOR<LogChatCreateInput, LogChatUncheckedCreateInput>
    /**
     * In case the LogChat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogChatUpdateInput, LogChatUncheckedUpdateInput>
  }


  /**
   * LogChat delete
   */
  export type LogChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    /**
     * Filter which LogChat to delete.
     */
    where: LogChatWhereUniqueInput
  }


  /**
   * LogChat deleteMany
   */
  export type LogChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogChats to delete
     */
    where?: LogChatWhereInput
  }


  /**
   * LogChat.room
   */
  export type LogChat$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
  }


  /**
   * LogChat without action
   */
  export type LogChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
  }



  /**
   * Model LogChatPub
   */

  export type AggregateLogChatPub = {
    _count: LogChatPubCountAggregateOutputType | null
    _avg: LogChatPubAvgAggregateOutputType | null
    _sum: LogChatPubSumAggregateOutputType | null
    _min: LogChatPubMinAggregateOutputType | null
    _max: LogChatPubMaxAggregateOutputType | null
  }

  export type LogChatPubAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    timestamp: number | null
  }

  export type LogChatPubSumAggregateOutputType = {
    id: number | null
    userId: number | null
    timestamp: number | null
  }

  export type LogChatPubMinAggregateOutputType = {
    id: number | null
    userId: number | null
    userName: string | null
    timestamp: number | null
    message: string | null
  }

  export type LogChatPubMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    userName: string | null
    timestamp: number | null
    message: string | null
  }

  export type LogChatPubCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    timestamp: number
    message: number
    _all: number
  }


  export type LogChatPubAvgAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
  }

  export type LogChatPubSumAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
  }

  export type LogChatPubMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    timestamp?: true
    message?: true
  }

  export type LogChatPubMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    timestamp?: true
    message?: true
  }

  export type LogChatPubCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    timestamp?: true
    message?: true
    _all?: true
  }

  export type LogChatPubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogChatPub to aggregate.
     */
    where?: LogChatPubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChatPubs to fetch.
     */
    orderBy?: LogChatPubOrderByWithRelationInput | LogChatPubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogChatPubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChatPubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChatPubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogChatPubs
    **/
    _count?: true | LogChatPubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogChatPubAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogChatPubSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogChatPubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogChatPubMaxAggregateInputType
  }

  export type GetLogChatPubAggregateType<T extends LogChatPubAggregateArgs> = {
        [P in keyof T & keyof AggregateLogChatPub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogChatPub[P]>
      : GetScalarType<T[P], AggregateLogChatPub[P]>
  }




  export type LogChatPubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogChatPubWhereInput
    orderBy?: LogChatPubOrderByWithAggregationInput | LogChatPubOrderByWithAggregationInput[]
    by: LogChatPubScalarFieldEnum[] | LogChatPubScalarFieldEnum
    having?: LogChatPubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogChatPubCountAggregateInputType | true
    _avg?: LogChatPubAvgAggregateInputType
    _sum?: LogChatPubSumAggregateInputType
    _min?: LogChatPubMinAggregateInputType
    _max?: LogChatPubMaxAggregateInputType
  }

  export type LogChatPubGroupByOutputType = {
    id: number
    userId: number
    userName: string
    timestamp: number
    message: string
    _count: LogChatPubCountAggregateOutputType | null
    _avg: LogChatPubAvgAggregateOutputType | null
    _sum: LogChatPubSumAggregateOutputType | null
    _min: LogChatPubMinAggregateOutputType | null
    _max: LogChatPubMaxAggregateOutputType | null
  }

  type GetLogChatPubGroupByPayload<T extends LogChatPubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogChatPubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogChatPubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogChatPubGroupByOutputType[P]>
            : GetScalarType<T[P], LogChatPubGroupByOutputType[P]>
        }
      >
    >


  export type LogChatPubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    timestamp?: boolean
    message?: boolean
  }, ExtArgs["result"]["logChatPub"]>

  export type LogChatPubSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    timestamp?: boolean
    message?: boolean
  }


  export type $LogChatPubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogChatPub"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      userName: string
      timestamp: number
      message: string
    }, ExtArgs["result"]["logChatPub"]>
    composites: {}
  }


  type LogChatPubGetPayload<S extends boolean | null | undefined | LogChatPubDefaultArgs> = $Result.GetResult<Prisma.$LogChatPubPayload, S>

  type LogChatPubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogChatPubFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogChatPubCountAggregateInputType | true
    }

  export interface LogChatPubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogChatPub'], meta: { name: 'LogChatPub' } }
    /**
     * Find zero or one LogChatPub that matches the filter.
     * @param {LogChatPubFindUniqueArgs} args - Arguments to find a LogChatPub
     * @example
     * // Get one LogChatPub
     * const logChatPub = await prisma.logChatPub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogChatPubFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatPubFindUniqueArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogChatPub that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogChatPubFindUniqueOrThrowArgs} args - Arguments to find a LogChatPub
     * @example
     * // Get one LogChatPub
     * const logChatPub = await prisma.logChatPub.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogChatPubFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatPubFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogChatPub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubFindFirstArgs} args - Arguments to find a LogChatPub
     * @example
     * // Get one LogChatPub
     * const logChatPub = await prisma.logChatPub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogChatPubFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatPubFindFirstArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogChatPub that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubFindFirstOrThrowArgs} args - Arguments to find a LogChatPub
     * @example
     * // Get one LogChatPub
     * const logChatPub = await prisma.logChatPub.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogChatPubFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatPubFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogChatPubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogChatPubs
     * const logChatPubs = await prisma.logChatPub.findMany()
     * 
     * // Get first 10 LogChatPubs
     * const logChatPubs = await prisma.logChatPub.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logChatPubWithIdOnly = await prisma.logChatPub.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogChatPubFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatPubFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogChatPub.
     * @param {LogChatPubCreateArgs} args - Arguments to create a LogChatPub.
     * @example
     * // Create one LogChatPub
     * const LogChatPub = await prisma.logChatPub.create({
     *   data: {
     *     // ... data to create a LogChatPub
     *   }
     * })
     * 
    **/
    create<T extends LogChatPubCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatPubCreateArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogChatPubs.
     *     @param {LogChatPubCreateManyArgs} args - Arguments to create many LogChatPubs.
     *     @example
     *     // Create many LogChatPubs
     *     const logChatPub = await prisma.logChatPub.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogChatPubCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatPubCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogChatPub.
     * @param {LogChatPubDeleteArgs} args - Arguments to delete one LogChatPub.
     * @example
     * // Delete one LogChatPub
     * const LogChatPub = await prisma.logChatPub.delete({
     *   where: {
     *     // ... filter to delete one LogChatPub
     *   }
     * })
     * 
    **/
    delete<T extends LogChatPubDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatPubDeleteArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogChatPub.
     * @param {LogChatPubUpdateArgs} args - Arguments to update one LogChatPub.
     * @example
     * // Update one LogChatPub
     * const logChatPub = await prisma.logChatPub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogChatPubUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatPubUpdateArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogChatPubs.
     * @param {LogChatPubDeleteManyArgs} args - Arguments to filter LogChatPubs to delete.
     * @example
     * // Delete a few LogChatPubs
     * const { count } = await prisma.logChatPub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogChatPubDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogChatPubDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogChatPubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogChatPubs
     * const logChatPub = await prisma.logChatPub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogChatPubUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatPubUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogChatPub.
     * @param {LogChatPubUpsertArgs} args - Arguments to update or create a LogChatPub.
     * @example
     * // Update or create a LogChatPub
     * const logChatPub = await prisma.logChatPub.upsert({
     *   create: {
     *     // ... data to create a LogChatPub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogChatPub we want to update
     *   }
     * })
    **/
    upsert<T extends LogChatPubUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogChatPubUpsertArgs<ExtArgs>>
    ): Prisma__LogChatPubClient<$Result.GetResult<Prisma.$LogChatPubPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogChatPubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubCountArgs} args - Arguments to filter LogChatPubs to count.
     * @example
     * // Count the number of LogChatPubs
     * const count = await prisma.logChatPub.count({
     *   where: {
     *     // ... the filter for the LogChatPubs we want to count
     *   }
     * })
    **/
    count<T extends LogChatPubCountArgs>(
      args?: Subset<T, LogChatPubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogChatPubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogChatPub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogChatPubAggregateArgs>(args: Subset<T, LogChatPubAggregateArgs>): Prisma.PrismaPromise<GetLogChatPubAggregateType<T>>

    /**
     * Group by LogChatPub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogChatPubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogChatPubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogChatPubGroupByArgs['orderBy'] }
        : { orderBy?: LogChatPubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogChatPubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogChatPubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogChatPub model
   */
  readonly fields: LogChatPubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogChatPub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogChatPubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogChatPub model
   */ 
  interface LogChatPubFieldRefs {
    readonly id: FieldRef<"LogChatPub", 'Int'>
    readonly userId: FieldRef<"LogChatPub", 'Int'>
    readonly userName: FieldRef<"LogChatPub", 'String'>
    readonly timestamp: FieldRef<"LogChatPub", 'Int'>
    readonly message: FieldRef<"LogChatPub", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LogChatPub findUnique
   */
  export type LogChatPubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * Filter, which LogChatPub to fetch.
     */
    where: LogChatPubWhereUniqueInput
  }


  /**
   * LogChatPub findUniqueOrThrow
   */
  export type LogChatPubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * Filter, which LogChatPub to fetch.
     */
    where: LogChatPubWhereUniqueInput
  }


  /**
   * LogChatPub findFirst
   */
  export type LogChatPubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * Filter, which LogChatPub to fetch.
     */
    where?: LogChatPubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChatPubs to fetch.
     */
    orderBy?: LogChatPubOrderByWithRelationInput | LogChatPubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogChatPubs.
     */
    cursor?: LogChatPubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChatPubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChatPubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogChatPubs.
     */
    distinct?: LogChatPubScalarFieldEnum | LogChatPubScalarFieldEnum[]
  }


  /**
   * LogChatPub findFirstOrThrow
   */
  export type LogChatPubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * Filter, which LogChatPub to fetch.
     */
    where?: LogChatPubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChatPubs to fetch.
     */
    orderBy?: LogChatPubOrderByWithRelationInput | LogChatPubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogChatPubs.
     */
    cursor?: LogChatPubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChatPubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChatPubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogChatPubs.
     */
    distinct?: LogChatPubScalarFieldEnum | LogChatPubScalarFieldEnum[]
  }


  /**
   * LogChatPub findMany
   */
  export type LogChatPubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * Filter, which LogChatPubs to fetch.
     */
    where?: LogChatPubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogChatPubs to fetch.
     */
    orderBy?: LogChatPubOrderByWithRelationInput | LogChatPubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogChatPubs.
     */
    cursor?: LogChatPubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogChatPubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogChatPubs.
     */
    skip?: number
    distinct?: LogChatPubScalarFieldEnum | LogChatPubScalarFieldEnum[]
  }


  /**
   * LogChatPub create
   */
  export type LogChatPubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * The data needed to create a LogChatPub.
     */
    data: XOR<LogChatPubCreateInput, LogChatPubUncheckedCreateInput>
  }


  /**
   * LogChatPub createMany
   */
  export type LogChatPubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogChatPubs.
     */
    data: LogChatPubCreateManyInput | LogChatPubCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogChatPub update
   */
  export type LogChatPubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * The data needed to update a LogChatPub.
     */
    data: XOR<LogChatPubUpdateInput, LogChatPubUncheckedUpdateInput>
    /**
     * Choose, which LogChatPub to update.
     */
    where: LogChatPubWhereUniqueInput
  }


  /**
   * LogChatPub updateMany
   */
  export type LogChatPubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogChatPubs.
     */
    data: XOR<LogChatPubUpdateManyMutationInput, LogChatPubUncheckedUpdateManyInput>
    /**
     * Filter which LogChatPubs to update
     */
    where?: LogChatPubWhereInput
  }


  /**
   * LogChatPub upsert
   */
  export type LogChatPubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * The filter to search for the LogChatPub to update in case it exists.
     */
    where: LogChatPubWhereUniqueInput
    /**
     * In case the LogChatPub found by the `where` argument doesn't exist, create a new LogChatPub with this data.
     */
    create: XOR<LogChatPubCreateInput, LogChatPubUncheckedCreateInput>
    /**
     * In case the LogChatPub was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogChatPubUpdateInput, LogChatPubUncheckedUpdateInput>
  }


  /**
   * LogChatPub delete
   */
  export type LogChatPubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
    /**
     * Filter which LogChatPub to delete.
     */
    where: LogChatPubWhereUniqueInput
  }


  /**
   * LogChatPub deleteMany
   */
  export type LogChatPubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogChatPubs to delete
     */
    where?: LogChatPubWhereInput
  }


  /**
   * LogChatPub without action
   */
  export type LogChatPubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChatPub
     */
    select?: LogChatPubSelect<ExtArgs> | null
  }



  /**
   * Model LogCommand
   */

  export type AggregateLogCommand = {
    _count: LogCommandCountAggregateOutputType | null
    _avg: LogCommandAvgAggregateOutputType | null
    _sum: LogCommandSumAggregateOutputType | null
    _min: LogCommandMinAggregateOutputType | null
    _max: LogCommandMaxAggregateOutputType | null
  }

  export type LogCommandAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomid: number | null
    timestamp: number | null
  }

  export type LogCommandSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomid: number | null
    timestamp: number | null
  }

  export type LogCommandMinAggregateOutputType = {
    id: number | null
    userId: number | null
    userName: string | null
    roomid: number | null
    command: string | null
    extraData: string | null
    timestamp: number | null
  }

  export type LogCommandMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    userName: string | null
    roomid: number | null
    command: string | null
    extraData: string | null
    timestamp: number | null
  }

  export type LogCommandCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    roomid: number
    command: number
    extraData: number
    timestamp: number
    _all: number
  }


  export type LogCommandAvgAggregateInputType = {
    id?: true
    userId?: true
    roomid?: true
    timestamp?: true
  }

  export type LogCommandSumAggregateInputType = {
    id?: true
    userId?: true
    roomid?: true
    timestamp?: true
  }

  export type LogCommandMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    roomid?: true
    command?: true
    extraData?: true
    timestamp?: true
  }

  export type LogCommandMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    roomid?: true
    command?: true
    extraData?: true
    timestamp?: true
  }

  export type LogCommandCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    roomid?: true
    command?: true
    extraData?: true
    timestamp?: true
    _all?: true
  }

  export type LogCommandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogCommand to aggregate.
     */
    where?: LogCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogCommands to fetch.
     */
    orderBy?: LogCommandOrderByWithRelationInput | LogCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogCommands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogCommands
    **/
    _count?: true | LogCommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogCommandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogCommandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogCommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogCommandMaxAggregateInputType
  }

  export type GetLogCommandAggregateType<T extends LogCommandAggregateArgs> = {
        [P in keyof T & keyof AggregateLogCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogCommand[P]>
      : GetScalarType<T[P], AggregateLogCommand[P]>
  }




  export type LogCommandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogCommandWhereInput
    orderBy?: LogCommandOrderByWithAggregationInput | LogCommandOrderByWithAggregationInput[]
    by: LogCommandScalarFieldEnum[] | LogCommandScalarFieldEnum
    having?: LogCommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCommandCountAggregateInputType | true
    _avg?: LogCommandAvgAggregateInputType
    _sum?: LogCommandSumAggregateInputType
    _min?: LogCommandMinAggregateInputType
    _max?: LogCommandMaxAggregateInputType
  }

  export type LogCommandGroupByOutputType = {
    id: number
    userId: number
    userName: string
    roomid: number
    command: string
    extraData: string
    timestamp: number
    _count: LogCommandCountAggregateOutputType | null
    _avg: LogCommandAvgAggregateOutputType | null
    _sum: LogCommandSumAggregateOutputType | null
    _min: LogCommandMinAggregateOutputType | null
    _max: LogCommandMaxAggregateOutputType | null
  }

  type GetLogCommandGroupByPayload<T extends LogCommandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogCommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogCommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogCommandGroupByOutputType[P]>
            : GetScalarType<T[P], LogCommandGroupByOutputType[P]>
        }
      >
    >


  export type LogCommandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    roomid?: boolean
    command?: boolean
    extraData?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["logCommand"]>

  export type LogCommandSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    roomid?: boolean
    command?: boolean
    extraData?: boolean
    timestamp?: boolean
  }


  export type $LogCommandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogCommand"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      userName: string
      roomid: number
      command: string
      extraData: string
      timestamp: number
    }, ExtArgs["result"]["logCommand"]>
    composites: {}
  }


  type LogCommandGetPayload<S extends boolean | null | undefined | LogCommandDefaultArgs> = $Result.GetResult<Prisma.$LogCommandPayload, S>

  type LogCommandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogCommandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogCommandCountAggregateInputType | true
    }

  export interface LogCommandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogCommand'], meta: { name: 'LogCommand' } }
    /**
     * Find zero or one LogCommand that matches the filter.
     * @param {LogCommandFindUniqueArgs} args - Arguments to find a LogCommand
     * @example
     * // Get one LogCommand
     * const logCommand = await prisma.logCommand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogCommandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogCommandFindUniqueArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogCommand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogCommandFindUniqueOrThrowArgs} args - Arguments to find a LogCommand
     * @example
     * // Get one LogCommand
     * const logCommand = await prisma.logCommand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogCommandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCommandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogCommand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandFindFirstArgs} args - Arguments to find a LogCommand
     * @example
     * // Get one LogCommand
     * const logCommand = await prisma.logCommand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogCommandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCommandFindFirstArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogCommand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandFindFirstOrThrowArgs} args - Arguments to find a LogCommand
     * @example
     * // Get one LogCommand
     * const logCommand = await prisma.logCommand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogCommandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCommandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogCommands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogCommands
     * const logCommands = await prisma.logCommand.findMany()
     * 
     * // Get first 10 LogCommands
     * const logCommands = await prisma.logCommand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logCommandWithIdOnly = await prisma.logCommand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogCommandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCommandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogCommand.
     * @param {LogCommandCreateArgs} args - Arguments to create a LogCommand.
     * @example
     * // Create one LogCommand
     * const LogCommand = await prisma.logCommand.create({
     *   data: {
     *     // ... data to create a LogCommand
     *   }
     * })
     * 
    **/
    create<T extends LogCommandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogCommandCreateArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogCommands.
     *     @param {LogCommandCreateManyArgs} args - Arguments to create many LogCommands.
     *     @example
     *     // Create many LogCommands
     *     const logCommand = await prisma.logCommand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogCommandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCommandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogCommand.
     * @param {LogCommandDeleteArgs} args - Arguments to delete one LogCommand.
     * @example
     * // Delete one LogCommand
     * const LogCommand = await prisma.logCommand.delete({
     *   where: {
     *     // ... filter to delete one LogCommand
     *   }
     * })
     * 
    **/
    delete<T extends LogCommandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogCommandDeleteArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogCommand.
     * @param {LogCommandUpdateArgs} args - Arguments to update one LogCommand.
     * @example
     * // Update one LogCommand
     * const logCommand = await prisma.logCommand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogCommandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogCommandUpdateArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogCommands.
     * @param {LogCommandDeleteManyArgs} args - Arguments to filter LogCommands to delete.
     * @example
     * // Delete a few LogCommands
     * const { count } = await prisma.logCommand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogCommandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogCommandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogCommands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogCommands
     * const logCommand = await prisma.logCommand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogCommandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogCommandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogCommand.
     * @param {LogCommandUpsertArgs} args - Arguments to update or create a LogCommand.
     * @example
     * // Update or create a LogCommand
     * const logCommand = await prisma.logCommand.upsert({
     *   create: {
     *     // ... data to create a LogCommand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogCommand we want to update
     *   }
     * })
    **/
    upsert<T extends LogCommandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogCommandUpsertArgs<ExtArgs>>
    ): Prisma__LogCommandClient<$Result.GetResult<Prisma.$LogCommandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogCommands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandCountArgs} args - Arguments to filter LogCommands to count.
     * @example
     * // Count the number of LogCommands
     * const count = await prisma.logCommand.count({
     *   where: {
     *     // ... the filter for the LogCommands we want to count
     *   }
     * })
    **/
    count<T extends LogCommandCountArgs>(
      args?: Subset<T, LogCommandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogCommand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogCommandAggregateArgs>(args: Subset<T, LogCommandAggregateArgs>): Prisma.PrismaPromise<GetLogCommandAggregateType<T>>

    /**
     * Group by LogCommand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogCommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogCommandGroupByArgs['orderBy'] }
        : { orderBy?: LogCommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogCommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogCommandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogCommand model
   */
  readonly fields: LogCommandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogCommand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogCommandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogCommand model
   */ 
  interface LogCommandFieldRefs {
    readonly id: FieldRef<"LogCommand", 'Int'>
    readonly userId: FieldRef<"LogCommand", 'Int'>
    readonly userName: FieldRef<"LogCommand", 'String'>
    readonly roomid: FieldRef<"LogCommand", 'Int'>
    readonly command: FieldRef<"LogCommand", 'String'>
    readonly extraData: FieldRef<"LogCommand", 'String'>
    readonly timestamp: FieldRef<"LogCommand", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogCommand findUnique
   */
  export type LogCommandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * Filter, which LogCommand to fetch.
     */
    where: LogCommandWhereUniqueInput
  }


  /**
   * LogCommand findUniqueOrThrow
   */
  export type LogCommandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * Filter, which LogCommand to fetch.
     */
    where: LogCommandWhereUniqueInput
  }


  /**
   * LogCommand findFirst
   */
  export type LogCommandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * Filter, which LogCommand to fetch.
     */
    where?: LogCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogCommands to fetch.
     */
    orderBy?: LogCommandOrderByWithRelationInput | LogCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogCommands.
     */
    cursor?: LogCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogCommands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogCommands.
     */
    distinct?: LogCommandScalarFieldEnum | LogCommandScalarFieldEnum[]
  }


  /**
   * LogCommand findFirstOrThrow
   */
  export type LogCommandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * Filter, which LogCommand to fetch.
     */
    where?: LogCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogCommands to fetch.
     */
    orderBy?: LogCommandOrderByWithRelationInput | LogCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogCommands.
     */
    cursor?: LogCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogCommands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogCommands.
     */
    distinct?: LogCommandScalarFieldEnum | LogCommandScalarFieldEnum[]
  }


  /**
   * LogCommand findMany
   */
  export type LogCommandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * Filter, which LogCommands to fetch.
     */
    where?: LogCommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogCommands to fetch.
     */
    orderBy?: LogCommandOrderByWithRelationInput | LogCommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogCommands.
     */
    cursor?: LogCommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogCommands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogCommands.
     */
    skip?: number
    distinct?: LogCommandScalarFieldEnum | LogCommandScalarFieldEnum[]
  }


  /**
   * LogCommand create
   */
  export type LogCommandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * The data needed to create a LogCommand.
     */
    data: XOR<LogCommandCreateInput, LogCommandUncheckedCreateInput>
  }


  /**
   * LogCommand createMany
   */
  export type LogCommandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogCommands.
     */
    data: LogCommandCreateManyInput | LogCommandCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogCommand update
   */
  export type LogCommandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * The data needed to update a LogCommand.
     */
    data: XOR<LogCommandUpdateInput, LogCommandUncheckedUpdateInput>
    /**
     * Choose, which LogCommand to update.
     */
    where: LogCommandWhereUniqueInput
  }


  /**
   * LogCommand updateMany
   */
  export type LogCommandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogCommands.
     */
    data: XOR<LogCommandUpdateManyMutationInput, LogCommandUncheckedUpdateManyInput>
    /**
     * Filter which LogCommands to update
     */
    where?: LogCommandWhereInput
  }


  /**
   * LogCommand upsert
   */
  export type LogCommandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * The filter to search for the LogCommand to update in case it exists.
     */
    where: LogCommandWhereUniqueInput
    /**
     * In case the LogCommand found by the `where` argument doesn't exist, create a new LogCommand with this data.
     */
    create: XOR<LogCommandCreateInput, LogCommandUncheckedCreateInput>
    /**
     * In case the LogCommand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogCommandUpdateInput, LogCommandUncheckedUpdateInput>
  }


  /**
   * LogCommand delete
   */
  export type LogCommandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
    /**
     * Filter which LogCommand to delete.
     */
    where: LogCommandWhereUniqueInput
  }


  /**
   * LogCommand deleteMany
   */
  export type LogCommandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogCommands to delete
     */
    where?: LogCommandWhereInput
  }


  /**
   * LogCommand without action
   */
  export type LogCommandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogCommand
     */
    select?: LogCommandSelect<ExtArgs> | null
  }



  /**
   * Model LogFlagme
   */

  export type AggregateLogFlagme = {
    _count: LogFlagmeCountAggregateOutputType | null
    _avg: LogFlagmeAvgAggregateOutputType | null
    _sum: LogFlagmeSumAggregateOutputType | null
    _min: LogFlagmeMinAggregateOutputType | null
    _max: LogFlagmeMaxAggregateOutputType | null
  }

  export type LogFlagmeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    time: number | null
  }

  export type LogFlagmeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    time: number | null
  }

  export type LogFlagmeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    oldusername: string | null
    newusername: string | null
    time: number | null
  }

  export type LogFlagmeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    oldusername: string | null
    newusername: string | null
    time: number | null
  }

  export type LogFlagmeCountAggregateOutputType = {
    id: number
    userId: number
    oldusername: number
    newusername: number
    time: number
    _all: number
  }


  export type LogFlagmeAvgAggregateInputType = {
    id?: true
    userId?: true
    time?: true
  }

  export type LogFlagmeSumAggregateInputType = {
    id?: true
    userId?: true
    time?: true
  }

  export type LogFlagmeMinAggregateInputType = {
    id?: true
    userId?: true
    oldusername?: true
    newusername?: true
    time?: true
  }

  export type LogFlagmeMaxAggregateInputType = {
    id?: true
    userId?: true
    oldusername?: true
    newusername?: true
    time?: true
  }

  export type LogFlagmeCountAggregateInputType = {
    id?: true
    userId?: true
    oldusername?: true
    newusername?: true
    time?: true
    _all?: true
  }

  export type LogFlagmeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogFlagme to aggregate.
     */
    where?: LogFlagmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogFlagmes to fetch.
     */
    orderBy?: LogFlagmeOrderByWithRelationInput | LogFlagmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogFlagmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogFlagmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogFlagmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogFlagmes
    **/
    _count?: true | LogFlagmeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogFlagmeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogFlagmeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogFlagmeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogFlagmeMaxAggregateInputType
  }

  export type GetLogFlagmeAggregateType<T extends LogFlagmeAggregateArgs> = {
        [P in keyof T & keyof AggregateLogFlagme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogFlagme[P]>
      : GetScalarType<T[P], AggregateLogFlagme[P]>
  }




  export type LogFlagmeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogFlagmeWhereInput
    orderBy?: LogFlagmeOrderByWithAggregationInput | LogFlagmeOrderByWithAggregationInput[]
    by: LogFlagmeScalarFieldEnum[] | LogFlagmeScalarFieldEnum
    having?: LogFlagmeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogFlagmeCountAggregateInputType | true
    _avg?: LogFlagmeAvgAggregateInputType
    _sum?: LogFlagmeSumAggregateInputType
    _min?: LogFlagmeMinAggregateInputType
    _max?: LogFlagmeMaxAggregateInputType
  }

  export type LogFlagmeGroupByOutputType = {
    id: number
    userId: number
    oldusername: string
    newusername: string
    time: number
    _count: LogFlagmeCountAggregateOutputType | null
    _avg: LogFlagmeAvgAggregateOutputType | null
    _sum: LogFlagmeSumAggregateOutputType | null
    _min: LogFlagmeMinAggregateOutputType | null
    _max: LogFlagmeMaxAggregateOutputType | null
  }

  type GetLogFlagmeGroupByPayload<T extends LogFlagmeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogFlagmeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogFlagmeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogFlagmeGroupByOutputType[P]>
            : GetScalarType<T[P], LogFlagmeGroupByOutputType[P]>
        }
      >
    >


  export type LogFlagmeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    oldusername?: boolean
    newusername?: boolean
    time?: boolean
  }, ExtArgs["result"]["logFlagme"]>

  export type LogFlagmeSelectScalar = {
    id?: boolean
    userId?: boolean
    oldusername?: boolean
    newusername?: boolean
    time?: boolean
  }


  export type $LogFlagmePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogFlagme"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      oldusername: string
      newusername: string
      time: number
    }, ExtArgs["result"]["logFlagme"]>
    composites: {}
  }


  type LogFlagmeGetPayload<S extends boolean | null | undefined | LogFlagmeDefaultArgs> = $Result.GetResult<Prisma.$LogFlagmePayload, S>

  type LogFlagmeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFlagmeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogFlagmeCountAggregateInputType | true
    }

  export interface LogFlagmeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogFlagme'], meta: { name: 'LogFlagme' } }
    /**
     * Find zero or one LogFlagme that matches the filter.
     * @param {LogFlagmeFindUniqueArgs} args - Arguments to find a LogFlagme
     * @example
     * // Get one LogFlagme
     * const logFlagme = await prisma.logFlagme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogFlagmeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogFlagmeFindUniqueArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogFlagme that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogFlagmeFindUniqueOrThrowArgs} args - Arguments to find a LogFlagme
     * @example
     * // Get one LogFlagme
     * const logFlagme = await prisma.logFlagme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogFlagmeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFlagmeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogFlagme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeFindFirstArgs} args - Arguments to find a LogFlagme
     * @example
     * // Get one LogFlagme
     * const logFlagme = await prisma.logFlagme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogFlagmeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFlagmeFindFirstArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogFlagme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeFindFirstOrThrowArgs} args - Arguments to find a LogFlagme
     * @example
     * // Get one LogFlagme
     * const logFlagme = await prisma.logFlagme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogFlagmeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFlagmeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogFlagmes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogFlagmes
     * const logFlagmes = await prisma.logFlagme.findMany()
     * 
     * // Get first 10 LogFlagmes
     * const logFlagmes = await prisma.logFlagme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logFlagmeWithIdOnly = await prisma.logFlagme.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogFlagmeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFlagmeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogFlagme.
     * @param {LogFlagmeCreateArgs} args - Arguments to create a LogFlagme.
     * @example
     * // Create one LogFlagme
     * const LogFlagme = await prisma.logFlagme.create({
     *   data: {
     *     // ... data to create a LogFlagme
     *   }
     * })
     * 
    **/
    create<T extends LogFlagmeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogFlagmeCreateArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogFlagmes.
     *     @param {LogFlagmeCreateManyArgs} args - Arguments to create many LogFlagmes.
     *     @example
     *     // Create many LogFlagmes
     *     const logFlagme = await prisma.logFlagme.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogFlagmeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFlagmeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogFlagme.
     * @param {LogFlagmeDeleteArgs} args - Arguments to delete one LogFlagme.
     * @example
     * // Delete one LogFlagme
     * const LogFlagme = await prisma.logFlagme.delete({
     *   where: {
     *     // ... filter to delete one LogFlagme
     *   }
     * })
     * 
    **/
    delete<T extends LogFlagmeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogFlagmeDeleteArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogFlagme.
     * @param {LogFlagmeUpdateArgs} args - Arguments to update one LogFlagme.
     * @example
     * // Update one LogFlagme
     * const logFlagme = await prisma.logFlagme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogFlagmeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogFlagmeUpdateArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogFlagmes.
     * @param {LogFlagmeDeleteManyArgs} args - Arguments to filter LogFlagmes to delete.
     * @example
     * // Delete a few LogFlagmes
     * const { count } = await prisma.logFlagme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogFlagmeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogFlagmeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogFlagmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogFlagmes
     * const logFlagme = await prisma.logFlagme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogFlagmeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogFlagmeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogFlagme.
     * @param {LogFlagmeUpsertArgs} args - Arguments to update or create a LogFlagme.
     * @example
     * // Update or create a LogFlagme
     * const logFlagme = await prisma.logFlagme.upsert({
     *   create: {
     *     // ... data to create a LogFlagme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogFlagme we want to update
     *   }
     * })
    **/
    upsert<T extends LogFlagmeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogFlagmeUpsertArgs<ExtArgs>>
    ): Prisma__LogFlagmeClient<$Result.GetResult<Prisma.$LogFlagmePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogFlagmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeCountArgs} args - Arguments to filter LogFlagmes to count.
     * @example
     * // Count the number of LogFlagmes
     * const count = await prisma.logFlagme.count({
     *   where: {
     *     // ... the filter for the LogFlagmes we want to count
     *   }
     * })
    **/
    count<T extends LogFlagmeCountArgs>(
      args?: Subset<T, LogFlagmeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogFlagmeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogFlagme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogFlagmeAggregateArgs>(args: Subset<T, LogFlagmeAggregateArgs>): Prisma.PrismaPromise<GetLogFlagmeAggregateType<T>>

    /**
     * Group by LogFlagme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFlagmeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogFlagmeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogFlagmeGroupByArgs['orderBy'] }
        : { orderBy?: LogFlagmeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogFlagmeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogFlagmeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogFlagme model
   */
  readonly fields: LogFlagmeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogFlagme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogFlagmeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogFlagme model
   */ 
  interface LogFlagmeFieldRefs {
    readonly id: FieldRef<"LogFlagme", 'Int'>
    readonly userId: FieldRef<"LogFlagme", 'Int'>
    readonly oldusername: FieldRef<"LogFlagme", 'String'>
    readonly newusername: FieldRef<"LogFlagme", 'String'>
    readonly time: FieldRef<"LogFlagme", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogFlagme findUnique
   */
  export type LogFlagmeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * Filter, which LogFlagme to fetch.
     */
    where: LogFlagmeWhereUniqueInput
  }


  /**
   * LogFlagme findUniqueOrThrow
   */
  export type LogFlagmeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * Filter, which LogFlagme to fetch.
     */
    where: LogFlagmeWhereUniqueInput
  }


  /**
   * LogFlagme findFirst
   */
  export type LogFlagmeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * Filter, which LogFlagme to fetch.
     */
    where?: LogFlagmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogFlagmes to fetch.
     */
    orderBy?: LogFlagmeOrderByWithRelationInput | LogFlagmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogFlagmes.
     */
    cursor?: LogFlagmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogFlagmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogFlagmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogFlagmes.
     */
    distinct?: LogFlagmeScalarFieldEnum | LogFlagmeScalarFieldEnum[]
  }


  /**
   * LogFlagme findFirstOrThrow
   */
  export type LogFlagmeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * Filter, which LogFlagme to fetch.
     */
    where?: LogFlagmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogFlagmes to fetch.
     */
    orderBy?: LogFlagmeOrderByWithRelationInput | LogFlagmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogFlagmes.
     */
    cursor?: LogFlagmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogFlagmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogFlagmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogFlagmes.
     */
    distinct?: LogFlagmeScalarFieldEnum | LogFlagmeScalarFieldEnum[]
  }


  /**
   * LogFlagme findMany
   */
  export type LogFlagmeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * Filter, which LogFlagmes to fetch.
     */
    where?: LogFlagmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogFlagmes to fetch.
     */
    orderBy?: LogFlagmeOrderByWithRelationInput | LogFlagmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogFlagmes.
     */
    cursor?: LogFlagmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogFlagmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogFlagmes.
     */
    skip?: number
    distinct?: LogFlagmeScalarFieldEnum | LogFlagmeScalarFieldEnum[]
  }


  /**
   * LogFlagme create
   */
  export type LogFlagmeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * The data needed to create a LogFlagme.
     */
    data: XOR<LogFlagmeCreateInput, LogFlagmeUncheckedCreateInput>
  }


  /**
   * LogFlagme createMany
   */
  export type LogFlagmeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogFlagmes.
     */
    data: LogFlagmeCreateManyInput | LogFlagmeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogFlagme update
   */
  export type LogFlagmeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * The data needed to update a LogFlagme.
     */
    data: XOR<LogFlagmeUpdateInput, LogFlagmeUncheckedUpdateInput>
    /**
     * Choose, which LogFlagme to update.
     */
    where: LogFlagmeWhereUniqueInput
  }


  /**
   * LogFlagme updateMany
   */
  export type LogFlagmeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogFlagmes.
     */
    data: XOR<LogFlagmeUpdateManyMutationInput, LogFlagmeUncheckedUpdateManyInput>
    /**
     * Filter which LogFlagmes to update
     */
    where?: LogFlagmeWhereInput
  }


  /**
   * LogFlagme upsert
   */
  export type LogFlagmeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * The filter to search for the LogFlagme to update in case it exists.
     */
    where: LogFlagmeWhereUniqueInput
    /**
     * In case the LogFlagme found by the `where` argument doesn't exist, create a new LogFlagme with this data.
     */
    create: XOR<LogFlagmeCreateInput, LogFlagmeUncheckedCreateInput>
    /**
     * In case the LogFlagme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogFlagmeUpdateInput, LogFlagmeUncheckedUpdateInput>
  }


  /**
   * LogFlagme delete
   */
  export type LogFlagmeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
    /**
     * Filter which LogFlagme to delete.
     */
    where: LogFlagmeWhereUniqueInput
  }


  /**
   * LogFlagme deleteMany
   */
  export type LogFlagmeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogFlagmes to delete
     */
    where?: LogFlagmeWhereInput
  }


  /**
   * LogFlagme without action
   */
  export type LogFlagmeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogFlagme
     */
    select?: LogFlagmeSelect<ExtArgs> | null
  }



  /**
   * Model LogLogin
   */

  export type AggregateLogLogin = {
    _count: LogLoginCountAggregateOutputType | null
    _avg: LogLoginAvgAggregateOutputType | null
    _sum: LogLoginSumAggregateOutputType | null
    _min: LogLoginMinAggregateOutputType | null
    _max: LogLoginMaxAggregateOutputType | null
  }

  export type LogLoginAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
  }

  export type LogLoginSumAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
  }

  export type LogLoginMinAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
    ip: string | null
    userAgent: string | null
  }

  export type LogLoginMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
    ip: string | null
    userAgent: string | null
  }

  export type LogLoginCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    ip: number
    userAgent: number
    _all: number
  }


  export type LogLoginAvgAggregateInputType = {
    id?: true
    userId?: true
    date?: true
  }

  export type LogLoginSumAggregateInputType = {
    id?: true
    userId?: true
    date?: true
  }

  export type LogLoginMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    ip?: true
    userAgent?: true
  }

  export type LogLoginMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    ip?: true
    userAgent?: true
  }

  export type LogLoginCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    ip?: true
    userAgent?: true
    _all?: true
  }

  export type LogLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogLogin to aggregate.
     */
    where?: LogLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLogins to fetch.
     */
    orderBy?: LogLoginOrderByWithRelationInput | LogLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogLogins
    **/
    _count?: true | LogLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogLoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogLoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogLoginMaxAggregateInputType
  }

  export type GetLogLoginAggregateType<T extends LogLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateLogLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogLogin[P]>
      : GetScalarType<T[P], AggregateLogLogin[P]>
  }




  export type LogLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogLoginWhereInput
    orderBy?: LogLoginOrderByWithAggregationInput | LogLoginOrderByWithAggregationInput[]
    by: LogLoginScalarFieldEnum[] | LogLoginScalarFieldEnum
    having?: LogLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogLoginCountAggregateInputType | true
    _avg?: LogLoginAvgAggregateInputType
    _sum?: LogLoginSumAggregateInputType
    _min?: LogLoginMinAggregateInputType
    _max?: LogLoginMaxAggregateInputType
  }

  export type LogLoginGroupByOutputType = {
    id: number
    userId: number
    date: number
    ip: string
    userAgent: string
    _count: LogLoginCountAggregateOutputType | null
    _avg: LogLoginAvgAggregateOutputType | null
    _sum: LogLoginSumAggregateOutputType | null
    _min: LogLoginMinAggregateOutputType | null
    _max: LogLoginMaxAggregateOutputType | null
  }

  type GetLogLoginGroupByPayload<T extends LogLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogLoginGroupByOutputType[P]>
            : GetScalarType<T[P], LogLoginGroupByOutputType[P]>
        }
      >
    >


  export type LogLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    ip?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logLogin"]>

  export type LogLoginSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    ip?: boolean
    userAgent?: boolean
  }

  export type LogLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LogLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogLogin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      date: number
      ip: string
      userAgent: string
    }, ExtArgs["result"]["logLogin"]>
    composites: {}
  }


  type LogLoginGetPayload<S extends boolean | null | undefined | LogLoginDefaultArgs> = $Result.GetResult<Prisma.$LogLoginPayload, S>

  type LogLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogLoginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogLoginCountAggregateInputType | true
    }

  export interface LogLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogLogin'], meta: { name: 'LogLogin' } }
    /**
     * Find zero or one LogLogin that matches the filter.
     * @param {LogLoginFindUniqueArgs} args - Arguments to find a LogLogin
     * @example
     * // Get one LogLogin
     * const logLogin = await prisma.logLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogLoginFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogLoginFindUniqueArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogLogin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogLoginFindUniqueOrThrowArgs} args - Arguments to find a LogLogin
     * @example
     * // Get one LogLogin
     * const logLogin = await prisma.logLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogLoginFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLoginFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginFindFirstArgs} args - Arguments to find a LogLogin
     * @example
     * // Get one LogLogin
     * const logLogin = await prisma.logLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogLoginFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLoginFindFirstArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginFindFirstOrThrowArgs} args - Arguments to find a LogLogin
     * @example
     * // Get one LogLogin
     * const logLogin = await prisma.logLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogLoginFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLoginFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogLogins
     * const logLogins = await prisma.logLogin.findMany()
     * 
     * // Get first 10 LogLogins
     * const logLogins = await prisma.logLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logLoginWithIdOnly = await prisma.logLogin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogLoginFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLoginFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogLogin.
     * @param {LogLoginCreateArgs} args - Arguments to create a LogLogin.
     * @example
     * // Create one LogLogin
     * const LogLogin = await prisma.logLogin.create({
     *   data: {
     *     // ... data to create a LogLogin
     *   }
     * })
     * 
    **/
    create<T extends LogLoginCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogLoginCreateArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogLogins.
     *     @param {LogLoginCreateManyArgs} args - Arguments to create many LogLogins.
     *     @example
     *     // Create many LogLogins
     *     const logLogin = await prisma.logLogin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogLoginCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLoginCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogLogin.
     * @param {LogLoginDeleteArgs} args - Arguments to delete one LogLogin.
     * @example
     * // Delete one LogLogin
     * const LogLogin = await prisma.logLogin.delete({
     *   where: {
     *     // ... filter to delete one LogLogin
     *   }
     * })
     * 
    **/
    delete<T extends LogLoginDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogLoginDeleteArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogLogin.
     * @param {LogLoginUpdateArgs} args - Arguments to update one LogLogin.
     * @example
     * // Update one LogLogin
     * const logLogin = await prisma.logLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogLoginUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogLoginUpdateArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogLogins.
     * @param {LogLoginDeleteManyArgs} args - Arguments to filter LogLogins to delete.
     * @example
     * // Delete a few LogLogins
     * const { count } = await prisma.logLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogLoginDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLoginDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogLogins
     * const logLogin = await prisma.logLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogLoginUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogLoginUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogLogin.
     * @param {LogLoginUpsertArgs} args - Arguments to update or create a LogLogin.
     * @example
     * // Update or create a LogLogin
     * const logLogin = await prisma.logLogin.upsert({
     *   create: {
     *     // ... data to create a LogLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogLogin we want to update
     *   }
     * })
    **/
    upsert<T extends LogLoginUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogLoginUpsertArgs<ExtArgs>>
    ): Prisma__LogLoginClient<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginCountArgs} args - Arguments to filter LogLogins to count.
     * @example
     * // Count the number of LogLogins
     * const count = await prisma.logLogin.count({
     *   where: {
     *     // ... the filter for the LogLogins we want to count
     *   }
     * })
    **/
    count<T extends LogLoginCountArgs>(
      args?: Subset<T, LogLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogLoginAggregateArgs>(args: Subset<T, LogLoginAggregateArgs>): Prisma.PrismaPromise<GetLogLoginAggregateType<T>>

    /**
     * Group by LogLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogLoginGroupByArgs['orderBy'] }
        : { orderBy?: LogLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogLogin model
   */
  readonly fields: LogLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogLogin model
   */ 
  interface LogLoginFieldRefs {
    readonly id: FieldRef<"LogLogin", 'Int'>
    readonly userId: FieldRef<"LogLogin", 'Int'>
    readonly date: FieldRef<"LogLogin", 'Int'>
    readonly ip: FieldRef<"LogLogin", 'String'>
    readonly userAgent: FieldRef<"LogLogin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LogLogin findUnique
   */
  export type LogLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * Filter, which LogLogin to fetch.
     */
    where: LogLoginWhereUniqueInput
  }


  /**
   * LogLogin findUniqueOrThrow
   */
  export type LogLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * Filter, which LogLogin to fetch.
     */
    where: LogLoginWhereUniqueInput
  }


  /**
   * LogLogin findFirst
   */
  export type LogLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * Filter, which LogLogin to fetch.
     */
    where?: LogLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLogins to fetch.
     */
    orderBy?: LogLoginOrderByWithRelationInput | LogLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogLogins.
     */
    cursor?: LogLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogLogins.
     */
    distinct?: LogLoginScalarFieldEnum | LogLoginScalarFieldEnum[]
  }


  /**
   * LogLogin findFirstOrThrow
   */
  export type LogLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * Filter, which LogLogin to fetch.
     */
    where?: LogLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLogins to fetch.
     */
    orderBy?: LogLoginOrderByWithRelationInput | LogLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogLogins.
     */
    cursor?: LogLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogLogins.
     */
    distinct?: LogLoginScalarFieldEnum | LogLoginScalarFieldEnum[]
  }


  /**
   * LogLogin findMany
   */
  export type LogLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * Filter, which LogLogins to fetch.
     */
    where?: LogLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLogins to fetch.
     */
    orderBy?: LogLoginOrderByWithRelationInput | LogLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogLogins.
     */
    cursor?: LogLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLogins.
     */
    skip?: number
    distinct?: LogLoginScalarFieldEnum | LogLoginScalarFieldEnum[]
  }


  /**
   * LogLogin create
   */
  export type LogLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a LogLogin.
     */
    data: XOR<LogLoginCreateInput, LogLoginUncheckedCreateInput>
  }


  /**
   * LogLogin createMany
   */
  export type LogLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogLogins.
     */
    data: LogLoginCreateManyInput | LogLoginCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogLogin update
   */
  export type LogLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a LogLogin.
     */
    data: XOR<LogLoginUpdateInput, LogLoginUncheckedUpdateInput>
    /**
     * Choose, which LogLogin to update.
     */
    where: LogLoginWhereUniqueInput
  }


  /**
   * LogLogin updateMany
   */
  export type LogLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogLogins.
     */
    data: XOR<LogLoginUpdateManyMutationInput, LogLoginUncheckedUpdateManyInput>
    /**
     * Filter which LogLogins to update
     */
    where?: LogLoginWhereInput
  }


  /**
   * LogLogin upsert
   */
  export type LogLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the LogLogin to update in case it exists.
     */
    where: LogLoginWhereUniqueInput
    /**
     * In case the LogLogin found by the `where` argument doesn't exist, create a new LogLogin with this data.
     */
    create: XOR<LogLoginCreateInput, LogLoginUncheckedCreateInput>
    /**
     * In case the LogLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogLoginUpdateInput, LogLoginUncheckedUpdateInput>
  }


  /**
   * LogLogin delete
   */
  export type LogLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    /**
     * Filter which LogLogin to delete.
     */
    where: LogLoginWhereUniqueInput
  }


  /**
   * LogLogin deleteMany
   */
  export type LogLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogLogins to delete
     */
    where?: LogLoginWhereInput
  }


  /**
   * LogLogin without action
   */
  export type LogLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
  }



  /**
   * Model LogLootbox
   */

  export type AggregateLogLootbox = {
    _count: LogLootboxCountAggregateOutputType | null
    _avg: LogLootboxAvgAggregateOutputType | null
    _sum: LogLootboxSumAggregateOutputType | null
    _min: LogLootboxMinAggregateOutputType | null
    _max: LogLootboxMaxAggregateOutputType | null
  }

  export type LogLootboxAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    itemId: number | null
    baseId: number | null
    timestamp: number | null
  }

  export type LogLootboxSumAggregateOutputType = {
    id: number | null
    userId: number | null
    itemId: number | null
    baseId: number | null
    timestamp: number | null
  }

  export type LogLootboxMinAggregateOutputType = {
    id: number | null
    interactionType: string | null
    userId: number | null
    itemId: number | null
    baseId: number | null
    timestamp: number | null
  }

  export type LogLootboxMaxAggregateOutputType = {
    id: number | null
    interactionType: string | null
    userId: number | null
    itemId: number | null
    baseId: number | null
    timestamp: number | null
  }

  export type LogLootboxCountAggregateOutputType = {
    id: number
    interactionType: number
    userId: number
    itemId: number
    baseId: number
    timestamp: number
    _all: number
  }


  export type LogLootboxAvgAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    baseId?: true
    timestamp?: true
  }

  export type LogLootboxSumAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    baseId?: true
    timestamp?: true
  }

  export type LogLootboxMinAggregateInputType = {
    id?: true
    interactionType?: true
    userId?: true
    itemId?: true
    baseId?: true
    timestamp?: true
  }

  export type LogLootboxMaxAggregateInputType = {
    id?: true
    interactionType?: true
    userId?: true
    itemId?: true
    baseId?: true
    timestamp?: true
  }

  export type LogLootboxCountAggregateInputType = {
    id?: true
    interactionType?: true
    userId?: true
    itemId?: true
    baseId?: true
    timestamp?: true
    _all?: true
  }

  export type LogLootboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogLootbox to aggregate.
     */
    where?: LogLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLootboxes to fetch.
     */
    orderBy?: LogLootboxOrderByWithRelationInput | LogLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLootboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogLootboxes
    **/
    _count?: true | LogLootboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogLootboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogLootboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogLootboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogLootboxMaxAggregateInputType
  }

  export type GetLogLootboxAggregateType<T extends LogLootboxAggregateArgs> = {
        [P in keyof T & keyof AggregateLogLootbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogLootbox[P]>
      : GetScalarType<T[P], AggregateLogLootbox[P]>
  }




  export type LogLootboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogLootboxWhereInput
    orderBy?: LogLootboxOrderByWithAggregationInput | LogLootboxOrderByWithAggregationInput[]
    by: LogLootboxScalarFieldEnum[] | LogLootboxScalarFieldEnum
    having?: LogLootboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogLootboxCountAggregateInputType | true
    _avg?: LogLootboxAvgAggregateInputType
    _sum?: LogLootboxSumAggregateInputType
    _min?: LogLootboxMinAggregateInputType
    _max?: LogLootboxMaxAggregateInputType
  }

  export type LogLootboxGroupByOutputType = {
    id: number
    interactionType: string
    userId: number
    itemId: number
    baseId: number
    timestamp: number
    _count: LogLootboxCountAggregateOutputType | null
    _avg: LogLootboxAvgAggregateOutputType | null
    _sum: LogLootboxSumAggregateOutputType | null
    _min: LogLootboxMinAggregateOutputType | null
    _max: LogLootboxMaxAggregateOutputType | null
  }

  type GetLogLootboxGroupByPayload<T extends LogLootboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogLootboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogLootboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogLootboxGroupByOutputType[P]>
            : GetScalarType<T[P], LogLootboxGroupByOutputType[P]>
        }
      >
    >


  export type LogLootboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interactionType?: boolean
    userId?: boolean
    itemId?: boolean
    baseId?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    itemBase?: boolean | ItemBaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logLootbox"]>

  export type LogLootboxSelectScalar = {
    id?: boolean
    interactionType?: boolean
    userId?: boolean
    itemId?: boolean
    baseId?: boolean
    timestamp?: boolean
  }

  export type LogLootboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    itemBase?: boolean | ItemBaseDefaultArgs<ExtArgs>
  }


  export type $LogLootboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogLootbox"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      itemBase: Prisma.$ItemBasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      interactionType: string
      userId: number
      itemId: number
      baseId: number
      timestamp: number
    }, ExtArgs["result"]["logLootbox"]>
    composites: {}
  }


  type LogLootboxGetPayload<S extends boolean | null | undefined | LogLootboxDefaultArgs> = $Result.GetResult<Prisma.$LogLootboxPayload, S>

  type LogLootboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogLootboxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogLootboxCountAggregateInputType | true
    }

  export interface LogLootboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogLootbox'], meta: { name: 'LogLootbox' } }
    /**
     * Find zero or one LogLootbox that matches the filter.
     * @param {LogLootboxFindUniqueArgs} args - Arguments to find a LogLootbox
     * @example
     * // Get one LogLootbox
     * const logLootbox = await prisma.logLootbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogLootboxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogLootboxFindUniqueArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogLootbox that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogLootboxFindUniqueOrThrowArgs} args - Arguments to find a LogLootbox
     * @example
     * // Get one LogLootbox
     * const logLootbox = await prisma.logLootbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogLootboxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLootboxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogLootbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxFindFirstArgs} args - Arguments to find a LogLootbox
     * @example
     * // Get one LogLootbox
     * const logLootbox = await prisma.logLootbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogLootboxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLootboxFindFirstArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogLootbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxFindFirstOrThrowArgs} args - Arguments to find a LogLootbox
     * @example
     * // Get one LogLootbox
     * const logLootbox = await prisma.logLootbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogLootboxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLootboxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogLootboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogLootboxes
     * const logLootboxes = await prisma.logLootbox.findMany()
     * 
     * // Get first 10 LogLootboxes
     * const logLootboxes = await prisma.logLootbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logLootboxWithIdOnly = await prisma.logLootbox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogLootboxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLootboxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogLootbox.
     * @param {LogLootboxCreateArgs} args - Arguments to create a LogLootbox.
     * @example
     * // Create one LogLootbox
     * const LogLootbox = await prisma.logLootbox.create({
     *   data: {
     *     // ... data to create a LogLootbox
     *   }
     * })
     * 
    **/
    create<T extends LogLootboxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogLootboxCreateArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogLootboxes.
     *     @param {LogLootboxCreateManyArgs} args - Arguments to create many LogLootboxes.
     *     @example
     *     // Create many LogLootboxes
     *     const logLootbox = await prisma.logLootbox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogLootboxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLootboxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogLootbox.
     * @param {LogLootboxDeleteArgs} args - Arguments to delete one LogLootbox.
     * @example
     * // Delete one LogLootbox
     * const LogLootbox = await prisma.logLootbox.delete({
     *   where: {
     *     // ... filter to delete one LogLootbox
     *   }
     * })
     * 
    **/
    delete<T extends LogLootboxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogLootboxDeleteArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogLootbox.
     * @param {LogLootboxUpdateArgs} args - Arguments to update one LogLootbox.
     * @example
     * // Update one LogLootbox
     * const logLootbox = await prisma.logLootbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogLootboxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogLootboxUpdateArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogLootboxes.
     * @param {LogLootboxDeleteManyArgs} args - Arguments to filter LogLootboxes to delete.
     * @example
     * // Delete a few LogLootboxes
     * const { count } = await prisma.logLootbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogLootboxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogLootboxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogLootboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogLootboxes
     * const logLootbox = await prisma.logLootbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogLootboxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogLootboxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogLootbox.
     * @param {LogLootboxUpsertArgs} args - Arguments to update or create a LogLootbox.
     * @example
     * // Update or create a LogLootbox
     * const logLootbox = await prisma.logLootbox.upsert({
     *   create: {
     *     // ... data to create a LogLootbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogLootbox we want to update
     *   }
     * })
    **/
    upsert<T extends LogLootboxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogLootboxUpsertArgs<ExtArgs>>
    ): Prisma__LogLootboxClient<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogLootboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxCountArgs} args - Arguments to filter LogLootboxes to count.
     * @example
     * // Count the number of LogLootboxes
     * const count = await prisma.logLootbox.count({
     *   where: {
     *     // ... the filter for the LogLootboxes we want to count
     *   }
     * })
    **/
    count<T extends LogLootboxCountArgs>(
      args?: Subset<T, LogLootboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogLootboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogLootbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogLootboxAggregateArgs>(args: Subset<T, LogLootboxAggregateArgs>): Prisma.PrismaPromise<GetLogLootboxAggregateType<T>>

    /**
     * Group by LogLootbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogLootboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogLootboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogLootboxGroupByArgs['orderBy'] }
        : { orderBy?: LogLootboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogLootboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogLootboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogLootbox model
   */
  readonly fields: LogLootboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogLootbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogLootboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    itemBase<T extends ItemBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemBaseDefaultArgs<ExtArgs>>): Prisma__ItemBaseClient<$Result.GetResult<Prisma.$ItemBasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogLootbox model
   */ 
  interface LogLootboxFieldRefs {
    readonly id: FieldRef<"LogLootbox", 'Int'>
    readonly interactionType: FieldRef<"LogLootbox", 'String'>
    readonly userId: FieldRef<"LogLootbox", 'Int'>
    readonly itemId: FieldRef<"LogLootbox", 'Int'>
    readonly baseId: FieldRef<"LogLootbox", 'Int'>
    readonly timestamp: FieldRef<"LogLootbox", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogLootbox findUnique
   */
  export type LogLootboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * Filter, which LogLootbox to fetch.
     */
    where: LogLootboxWhereUniqueInput
  }


  /**
   * LogLootbox findUniqueOrThrow
   */
  export type LogLootboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * Filter, which LogLootbox to fetch.
     */
    where: LogLootboxWhereUniqueInput
  }


  /**
   * LogLootbox findFirst
   */
  export type LogLootboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * Filter, which LogLootbox to fetch.
     */
    where?: LogLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLootboxes to fetch.
     */
    orderBy?: LogLootboxOrderByWithRelationInput | LogLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogLootboxes.
     */
    cursor?: LogLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLootboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogLootboxes.
     */
    distinct?: LogLootboxScalarFieldEnum | LogLootboxScalarFieldEnum[]
  }


  /**
   * LogLootbox findFirstOrThrow
   */
  export type LogLootboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * Filter, which LogLootbox to fetch.
     */
    where?: LogLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLootboxes to fetch.
     */
    orderBy?: LogLootboxOrderByWithRelationInput | LogLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogLootboxes.
     */
    cursor?: LogLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLootboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogLootboxes.
     */
    distinct?: LogLootboxScalarFieldEnum | LogLootboxScalarFieldEnum[]
  }


  /**
   * LogLootbox findMany
   */
  export type LogLootboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * Filter, which LogLootboxes to fetch.
     */
    where?: LogLootboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogLootboxes to fetch.
     */
    orderBy?: LogLootboxOrderByWithRelationInput | LogLootboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogLootboxes.
     */
    cursor?: LogLootboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogLootboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogLootboxes.
     */
    skip?: number
    distinct?: LogLootboxScalarFieldEnum | LogLootboxScalarFieldEnum[]
  }


  /**
   * LogLootbox create
   */
  export type LogLootboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * The data needed to create a LogLootbox.
     */
    data: XOR<LogLootboxCreateInput, LogLootboxUncheckedCreateInput>
  }


  /**
   * LogLootbox createMany
   */
  export type LogLootboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogLootboxes.
     */
    data: LogLootboxCreateManyInput | LogLootboxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogLootbox update
   */
  export type LogLootboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * The data needed to update a LogLootbox.
     */
    data: XOR<LogLootboxUpdateInput, LogLootboxUncheckedUpdateInput>
    /**
     * Choose, which LogLootbox to update.
     */
    where: LogLootboxWhereUniqueInput
  }


  /**
   * LogLootbox updateMany
   */
  export type LogLootboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogLootboxes.
     */
    data: XOR<LogLootboxUpdateManyMutationInput, LogLootboxUncheckedUpdateManyInput>
    /**
     * Filter which LogLootboxes to update
     */
    where?: LogLootboxWhereInput
  }


  /**
   * LogLootbox upsert
   */
  export type LogLootboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * The filter to search for the LogLootbox to update in case it exists.
     */
    where: LogLootboxWhereUniqueInput
    /**
     * In case the LogLootbox found by the `where` argument doesn't exist, create a new LogLootbox with this data.
     */
    create: XOR<LogLootboxCreateInput, LogLootboxUncheckedCreateInput>
    /**
     * In case the LogLootbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogLootboxUpdateInput, LogLootboxUncheckedUpdateInput>
  }


  /**
   * LogLootbox delete
   */
  export type LogLootboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    /**
     * Filter which LogLootbox to delete.
     */
    where: LogLootboxWhereUniqueInput
  }


  /**
   * LogLootbox deleteMany
   */
  export type LogLootboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogLootboxes to delete
     */
    where?: LogLootboxWhereInput
  }


  /**
   * LogLootbox without action
   */
  export type LogLootboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
  }



  /**
   * Model LogPayment
   */

  export type AggregateLogPayment = {
    _count: LogPaymentCountAggregateOutputType | null
    _avg: LogPaymentAvgAggregateOutputType | null
    _sum: LogPaymentSumAggregateOutputType | null
    _min: LogPaymentMinAggregateOutputType | null
    _max: LogPaymentMaxAggregateOutputType | null
  }

  export type LogPaymentAvgAggregateOutputType = {
    historyPaymentId: number | null
    docId: number | null
    userId: number | null
    awards: number | null
    promoId: number | null
  }

  export type LogPaymentSumAggregateOutputType = {
    historyPaymentId: number | null
    docId: number | null
    userId: number | null
    awards: number | null
    promoId: number | null
  }

  export type LogPaymentMinAggregateOutputType = {
    historyPaymentId: number | null
    docId: number | null
    userId: number | null
    awards: number | null
    externalReference: string | null
    promoId: number | null
    date: Date | null
  }

  export type LogPaymentMaxAggregateOutputType = {
    historyPaymentId: number | null
    docId: number | null
    userId: number | null
    awards: number | null
    externalReference: string | null
    promoId: number | null
    date: Date | null
  }

  export type LogPaymentCountAggregateOutputType = {
    historyPaymentId: number
    docId: number
    userId: number
    awards: number
    externalReference: number
    promoId: number
    date: number
    _all: number
  }


  export type LogPaymentAvgAggregateInputType = {
    historyPaymentId?: true
    docId?: true
    userId?: true
    awards?: true
    promoId?: true
  }

  export type LogPaymentSumAggregateInputType = {
    historyPaymentId?: true
    docId?: true
    userId?: true
    awards?: true
    promoId?: true
  }

  export type LogPaymentMinAggregateInputType = {
    historyPaymentId?: true
    docId?: true
    userId?: true
    awards?: true
    externalReference?: true
    promoId?: true
    date?: true
  }

  export type LogPaymentMaxAggregateInputType = {
    historyPaymentId?: true
    docId?: true
    userId?: true
    awards?: true
    externalReference?: true
    promoId?: true
    date?: true
  }

  export type LogPaymentCountAggregateInputType = {
    historyPaymentId?: true
    docId?: true
    userId?: true
    awards?: true
    externalReference?: true
    promoId?: true
    date?: true
    _all?: true
  }

  export type LogPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogPayment to aggregate.
     */
    where?: LogPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogPayments to fetch.
     */
    orderBy?: LogPaymentOrderByWithRelationInput | LogPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogPayments
    **/
    _count?: true | LogPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogPaymentMaxAggregateInputType
  }

  export type GetLogPaymentAggregateType<T extends LogPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateLogPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogPayment[P]>
      : GetScalarType<T[P], AggregateLogPayment[P]>
  }




  export type LogPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogPaymentWhereInput
    orderBy?: LogPaymentOrderByWithAggregationInput | LogPaymentOrderByWithAggregationInput[]
    by: LogPaymentScalarFieldEnum[] | LogPaymentScalarFieldEnum
    having?: LogPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogPaymentCountAggregateInputType | true
    _avg?: LogPaymentAvgAggregateInputType
    _sum?: LogPaymentSumAggregateInputType
    _min?: LogPaymentMinAggregateInputType
    _max?: LogPaymentMaxAggregateInputType
  }

  export type LogPaymentGroupByOutputType = {
    historyPaymentId: number
    docId: number
    userId: number
    awards: number
    externalReference: string
    promoId: number
    date: Date
    _count: LogPaymentCountAggregateOutputType | null
    _avg: LogPaymentAvgAggregateOutputType | null
    _sum: LogPaymentSumAggregateOutputType | null
    _min: LogPaymentMinAggregateOutputType | null
    _max: LogPaymentMaxAggregateOutputType | null
  }

  type GetLogPaymentGroupByPayload<T extends LogPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], LogPaymentGroupByOutputType[P]>
        }
      >
    >


  export type LogPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyPaymentId?: boolean
    docId?: boolean
    userId?: boolean
    awards?: boolean
    externalReference?: boolean
    promoId?: boolean
    date?: boolean
  }, ExtArgs["result"]["logPayment"]>

  export type LogPaymentSelectScalar = {
    historyPaymentId?: boolean
    docId?: boolean
    userId?: boolean
    awards?: boolean
    externalReference?: boolean
    promoId?: boolean
    date?: boolean
  }


  export type $LogPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogPayment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      historyPaymentId: number
      docId: number
      userId: number
      awards: number
      externalReference: string
      promoId: number
      date: Date
    }, ExtArgs["result"]["logPayment"]>
    composites: {}
  }


  type LogPaymentGetPayload<S extends boolean | null | undefined | LogPaymentDefaultArgs> = $Result.GetResult<Prisma.$LogPaymentPayload, S>

  type LogPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogPaymentCountAggregateInputType | true
    }

  export interface LogPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogPayment'], meta: { name: 'LogPayment' } }
    /**
     * Find zero or one LogPayment that matches the filter.
     * @param {LogPaymentFindUniqueArgs} args - Arguments to find a LogPayment
     * @example
     * // Get one LogPayment
     * const logPayment = await prisma.logPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogPayment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogPaymentFindUniqueOrThrowArgs} args - Arguments to find a LogPayment
     * @example
     * // Get one LogPayment
     * const logPayment = await prisma.logPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentFindFirstArgs} args - Arguments to find a LogPayment
     * @example
     * // Get one LogPayment
     * const logPayment = await prisma.logPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentFindFirstOrThrowArgs} args - Arguments to find a LogPayment
     * @example
     * // Get one LogPayment
     * const logPayment = await prisma.logPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogPayments
     * const logPayments = await prisma.logPayment.findMany()
     * 
     * // Get first 10 LogPayments
     * const logPayments = await prisma.logPayment.findMany({ take: 10 })
     * 
     * // Only select the `historyPaymentId`
     * const logPaymentWithHistoryPaymentIdOnly = await prisma.logPayment.findMany({ select: { historyPaymentId: true } })
     * 
    **/
    findMany<T extends LogPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogPayment.
     * @param {LogPaymentCreateArgs} args - Arguments to create a LogPayment.
     * @example
     * // Create one LogPayment
     * const LogPayment = await prisma.logPayment.create({
     *   data: {
     *     // ... data to create a LogPayment
     *   }
     * })
     * 
    **/
    create<T extends LogPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogPaymentCreateArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogPayments.
     *     @param {LogPaymentCreateManyArgs} args - Arguments to create many LogPayments.
     *     @example
     *     // Create many LogPayments
     *     const logPayment = await prisma.logPayment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogPayment.
     * @param {LogPaymentDeleteArgs} args - Arguments to delete one LogPayment.
     * @example
     * // Delete one LogPayment
     * const LogPayment = await prisma.logPayment.delete({
     *   where: {
     *     // ... filter to delete one LogPayment
     *   }
     * })
     * 
    **/
    delete<T extends LogPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogPaymentDeleteArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogPayment.
     * @param {LogPaymentUpdateArgs} args - Arguments to update one LogPayment.
     * @example
     * // Update one LogPayment
     * const logPayment = await prisma.logPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogPaymentUpdateArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogPayments.
     * @param {LogPaymentDeleteManyArgs} args - Arguments to filter LogPayments to delete.
     * @example
     * // Delete a few LogPayments
     * const { count } = await prisma.logPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogPayments
     * const logPayment = await prisma.logPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogPayment.
     * @param {LogPaymentUpsertArgs} args - Arguments to update or create a LogPayment.
     * @example
     * // Update or create a LogPayment
     * const logPayment = await prisma.logPayment.upsert({
     *   create: {
     *     // ... data to create a LogPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogPayment we want to update
     *   }
     * })
    **/
    upsert<T extends LogPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogPaymentUpsertArgs<ExtArgs>>
    ): Prisma__LogPaymentClient<$Result.GetResult<Prisma.$LogPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentCountArgs} args - Arguments to filter LogPayments to count.
     * @example
     * // Count the number of LogPayments
     * const count = await prisma.logPayment.count({
     *   where: {
     *     // ... the filter for the LogPayments we want to count
     *   }
     * })
    **/
    count<T extends LogPaymentCountArgs>(
      args?: Subset<T, LogPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogPaymentAggregateArgs>(args: Subset<T, LogPaymentAggregateArgs>): Prisma.PrismaPromise<GetLogPaymentAggregateType<T>>

    /**
     * Group by LogPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogPaymentGroupByArgs['orderBy'] }
        : { orderBy?: LogPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogPayment model
   */
  readonly fields: LogPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogPayment model
   */ 
  interface LogPaymentFieldRefs {
    readonly historyPaymentId: FieldRef<"LogPayment", 'Int'>
    readonly docId: FieldRef<"LogPayment", 'Int'>
    readonly userId: FieldRef<"LogPayment", 'Int'>
    readonly awards: FieldRef<"LogPayment", 'Int'>
    readonly externalReference: FieldRef<"LogPayment", 'String'>
    readonly promoId: FieldRef<"LogPayment", 'Int'>
    readonly date: FieldRef<"LogPayment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LogPayment findUnique
   */
  export type LogPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * Filter, which LogPayment to fetch.
     */
    where: LogPaymentWhereUniqueInput
  }


  /**
   * LogPayment findUniqueOrThrow
   */
  export type LogPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * Filter, which LogPayment to fetch.
     */
    where: LogPaymentWhereUniqueInput
  }


  /**
   * LogPayment findFirst
   */
  export type LogPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * Filter, which LogPayment to fetch.
     */
    where?: LogPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogPayments to fetch.
     */
    orderBy?: LogPaymentOrderByWithRelationInput | LogPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogPayments.
     */
    cursor?: LogPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogPayments.
     */
    distinct?: LogPaymentScalarFieldEnum | LogPaymentScalarFieldEnum[]
  }


  /**
   * LogPayment findFirstOrThrow
   */
  export type LogPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * Filter, which LogPayment to fetch.
     */
    where?: LogPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogPayments to fetch.
     */
    orderBy?: LogPaymentOrderByWithRelationInput | LogPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogPayments.
     */
    cursor?: LogPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogPayments.
     */
    distinct?: LogPaymentScalarFieldEnum | LogPaymentScalarFieldEnum[]
  }


  /**
   * LogPayment findMany
   */
  export type LogPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * Filter, which LogPayments to fetch.
     */
    where?: LogPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogPayments to fetch.
     */
    orderBy?: LogPaymentOrderByWithRelationInput | LogPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogPayments.
     */
    cursor?: LogPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogPayments.
     */
    skip?: number
    distinct?: LogPaymentScalarFieldEnum | LogPaymentScalarFieldEnum[]
  }


  /**
   * LogPayment create
   */
  export type LogPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * The data needed to create a LogPayment.
     */
    data: XOR<LogPaymentCreateInput, LogPaymentUncheckedCreateInput>
  }


  /**
   * LogPayment createMany
   */
  export type LogPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogPayments.
     */
    data: LogPaymentCreateManyInput | LogPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogPayment update
   */
  export type LogPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * The data needed to update a LogPayment.
     */
    data: XOR<LogPaymentUpdateInput, LogPaymentUncheckedUpdateInput>
    /**
     * Choose, which LogPayment to update.
     */
    where: LogPaymentWhereUniqueInput
  }


  /**
   * LogPayment updateMany
   */
  export type LogPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogPayments.
     */
    data: XOR<LogPaymentUpdateManyMutationInput, LogPaymentUncheckedUpdateManyInput>
    /**
     * Filter which LogPayments to update
     */
    where?: LogPaymentWhereInput
  }


  /**
   * LogPayment upsert
   */
  export type LogPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * The filter to search for the LogPayment to update in case it exists.
     */
    where: LogPaymentWhereUniqueInput
    /**
     * In case the LogPayment found by the `where` argument doesn't exist, create a new LogPayment with this data.
     */
    create: XOR<LogPaymentCreateInput, LogPaymentUncheckedCreateInput>
    /**
     * In case the LogPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogPaymentUpdateInput, LogPaymentUncheckedUpdateInput>
  }


  /**
   * LogPayment delete
   */
  export type LogPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
    /**
     * Filter which LogPayment to delete.
     */
    where: LogPaymentWhereUniqueInput
  }


  /**
   * LogPayment deleteMany
   */
  export type LogPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogPayments to delete
     */
    where?: LogPaymentWhereInput
  }


  /**
   * LogPayment without action
   */
  export type LogPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogPayment
     */
    select?: LogPaymentSelect<ExtArgs> | null
  }



  /**
   * Model LogShop
   */

  export type AggregateLogShop = {
    _count: LogShopCountAggregateOutputType | null
    _avg: LogShopAvgAggregateOutputType | null
    _sum: LogShopSumAggregateOutputType | null
    _min: LogShopMinAggregateOutputType | null
    _max: LogShopMaxAggregateOutputType | null
  }

  export type LogShopAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
    price: number | null
    type: number | null
    catalogItemId: number | null
  }

  export type LogShopSumAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
    price: number | null
    type: number | null
    catalogItemId: number | null
  }

  export type LogShopMinAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
    price: number | null
    content: string | null
    type: number | null
    catalogItemId: number | null
  }

  export type LogShopMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    date: number | null
    price: number | null
    content: string | null
    type: number | null
    catalogItemId: number | null
  }

  export type LogShopCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    price: number
    content: number
    type: number
    catalogItemId: number
    _all: number
  }


  export type LogShopAvgAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    price?: true
    type?: true
    catalogItemId?: true
  }

  export type LogShopSumAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    price?: true
    type?: true
    catalogItemId?: true
  }

  export type LogShopMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    price?: true
    content?: true
    type?: true
    catalogItemId?: true
  }

  export type LogShopMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    price?: true
    content?: true
    type?: true
    catalogItemId?: true
  }

  export type LogShopCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    price?: true
    content?: true
    type?: true
    catalogItemId?: true
    _all?: true
  }

  export type LogShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogShop to aggregate.
     */
    where?: LogShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogShops to fetch.
     */
    orderBy?: LogShopOrderByWithRelationInput | LogShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogShops
    **/
    _count?: true | LogShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogShopMaxAggregateInputType
  }

  export type GetLogShopAggregateType<T extends LogShopAggregateArgs> = {
        [P in keyof T & keyof AggregateLogShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogShop[P]>
      : GetScalarType<T[P], AggregateLogShop[P]>
  }




  export type LogShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogShopWhereInput
    orderBy?: LogShopOrderByWithAggregationInput | LogShopOrderByWithAggregationInput[]
    by: LogShopScalarFieldEnum[] | LogShopScalarFieldEnum
    having?: LogShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogShopCountAggregateInputType | true
    _avg?: LogShopAvgAggregateInputType
    _sum?: LogShopSumAggregateInputType
    _min?: LogShopMinAggregateInputType
    _max?: LogShopMaxAggregateInputType
  }

  export type LogShopGroupByOutputType = {
    id: number
    userId: number
    date: number
    price: number
    content: string
    type: number
    catalogItemId: number
    _count: LogShopCountAggregateOutputType | null
    _avg: LogShopAvgAggregateOutputType | null
    _sum: LogShopSumAggregateOutputType | null
    _min: LogShopMinAggregateOutputType | null
    _max: LogShopMaxAggregateOutputType | null
  }

  type GetLogShopGroupByPayload<T extends LogShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogShopGroupByOutputType[P]>
            : GetScalarType<T[P], LogShopGroupByOutputType[P]>
        }
      >
    >


  export type LogShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    price?: boolean
    content?: boolean
    type?: boolean
    catalogItemId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logShop"]>

  export type LogShopSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    price?: boolean
    content?: boolean
    type?: boolean
    catalogItemId?: boolean
  }

  export type LogShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LogShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogShop"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      date: number
      price: number
      content: string
      type: number
      catalogItemId: number
    }, ExtArgs["result"]["logShop"]>
    composites: {}
  }


  type LogShopGetPayload<S extends boolean | null | undefined | LogShopDefaultArgs> = $Result.GetResult<Prisma.$LogShopPayload, S>

  type LogShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogShopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogShopCountAggregateInputType | true
    }

  export interface LogShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogShop'], meta: { name: 'LogShop' } }
    /**
     * Find zero or one LogShop that matches the filter.
     * @param {LogShopFindUniqueArgs} args - Arguments to find a LogShop
     * @example
     * // Get one LogShop
     * const logShop = await prisma.logShop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogShopFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogShopFindUniqueArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogShop that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogShopFindUniqueOrThrowArgs} args - Arguments to find a LogShop
     * @example
     * // Get one LogShop
     * const logShop = await prisma.logShop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogShopFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogShopFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogShop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopFindFirstArgs} args - Arguments to find a LogShop
     * @example
     * // Get one LogShop
     * const logShop = await prisma.logShop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogShopFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogShopFindFirstArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogShop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopFindFirstOrThrowArgs} args - Arguments to find a LogShop
     * @example
     * // Get one LogShop
     * const logShop = await prisma.logShop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogShopFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogShopFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogShops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogShops
     * const logShops = await prisma.logShop.findMany()
     * 
     * // Get first 10 LogShops
     * const logShops = await prisma.logShop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logShopWithIdOnly = await prisma.logShop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogShopFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogShopFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogShop.
     * @param {LogShopCreateArgs} args - Arguments to create a LogShop.
     * @example
     * // Create one LogShop
     * const LogShop = await prisma.logShop.create({
     *   data: {
     *     // ... data to create a LogShop
     *   }
     * })
     * 
    **/
    create<T extends LogShopCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogShopCreateArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogShops.
     *     @param {LogShopCreateManyArgs} args - Arguments to create many LogShops.
     *     @example
     *     // Create many LogShops
     *     const logShop = await prisma.logShop.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogShopCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogShopCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogShop.
     * @param {LogShopDeleteArgs} args - Arguments to delete one LogShop.
     * @example
     * // Delete one LogShop
     * const LogShop = await prisma.logShop.delete({
     *   where: {
     *     // ... filter to delete one LogShop
     *   }
     * })
     * 
    **/
    delete<T extends LogShopDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogShopDeleteArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogShop.
     * @param {LogShopUpdateArgs} args - Arguments to update one LogShop.
     * @example
     * // Update one LogShop
     * const logShop = await prisma.logShop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogShopUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogShopUpdateArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogShops.
     * @param {LogShopDeleteManyArgs} args - Arguments to filter LogShops to delete.
     * @example
     * // Delete a few LogShops
     * const { count } = await prisma.logShop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogShopDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogShopDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogShops
     * const logShop = await prisma.logShop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogShopUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogShopUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogShop.
     * @param {LogShopUpsertArgs} args - Arguments to update or create a LogShop.
     * @example
     * // Update or create a LogShop
     * const logShop = await prisma.logShop.upsert({
     *   create: {
     *     // ... data to create a LogShop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogShop we want to update
     *   }
     * })
    **/
    upsert<T extends LogShopUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogShopUpsertArgs<ExtArgs>>
    ): Prisma__LogShopClient<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogShops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopCountArgs} args - Arguments to filter LogShops to count.
     * @example
     * // Count the number of LogShops
     * const count = await prisma.logShop.count({
     *   where: {
     *     // ... the filter for the LogShops we want to count
     *   }
     * })
    **/
    count<T extends LogShopCountArgs>(
      args?: Subset<T, LogShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogShopAggregateArgs>(args: Subset<T, LogShopAggregateArgs>): Prisma.PrismaPromise<GetLogShopAggregateType<T>>

    /**
     * Group by LogShop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogShopGroupByArgs['orderBy'] }
        : { orderBy?: LogShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogShop model
   */
  readonly fields: LogShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogShop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogShop model
   */ 
  interface LogShopFieldRefs {
    readonly id: FieldRef<"LogShop", 'Int'>
    readonly userId: FieldRef<"LogShop", 'Int'>
    readonly date: FieldRef<"LogShop", 'Int'>
    readonly price: FieldRef<"LogShop", 'Int'>
    readonly content: FieldRef<"LogShop", 'String'>
    readonly type: FieldRef<"LogShop", 'Int'>
    readonly catalogItemId: FieldRef<"LogShop", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogShop findUnique
   */
  export type LogShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * Filter, which LogShop to fetch.
     */
    where: LogShopWhereUniqueInput
  }


  /**
   * LogShop findUniqueOrThrow
   */
  export type LogShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * Filter, which LogShop to fetch.
     */
    where: LogShopWhereUniqueInput
  }


  /**
   * LogShop findFirst
   */
  export type LogShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * Filter, which LogShop to fetch.
     */
    where?: LogShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogShops to fetch.
     */
    orderBy?: LogShopOrderByWithRelationInput | LogShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogShops.
     */
    cursor?: LogShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogShops.
     */
    distinct?: LogShopScalarFieldEnum | LogShopScalarFieldEnum[]
  }


  /**
   * LogShop findFirstOrThrow
   */
  export type LogShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * Filter, which LogShop to fetch.
     */
    where?: LogShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogShops to fetch.
     */
    orderBy?: LogShopOrderByWithRelationInput | LogShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogShops.
     */
    cursor?: LogShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogShops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogShops.
     */
    distinct?: LogShopScalarFieldEnum | LogShopScalarFieldEnum[]
  }


  /**
   * LogShop findMany
   */
  export type LogShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * Filter, which LogShops to fetch.
     */
    where?: LogShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogShops to fetch.
     */
    orderBy?: LogShopOrderByWithRelationInput | LogShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogShops.
     */
    cursor?: LogShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogShops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogShops.
     */
    skip?: number
    distinct?: LogShopScalarFieldEnum | LogShopScalarFieldEnum[]
  }


  /**
   * LogShop create
   */
  export type LogShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * The data needed to create a LogShop.
     */
    data: XOR<LogShopCreateInput, LogShopUncheckedCreateInput>
  }


  /**
   * LogShop createMany
   */
  export type LogShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogShops.
     */
    data: LogShopCreateManyInput | LogShopCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogShop update
   */
  export type LogShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * The data needed to update a LogShop.
     */
    data: XOR<LogShopUpdateInput, LogShopUncheckedUpdateInput>
    /**
     * Choose, which LogShop to update.
     */
    where: LogShopWhereUniqueInput
  }


  /**
   * LogShop updateMany
   */
  export type LogShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogShops.
     */
    data: XOR<LogShopUpdateManyMutationInput, LogShopUncheckedUpdateManyInput>
    /**
     * Filter which LogShops to update
     */
    where?: LogShopWhereInput
  }


  /**
   * LogShop upsert
   */
  export type LogShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * The filter to search for the LogShop to update in case it exists.
     */
    where: LogShopWhereUniqueInput
    /**
     * In case the LogShop found by the `where` argument doesn't exist, create a new LogShop with this data.
     */
    create: XOR<LogShopCreateInput, LogShopUncheckedCreateInput>
    /**
     * In case the LogShop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogShopUpdateInput, LogShopUncheckedUpdateInput>
  }


  /**
   * LogShop delete
   */
  export type LogShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    /**
     * Filter which LogShop to delete.
     */
    where: LogShopWhereUniqueInput
  }


  /**
   * LogShop deleteMany
   */
  export type LogShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogShops to delete
     */
    where?: LogShopWhereInput
  }


  /**
   * LogShop without action
   */
  export type LogShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
  }



  /**
   * Model LogSlotmachine
   */

  export type AggregateLogSlotmachine = {
    _count: LogSlotmachineCountAggregateOutputType | null
    _avg: LogSlotmachineAvgAggregateOutputType | null
    _sum: LogSlotmachineSumAggregateOutputType | null
    _min: LogSlotmachineMinAggregateOutputType | null
    _max: LogSlotmachineMaxAggregateOutputType | null
  }

  export type LogSlotmachineAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    date: number | null
  }

  export type LogSlotmachineSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    date: number | null
  }

  export type LogSlotmachineMinAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    isWin: boolean | null
    date: number | null
  }

  export type LogSlotmachineMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    isWin: boolean | null
    date: number | null
  }

  export type LogSlotmachineCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    isWin: number
    date: number
    _all: number
  }


  export type LogSlotmachineAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    date?: true
  }

  export type LogSlotmachineSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    date?: true
  }

  export type LogSlotmachineMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    isWin?: true
    date?: true
  }

  export type LogSlotmachineMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    isWin?: true
    date?: true
  }

  export type LogSlotmachineCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    isWin?: true
    date?: true
    _all?: true
  }

  export type LogSlotmachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSlotmachine to aggregate.
     */
    where?: LogSlotmachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSlotmachines to fetch.
     */
    orderBy?: LogSlotmachineOrderByWithRelationInput | LogSlotmachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogSlotmachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSlotmachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSlotmachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogSlotmachines
    **/
    _count?: true | LogSlotmachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogSlotmachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSlotmachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogSlotmachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogSlotmachineMaxAggregateInputType
  }

  export type GetLogSlotmachineAggregateType<T extends LogSlotmachineAggregateArgs> = {
        [P in keyof T & keyof AggregateLogSlotmachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogSlotmachine[P]>
      : GetScalarType<T[P], AggregateLogSlotmachine[P]>
  }




  export type LogSlotmachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSlotmachineWhereInput
    orderBy?: LogSlotmachineOrderByWithAggregationInput | LogSlotmachineOrderByWithAggregationInput[]
    by: LogSlotmachineScalarFieldEnum[] | LogSlotmachineScalarFieldEnum
    having?: LogSlotmachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogSlotmachineCountAggregateInputType | true
    _avg?: LogSlotmachineAvgAggregateInputType
    _sum?: LogSlotmachineSumAggregateInputType
    _min?: LogSlotmachineMinAggregateInputType
    _max?: LogSlotmachineMaxAggregateInputType
  }

  export type LogSlotmachineGroupByOutputType = {
    id: number
    userId: number
    amount: number
    isWin: boolean
    date: number
    _count: LogSlotmachineCountAggregateOutputType | null
    _avg: LogSlotmachineAvgAggregateOutputType | null
    _sum: LogSlotmachineSumAggregateOutputType | null
    _min: LogSlotmachineMinAggregateOutputType | null
    _max: LogSlotmachineMaxAggregateOutputType | null
  }

  type GetLogSlotmachineGroupByPayload<T extends LogSlotmachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogSlotmachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogSlotmachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogSlotmachineGroupByOutputType[P]>
            : GetScalarType<T[P], LogSlotmachineGroupByOutputType[P]>
        }
      >
    >


  export type LogSlotmachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    isWin?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logSlotmachine"]>

  export type LogSlotmachineSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    isWin?: boolean
    date?: boolean
  }

  export type LogSlotmachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LogSlotmachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogSlotmachine"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      amount: number
      isWin: boolean
      date: number
    }, ExtArgs["result"]["logSlotmachine"]>
    composites: {}
  }


  type LogSlotmachineGetPayload<S extends boolean | null | undefined | LogSlotmachineDefaultArgs> = $Result.GetResult<Prisma.$LogSlotmachinePayload, S>

  type LogSlotmachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogSlotmachineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogSlotmachineCountAggregateInputType | true
    }

  export interface LogSlotmachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogSlotmachine'], meta: { name: 'LogSlotmachine' } }
    /**
     * Find zero or one LogSlotmachine that matches the filter.
     * @param {LogSlotmachineFindUniqueArgs} args - Arguments to find a LogSlotmachine
     * @example
     * // Get one LogSlotmachine
     * const logSlotmachine = await prisma.logSlotmachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogSlotmachineFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogSlotmachineFindUniqueArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogSlotmachine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogSlotmachineFindUniqueOrThrowArgs} args - Arguments to find a LogSlotmachine
     * @example
     * // Get one LogSlotmachine
     * const logSlotmachine = await prisma.logSlotmachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogSlotmachineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSlotmachineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogSlotmachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineFindFirstArgs} args - Arguments to find a LogSlotmachine
     * @example
     * // Get one LogSlotmachine
     * const logSlotmachine = await prisma.logSlotmachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogSlotmachineFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSlotmachineFindFirstArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogSlotmachine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineFindFirstOrThrowArgs} args - Arguments to find a LogSlotmachine
     * @example
     * // Get one LogSlotmachine
     * const logSlotmachine = await prisma.logSlotmachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogSlotmachineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSlotmachineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogSlotmachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogSlotmachines
     * const logSlotmachines = await prisma.logSlotmachine.findMany()
     * 
     * // Get first 10 LogSlotmachines
     * const logSlotmachines = await prisma.logSlotmachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logSlotmachineWithIdOnly = await prisma.logSlotmachine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogSlotmachineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSlotmachineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogSlotmachine.
     * @param {LogSlotmachineCreateArgs} args - Arguments to create a LogSlotmachine.
     * @example
     * // Create one LogSlotmachine
     * const LogSlotmachine = await prisma.logSlotmachine.create({
     *   data: {
     *     // ... data to create a LogSlotmachine
     *   }
     * })
     * 
    **/
    create<T extends LogSlotmachineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogSlotmachineCreateArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogSlotmachines.
     *     @param {LogSlotmachineCreateManyArgs} args - Arguments to create many LogSlotmachines.
     *     @example
     *     // Create many LogSlotmachines
     *     const logSlotmachine = await prisma.logSlotmachine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogSlotmachineCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSlotmachineCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogSlotmachine.
     * @param {LogSlotmachineDeleteArgs} args - Arguments to delete one LogSlotmachine.
     * @example
     * // Delete one LogSlotmachine
     * const LogSlotmachine = await prisma.logSlotmachine.delete({
     *   where: {
     *     // ... filter to delete one LogSlotmachine
     *   }
     * })
     * 
    **/
    delete<T extends LogSlotmachineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogSlotmachineDeleteArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogSlotmachine.
     * @param {LogSlotmachineUpdateArgs} args - Arguments to update one LogSlotmachine.
     * @example
     * // Update one LogSlotmachine
     * const logSlotmachine = await prisma.logSlotmachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogSlotmachineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogSlotmachineUpdateArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogSlotmachines.
     * @param {LogSlotmachineDeleteManyArgs} args - Arguments to filter LogSlotmachines to delete.
     * @example
     * // Delete a few LogSlotmachines
     * const { count } = await prisma.logSlotmachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogSlotmachineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSlotmachineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogSlotmachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogSlotmachines
     * const logSlotmachine = await prisma.logSlotmachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogSlotmachineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogSlotmachineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogSlotmachine.
     * @param {LogSlotmachineUpsertArgs} args - Arguments to update or create a LogSlotmachine.
     * @example
     * // Update or create a LogSlotmachine
     * const logSlotmachine = await prisma.logSlotmachine.upsert({
     *   create: {
     *     // ... data to create a LogSlotmachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogSlotmachine we want to update
     *   }
     * })
    **/
    upsert<T extends LogSlotmachineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogSlotmachineUpsertArgs<ExtArgs>>
    ): Prisma__LogSlotmachineClient<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogSlotmachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineCountArgs} args - Arguments to filter LogSlotmachines to count.
     * @example
     * // Count the number of LogSlotmachines
     * const count = await prisma.logSlotmachine.count({
     *   where: {
     *     // ... the filter for the LogSlotmachines we want to count
     *   }
     * })
    **/
    count<T extends LogSlotmachineCountArgs>(
      args?: Subset<T, LogSlotmachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogSlotmachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogSlotmachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogSlotmachineAggregateArgs>(args: Subset<T, LogSlotmachineAggregateArgs>): Prisma.PrismaPromise<GetLogSlotmachineAggregateType<T>>

    /**
     * Group by LogSlotmachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSlotmachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogSlotmachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogSlotmachineGroupByArgs['orderBy'] }
        : { orderBy?: LogSlotmachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogSlotmachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogSlotmachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogSlotmachine model
   */
  readonly fields: LogSlotmachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogSlotmachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogSlotmachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogSlotmachine model
   */ 
  interface LogSlotmachineFieldRefs {
    readonly id: FieldRef<"LogSlotmachine", 'Int'>
    readonly userId: FieldRef<"LogSlotmachine", 'Int'>
    readonly amount: FieldRef<"LogSlotmachine", 'Int'>
    readonly isWin: FieldRef<"LogSlotmachine", 'Boolean'>
    readonly date: FieldRef<"LogSlotmachine", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogSlotmachine findUnique
   */
  export type LogSlotmachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * Filter, which LogSlotmachine to fetch.
     */
    where: LogSlotmachineWhereUniqueInput
  }


  /**
   * LogSlotmachine findUniqueOrThrow
   */
  export type LogSlotmachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * Filter, which LogSlotmachine to fetch.
     */
    where: LogSlotmachineWhereUniqueInput
  }


  /**
   * LogSlotmachine findFirst
   */
  export type LogSlotmachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * Filter, which LogSlotmachine to fetch.
     */
    where?: LogSlotmachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSlotmachines to fetch.
     */
    orderBy?: LogSlotmachineOrderByWithRelationInput | LogSlotmachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSlotmachines.
     */
    cursor?: LogSlotmachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSlotmachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSlotmachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSlotmachines.
     */
    distinct?: LogSlotmachineScalarFieldEnum | LogSlotmachineScalarFieldEnum[]
  }


  /**
   * LogSlotmachine findFirstOrThrow
   */
  export type LogSlotmachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * Filter, which LogSlotmachine to fetch.
     */
    where?: LogSlotmachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSlotmachines to fetch.
     */
    orderBy?: LogSlotmachineOrderByWithRelationInput | LogSlotmachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSlotmachines.
     */
    cursor?: LogSlotmachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSlotmachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSlotmachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSlotmachines.
     */
    distinct?: LogSlotmachineScalarFieldEnum | LogSlotmachineScalarFieldEnum[]
  }


  /**
   * LogSlotmachine findMany
   */
  export type LogSlotmachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * Filter, which LogSlotmachines to fetch.
     */
    where?: LogSlotmachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSlotmachines to fetch.
     */
    orderBy?: LogSlotmachineOrderByWithRelationInput | LogSlotmachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogSlotmachines.
     */
    cursor?: LogSlotmachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSlotmachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSlotmachines.
     */
    skip?: number
    distinct?: LogSlotmachineScalarFieldEnum | LogSlotmachineScalarFieldEnum[]
  }


  /**
   * LogSlotmachine create
   */
  export type LogSlotmachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * The data needed to create a LogSlotmachine.
     */
    data: XOR<LogSlotmachineCreateInput, LogSlotmachineUncheckedCreateInput>
  }


  /**
   * LogSlotmachine createMany
   */
  export type LogSlotmachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogSlotmachines.
     */
    data: LogSlotmachineCreateManyInput | LogSlotmachineCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogSlotmachine update
   */
  export type LogSlotmachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * The data needed to update a LogSlotmachine.
     */
    data: XOR<LogSlotmachineUpdateInput, LogSlotmachineUncheckedUpdateInput>
    /**
     * Choose, which LogSlotmachine to update.
     */
    where: LogSlotmachineWhereUniqueInput
  }


  /**
   * LogSlotmachine updateMany
   */
  export type LogSlotmachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogSlotmachines.
     */
    data: XOR<LogSlotmachineUpdateManyMutationInput, LogSlotmachineUncheckedUpdateManyInput>
    /**
     * Filter which LogSlotmachines to update
     */
    where?: LogSlotmachineWhereInput
  }


  /**
   * LogSlotmachine upsert
   */
  export type LogSlotmachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * The filter to search for the LogSlotmachine to update in case it exists.
     */
    where: LogSlotmachineWhereUniqueInput
    /**
     * In case the LogSlotmachine found by the `where` argument doesn't exist, create a new LogSlotmachine with this data.
     */
    create: XOR<LogSlotmachineCreateInput, LogSlotmachineUncheckedCreateInput>
    /**
     * In case the LogSlotmachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogSlotmachineUpdateInput, LogSlotmachineUncheckedUpdateInput>
  }


  /**
   * LogSlotmachine delete
   */
  export type LogSlotmachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    /**
     * Filter which LogSlotmachine to delete.
     */
    where: LogSlotmachineWhereUniqueInput
  }


  /**
   * LogSlotmachine deleteMany
   */
  export type LogSlotmachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSlotmachines to delete
     */
    where?: LogSlotmachineWhereInput
  }


  /**
   * LogSlotmachine without action
   */
  export type LogSlotmachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
  }



  /**
   * Model LogStaff
   */

  export type AggregateLogStaff = {
    _count: LogStaffCountAggregateOutputType | null
    _avg: LogStaffAvgAggregateOutputType | null
    _sum: LogStaffSumAggregateOutputType | null
    _min: LogStaffMinAggregateOutputType | null
    _max: LogStaffMaxAggregateOutputType | null
  }

  export type LogStaffAvgAggregateOutputType = {
    id: number | null
    date: number | null
  }

  export type LogStaffSumAggregateOutputType = {
    id: number | null
    date: number | null
  }

  export type LogStaffMinAggregateOutputType = {
    id: number | null
    pseudo: string | null
    action: string | null
    date: number | null
  }

  export type LogStaffMaxAggregateOutputType = {
    id: number | null
    pseudo: string | null
    action: string | null
    date: number | null
  }

  export type LogStaffCountAggregateOutputType = {
    id: number
    pseudo: number
    action: number
    date: number
    _all: number
  }


  export type LogStaffAvgAggregateInputType = {
    id?: true
    date?: true
  }

  export type LogStaffSumAggregateInputType = {
    id?: true
    date?: true
  }

  export type LogStaffMinAggregateInputType = {
    id?: true
    pseudo?: true
    action?: true
    date?: true
  }

  export type LogStaffMaxAggregateInputType = {
    id?: true
    pseudo?: true
    action?: true
    date?: true
  }

  export type LogStaffCountAggregateInputType = {
    id?: true
    pseudo?: true
    action?: true
    date?: true
    _all?: true
  }

  export type LogStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogStaff to aggregate.
     */
    where?: LogStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStaffs to fetch.
     */
    orderBy?: LogStaffOrderByWithRelationInput | LogStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogStaffs
    **/
    _count?: true | LogStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogStaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogStaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogStaffMaxAggregateInputType
  }

  export type GetLogStaffAggregateType<T extends LogStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateLogStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogStaff[P]>
      : GetScalarType<T[P], AggregateLogStaff[P]>
  }




  export type LogStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogStaffWhereInput
    orderBy?: LogStaffOrderByWithAggregationInput | LogStaffOrderByWithAggregationInput[]
    by: LogStaffScalarFieldEnum[] | LogStaffScalarFieldEnum
    having?: LogStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogStaffCountAggregateInputType | true
    _avg?: LogStaffAvgAggregateInputType
    _sum?: LogStaffSumAggregateInputType
    _min?: LogStaffMinAggregateInputType
    _max?: LogStaffMaxAggregateInputType
  }

  export type LogStaffGroupByOutputType = {
    id: number
    pseudo: string
    action: string
    date: number
    _count: LogStaffCountAggregateOutputType | null
    _avg: LogStaffAvgAggregateOutputType | null
    _sum: LogStaffSumAggregateOutputType | null
    _min: LogStaffMinAggregateOutputType | null
    _max: LogStaffMaxAggregateOutputType | null
  }

  type GetLogStaffGroupByPayload<T extends LogStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogStaffGroupByOutputType[P]>
            : GetScalarType<T[P], LogStaffGroupByOutputType[P]>
        }
      >
    >


  export type LogStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pseudo?: boolean
    action?: boolean
    date?: boolean
  }, ExtArgs["result"]["logStaff"]>

  export type LogStaffSelectScalar = {
    id?: boolean
    pseudo?: boolean
    action?: boolean
    date?: boolean
  }


  export type $LogStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogStaff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pseudo: string
      action: string
      date: number
    }, ExtArgs["result"]["logStaff"]>
    composites: {}
  }


  type LogStaffGetPayload<S extends boolean | null | undefined | LogStaffDefaultArgs> = $Result.GetResult<Prisma.$LogStaffPayload, S>

  type LogStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogStaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogStaffCountAggregateInputType | true
    }

  export interface LogStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogStaff'], meta: { name: 'LogStaff' } }
    /**
     * Find zero or one LogStaff that matches the filter.
     * @param {LogStaffFindUniqueArgs} args - Arguments to find a LogStaff
     * @example
     * // Get one LogStaff
     * const logStaff = await prisma.logStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogStaffFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogStaffFindUniqueArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogStaff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogStaffFindUniqueOrThrowArgs} args - Arguments to find a LogStaff
     * @example
     * // Get one LogStaff
     * const logStaff = await prisma.logStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogStaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogStaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffFindFirstArgs} args - Arguments to find a LogStaff
     * @example
     * // Get one LogStaff
     * const logStaff = await prisma.logStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogStaffFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogStaffFindFirstArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffFindFirstOrThrowArgs} args - Arguments to find a LogStaff
     * @example
     * // Get one LogStaff
     * const logStaff = await prisma.logStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogStaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogStaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogStaffs
     * const logStaffs = await prisma.logStaff.findMany()
     * 
     * // Get first 10 LogStaffs
     * const logStaffs = await prisma.logStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logStaffWithIdOnly = await prisma.logStaff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogStaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogStaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogStaff.
     * @param {LogStaffCreateArgs} args - Arguments to create a LogStaff.
     * @example
     * // Create one LogStaff
     * const LogStaff = await prisma.logStaff.create({
     *   data: {
     *     // ... data to create a LogStaff
     *   }
     * })
     * 
    **/
    create<T extends LogStaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogStaffCreateArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogStaffs.
     *     @param {LogStaffCreateManyArgs} args - Arguments to create many LogStaffs.
     *     @example
     *     // Create many LogStaffs
     *     const logStaff = await prisma.logStaff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogStaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogStaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogStaff.
     * @param {LogStaffDeleteArgs} args - Arguments to delete one LogStaff.
     * @example
     * // Delete one LogStaff
     * const LogStaff = await prisma.logStaff.delete({
     *   where: {
     *     // ... filter to delete one LogStaff
     *   }
     * })
     * 
    **/
    delete<T extends LogStaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogStaffDeleteArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogStaff.
     * @param {LogStaffUpdateArgs} args - Arguments to update one LogStaff.
     * @example
     * // Update one LogStaff
     * const logStaff = await prisma.logStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogStaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogStaffUpdateArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogStaffs.
     * @param {LogStaffDeleteManyArgs} args - Arguments to filter LogStaffs to delete.
     * @example
     * // Delete a few LogStaffs
     * const { count } = await prisma.logStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogStaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogStaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogStaffs
     * const logStaff = await prisma.logStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogStaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogStaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogStaff.
     * @param {LogStaffUpsertArgs} args - Arguments to update or create a LogStaff.
     * @example
     * // Update or create a LogStaff
     * const logStaff = await prisma.logStaff.upsert({
     *   create: {
     *     // ... data to create a LogStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogStaff we want to update
     *   }
     * })
    **/
    upsert<T extends LogStaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogStaffUpsertArgs<ExtArgs>>
    ): Prisma__LogStaffClient<$Result.GetResult<Prisma.$LogStaffPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffCountArgs} args - Arguments to filter LogStaffs to count.
     * @example
     * // Count the number of LogStaffs
     * const count = await prisma.logStaff.count({
     *   where: {
     *     // ... the filter for the LogStaffs we want to count
     *   }
     * })
    **/
    count<T extends LogStaffCountArgs>(
      args?: Subset<T, LogStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogStaffAggregateArgs>(args: Subset<T, LogStaffAggregateArgs>): Prisma.PrismaPromise<GetLogStaffAggregateType<T>>

    /**
     * Group by LogStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogStaffGroupByArgs['orderBy'] }
        : { orderBy?: LogStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogStaff model
   */
  readonly fields: LogStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogStaff model
   */ 
  interface LogStaffFieldRefs {
    readonly id: FieldRef<"LogStaff", 'Int'>
    readonly pseudo: FieldRef<"LogStaff", 'String'>
    readonly action: FieldRef<"LogStaff", 'String'>
    readonly date: FieldRef<"LogStaff", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogStaff findUnique
   */
  export type LogStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * Filter, which LogStaff to fetch.
     */
    where: LogStaffWhereUniqueInput
  }


  /**
   * LogStaff findUniqueOrThrow
   */
  export type LogStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * Filter, which LogStaff to fetch.
     */
    where: LogStaffWhereUniqueInput
  }


  /**
   * LogStaff findFirst
   */
  export type LogStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * Filter, which LogStaff to fetch.
     */
    where?: LogStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStaffs to fetch.
     */
    orderBy?: LogStaffOrderByWithRelationInput | LogStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogStaffs.
     */
    cursor?: LogStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogStaffs.
     */
    distinct?: LogStaffScalarFieldEnum | LogStaffScalarFieldEnum[]
  }


  /**
   * LogStaff findFirstOrThrow
   */
  export type LogStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * Filter, which LogStaff to fetch.
     */
    where?: LogStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStaffs to fetch.
     */
    orderBy?: LogStaffOrderByWithRelationInput | LogStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogStaffs.
     */
    cursor?: LogStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogStaffs.
     */
    distinct?: LogStaffScalarFieldEnum | LogStaffScalarFieldEnum[]
  }


  /**
   * LogStaff findMany
   */
  export type LogStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * Filter, which LogStaffs to fetch.
     */
    where?: LogStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStaffs to fetch.
     */
    orderBy?: LogStaffOrderByWithRelationInput | LogStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogStaffs.
     */
    cursor?: LogStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStaffs.
     */
    skip?: number
    distinct?: LogStaffScalarFieldEnum | LogStaffScalarFieldEnum[]
  }


  /**
   * LogStaff create
   */
  export type LogStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * The data needed to create a LogStaff.
     */
    data: XOR<LogStaffCreateInput, LogStaffUncheckedCreateInput>
  }


  /**
   * LogStaff createMany
   */
  export type LogStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogStaffs.
     */
    data: LogStaffCreateManyInput | LogStaffCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogStaff update
   */
  export type LogStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * The data needed to update a LogStaff.
     */
    data: XOR<LogStaffUpdateInput, LogStaffUncheckedUpdateInput>
    /**
     * Choose, which LogStaff to update.
     */
    where: LogStaffWhereUniqueInput
  }


  /**
   * LogStaff updateMany
   */
  export type LogStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogStaffs.
     */
    data: XOR<LogStaffUpdateManyMutationInput, LogStaffUncheckedUpdateManyInput>
    /**
     * Filter which LogStaffs to update
     */
    where?: LogStaffWhereInput
  }


  /**
   * LogStaff upsert
   */
  export type LogStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * The filter to search for the LogStaff to update in case it exists.
     */
    where: LogStaffWhereUniqueInput
    /**
     * In case the LogStaff found by the `where` argument doesn't exist, create a new LogStaff with this data.
     */
    create: XOR<LogStaffCreateInput, LogStaffUncheckedCreateInput>
    /**
     * In case the LogStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogStaffUpdateInput, LogStaffUncheckedUpdateInput>
  }


  /**
   * LogStaff delete
   */
  export type LogStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
    /**
     * Filter which LogStaff to delete.
     */
    where: LogStaffWhereUniqueInput
  }


  /**
   * LogStaff deleteMany
   */
  export type LogStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogStaffs to delete
     */
    where?: LogStaffWhereInput
  }


  /**
   * LogStaff without action
   */
  export type LogStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStaff
     */
    select?: LogStaffSelect<ExtArgs> | null
  }



  /**
   * Model LogTrade
   */

  export type AggregateLogTrade = {
    _count: LogTradeCountAggregateOutputType | null
    _avg: LogTradeAvgAggregateOutputType | null
    _sum: LogTradeSumAggregateOutputType | null
    _min: LogTradeMinAggregateOutputType | null
    _max: LogTradeMaxAggregateOutputType | null
  }

  export type LogTradeAvgAggregateOutputType = {
    id: number | null
    userOneId: number | null
    userTwoId: number | null
    roomId: number | null
    time: number | null
  }

  export type LogTradeSumAggregateOutputType = {
    id: number | null
    userOneId: number | null
    userTwoId: number | null
    roomId: number | null
    time: number | null
  }

  export type LogTradeMinAggregateOutputType = {
    id: number | null
    userOneId: number | null
    userTwoId: number | null
    userOneItems: string | null
    userTwoItems: string | null
    roomId: number | null
    time: number | null
  }

  export type LogTradeMaxAggregateOutputType = {
    id: number | null
    userOneId: number | null
    userTwoId: number | null
    userOneItems: string | null
    userTwoItems: string | null
    roomId: number | null
    time: number | null
  }

  export type LogTradeCountAggregateOutputType = {
    id: number
    userOneId: number
    userTwoId: number
    userOneItems: number
    userTwoItems: number
    roomId: number
    time: number
    _all: number
  }


  export type LogTradeAvgAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
    roomId?: true
    time?: true
  }

  export type LogTradeSumAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
    roomId?: true
    time?: true
  }

  export type LogTradeMinAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
    userOneItems?: true
    userTwoItems?: true
    roomId?: true
    time?: true
  }

  export type LogTradeMaxAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
    userOneItems?: true
    userTwoItems?: true
    roomId?: true
    time?: true
  }

  export type LogTradeCountAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
    userOneItems?: true
    userTwoItems?: true
    roomId?: true
    time?: true
    _all?: true
  }

  export type LogTradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogTrade to aggregate.
     */
    where?: LogTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTrades to fetch.
     */
    orderBy?: LogTradeOrderByWithRelationInput | LogTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogTrades
    **/
    _count?: true | LogTradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogTradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogTradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogTradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogTradeMaxAggregateInputType
  }

  export type GetLogTradeAggregateType<T extends LogTradeAggregateArgs> = {
        [P in keyof T & keyof AggregateLogTrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogTrade[P]>
      : GetScalarType<T[P], AggregateLogTrade[P]>
  }




  export type LogTradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogTradeWhereInput
    orderBy?: LogTradeOrderByWithAggregationInput | LogTradeOrderByWithAggregationInput[]
    by: LogTradeScalarFieldEnum[] | LogTradeScalarFieldEnum
    having?: LogTradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogTradeCountAggregateInputType | true
    _avg?: LogTradeAvgAggregateInputType
    _sum?: LogTradeSumAggregateInputType
    _min?: LogTradeMinAggregateInputType
    _max?: LogTradeMaxAggregateInputType
  }

  export type LogTradeGroupByOutputType = {
    id: number
    userOneId: number
    userTwoId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
    _count: LogTradeCountAggregateOutputType | null
    _avg: LogTradeAvgAggregateOutputType | null
    _sum: LogTradeSumAggregateOutputType | null
    _min: LogTradeMinAggregateOutputType | null
    _max: LogTradeMaxAggregateOutputType | null
  }

  type GetLogTradeGroupByPayload<T extends LogTradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogTradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogTradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogTradeGroupByOutputType[P]>
            : GetScalarType<T[P], LogTradeGroupByOutputType[P]>
        }
      >
    >


  export type LogTradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userOneId?: boolean
    userTwoId?: boolean
    userOneItems?: boolean
    userTwoItems?: boolean
    roomId?: boolean
    time?: boolean
    userOneTrade?: boolean | UserDefaultArgs<ExtArgs>
    userTwoTrade?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logTrade"]>

  export type LogTradeSelectScalar = {
    id?: boolean
    userOneId?: boolean
    userTwoId?: boolean
    userOneItems?: boolean
    userTwoItems?: boolean
    roomId?: boolean
    time?: boolean
  }

  export type LogTradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userOneTrade?: boolean | UserDefaultArgs<ExtArgs>
    userTwoTrade?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LogTradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogTrade"
    objects: {
      userOneTrade: Prisma.$UserPayload<ExtArgs>
      userTwoTrade: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userOneId: number
      userTwoId: number
      userOneItems: string
      userTwoItems: string
      roomId: number
      time: number
    }, ExtArgs["result"]["logTrade"]>
    composites: {}
  }


  type LogTradeGetPayload<S extends boolean | null | undefined | LogTradeDefaultArgs> = $Result.GetResult<Prisma.$LogTradePayload, S>

  type LogTradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogTradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogTradeCountAggregateInputType | true
    }

  export interface LogTradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogTrade'], meta: { name: 'LogTrade' } }
    /**
     * Find zero or one LogTrade that matches the filter.
     * @param {LogTradeFindUniqueArgs} args - Arguments to find a LogTrade
     * @example
     * // Get one LogTrade
     * const logTrade = await prisma.logTrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogTradeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogTradeFindUniqueArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogTrade that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogTradeFindUniqueOrThrowArgs} args - Arguments to find a LogTrade
     * @example
     * // Get one LogTrade
     * const logTrade = await prisma.logTrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogTradeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTradeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogTrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeFindFirstArgs} args - Arguments to find a LogTrade
     * @example
     * // Get one LogTrade
     * const logTrade = await prisma.logTrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogTradeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTradeFindFirstArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogTrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeFindFirstOrThrowArgs} args - Arguments to find a LogTrade
     * @example
     * // Get one LogTrade
     * const logTrade = await prisma.logTrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogTradeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTradeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogTrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogTrades
     * const logTrades = await prisma.logTrade.findMany()
     * 
     * // Get first 10 LogTrades
     * const logTrades = await prisma.logTrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logTradeWithIdOnly = await prisma.logTrade.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogTradeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTradeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogTrade.
     * @param {LogTradeCreateArgs} args - Arguments to create a LogTrade.
     * @example
     * // Create one LogTrade
     * const LogTrade = await prisma.logTrade.create({
     *   data: {
     *     // ... data to create a LogTrade
     *   }
     * })
     * 
    **/
    create<T extends LogTradeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogTradeCreateArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogTrades.
     *     @param {LogTradeCreateManyArgs} args - Arguments to create many LogTrades.
     *     @example
     *     // Create many LogTrades
     *     const logTrade = await prisma.logTrade.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogTradeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTradeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogTrade.
     * @param {LogTradeDeleteArgs} args - Arguments to delete one LogTrade.
     * @example
     * // Delete one LogTrade
     * const LogTrade = await prisma.logTrade.delete({
     *   where: {
     *     // ... filter to delete one LogTrade
     *   }
     * })
     * 
    **/
    delete<T extends LogTradeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogTradeDeleteArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogTrade.
     * @param {LogTradeUpdateArgs} args - Arguments to update one LogTrade.
     * @example
     * // Update one LogTrade
     * const logTrade = await prisma.logTrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogTradeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogTradeUpdateArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogTrades.
     * @param {LogTradeDeleteManyArgs} args - Arguments to filter LogTrades to delete.
     * @example
     * // Delete a few LogTrades
     * const { count } = await prisma.logTrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogTradeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogTradeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogTrades
     * const logTrade = await prisma.logTrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogTradeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogTradeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogTrade.
     * @param {LogTradeUpsertArgs} args - Arguments to update or create a LogTrade.
     * @example
     * // Update or create a LogTrade
     * const logTrade = await prisma.logTrade.upsert({
     *   create: {
     *     // ... data to create a LogTrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogTrade we want to update
     *   }
     * })
    **/
    upsert<T extends LogTradeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogTradeUpsertArgs<ExtArgs>>
    ): Prisma__LogTradeClient<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogTrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeCountArgs} args - Arguments to filter LogTrades to count.
     * @example
     * // Count the number of LogTrades
     * const count = await prisma.logTrade.count({
     *   where: {
     *     // ... the filter for the LogTrades we want to count
     *   }
     * })
    **/
    count<T extends LogTradeCountArgs>(
      args?: Subset<T, LogTradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogTradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogTrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogTradeAggregateArgs>(args: Subset<T, LogTradeAggregateArgs>): Prisma.PrismaPromise<GetLogTradeAggregateType<T>>

    /**
     * Group by LogTrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogTradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogTradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogTradeGroupByArgs['orderBy'] }
        : { orderBy?: LogTradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogTradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogTradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogTrade model
   */
  readonly fields: LogTradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogTrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogTradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userOneTrade<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userTwoTrade<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogTrade model
   */ 
  interface LogTradeFieldRefs {
    readonly id: FieldRef<"LogTrade", 'Int'>
    readonly userOneId: FieldRef<"LogTrade", 'Int'>
    readonly userTwoId: FieldRef<"LogTrade", 'Int'>
    readonly userOneItems: FieldRef<"LogTrade", 'String'>
    readonly userTwoItems: FieldRef<"LogTrade", 'String'>
    readonly roomId: FieldRef<"LogTrade", 'Int'>
    readonly time: FieldRef<"LogTrade", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LogTrade findUnique
   */
  export type LogTradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * Filter, which LogTrade to fetch.
     */
    where: LogTradeWhereUniqueInput
  }


  /**
   * LogTrade findUniqueOrThrow
   */
  export type LogTradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * Filter, which LogTrade to fetch.
     */
    where: LogTradeWhereUniqueInput
  }


  /**
   * LogTrade findFirst
   */
  export type LogTradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * Filter, which LogTrade to fetch.
     */
    where?: LogTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTrades to fetch.
     */
    orderBy?: LogTradeOrderByWithRelationInput | LogTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogTrades.
     */
    cursor?: LogTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogTrades.
     */
    distinct?: LogTradeScalarFieldEnum | LogTradeScalarFieldEnum[]
  }


  /**
   * LogTrade findFirstOrThrow
   */
  export type LogTradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * Filter, which LogTrade to fetch.
     */
    where?: LogTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTrades to fetch.
     */
    orderBy?: LogTradeOrderByWithRelationInput | LogTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogTrades.
     */
    cursor?: LogTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogTrades.
     */
    distinct?: LogTradeScalarFieldEnum | LogTradeScalarFieldEnum[]
  }


  /**
   * LogTrade findMany
   */
  export type LogTradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * Filter, which LogTrades to fetch.
     */
    where?: LogTradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogTrades to fetch.
     */
    orderBy?: LogTradeOrderByWithRelationInput | LogTradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogTrades.
     */
    cursor?: LogTradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogTrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogTrades.
     */
    skip?: number
    distinct?: LogTradeScalarFieldEnum | LogTradeScalarFieldEnum[]
  }


  /**
   * LogTrade create
   */
  export type LogTradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * The data needed to create a LogTrade.
     */
    data: XOR<LogTradeCreateInput, LogTradeUncheckedCreateInput>
  }


  /**
   * LogTrade createMany
   */
  export type LogTradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogTrades.
     */
    data: LogTradeCreateManyInput | LogTradeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogTrade update
   */
  export type LogTradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * The data needed to update a LogTrade.
     */
    data: XOR<LogTradeUpdateInput, LogTradeUncheckedUpdateInput>
    /**
     * Choose, which LogTrade to update.
     */
    where: LogTradeWhereUniqueInput
  }


  /**
   * LogTrade updateMany
   */
  export type LogTradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogTrades.
     */
    data: XOR<LogTradeUpdateManyMutationInput, LogTradeUncheckedUpdateManyInput>
    /**
     * Filter which LogTrades to update
     */
    where?: LogTradeWhereInput
  }


  /**
   * LogTrade upsert
   */
  export type LogTradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * The filter to search for the LogTrade to update in case it exists.
     */
    where: LogTradeWhereUniqueInput
    /**
     * In case the LogTrade found by the `where` argument doesn't exist, create a new LogTrade with this data.
     */
    create: XOR<LogTradeCreateInput, LogTradeUncheckedCreateInput>
    /**
     * In case the LogTrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogTradeUpdateInput, LogTradeUncheckedUpdateInput>
  }


  /**
   * LogTrade delete
   */
  export type LogTradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    /**
     * Filter which LogTrade to delete.
     */
    where: LogTradeWhereUniqueInput
  }


  /**
   * LogTrade deleteMany
   */
  export type LogTradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogTrades to delete
     */
    where?: LogTradeWhereInput
  }


  /**
   * LogTrade without action
   */
  export type LogTradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
  }



  /**
   * Model LogVpn
   */

  export type AggregateLogVpn = {
    _count: LogVpnCountAggregateOutputType | null
    _avg: LogVpnAvgAggregateOutputType | null
    _sum: LogVpnSumAggregateOutputType | null
    _min: LogVpnMinAggregateOutputType | null
    _max: LogVpnMaxAggregateOutputType | null
  }

  export type LogVpnAvgAggregateOutputType = {
    id: number | null
    timestampCreated: number | null
  }

  export type LogVpnSumAggregateOutputType = {
    id: number | null
    timestampCreated: number | null
  }

  export type LogVpnMinAggregateOutputType = {
    id: number | null
    ip: string | null
    ipCountry: string | null
    host: string | null
    timestampCreated: number | null
    isVpn: boolean | null
  }

  export type LogVpnMaxAggregateOutputType = {
    id: number | null
    ip: string | null
    ipCountry: string | null
    host: string | null
    timestampCreated: number | null
    isVpn: boolean | null
  }

  export type LogVpnCountAggregateOutputType = {
    id: number
    ip: number
    ipCountry: number
    host: number
    timestampCreated: number
    isVpn: number
    _all: number
  }


  export type LogVpnAvgAggregateInputType = {
    id?: true
    timestampCreated?: true
  }

  export type LogVpnSumAggregateInputType = {
    id?: true
    timestampCreated?: true
  }

  export type LogVpnMinAggregateInputType = {
    id?: true
    ip?: true
    ipCountry?: true
    host?: true
    timestampCreated?: true
    isVpn?: true
  }

  export type LogVpnMaxAggregateInputType = {
    id?: true
    ip?: true
    ipCountry?: true
    host?: true
    timestampCreated?: true
    isVpn?: true
  }

  export type LogVpnCountAggregateInputType = {
    id?: true
    ip?: true
    ipCountry?: true
    host?: true
    timestampCreated?: true
    isVpn?: true
    _all?: true
  }

  export type LogVpnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogVpn to aggregate.
     */
    where?: LogVpnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogVpns to fetch.
     */
    orderBy?: LogVpnOrderByWithRelationInput | LogVpnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogVpnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogVpns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogVpns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogVpns
    **/
    _count?: true | LogVpnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogVpnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogVpnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogVpnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogVpnMaxAggregateInputType
  }

  export type GetLogVpnAggregateType<T extends LogVpnAggregateArgs> = {
        [P in keyof T & keyof AggregateLogVpn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogVpn[P]>
      : GetScalarType<T[P], AggregateLogVpn[P]>
  }




  export type LogVpnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogVpnWhereInput
    orderBy?: LogVpnOrderByWithAggregationInput | LogVpnOrderByWithAggregationInput[]
    by: LogVpnScalarFieldEnum[] | LogVpnScalarFieldEnum
    having?: LogVpnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogVpnCountAggregateInputType | true
    _avg?: LogVpnAvgAggregateInputType
    _sum?: LogVpnSumAggregateInputType
    _min?: LogVpnMinAggregateInputType
    _max?: LogVpnMaxAggregateInputType
  }

  export type LogVpnGroupByOutputType = {
    id: number
    ip: string
    ipCountry: string | null
    host: string | null
    timestampCreated: number
    isVpn: boolean
    _count: LogVpnCountAggregateOutputType | null
    _avg: LogVpnAvgAggregateOutputType | null
    _sum: LogVpnSumAggregateOutputType | null
    _min: LogVpnMinAggregateOutputType | null
    _max: LogVpnMaxAggregateOutputType | null
  }

  type GetLogVpnGroupByPayload<T extends LogVpnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogVpnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogVpnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogVpnGroupByOutputType[P]>
            : GetScalarType<T[P], LogVpnGroupByOutputType[P]>
        }
      >
    >


  export type LogVpnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    ipCountry?: boolean
    host?: boolean
    timestampCreated?: boolean
    isVpn?: boolean
  }, ExtArgs["result"]["logVpn"]>

  export type LogVpnSelectScalar = {
    id?: boolean
    ip?: boolean
    ipCountry?: boolean
    host?: boolean
    timestampCreated?: boolean
    isVpn?: boolean
  }


  export type $LogVpnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogVpn"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ip: string
      ipCountry: string | null
      host: string | null
      timestampCreated: number
      isVpn: boolean
    }, ExtArgs["result"]["logVpn"]>
    composites: {}
  }


  type LogVpnGetPayload<S extends boolean | null | undefined | LogVpnDefaultArgs> = $Result.GetResult<Prisma.$LogVpnPayload, S>

  type LogVpnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogVpnFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogVpnCountAggregateInputType | true
    }

  export interface LogVpnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogVpn'], meta: { name: 'LogVpn' } }
    /**
     * Find zero or one LogVpn that matches the filter.
     * @param {LogVpnFindUniqueArgs} args - Arguments to find a LogVpn
     * @example
     * // Get one LogVpn
     * const logVpn = await prisma.logVpn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogVpnFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogVpnFindUniqueArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogVpn that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogVpnFindUniqueOrThrowArgs} args - Arguments to find a LogVpn
     * @example
     * // Get one LogVpn
     * const logVpn = await prisma.logVpn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogVpnFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogVpnFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogVpn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnFindFirstArgs} args - Arguments to find a LogVpn
     * @example
     * // Get one LogVpn
     * const logVpn = await prisma.logVpn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogVpnFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogVpnFindFirstArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogVpn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnFindFirstOrThrowArgs} args - Arguments to find a LogVpn
     * @example
     * // Get one LogVpn
     * const logVpn = await prisma.logVpn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogVpnFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogVpnFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogVpns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogVpns
     * const logVpns = await prisma.logVpn.findMany()
     * 
     * // Get first 10 LogVpns
     * const logVpns = await prisma.logVpn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logVpnWithIdOnly = await prisma.logVpn.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogVpnFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogVpnFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogVpn.
     * @param {LogVpnCreateArgs} args - Arguments to create a LogVpn.
     * @example
     * // Create one LogVpn
     * const LogVpn = await prisma.logVpn.create({
     *   data: {
     *     // ... data to create a LogVpn
     *   }
     * })
     * 
    **/
    create<T extends LogVpnCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogVpnCreateArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogVpns.
     *     @param {LogVpnCreateManyArgs} args - Arguments to create many LogVpns.
     *     @example
     *     // Create many LogVpns
     *     const logVpn = await prisma.logVpn.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogVpnCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogVpnCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogVpn.
     * @param {LogVpnDeleteArgs} args - Arguments to delete one LogVpn.
     * @example
     * // Delete one LogVpn
     * const LogVpn = await prisma.logVpn.delete({
     *   where: {
     *     // ... filter to delete one LogVpn
     *   }
     * })
     * 
    **/
    delete<T extends LogVpnDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogVpnDeleteArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogVpn.
     * @param {LogVpnUpdateArgs} args - Arguments to update one LogVpn.
     * @example
     * // Update one LogVpn
     * const logVpn = await prisma.logVpn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogVpnUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogVpnUpdateArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogVpns.
     * @param {LogVpnDeleteManyArgs} args - Arguments to filter LogVpns to delete.
     * @example
     * // Delete a few LogVpns
     * const { count } = await prisma.logVpn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogVpnDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogVpnDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogVpns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogVpns
     * const logVpn = await prisma.logVpn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogVpnUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogVpnUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogVpn.
     * @param {LogVpnUpsertArgs} args - Arguments to update or create a LogVpn.
     * @example
     * // Update or create a LogVpn
     * const logVpn = await prisma.logVpn.upsert({
     *   create: {
     *     // ... data to create a LogVpn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogVpn we want to update
     *   }
     * })
    **/
    upsert<T extends LogVpnUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogVpnUpsertArgs<ExtArgs>>
    ): Prisma__LogVpnClient<$Result.GetResult<Prisma.$LogVpnPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogVpns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnCountArgs} args - Arguments to filter LogVpns to count.
     * @example
     * // Count the number of LogVpns
     * const count = await prisma.logVpn.count({
     *   where: {
     *     // ... the filter for the LogVpns we want to count
     *   }
     * })
    **/
    count<T extends LogVpnCountArgs>(
      args?: Subset<T, LogVpnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogVpnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogVpn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogVpnAggregateArgs>(args: Subset<T, LogVpnAggregateArgs>): Prisma.PrismaPromise<GetLogVpnAggregateType<T>>

    /**
     * Group by LogVpn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogVpnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogVpnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogVpnGroupByArgs['orderBy'] }
        : { orderBy?: LogVpnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogVpnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogVpnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogVpn model
   */
  readonly fields: LogVpnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogVpn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogVpnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogVpn model
   */ 
  interface LogVpnFieldRefs {
    readonly id: FieldRef<"LogVpn", 'Int'>
    readonly ip: FieldRef<"LogVpn", 'String'>
    readonly ipCountry: FieldRef<"LogVpn", 'String'>
    readonly host: FieldRef<"LogVpn", 'String'>
    readonly timestampCreated: FieldRef<"LogVpn", 'Int'>
    readonly isVpn: FieldRef<"LogVpn", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * LogVpn findUnique
   */
  export type LogVpnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * Filter, which LogVpn to fetch.
     */
    where: LogVpnWhereUniqueInput
  }


  /**
   * LogVpn findUniqueOrThrow
   */
  export type LogVpnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * Filter, which LogVpn to fetch.
     */
    where: LogVpnWhereUniqueInput
  }


  /**
   * LogVpn findFirst
   */
  export type LogVpnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * Filter, which LogVpn to fetch.
     */
    where?: LogVpnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogVpns to fetch.
     */
    orderBy?: LogVpnOrderByWithRelationInput | LogVpnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogVpns.
     */
    cursor?: LogVpnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogVpns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogVpns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogVpns.
     */
    distinct?: LogVpnScalarFieldEnum | LogVpnScalarFieldEnum[]
  }


  /**
   * LogVpn findFirstOrThrow
   */
  export type LogVpnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * Filter, which LogVpn to fetch.
     */
    where?: LogVpnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogVpns to fetch.
     */
    orderBy?: LogVpnOrderByWithRelationInput | LogVpnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogVpns.
     */
    cursor?: LogVpnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogVpns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogVpns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogVpns.
     */
    distinct?: LogVpnScalarFieldEnum | LogVpnScalarFieldEnum[]
  }


  /**
   * LogVpn findMany
   */
  export type LogVpnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * Filter, which LogVpns to fetch.
     */
    where?: LogVpnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogVpns to fetch.
     */
    orderBy?: LogVpnOrderByWithRelationInput | LogVpnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogVpns.
     */
    cursor?: LogVpnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogVpns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogVpns.
     */
    skip?: number
    distinct?: LogVpnScalarFieldEnum | LogVpnScalarFieldEnum[]
  }


  /**
   * LogVpn create
   */
  export type LogVpnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * The data needed to create a LogVpn.
     */
    data: XOR<LogVpnCreateInput, LogVpnUncheckedCreateInput>
  }


  /**
   * LogVpn createMany
   */
  export type LogVpnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogVpns.
     */
    data: LogVpnCreateManyInput | LogVpnCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogVpn update
   */
  export type LogVpnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * The data needed to update a LogVpn.
     */
    data: XOR<LogVpnUpdateInput, LogVpnUncheckedUpdateInput>
    /**
     * Choose, which LogVpn to update.
     */
    where: LogVpnWhereUniqueInput
  }


  /**
   * LogVpn updateMany
   */
  export type LogVpnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogVpns.
     */
    data: XOR<LogVpnUpdateManyMutationInput, LogVpnUncheckedUpdateManyInput>
    /**
     * Filter which LogVpns to update
     */
    where?: LogVpnWhereInput
  }


  /**
   * LogVpn upsert
   */
  export type LogVpnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * The filter to search for the LogVpn to update in case it exists.
     */
    where: LogVpnWhereUniqueInput
    /**
     * In case the LogVpn found by the `where` argument doesn't exist, create a new LogVpn with this data.
     */
    create: XOR<LogVpnCreateInput, LogVpnUncheckedCreateInput>
    /**
     * In case the LogVpn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogVpnUpdateInput, LogVpnUncheckedUpdateInput>
  }


  /**
   * LogVpn delete
   */
  export type LogVpnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
    /**
     * Filter which LogVpn to delete.
     */
    where: LogVpnWhereUniqueInput
  }


  /**
   * LogVpn deleteMany
   */
  export type LogVpnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogVpns to delete
     */
    where?: LogVpnWhereInput
  }


  /**
   * LogVpn without action
   */
  export type LogVpnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogVpn
     */
    select?: LogVpnSelect<ExtArgs> | null
  }



  /**
   * Model LogSandbox
   */

  export type AggregateLogSandbox = {
    _count: LogSandboxCountAggregateOutputType | null
    _avg: LogSandboxAvgAggregateOutputType | null
    _sum: LogSandboxSumAggregateOutputType | null
    _min: LogSandboxMinAggregateOutputType | null
    _max: LogSandboxMaxAggregateOutputType | null
  }

  export type LogSandboxAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogSandboxSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogSandboxMinAggregateOutputType = {
    id: number | null
    userId: number | null
    method: string | null
    editName: string | null
    editKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogSandboxMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    method: string | null
    editName: string | null
    editKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogSandboxCountAggregateOutputType = {
    id: number
    userId: number
    method: number
    editName: number
    editKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LogSandboxAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogSandboxSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogSandboxMinAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    editName?: true
    editKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogSandboxMaxAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    editName?: true
    editKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogSandboxCountAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    editName?: true
    editKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LogSandboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSandbox to aggregate.
     */
    where?: LogSandboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSandboxes to fetch.
     */
    orderBy?: LogSandboxOrderByWithRelationInput | LogSandboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogSandboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSandboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSandboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogSandboxes
    **/
    _count?: true | LogSandboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogSandboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSandboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogSandboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogSandboxMaxAggregateInputType
  }

  export type GetLogSandboxAggregateType<T extends LogSandboxAggregateArgs> = {
        [P in keyof T & keyof AggregateLogSandbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogSandbox[P]>
      : GetScalarType<T[P], AggregateLogSandbox[P]>
  }




  export type LogSandboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSandboxWhereInput
    orderBy?: LogSandboxOrderByWithAggregationInput | LogSandboxOrderByWithAggregationInput[]
    by: LogSandboxScalarFieldEnum[] | LogSandboxScalarFieldEnum
    having?: LogSandboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogSandboxCountAggregateInputType | true
    _avg?: LogSandboxAvgAggregateInputType
    _sum?: LogSandboxSumAggregateInputType
    _min?: LogSandboxMinAggregateInputType
    _max?: LogSandboxMaxAggregateInputType
  }

  export type LogSandboxGroupByOutputType = {
    id: number
    userId: number
    method: string
    editName: string
    editKey: string
    createdAt: Date
    updatedAt: Date
    _count: LogSandboxCountAggregateOutputType | null
    _avg: LogSandboxAvgAggregateOutputType | null
    _sum: LogSandboxSumAggregateOutputType | null
    _min: LogSandboxMinAggregateOutputType | null
    _max: LogSandboxMaxAggregateOutputType | null
  }

  type GetLogSandboxGroupByPayload<T extends LogSandboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogSandboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogSandboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogSandboxGroupByOutputType[P]>
            : GetScalarType<T[P], LogSandboxGroupByOutputType[P]>
        }
      >
    >


  export type LogSandboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    editName?: boolean
    editKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logSandbox"]>

  export type LogSandboxSelectScalar = {
    id?: boolean
    userId?: boolean
    method?: boolean
    editName?: boolean
    editKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LogSandboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LogSandboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogSandbox"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      method: string
      editName: string
      editKey: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["logSandbox"]>
    composites: {}
  }


  type LogSandboxGetPayload<S extends boolean | null | undefined | LogSandboxDefaultArgs> = $Result.GetResult<Prisma.$LogSandboxPayload, S>

  type LogSandboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogSandboxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogSandboxCountAggregateInputType | true
    }

  export interface LogSandboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogSandbox'], meta: { name: 'LogSandbox' } }
    /**
     * Find zero or one LogSandbox that matches the filter.
     * @param {LogSandboxFindUniqueArgs} args - Arguments to find a LogSandbox
     * @example
     * // Get one LogSandbox
     * const logSandbox = await prisma.logSandbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogSandboxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LogSandboxFindUniqueArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LogSandbox that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogSandboxFindUniqueOrThrowArgs} args - Arguments to find a LogSandbox
     * @example
     * // Get one LogSandbox
     * const logSandbox = await prisma.logSandbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogSandboxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSandboxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LogSandbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxFindFirstArgs} args - Arguments to find a LogSandbox
     * @example
     * // Get one LogSandbox
     * const logSandbox = await prisma.logSandbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogSandboxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSandboxFindFirstArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LogSandbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxFindFirstOrThrowArgs} args - Arguments to find a LogSandbox
     * @example
     * // Get one LogSandbox
     * const logSandbox = await prisma.logSandbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogSandboxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSandboxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LogSandboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogSandboxes
     * const logSandboxes = await prisma.logSandbox.findMany()
     * 
     * // Get first 10 LogSandboxes
     * const logSandboxes = await prisma.logSandbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logSandboxWithIdOnly = await prisma.logSandbox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogSandboxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSandboxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LogSandbox.
     * @param {LogSandboxCreateArgs} args - Arguments to create a LogSandbox.
     * @example
     * // Create one LogSandbox
     * const LogSandbox = await prisma.logSandbox.create({
     *   data: {
     *     // ... data to create a LogSandbox
     *   }
     * })
     * 
    **/
    create<T extends LogSandboxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LogSandboxCreateArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LogSandboxes.
     *     @param {LogSandboxCreateManyArgs} args - Arguments to create many LogSandboxes.
     *     @example
     *     // Create many LogSandboxes
     *     const logSandbox = await prisma.logSandbox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogSandboxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSandboxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogSandbox.
     * @param {LogSandboxDeleteArgs} args - Arguments to delete one LogSandbox.
     * @example
     * // Delete one LogSandbox
     * const LogSandbox = await prisma.logSandbox.delete({
     *   where: {
     *     // ... filter to delete one LogSandbox
     *   }
     * })
     * 
    **/
    delete<T extends LogSandboxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LogSandboxDeleteArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LogSandbox.
     * @param {LogSandboxUpdateArgs} args - Arguments to update one LogSandbox.
     * @example
     * // Update one LogSandbox
     * const logSandbox = await prisma.logSandbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogSandboxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LogSandboxUpdateArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LogSandboxes.
     * @param {LogSandboxDeleteManyArgs} args - Arguments to filter LogSandboxes to delete.
     * @example
     * // Delete a few LogSandboxes
     * const { count } = await prisma.logSandbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogSandboxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LogSandboxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogSandboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogSandboxes
     * const logSandbox = await prisma.logSandbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogSandboxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LogSandboxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogSandbox.
     * @param {LogSandboxUpsertArgs} args - Arguments to update or create a LogSandbox.
     * @example
     * // Update or create a LogSandbox
     * const logSandbox = await prisma.logSandbox.upsert({
     *   create: {
     *     // ... data to create a LogSandbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogSandbox we want to update
     *   }
     * })
    **/
    upsert<T extends LogSandboxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LogSandboxUpsertArgs<ExtArgs>>
    ): Prisma__LogSandboxClient<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LogSandboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxCountArgs} args - Arguments to filter LogSandboxes to count.
     * @example
     * // Count the number of LogSandboxes
     * const count = await prisma.logSandbox.count({
     *   where: {
     *     // ... the filter for the LogSandboxes we want to count
     *   }
     * })
    **/
    count<T extends LogSandboxCountArgs>(
      args?: Subset<T, LogSandboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogSandboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogSandbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogSandboxAggregateArgs>(args: Subset<T, LogSandboxAggregateArgs>): Prisma.PrismaPromise<GetLogSandboxAggregateType<T>>

    /**
     * Group by LogSandbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSandboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogSandboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogSandboxGroupByArgs['orderBy'] }
        : { orderBy?: LogSandboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogSandboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogSandboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogSandbox model
   */
  readonly fields: LogSandboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogSandbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogSandboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LogSandbox model
   */ 
  interface LogSandboxFieldRefs {
    readonly id: FieldRef<"LogSandbox", 'Int'>
    readonly userId: FieldRef<"LogSandbox", 'Int'>
    readonly method: FieldRef<"LogSandbox", 'String'>
    readonly editName: FieldRef<"LogSandbox", 'String'>
    readonly editKey: FieldRef<"LogSandbox", 'String'>
    readonly createdAt: FieldRef<"LogSandbox", 'DateTime'>
    readonly updatedAt: FieldRef<"LogSandbox", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * LogSandbox findUnique
   */
  export type LogSandboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * Filter, which LogSandbox to fetch.
     */
    where: LogSandboxWhereUniqueInput
  }


  /**
   * LogSandbox findUniqueOrThrow
   */
  export type LogSandboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * Filter, which LogSandbox to fetch.
     */
    where: LogSandboxWhereUniqueInput
  }


  /**
   * LogSandbox findFirst
   */
  export type LogSandboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * Filter, which LogSandbox to fetch.
     */
    where?: LogSandboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSandboxes to fetch.
     */
    orderBy?: LogSandboxOrderByWithRelationInput | LogSandboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSandboxes.
     */
    cursor?: LogSandboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSandboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSandboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSandboxes.
     */
    distinct?: LogSandboxScalarFieldEnum | LogSandboxScalarFieldEnum[]
  }


  /**
   * LogSandbox findFirstOrThrow
   */
  export type LogSandboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * Filter, which LogSandbox to fetch.
     */
    where?: LogSandboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSandboxes to fetch.
     */
    orderBy?: LogSandboxOrderByWithRelationInput | LogSandboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSandboxes.
     */
    cursor?: LogSandboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSandboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSandboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSandboxes.
     */
    distinct?: LogSandboxScalarFieldEnum | LogSandboxScalarFieldEnum[]
  }


  /**
   * LogSandbox findMany
   */
  export type LogSandboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * Filter, which LogSandboxes to fetch.
     */
    where?: LogSandboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSandboxes to fetch.
     */
    orderBy?: LogSandboxOrderByWithRelationInput | LogSandboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogSandboxes.
     */
    cursor?: LogSandboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSandboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSandboxes.
     */
    skip?: number
    distinct?: LogSandboxScalarFieldEnum | LogSandboxScalarFieldEnum[]
  }


  /**
   * LogSandbox create
   */
  export type LogSandboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * The data needed to create a LogSandbox.
     */
    data: XOR<LogSandboxCreateInput, LogSandboxUncheckedCreateInput>
  }


  /**
   * LogSandbox createMany
   */
  export type LogSandboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogSandboxes.
     */
    data: LogSandboxCreateManyInput | LogSandboxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LogSandbox update
   */
  export type LogSandboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * The data needed to update a LogSandbox.
     */
    data: XOR<LogSandboxUpdateInput, LogSandboxUncheckedUpdateInput>
    /**
     * Choose, which LogSandbox to update.
     */
    where: LogSandboxWhereUniqueInput
  }


  /**
   * LogSandbox updateMany
   */
  export type LogSandboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogSandboxes.
     */
    data: XOR<LogSandboxUpdateManyMutationInput, LogSandboxUncheckedUpdateManyInput>
    /**
     * Filter which LogSandboxes to update
     */
    where?: LogSandboxWhereInput
  }


  /**
   * LogSandbox upsert
   */
  export type LogSandboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * The filter to search for the LogSandbox to update in case it exists.
     */
    where: LogSandboxWhereUniqueInput
    /**
     * In case the LogSandbox found by the `where` argument doesn't exist, create a new LogSandbox with this data.
     */
    create: XOR<LogSandboxCreateInput, LogSandboxUncheckedCreateInput>
    /**
     * In case the LogSandbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogSandboxUpdateInput, LogSandboxUncheckedUpdateInput>
  }


  /**
   * LogSandbox delete
   */
  export type LogSandboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    /**
     * Filter which LogSandbox to delete.
     */
    where: LogSandboxWhereUniqueInput
  }


  /**
   * LogSandbox deleteMany
   */
  export type LogSandboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSandboxes to delete
     */
    where?: LogSandboxWhereInput
  }


  /**
   * LogSandbox without action
   */
  export type LogSandboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
  }



  /**
   * Model MessengerFriendship
   */

  export type AggregateMessengerFriendship = {
    _count: MessengerFriendshipCountAggregateOutputType | null
    _avg: MessengerFriendshipAvgAggregateOutputType | null
    _sum: MessengerFriendshipSumAggregateOutputType | null
    _min: MessengerFriendshipMinAggregateOutputType | null
    _max: MessengerFriendshipMaxAggregateOutputType | null
  }

  export type MessengerFriendshipAvgAggregateOutputType = {
    userOneId: number | null
    userTwoId: number | null
    relation: number | null
  }

  export type MessengerFriendshipSumAggregateOutputType = {
    userOneId: number | null
    userTwoId: number | null
    relation: number | null
  }

  export type MessengerFriendshipMinAggregateOutputType = {
    userOneId: number | null
    userTwoId: number | null
    relation: number | null
  }

  export type MessengerFriendshipMaxAggregateOutputType = {
    userOneId: number | null
    userTwoId: number | null
    relation: number | null
  }

  export type MessengerFriendshipCountAggregateOutputType = {
    userOneId: number
    userTwoId: number
    relation: number
    _all: number
  }


  export type MessengerFriendshipAvgAggregateInputType = {
    userOneId?: true
    userTwoId?: true
    relation?: true
  }

  export type MessengerFriendshipSumAggregateInputType = {
    userOneId?: true
    userTwoId?: true
    relation?: true
  }

  export type MessengerFriendshipMinAggregateInputType = {
    userOneId?: true
    userTwoId?: true
    relation?: true
  }

  export type MessengerFriendshipMaxAggregateInputType = {
    userOneId?: true
    userTwoId?: true
    relation?: true
  }

  export type MessengerFriendshipCountAggregateInputType = {
    userOneId?: true
    userTwoId?: true
    relation?: true
    _all?: true
  }

  export type MessengerFriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessengerFriendship to aggregate.
     */
    where?: MessengerFriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerFriendships to fetch.
     */
    orderBy?: MessengerFriendshipOrderByWithRelationInput | MessengerFriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessengerFriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerFriendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerFriendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessengerFriendships
    **/
    _count?: true | MessengerFriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessengerFriendshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessengerFriendshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessengerFriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessengerFriendshipMaxAggregateInputType
  }

  export type GetMessengerFriendshipAggregateType<T extends MessengerFriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateMessengerFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessengerFriendship[P]>
      : GetScalarType<T[P], AggregateMessengerFriendship[P]>
  }




  export type MessengerFriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessengerFriendshipWhereInput
    orderBy?: MessengerFriendshipOrderByWithAggregationInput | MessengerFriendshipOrderByWithAggregationInput[]
    by: MessengerFriendshipScalarFieldEnum[] | MessengerFriendshipScalarFieldEnum
    having?: MessengerFriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessengerFriendshipCountAggregateInputType | true
    _avg?: MessengerFriendshipAvgAggregateInputType
    _sum?: MessengerFriendshipSumAggregateInputType
    _min?: MessengerFriendshipMinAggregateInputType
    _max?: MessengerFriendshipMaxAggregateInputType
  }

  export type MessengerFriendshipGroupByOutputType = {
    userOneId: number
    userTwoId: number
    relation: number
    _count: MessengerFriendshipCountAggregateOutputType | null
    _avg: MessengerFriendshipAvgAggregateOutputType | null
    _sum: MessengerFriendshipSumAggregateOutputType | null
    _min: MessengerFriendshipMinAggregateOutputType | null
    _max: MessengerFriendshipMaxAggregateOutputType | null
  }

  type GetMessengerFriendshipGroupByPayload<T extends MessengerFriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessengerFriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessengerFriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessengerFriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], MessengerFriendshipGroupByOutputType[P]>
        }
      >
    >


  export type MessengerFriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userOneId?: boolean
    userTwoId?: boolean
    relation?: boolean
  }, ExtArgs["result"]["messengerFriendship"]>

  export type MessengerFriendshipSelectScalar = {
    userOneId?: boolean
    userTwoId?: boolean
    relation?: boolean
  }


  export type $MessengerFriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessengerFriendship"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userOneId: number
      userTwoId: number
      relation: number
    }, ExtArgs["result"]["messengerFriendship"]>
    composites: {}
  }


  type MessengerFriendshipGetPayload<S extends boolean | null | undefined | MessengerFriendshipDefaultArgs> = $Result.GetResult<Prisma.$MessengerFriendshipPayload, S>

  type MessengerFriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessengerFriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessengerFriendshipCountAggregateInputType | true
    }

  export interface MessengerFriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessengerFriendship'], meta: { name: 'MessengerFriendship' } }
    /**
     * Find zero or one MessengerFriendship that matches the filter.
     * @param {MessengerFriendshipFindUniqueArgs} args - Arguments to find a MessengerFriendship
     * @example
     * // Get one MessengerFriendship
     * const messengerFriendship = await prisma.messengerFriendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessengerFriendshipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerFriendshipFindUniqueArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessengerFriendship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessengerFriendshipFindUniqueOrThrowArgs} args - Arguments to find a MessengerFriendship
     * @example
     * // Get one MessengerFriendship
     * const messengerFriendship = await prisma.messengerFriendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessengerFriendshipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerFriendshipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessengerFriendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipFindFirstArgs} args - Arguments to find a MessengerFriendship
     * @example
     * // Get one MessengerFriendship
     * const messengerFriendship = await prisma.messengerFriendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessengerFriendshipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerFriendshipFindFirstArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessengerFriendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipFindFirstOrThrowArgs} args - Arguments to find a MessengerFriendship
     * @example
     * // Get one MessengerFriendship
     * const messengerFriendship = await prisma.messengerFriendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessengerFriendshipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerFriendshipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessengerFriendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessengerFriendships
     * const messengerFriendships = await prisma.messengerFriendship.findMany()
     * 
     * // Get first 10 MessengerFriendships
     * const messengerFriendships = await prisma.messengerFriendship.findMany({ take: 10 })
     * 
     * // Only select the `userOneId`
     * const messengerFriendshipWithUserOneIdOnly = await prisma.messengerFriendship.findMany({ select: { userOneId: true } })
     * 
    **/
    findMany<T extends MessengerFriendshipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerFriendshipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessengerFriendship.
     * @param {MessengerFriendshipCreateArgs} args - Arguments to create a MessengerFriendship.
     * @example
     * // Create one MessengerFriendship
     * const MessengerFriendship = await prisma.messengerFriendship.create({
     *   data: {
     *     // ... data to create a MessengerFriendship
     *   }
     * })
     * 
    **/
    create<T extends MessengerFriendshipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerFriendshipCreateArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessengerFriendships.
     *     @param {MessengerFriendshipCreateManyArgs} args - Arguments to create many MessengerFriendships.
     *     @example
     *     // Create many MessengerFriendships
     *     const messengerFriendship = await prisma.messengerFriendship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessengerFriendshipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerFriendshipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessengerFriendship.
     * @param {MessengerFriendshipDeleteArgs} args - Arguments to delete one MessengerFriendship.
     * @example
     * // Delete one MessengerFriendship
     * const MessengerFriendship = await prisma.messengerFriendship.delete({
     *   where: {
     *     // ... filter to delete one MessengerFriendship
     *   }
     * })
     * 
    **/
    delete<T extends MessengerFriendshipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerFriendshipDeleteArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessengerFriendship.
     * @param {MessengerFriendshipUpdateArgs} args - Arguments to update one MessengerFriendship.
     * @example
     * // Update one MessengerFriendship
     * const messengerFriendship = await prisma.messengerFriendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessengerFriendshipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerFriendshipUpdateArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessengerFriendships.
     * @param {MessengerFriendshipDeleteManyArgs} args - Arguments to filter MessengerFriendships to delete.
     * @example
     * // Delete a few MessengerFriendships
     * const { count } = await prisma.messengerFriendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessengerFriendshipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerFriendshipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessengerFriendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessengerFriendships
     * const messengerFriendship = await prisma.messengerFriendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessengerFriendshipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerFriendshipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessengerFriendship.
     * @param {MessengerFriendshipUpsertArgs} args - Arguments to update or create a MessengerFriendship.
     * @example
     * // Update or create a MessengerFriendship
     * const messengerFriendship = await prisma.messengerFriendship.upsert({
     *   create: {
     *     // ... data to create a MessengerFriendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessengerFriendship we want to update
     *   }
     * })
    **/
    upsert<T extends MessengerFriendshipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerFriendshipUpsertArgs<ExtArgs>>
    ): Prisma__MessengerFriendshipClient<$Result.GetResult<Prisma.$MessengerFriendshipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessengerFriendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipCountArgs} args - Arguments to filter MessengerFriendships to count.
     * @example
     * // Count the number of MessengerFriendships
     * const count = await prisma.messengerFriendship.count({
     *   where: {
     *     // ... the filter for the MessengerFriendships we want to count
     *   }
     * })
    **/
    count<T extends MessengerFriendshipCountArgs>(
      args?: Subset<T, MessengerFriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessengerFriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessengerFriendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessengerFriendshipAggregateArgs>(args: Subset<T, MessengerFriendshipAggregateArgs>): Prisma.PrismaPromise<GetMessengerFriendshipAggregateType<T>>

    /**
     * Group by MessengerFriendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerFriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessengerFriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessengerFriendshipGroupByArgs['orderBy'] }
        : { orderBy?: MessengerFriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessengerFriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessengerFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessengerFriendship model
   */
  readonly fields: MessengerFriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessengerFriendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessengerFriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MessengerFriendship model
   */ 
  interface MessengerFriendshipFieldRefs {
    readonly userOneId: FieldRef<"MessengerFriendship", 'Int'>
    readonly userTwoId: FieldRef<"MessengerFriendship", 'Int'>
    readonly relation: FieldRef<"MessengerFriendship", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MessengerFriendship findUnique
   */
  export type MessengerFriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * Filter, which MessengerFriendship to fetch.
     */
    where: MessengerFriendshipWhereUniqueInput
  }


  /**
   * MessengerFriendship findUniqueOrThrow
   */
  export type MessengerFriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * Filter, which MessengerFriendship to fetch.
     */
    where: MessengerFriendshipWhereUniqueInput
  }


  /**
   * MessengerFriendship findFirst
   */
  export type MessengerFriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * Filter, which MessengerFriendship to fetch.
     */
    where?: MessengerFriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerFriendships to fetch.
     */
    orderBy?: MessengerFriendshipOrderByWithRelationInput | MessengerFriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerFriendships.
     */
    cursor?: MessengerFriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerFriendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerFriendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerFriendships.
     */
    distinct?: MessengerFriendshipScalarFieldEnum | MessengerFriendshipScalarFieldEnum[]
  }


  /**
   * MessengerFriendship findFirstOrThrow
   */
  export type MessengerFriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * Filter, which MessengerFriendship to fetch.
     */
    where?: MessengerFriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerFriendships to fetch.
     */
    orderBy?: MessengerFriendshipOrderByWithRelationInput | MessengerFriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerFriendships.
     */
    cursor?: MessengerFriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerFriendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerFriendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerFriendships.
     */
    distinct?: MessengerFriendshipScalarFieldEnum | MessengerFriendshipScalarFieldEnum[]
  }


  /**
   * MessengerFriendship findMany
   */
  export type MessengerFriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * Filter, which MessengerFriendships to fetch.
     */
    where?: MessengerFriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerFriendships to fetch.
     */
    orderBy?: MessengerFriendshipOrderByWithRelationInput | MessengerFriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessengerFriendships.
     */
    cursor?: MessengerFriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerFriendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerFriendships.
     */
    skip?: number
    distinct?: MessengerFriendshipScalarFieldEnum | MessengerFriendshipScalarFieldEnum[]
  }


  /**
   * MessengerFriendship create
   */
  export type MessengerFriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * The data needed to create a MessengerFriendship.
     */
    data: XOR<MessengerFriendshipCreateInput, MessengerFriendshipUncheckedCreateInput>
  }


  /**
   * MessengerFriendship createMany
   */
  export type MessengerFriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessengerFriendships.
     */
    data: MessengerFriendshipCreateManyInput | MessengerFriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessengerFriendship update
   */
  export type MessengerFriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * The data needed to update a MessengerFriendship.
     */
    data: XOR<MessengerFriendshipUpdateInput, MessengerFriendshipUncheckedUpdateInput>
    /**
     * Choose, which MessengerFriendship to update.
     */
    where: MessengerFriendshipWhereUniqueInput
  }


  /**
   * MessengerFriendship updateMany
   */
  export type MessengerFriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessengerFriendships.
     */
    data: XOR<MessengerFriendshipUpdateManyMutationInput, MessengerFriendshipUncheckedUpdateManyInput>
    /**
     * Filter which MessengerFriendships to update
     */
    where?: MessengerFriendshipWhereInput
  }


  /**
   * MessengerFriendship upsert
   */
  export type MessengerFriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * The filter to search for the MessengerFriendship to update in case it exists.
     */
    where: MessengerFriendshipWhereUniqueInput
    /**
     * In case the MessengerFriendship found by the `where` argument doesn't exist, create a new MessengerFriendship with this data.
     */
    create: XOR<MessengerFriendshipCreateInput, MessengerFriendshipUncheckedCreateInput>
    /**
     * In case the MessengerFriendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessengerFriendshipUpdateInput, MessengerFriendshipUncheckedUpdateInput>
  }


  /**
   * MessengerFriendship delete
   */
  export type MessengerFriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
    /**
     * Filter which MessengerFriendship to delete.
     */
    where: MessengerFriendshipWhereUniqueInput
  }


  /**
   * MessengerFriendship deleteMany
   */
  export type MessengerFriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessengerFriendships to delete
     */
    where?: MessengerFriendshipWhereInput
  }


  /**
   * MessengerFriendship without action
   */
  export type MessengerFriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerFriendship
     */
    select?: MessengerFriendshipSelect<ExtArgs> | null
  }



  /**
   * Model MessengerOfflineMessage
   */

  export type AggregateMessengerOfflineMessage = {
    _count: MessengerOfflineMessageCountAggregateOutputType | null
    _avg: MessengerOfflineMessageAvgAggregateOutputType | null
    _sum: MessengerOfflineMessageSumAggregateOutputType | null
    _min: MessengerOfflineMessageMinAggregateOutputType | null
    _max: MessengerOfflineMessageMaxAggregateOutputType | null
  }

  export type MessengerOfflineMessageAvgAggregateOutputType = {
    id: number | null
    toId: number | null
    fromId: number | null
    timestamp: number | null
  }

  export type MessengerOfflineMessageSumAggregateOutputType = {
    id: number | null
    toId: number | null
    fromId: number | null
    timestamp: number | null
  }

  export type MessengerOfflineMessageMinAggregateOutputType = {
    id: number | null
    toId: number | null
    fromId: number | null
    message: string | null
    timestamp: number | null
  }

  export type MessengerOfflineMessageMaxAggregateOutputType = {
    id: number | null
    toId: number | null
    fromId: number | null
    message: string | null
    timestamp: number | null
  }

  export type MessengerOfflineMessageCountAggregateOutputType = {
    id: number
    toId: number
    fromId: number
    message: number
    timestamp: number
    _all: number
  }


  export type MessengerOfflineMessageAvgAggregateInputType = {
    id?: true
    toId?: true
    fromId?: true
    timestamp?: true
  }

  export type MessengerOfflineMessageSumAggregateInputType = {
    id?: true
    toId?: true
    fromId?: true
    timestamp?: true
  }

  export type MessengerOfflineMessageMinAggregateInputType = {
    id?: true
    toId?: true
    fromId?: true
    message?: true
    timestamp?: true
  }

  export type MessengerOfflineMessageMaxAggregateInputType = {
    id?: true
    toId?: true
    fromId?: true
    message?: true
    timestamp?: true
  }

  export type MessengerOfflineMessageCountAggregateInputType = {
    id?: true
    toId?: true
    fromId?: true
    message?: true
    timestamp?: true
    _all?: true
  }

  export type MessengerOfflineMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessengerOfflineMessage to aggregate.
     */
    where?: MessengerOfflineMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerOfflineMessages to fetch.
     */
    orderBy?: MessengerOfflineMessageOrderByWithRelationInput | MessengerOfflineMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessengerOfflineMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerOfflineMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerOfflineMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessengerOfflineMessages
    **/
    _count?: true | MessengerOfflineMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessengerOfflineMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessengerOfflineMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessengerOfflineMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessengerOfflineMessageMaxAggregateInputType
  }

  export type GetMessengerOfflineMessageAggregateType<T extends MessengerOfflineMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessengerOfflineMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessengerOfflineMessage[P]>
      : GetScalarType<T[P], AggregateMessengerOfflineMessage[P]>
  }




  export type MessengerOfflineMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessengerOfflineMessageWhereInput
    orderBy?: MessengerOfflineMessageOrderByWithAggregationInput | MessengerOfflineMessageOrderByWithAggregationInput[]
    by: MessengerOfflineMessageScalarFieldEnum[] | MessengerOfflineMessageScalarFieldEnum
    having?: MessengerOfflineMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessengerOfflineMessageCountAggregateInputType | true
    _avg?: MessengerOfflineMessageAvgAggregateInputType
    _sum?: MessengerOfflineMessageSumAggregateInputType
    _min?: MessengerOfflineMessageMinAggregateInputType
    _max?: MessengerOfflineMessageMaxAggregateInputType
  }

  export type MessengerOfflineMessageGroupByOutputType = {
    id: number
    toId: number
    fromId: number
    message: string
    timestamp: number
    _count: MessengerOfflineMessageCountAggregateOutputType | null
    _avg: MessengerOfflineMessageAvgAggregateOutputType | null
    _sum: MessengerOfflineMessageSumAggregateOutputType | null
    _min: MessengerOfflineMessageMinAggregateOutputType | null
    _max: MessengerOfflineMessageMaxAggregateOutputType | null
  }

  type GetMessengerOfflineMessageGroupByPayload<T extends MessengerOfflineMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessengerOfflineMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessengerOfflineMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessengerOfflineMessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessengerOfflineMessageGroupByOutputType[P]>
        }
      >
    >


  export type MessengerOfflineMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    toId?: boolean
    fromId?: boolean
    message?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["messengerOfflineMessage"]>

  export type MessengerOfflineMessageSelectScalar = {
    id?: boolean
    toId?: boolean
    fromId?: boolean
    message?: boolean
    timestamp?: boolean
  }


  export type $MessengerOfflineMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessengerOfflineMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      toId: number
      fromId: number
      message: string
      timestamp: number
    }, ExtArgs["result"]["messengerOfflineMessage"]>
    composites: {}
  }


  type MessengerOfflineMessageGetPayload<S extends boolean | null | undefined | MessengerOfflineMessageDefaultArgs> = $Result.GetResult<Prisma.$MessengerOfflineMessagePayload, S>

  type MessengerOfflineMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessengerOfflineMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessengerOfflineMessageCountAggregateInputType | true
    }

  export interface MessengerOfflineMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessengerOfflineMessage'], meta: { name: 'MessengerOfflineMessage' } }
    /**
     * Find zero or one MessengerOfflineMessage that matches the filter.
     * @param {MessengerOfflineMessageFindUniqueArgs} args - Arguments to find a MessengerOfflineMessage
     * @example
     * // Get one MessengerOfflineMessage
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessengerOfflineMessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerOfflineMessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessengerOfflineMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessengerOfflineMessageFindUniqueOrThrowArgs} args - Arguments to find a MessengerOfflineMessage
     * @example
     * // Get one MessengerOfflineMessage
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessengerOfflineMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerOfflineMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessengerOfflineMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageFindFirstArgs} args - Arguments to find a MessengerOfflineMessage
     * @example
     * // Get one MessengerOfflineMessage
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessengerOfflineMessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerOfflineMessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessengerOfflineMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageFindFirstOrThrowArgs} args - Arguments to find a MessengerOfflineMessage
     * @example
     * // Get one MessengerOfflineMessage
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessengerOfflineMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerOfflineMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessengerOfflineMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessengerOfflineMessages
     * const messengerOfflineMessages = await prisma.messengerOfflineMessage.findMany()
     * 
     * // Get first 10 MessengerOfflineMessages
     * const messengerOfflineMessages = await prisma.messengerOfflineMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messengerOfflineMessageWithIdOnly = await prisma.messengerOfflineMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessengerOfflineMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerOfflineMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessengerOfflineMessage.
     * @param {MessengerOfflineMessageCreateArgs} args - Arguments to create a MessengerOfflineMessage.
     * @example
     * // Create one MessengerOfflineMessage
     * const MessengerOfflineMessage = await prisma.messengerOfflineMessage.create({
     *   data: {
     *     // ... data to create a MessengerOfflineMessage
     *   }
     * })
     * 
    **/
    create<T extends MessengerOfflineMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerOfflineMessageCreateArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessengerOfflineMessages.
     *     @param {MessengerOfflineMessageCreateManyArgs} args - Arguments to create many MessengerOfflineMessages.
     *     @example
     *     // Create many MessengerOfflineMessages
     *     const messengerOfflineMessage = await prisma.messengerOfflineMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessengerOfflineMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerOfflineMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessengerOfflineMessage.
     * @param {MessengerOfflineMessageDeleteArgs} args - Arguments to delete one MessengerOfflineMessage.
     * @example
     * // Delete one MessengerOfflineMessage
     * const MessengerOfflineMessage = await prisma.messengerOfflineMessage.delete({
     *   where: {
     *     // ... filter to delete one MessengerOfflineMessage
     *   }
     * })
     * 
    **/
    delete<T extends MessengerOfflineMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerOfflineMessageDeleteArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessengerOfflineMessage.
     * @param {MessengerOfflineMessageUpdateArgs} args - Arguments to update one MessengerOfflineMessage.
     * @example
     * // Update one MessengerOfflineMessage
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessengerOfflineMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerOfflineMessageUpdateArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessengerOfflineMessages.
     * @param {MessengerOfflineMessageDeleteManyArgs} args - Arguments to filter MessengerOfflineMessages to delete.
     * @example
     * // Delete a few MessengerOfflineMessages
     * const { count } = await prisma.messengerOfflineMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessengerOfflineMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerOfflineMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessengerOfflineMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessengerOfflineMessages
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessengerOfflineMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerOfflineMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessengerOfflineMessage.
     * @param {MessengerOfflineMessageUpsertArgs} args - Arguments to update or create a MessengerOfflineMessage.
     * @example
     * // Update or create a MessengerOfflineMessage
     * const messengerOfflineMessage = await prisma.messengerOfflineMessage.upsert({
     *   create: {
     *     // ... data to create a MessengerOfflineMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessengerOfflineMessage we want to update
     *   }
     * })
    **/
    upsert<T extends MessengerOfflineMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerOfflineMessageUpsertArgs<ExtArgs>>
    ): Prisma__MessengerOfflineMessageClient<$Result.GetResult<Prisma.$MessengerOfflineMessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessengerOfflineMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageCountArgs} args - Arguments to filter MessengerOfflineMessages to count.
     * @example
     * // Count the number of MessengerOfflineMessages
     * const count = await prisma.messengerOfflineMessage.count({
     *   where: {
     *     // ... the filter for the MessengerOfflineMessages we want to count
     *   }
     * })
    **/
    count<T extends MessengerOfflineMessageCountArgs>(
      args?: Subset<T, MessengerOfflineMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessengerOfflineMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessengerOfflineMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessengerOfflineMessageAggregateArgs>(args: Subset<T, MessengerOfflineMessageAggregateArgs>): Prisma.PrismaPromise<GetMessengerOfflineMessageAggregateType<T>>

    /**
     * Group by MessengerOfflineMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerOfflineMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessengerOfflineMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessengerOfflineMessageGroupByArgs['orderBy'] }
        : { orderBy?: MessengerOfflineMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessengerOfflineMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessengerOfflineMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessengerOfflineMessage model
   */
  readonly fields: MessengerOfflineMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessengerOfflineMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessengerOfflineMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MessengerOfflineMessage model
   */ 
  interface MessengerOfflineMessageFieldRefs {
    readonly id: FieldRef<"MessengerOfflineMessage", 'Int'>
    readonly toId: FieldRef<"MessengerOfflineMessage", 'Int'>
    readonly fromId: FieldRef<"MessengerOfflineMessage", 'Int'>
    readonly message: FieldRef<"MessengerOfflineMessage", 'String'>
    readonly timestamp: FieldRef<"MessengerOfflineMessage", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MessengerOfflineMessage findUnique
   */
  export type MessengerOfflineMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * Filter, which MessengerOfflineMessage to fetch.
     */
    where: MessengerOfflineMessageWhereUniqueInput
  }


  /**
   * MessengerOfflineMessage findUniqueOrThrow
   */
  export type MessengerOfflineMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * Filter, which MessengerOfflineMessage to fetch.
     */
    where: MessengerOfflineMessageWhereUniqueInput
  }


  /**
   * MessengerOfflineMessage findFirst
   */
  export type MessengerOfflineMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * Filter, which MessengerOfflineMessage to fetch.
     */
    where?: MessengerOfflineMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerOfflineMessages to fetch.
     */
    orderBy?: MessengerOfflineMessageOrderByWithRelationInput | MessengerOfflineMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerOfflineMessages.
     */
    cursor?: MessengerOfflineMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerOfflineMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerOfflineMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerOfflineMessages.
     */
    distinct?: MessengerOfflineMessageScalarFieldEnum | MessengerOfflineMessageScalarFieldEnum[]
  }


  /**
   * MessengerOfflineMessage findFirstOrThrow
   */
  export type MessengerOfflineMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * Filter, which MessengerOfflineMessage to fetch.
     */
    where?: MessengerOfflineMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerOfflineMessages to fetch.
     */
    orderBy?: MessengerOfflineMessageOrderByWithRelationInput | MessengerOfflineMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerOfflineMessages.
     */
    cursor?: MessengerOfflineMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerOfflineMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerOfflineMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerOfflineMessages.
     */
    distinct?: MessengerOfflineMessageScalarFieldEnum | MessengerOfflineMessageScalarFieldEnum[]
  }


  /**
   * MessengerOfflineMessage findMany
   */
  export type MessengerOfflineMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * Filter, which MessengerOfflineMessages to fetch.
     */
    where?: MessengerOfflineMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerOfflineMessages to fetch.
     */
    orderBy?: MessengerOfflineMessageOrderByWithRelationInput | MessengerOfflineMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessengerOfflineMessages.
     */
    cursor?: MessengerOfflineMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerOfflineMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerOfflineMessages.
     */
    skip?: number
    distinct?: MessengerOfflineMessageScalarFieldEnum | MessengerOfflineMessageScalarFieldEnum[]
  }


  /**
   * MessengerOfflineMessage create
   */
  export type MessengerOfflineMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * The data needed to create a MessengerOfflineMessage.
     */
    data: XOR<MessengerOfflineMessageCreateInput, MessengerOfflineMessageUncheckedCreateInput>
  }


  /**
   * MessengerOfflineMessage createMany
   */
  export type MessengerOfflineMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessengerOfflineMessages.
     */
    data: MessengerOfflineMessageCreateManyInput | MessengerOfflineMessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessengerOfflineMessage update
   */
  export type MessengerOfflineMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * The data needed to update a MessengerOfflineMessage.
     */
    data: XOR<MessengerOfflineMessageUpdateInput, MessengerOfflineMessageUncheckedUpdateInput>
    /**
     * Choose, which MessengerOfflineMessage to update.
     */
    where: MessengerOfflineMessageWhereUniqueInput
  }


  /**
   * MessengerOfflineMessage updateMany
   */
  export type MessengerOfflineMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessengerOfflineMessages.
     */
    data: XOR<MessengerOfflineMessageUpdateManyMutationInput, MessengerOfflineMessageUncheckedUpdateManyInput>
    /**
     * Filter which MessengerOfflineMessages to update
     */
    where?: MessengerOfflineMessageWhereInput
  }


  /**
   * MessengerOfflineMessage upsert
   */
  export type MessengerOfflineMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * The filter to search for the MessengerOfflineMessage to update in case it exists.
     */
    where: MessengerOfflineMessageWhereUniqueInput
    /**
     * In case the MessengerOfflineMessage found by the `where` argument doesn't exist, create a new MessengerOfflineMessage with this data.
     */
    create: XOR<MessengerOfflineMessageCreateInput, MessengerOfflineMessageUncheckedCreateInput>
    /**
     * In case the MessengerOfflineMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessengerOfflineMessageUpdateInput, MessengerOfflineMessageUncheckedUpdateInput>
  }


  /**
   * MessengerOfflineMessage delete
   */
  export type MessengerOfflineMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
    /**
     * Filter which MessengerOfflineMessage to delete.
     */
    where: MessengerOfflineMessageWhereUniqueInput
  }


  /**
   * MessengerOfflineMessage deleteMany
   */
  export type MessengerOfflineMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessengerOfflineMessages to delete
     */
    where?: MessengerOfflineMessageWhereInput
  }


  /**
   * MessengerOfflineMessage without action
   */
  export type MessengerOfflineMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerOfflineMessage
     */
    select?: MessengerOfflineMessageSelect<ExtArgs> | null
  }



  /**
   * Model MessengerRequest
   */

  export type AggregateMessengerRequest = {
    _count: MessengerRequestCountAggregateOutputType | null
    _avg: MessengerRequestAvgAggregateOutputType | null
    _sum: MessengerRequestSumAggregateOutputType | null
    _min: MessengerRequestMinAggregateOutputType | null
    _max: MessengerRequestMaxAggregateOutputType | null
  }

  export type MessengerRequestAvgAggregateOutputType = {
    fromId: number | null
    toId: number | null
  }

  export type MessengerRequestSumAggregateOutputType = {
    fromId: number | null
    toId: number | null
  }

  export type MessengerRequestMinAggregateOutputType = {
    fromId: number | null
    toId: number | null
  }

  export type MessengerRequestMaxAggregateOutputType = {
    fromId: number | null
    toId: number | null
  }

  export type MessengerRequestCountAggregateOutputType = {
    fromId: number
    toId: number
    _all: number
  }


  export type MessengerRequestAvgAggregateInputType = {
    fromId?: true
    toId?: true
  }

  export type MessengerRequestSumAggregateInputType = {
    fromId?: true
    toId?: true
  }

  export type MessengerRequestMinAggregateInputType = {
    fromId?: true
    toId?: true
  }

  export type MessengerRequestMaxAggregateInputType = {
    fromId?: true
    toId?: true
  }

  export type MessengerRequestCountAggregateInputType = {
    fromId?: true
    toId?: true
    _all?: true
  }

  export type MessengerRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessengerRequest to aggregate.
     */
    where?: MessengerRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerRequests to fetch.
     */
    orderBy?: MessengerRequestOrderByWithRelationInput | MessengerRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessengerRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessengerRequests
    **/
    _count?: true | MessengerRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessengerRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessengerRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessengerRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessengerRequestMaxAggregateInputType
  }

  export type GetMessengerRequestAggregateType<T extends MessengerRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMessengerRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessengerRequest[P]>
      : GetScalarType<T[P], AggregateMessengerRequest[P]>
  }




  export type MessengerRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessengerRequestWhereInput
    orderBy?: MessengerRequestOrderByWithAggregationInput | MessengerRequestOrderByWithAggregationInput[]
    by: MessengerRequestScalarFieldEnum[] | MessengerRequestScalarFieldEnum
    having?: MessengerRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessengerRequestCountAggregateInputType | true
    _avg?: MessengerRequestAvgAggregateInputType
    _sum?: MessengerRequestSumAggregateInputType
    _min?: MessengerRequestMinAggregateInputType
    _max?: MessengerRequestMaxAggregateInputType
  }

  export type MessengerRequestGroupByOutputType = {
    fromId: number
    toId: number
    _count: MessengerRequestCountAggregateOutputType | null
    _avg: MessengerRequestAvgAggregateOutputType | null
    _sum: MessengerRequestSumAggregateOutputType | null
    _min: MessengerRequestMinAggregateOutputType | null
    _max: MessengerRequestMaxAggregateOutputType | null
  }

  type GetMessengerRequestGroupByPayload<T extends MessengerRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessengerRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessengerRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessengerRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MessengerRequestGroupByOutputType[P]>
        }
      >
    >


  export type MessengerRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fromId?: boolean
    toId?: boolean
  }, ExtArgs["result"]["messengerRequest"]>

  export type MessengerRequestSelectScalar = {
    fromId?: boolean
    toId?: boolean
  }


  export type $MessengerRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessengerRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      fromId: number
      toId: number
    }, ExtArgs["result"]["messengerRequest"]>
    composites: {}
  }


  type MessengerRequestGetPayload<S extends boolean | null | undefined | MessengerRequestDefaultArgs> = $Result.GetResult<Prisma.$MessengerRequestPayload, S>

  type MessengerRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessengerRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessengerRequestCountAggregateInputType | true
    }

  export interface MessengerRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessengerRequest'], meta: { name: 'MessengerRequest' } }
    /**
     * Find zero or one MessengerRequest that matches the filter.
     * @param {MessengerRequestFindUniqueArgs} args - Arguments to find a MessengerRequest
     * @example
     * // Get one MessengerRequest
     * const messengerRequest = await prisma.messengerRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessengerRequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerRequestFindUniqueArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessengerRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessengerRequestFindUniqueOrThrowArgs} args - Arguments to find a MessengerRequest
     * @example
     * // Get one MessengerRequest
     * const messengerRequest = await prisma.messengerRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessengerRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessengerRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestFindFirstArgs} args - Arguments to find a MessengerRequest
     * @example
     * // Get one MessengerRequest
     * const messengerRequest = await prisma.messengerRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessengerRequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerRequestFindFirstArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessengerRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestFindFirstOrThrowArgs} args - Arguments to find a MessengerRequest
     * @example
     * // Get one MessengerRequest
     * const messengerRequest = await prisma.messengerRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessengerRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessengerRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessengerRequests
     * const messengerRequests = await prisma.messengerRequest.findMany()
     * 
     * // Get first 10 MessengerRequests
     * const messengerRequests = await prisma.messengerRequest.findMany({ take: 10 })
     * 
     * // Only select the `fromId`
     * const messengerRequestWithFromIdOnly = await prisma.messengerRequest.findMany({ select: { fromId: true } })
     * 
    **/
    findMany<T extends MessengerRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessengerRequest.
     * @param {MessengerRequestCreateArgs} args - Arguments to create a MessengerRequest.
     * @example
     * // Create one MessengerRequest
     * const MessengerRequest = await prisma.messengerRequest.create({
     *   data: {
     *     // ... data to create a MessengerRequest
     *   }
     * })
     * 
    **/
    create<T extends MessengerRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerRequestCreateArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessengerRequests.
     *     @param {MessengerRequestCreateManyArgs} args - Arguments to create many MessengerRequests.
     *     @example
     *     // Create many MessengerRequests
     *     const messengerRequest = await prisma.messengerRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessengerRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessengerRequest.
     * @param {MessengerRequestDeleteArgs} args - Arguments to delete one MessengerRequest.
     * @example
     * // Delete one MessengerRequest
     * const MessengerRequest = await prisma.messengerRequest.delete({
     *   where: {
     *     // ... filter to delete one MessengerRequest
     *   }
     * })
     * 
    **/
    delete<T extends MessengerRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerRequestDeleteArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessengerRequest.
     * @param {MessengerRequestUpdateArgs} args - Arguments to update one MessengerRequest.
     * @example
     * // Update one MessengerRequest
     * const messengerRequest = await prisma.messengerRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessengerRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerRequestUpdateArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessengerRequests.
     * @param {MessengerRequestDeleteManyArgs} args - Arguments to filter MessengerRequests to delete.
     * @example
     * // Delete a few MessengerRequests
     * const { count } = await prisma.messengerRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessengerRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessengerRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessengerRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessengerRequests
     * const messengerRequest = await prisma.messengerRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessengerRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessengerRequest.
     * @param {MessengerRequestUpsertArgs} args - Arguments to update or create a MessengerRequest.
     * @example
     * // Update or create a MessengerRequest
     * const messengerRequest = await prisma.messengerRequest.upsert({
     *   create: {
     *     // ... data to create a MessengerRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessengerRequest we want to update
     *   }
     * })
    **/
    upsert<T extends MessengerRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessengerRequestUpsertArgs<ExtArgs>>
    ): Prisma__MessengerRequestClient<$Result.GetResult<Prisma.$MessengerRequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessengerRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestCountArgs} args - Arguments to filter MessengerRequests to count.
     * @example
     * // Count the number of MessengerRequests
     * const count = await prisma.messengerRequest.count({
     *   where: {
     *     // ... the filter for the MessengerRequests we want to count
     *   }
     * })
    **/
    count<T extends MessengerRequestCountArgs>(
      args?: Subset<T, MessengerRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessengerRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessengerRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessengerRequestAggregateArgs>(args: Subset<T, MessengerRequestAggregateArgs>): Prisma.PrismaPromise<GetMessengerRequestAggregateType<T>>

    /**
     * Group by MessengerRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessengerRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessengerRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessengerRequestGroupByArgs['orderBy'] }
        : { orderBy?: MessengerRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessengerRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessengerRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessengerRequest model
   */
  readonly fields: MessengerRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessengerRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessengerRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MessengerRequest model
   */ 
  interface MessengerRequestFieldRefs {
    readonly fromId: FieldRef<"MessengerRequest", 'Int'>
    readonly toId: FieldRef<"MessengerRequest", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MessengerRequest findUnique
   */
  export type MessengerRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * Filter, which MessengerRequest to fetch.
     */
    where: MessengerRequestWhereUniqueInput
  }


  /**
   * MessengerRequest findUniqueOrThrow
   */
  export type MessengerRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * Filter, which MessengerRequest to fetch.
     */
    where: MessengerRequestWhereUniqueInput
  }


  /**
   * MessengerRequest findFirst
   */
  export type MessengerRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * Filter, which MessengerRequest to fetch.
     */
    where?: MessengerRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerRequests to fetch.
     */
    orderBy?: MessengerRequestOrderByWithRelationInput | MessengerRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerRequests.
     */
    cursor?: MessengerRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerRequests.
     */
    distinct?: MessengerRequestScalarFieldEnum | MessengerRequestScalarFieldEnum[]
  }


  /**
   * MessengerRequest findFirstOrThrow
   */
  export type MessengerRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * Filter, which MessengerRequest to fetch.
     */
    where?: MessengerRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerRequests to fetch.
     */
    orderBy?: MessengerRequestOrderByWithRelationInput | MessengerRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessengerRequests.
     */
    cursor?: MessengerRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessengerRequests.
     */
    distinct?: MessengerRequestScalarFieldEnum | MessengerRequestScalarFieldEnum[]
  }


  /**
   * MessengerRequest findMany
   */
  export type MessengerRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * Filter, which MessengerRequests to fetch.
     */
    where?: MessengerRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessengerRequests to fetch.
     */
    orderBy?: MessengerRequestOrderByWithRelationInput | MessengerRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessengerRequests.
     */
    cursor?: MessengerRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessengerRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessengerRequests.
     */
    skip?: number
    distinct?: MessengerRequestScalarFieldEnum | MessengerRequestScalarFieldEnum[]
  }


  /**
   * MessengerRequest create
   */
  export type MessengerRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a MessengerRequest.
     */
    data: XOR<MessengerRequestCreateInput, MessengerRequestUncheckedCreateInput>
  }


  /**
   * MessengerRequest createMany
   */
  export type MessengerRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessengerRequests.
     */
    data: MessengerRequestCreateManyInput | MessengerRequestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessengerRequest update
   */
  export type MessengerRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a MessengerRequest.
     */
    data: XOR<MessengerRequestUpdateInput, MessengerRequestUncheckedUpdateInput>
    /**
     * Choose, which MessengerRequest to update.
     */
    where: MessengerRequestWhereUniqueInput
  }


  /**
   * MessengerRequest updateMany
   */
  export type MessengerRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessengerRequests.
     */
    data: XOR<MessengerRequestUpdateManyMutationInput, MessengerRequestUncheckedUpdateManyInput>
    /**
     * Filter which MessengerRequests to update
     */
    where?: MessengerRequestWhereInput
  }


  /**
   * MessengerRequest upsert
   */
  export type MessengerRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the MessengerRequest to update in case it exists.
     */
    where: MessengerRequestWhereUniqueInput
    /**
     * In case the MessengerRequest found by the `where` argument doesn't exist, create a new MessengerRequest with this data.
     */
    create: XOR<MessengerRequestCreateInput, MessengerRequestUncheckedCreateInput>
    /**
     * In case the MessengerRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessengerRequestUpdateInput, MessengerRequestUncheckedUpdateInput>
  }


  /**
   * MessengerRequest delete
   */
  export type MessengerRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
    /**
     * Filter which MessengerRequest to delete.
     */
    where: MessengerRequestWhereUniqueInput
  }


  /**
   * MessengerRequest deleteMany
   */
  export type MessengerRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessengerRequests to delete
     */
    where?: MessengerRequestWhereInput
  }


  /**
   * MessengerRequest without action
   */
  export type MessengerRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessengerRequest
     */
    select?: MessengerRequestSelect<ExtArgs> | null
  }



  /**
   * Model ModerationPreset
   */

  export type AggregateModerationPreset = {
    _count: ModerationPresetCountAggregateOutputType | null
    _avg: ModerationPresetAvgAggregateOutputType | null
    _sum: ModerationPresetSumAggregateOutputType | null
    _min: ModerationPresetMinAggregateOutputType | null
    _max: ModerationPresetMaxAggregateOutputType | null
  }

  export type ModerationPresetAvgAggregateOutputType = {
    id: number | null
  }

  export type ModerationPresetSumAggregateOutputType = {
    id: number | null
  }

  export type ModerationPresetMinAggregateOutputType = {
    id: number | null
    enabled: boolean | null
    type: $Enums.ModerationPresetType | null
    message: string | null
  }

  export type ModerationPresetMaxAggregateOutputType = {
    id: number | null
    enabled: boolean | null
    type: $Enums.ModerationPresetType | null
    message: string | null
  }

  export type ModerationPresetCountAggregateOutputType = {
    id: number
    enabled: number
    type: number
    message: number
    _all: number
  }


  export type ModerationPresetAvgAggregateInputType = {
    id?: true
  }

  export type ModerationPresetSumAggregateInputType = {
    id?: true
  }

  export type ModerationPresetMinAggregateInputType = {
    id?: true
    enabled?: true
    type?: true
    message?: true
  }

  export type ModerationPresetMaxAggregateInputType = {
    id?: true
    enabled?: true
    type?: true
    message?: true
  }

  export type ModerationPresetCountAggregateInputType = {
    id?: true
    enabled?: true
    type?: true
    message?: true
    _all?: true
  }

  export type ModerationPresetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationPreset to aggregate.
     */
    where?: ModerationPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationPresets to fetch.
     */
    orderBy?: ModerationPresetOrderByWithRelationInput | ModerationPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationPresets
    **/
    _count?: true | ModerationPresetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationPresetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationPresetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationPresetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationPresetMaxAggregateInputType
  }

  export type GetModerationPresetAggregateType<T extends ModerationPresetAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationPreset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationPreset[P]>
      : GetScalarType<T[P], AggregateModerationPreset[P]>
  }




  export type ModerationPresetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationPresetWhereInput
    orderBy?: ModerationPresetOrderByWithAggregationInput | ModerationPresetOrderByWithAggregationInput[]
    by: ModerationPresetScalarFieldEnum[] | ModerationPresetScalarFieldEnum
    having?: ModerationPresetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationPresetCountAggregateInputType | true
    _avg?: ModerationPresetAvgAggregateInputType
    _sum?: ModerationPresetSumAggregateInputType
    _min?: ModerationPresetMinAggregateInputType
    _max?: ModerationPresetMaxAggregateInputType
  }

  export type ModerationPresetGroupByOutputType = {
    id: number
    enabled: boolean
    type: $Enums.ModerationPresetType
    message: string
    _count: ModerationPresetCountAggregateOutputType | null
    _avg: ModerationPresetAvgAggregateOutputType | null
    _sum: ModerationPresetSumAggregateOutputType | null
    _min: ModerationPresetMinAggregateOutputType | null
    _max: ModerationPresetMaxAggregateOutputType | null
  }

  type GetModerationPresetGroupByPayload<T extends ModerationPresetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationPresetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationPresetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationPresetGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationPresetGroupByOutputType[P]>
        }
      >
    >


  export type ModerationPresetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    type?: boolean
    message?: boolean
  }, ExtArgs["result"]["moderationPreset"]>

  export type ModerationPresetSelectScalar = {
    id?: boolean
    enabled?: boolean
    type?: boolean
    message?: boolean
  }


  export type $ModerationPresetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationPreset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enabled: boolean
      type: $Enums.ModerationPresetType
      message: string
    }, ExtArgs["result"]["moderationPreset"]>
    composites: {}
  }


  type ModerationPresetGetPayload<S extends boolean | null | undefined | ModerationPresetDefaultArgs> = $Result.GetResult<Prisma.$ModerationPresetPayload, S>

  type ModerationPresetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationPresetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationPresetCountAggregateInputType | true
    }

  export interface ModerationPresetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationPreset'], meta: { name: 'ModerationPreset' } }
    /**
     * Find zero or one ModerationPreset that matches the filter.
     * @param {ModerationPresetFindUniqueArgs} args - Arguments to find a ModerationPreset
     * @example
     * // Get one ModerationPreset
     * const moderationPreset = await prisma.moderationPreset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModerationPresetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationPresetFindUniqueArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ModerationPreset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModerationPresetFindUniqueOrThrowArgs} args - Arguments to find a ModerationPreset
     * @example
     * // Get one ModerationPreset
     * const moderationPreset = await prisma.moderationPreset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModerationPresetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationPresetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ModerationPreset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetFindFirstArgs} args - Arguments to find a ModerationPreset
     * @example
     * // Get one ModerationPreset
     * const moderationPreset = await prisma.moderationPreset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModerationPresetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationPresetFindFirstArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ModerationPreset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetFindFirstOrThrowArgs} args - Arguments to find a ModerationPreset
     * @example
     * // Get one ModerationPreset
     * const moderationPreset = await prisma.moderationPreset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModerationPresetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationPresetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ModerationPresets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationPresets
     * const moderationPresets = await prisma.moderationPreset.findMany()
     * 
     * // Get first 10 ModerationPresets
     * const moderationPresets = await prisma.moderationPreset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationPresetWithIdOnly = await prisma.moderationPreset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModerationPresetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationPresetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ModerationPreset.
     * @param {ModerationPresetCreateArgs} args - Arguments to create a ModerationPreset.
     * @example
     * // Create one ModerationPreset
     * const ModerationPreset = await prisma.moderationPreset.create({
     *   data: {
     *     // ... data to create a ModerationPreset
     *   }
     * })
     * 
    **/
    create<T extends ModerationPresetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationPresetCreateArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ModerationPresets.
     *     @param {ModerationPresetCreateManyArgs} args - Arguments to create many ModerationPresets.
     *     @example
     *     // Create many ModerationPresets
     *     const moderationPreset = await prisma.moderationPreset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModerationPresetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationPresetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModerationPreset.
     * @param {ModerationPresetDeleteArgs} args - Arguments to delete one ModerationPreset.
     * @example
     * // Delete one ModerationPreset
     * const ModerationPreset = await prisma.moderationPreset.delete({
     *   where: {
     *     // ... filter to delete one ModerationPreset
     *   }
     * })
     * 
    **/
    delete<T extends ModerationPresetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationPresetDeleteArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ModerationPreset.
     * @param {ModerationPresetUpdateArgs} args - Arguments to update one ModerationPreset.
     * @example
     * // Update one ModerationPreset
     * const moderationPreset = await prisma.moderationPreset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModerationPresetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationPresetUpdateArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ModerationPresets.
     * @param {ModerationPresetDeleteManyArgs} args - Arguments to filter ModerationPresets to delete.
     * @example
     * // Delete a few ModerationPresets
     * const { count } = await prisma.moderationPreset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModerationPresetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationPresetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationPresets
     * const moderationPreset = await prisma.moderationPreset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModerationPresetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationPresetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationPreset.
     * @param {ModerationPresetUpsertArgs} args - Arguments to update or create a ModerationPreset.
     * @example
     * // Update or create a ModerationPreset
     * const moderationPreset = await prisma.moderationPreset.upsert({
     *   create: {
     *     // ... data to create a ModerationPreset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationPreset we want to update
     *   }
     * })
    **/
    upsert<T extends ModerationPresetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationPresetUpsertArgs<ExtArgs>>
    ): Prisma__ModerationPresetClient<$Result.GetResult<Prisma.$ModerationPresetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ModerationPresets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetCountArgs} args - Arguments to filter ModerationPresets to count.
     * @example
     * // Count the number of ModerationPresets
     * const count = await prisma.moderationPreset.count({
     *   where: {
     *     // ... the filter for the ModerationPresets we want to count
     *   }
     * })
    **/
    count<T extends ModerationPresetCountArgs>(
      args?: Subset<T, ModerationPresetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationPresetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationPresetAggregateArgs>(args: Subset<T, ModerationPresetAggregateArgs>): Prisma.PrismaPromise<GetModerationPresetAggregateType<T>>

    /**
     * Group by ModerationPreset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationPresetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationPresetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationPresetGroupByArgs['orderBy'] }
        : { orderBy?: ModerationPresetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationPresetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationPresetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationPreset model
   */
  readonly fields: ModerationPresetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationPreset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationPresetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ModerationPreset model
   */ 
  interface ModerationPresetFieldRefs {
    readonly id: FieldRef<"ModerationPreset", 'Int'>
    readonly enabled: FieldRef<"ModerationPreset", 'Boolean'>
    readonly type: FieldRef<"ModerationPreset", 'ModerationPresetType'>
    readonly message: FieldRef<"ModerationPreset", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ModerationPreset findUnique
   */
  export type ModerationPresetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * Filter, which ModerationPreset to fetch.
     */
    where: ModerationPresetWhereUniqueInput
  }


  /**
   * ModerationPreset findUniqueOrThrow
   */
  export type ModerationPresetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * Filter, which ModerationPreset to fetch.
     */
    where: ModerationPresetWhereUniqueInput
  }


  /**
   * ModerationPreset findFirst
   */
  export type ModerationPresetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * Filter, which ModerationPreset to fetch.
     */
    where?: ModerationPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationPresets to fetch.
     */
    orderBy?: ModerationPresetOrderByWithRelationInput | ModerationPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationPresets.
     */
    cursor?: ModerationPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationPresets.
     */
    distinct?: ModerationPresetScalarFieldEnum | ModerationPresetScalarFieldEnum[]
  }


  /**
   * ModerationPreset findFirstOrThrow
   */
  export type ModerationPresetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * Filter, which ModerationPreset to fetch.
     */
    where?: ModerationPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationPresets to fetch.
     */
    orderBy?: ModerationPresetOrderByWithRelationInput | ModerationPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationPresets.
     */
    cursor?: ModerationPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationPresets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationPresets.
     */
    distinct?: ModerationPresetScalarFieldEnum | ModerationPresetScalarFieldEnum[]
  }


  /**
   * ModerationPreset findMany
   */
  export type ModerationPresetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * Filter, which ModerationPresets to fetch.
     */
    where?: ModerationPresetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationPresets to fetch.
     */
    orderBy?: ModerationPresetOrderByWithRelationInput | ModerationPresetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationPresets.
     */
    cursor?: ModerationPresetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationPresets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationPresets.
     */
    skip?: number
    distinct?: ModerationPresetScalarFieldEnum | ModerationPresetScalarFieldEnum[]
  }


  /**
   * ModerationPreset create
   */
  export type ModerationPresetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationPreset.
     */
    data: XOR<ModerationPresetCreateInput, ModerationPresetUncheckedCreateInput>
  }


  /**
   * ModerationPreset createMany
   */
  export type ModerationPresetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationPresets.
     */
    data: ModerationPresetCreateManyInput | ModerationPresetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ModerationPreset update
   */
  export type ModerationPresetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationPreset.
     */
    data: XOR<ModerationPresetUpdateInput, ModerationPresetUncheckedUpdateInput>
    /**
     * Choose, which ModerationPreset to update.
     */
    where: ModerationPresetWhereUniqueInput
  }


  /**
   * ModerationPreset updateMany
   */
  export type ModerationPresetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationPresets.
     */
    data: XOR<ModerationPresetUpdateManyMutationInput, ModerationPresetUncheckedUpdateManyInput>
    /**
     * Filter which ModerationPresets to update
     */
    where?: ModerationPresetWhereInput
  }


  /**
   * ModerationPreset upsert
   */
  export type ModerationPresetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationPreset to update in case it exists.
     */
    where: ModerationPresetWhereUniqueInput
    /**
     * In case the ModerationPreset found by the `where` argument doesn't exist, create a new ModerationPreset with this data.
     */
    create: XOR<ModerationPresetCreateInput, ModerationPresetUncheckedCreateInput>
    /**
     * In case the ModerationPreset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationPresetUpdateInput, ModerationPresetUncheckedUpdateInput>
  }


  /**
   * ModerationPreset delete
   */
  export type ModerationPresetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
    /**
     * Filter which ModerationPreset to delete.
     */
    where: ModerationPresetWhereUniqueInput
  }


  /**
   * ModerationPreset deleteMany
   */
  export type ModerationPresetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationPresets to delete
     */
    where?: ModerationPresetWhereInput
  }


  /**
   * ModerationPreset without action
   */
  export type ModerationPresetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationPreset
     */
    select?: ModerationPresetSelect<ExtArgs> | null
  }



  /**
   * Model ModerationResolution
   */

  export type AggregateModerationResolution = {
    _count: ModerationResolutionCountAggregateOutputType | null
    _avg: ModerationResolutionAvgAggregateOutputType | null
    _sum: ModerationResolutionSumAggregateOutputType | null
    _min: ModerationResolutionMinAggregateOutputType | null
    _max: ModerationResolutionMaxAggregateOutputType | null
  }

  export type ModerationResolutionAvgAggregateOutputType = {
    id: number | null
    banHours: number | null
    enableMute: number | null
    muteHours: number | null
    reminder: number | null
  }

  export type ModerationResolutionSumAggregateOutputType = {
    id: number | null
    banHours: number | null
    enableMute: number | null
    muteHours: number | null
    reminder: number | null
  }

  export type ModerationResolutionMinAggregateOutputType = {
    id: number | null
    type: $Enums.ModerationResolutionType | null
    title: string | null
    subtitle: string | null
    banHours: number | null
    enableMute: number | null
    muteHours: number | null
    reminder: number | null
    message: string | null
  }

  export type ModerationResolutionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.ModerationResolutionType | null
    title: string | null
    subtitle: string | null
    banHours: number | null
    enableMute: number | null
    muteHours: number | null
    reminder: number | null
    message: string | null
  }

  export type ModerationResolutionCountAggregateOutputType = {
    id: number
    type: number
    title: number
    subtitle: number
    banHours: number
    enableMute: number
    muteHours: number
    reminder: number
    message: number
    _all: number
  }


  export type ModerationResolutionAvgAggregateInputType = {
    id?: true
    banHours?: true
    enableMute?: true
    muteHours?: true
    reminder?: true
  }

  export type ModerationResolutionSumAggregateInputType = {
    id?: true
    banHours?: true
    enableMute?: true
    muteHours?: true
    reminder?: true
  }

  export type ModerationResolutionMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    subtitle?: true
    banHours?: true
    enableMute?: true
    muteHours?: true
    reminder?: true
    message?: true
  }

  export type ModerationResolutionMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    subtitle?: true
    banHours?: true
    enableMute?: true
    muteHours?: true
    reminder?: true
    message?: true
  }

  export type ModerationResolutionCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    subtitle?: true
    banHours?: true
    enableMute?: true
    muteHours?: true
    reminder?: true
    message?: true
    _all?: true
  }

  export type ModerationResolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationResolution to aggregate.
     */
    where?: ModerationResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationResolutions to fetch.
     */
    orderBy?: ModerationResolutionOrderByWithRelationInput | ModerationResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationResolutions
    **/
    _count?: true | ModerationResolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationResolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationResolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationResolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationResolutionMaxAggregateInputType
  }

  export type GetModerationResolutionAggregateType<T extends ModerationResolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationResolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationResolution[P]>
      : GetScalarType<T[P], AggregateModerationResolution[P]>
  }




  export type ModerationResolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationResolutionWhereInput
    orderBy?: ModerationResolutionOrderByWithAggregationInput | ModerationResolutionOrderByWithAggregationInput[]
    by: ModerationResolutionScalarFieldEnum[] | ModerationResolutionScalarFieldEnum
    having?: ModerationResolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationResolutionCountAggregateInputType | true
    _avg?: ModerationResolutionAvgAggregateInputType
    _sum?: ModerationResolutionSumAggregateInputType
    _min?: ModerationResolutionMinAggregateInputType
    _max?: ModerationResolutionMaxAggregateInputType
  }

  export type ModerationResolutionGroupByOutputType = {
    id: number
    type: $Enums.ModerationResolutionType
    title: string
    subtitle: string
    banHours: number
    enableMute: number
    muteHours: number
    reminder: number
    message: string
    _count: ModerationResolutionCountAggregateOutputType | null
    _avg: ModerationResolutionAvgAggregateOutputType | null
    _sum: ModerationResolutionSumAggregateOutputType | null
    _min: ModerationResolutionMinAggregateOutputType | null
    _max: ModerationResolutionMaxAggregateOutputType | null
  }

  type GetModerationResolutionGroupByPayload<T extends ModerationResolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationResolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationResolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationResolutionGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationResolutionGroupByOutputType[P]>
        }
      >
    >


  export type ModerationResolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    subtitle?: boolean
    banHours?: boolean
    enableMute?: boolean
    muteHours?: boolean
    reminder?: boolean
    message?: boolean
  }, ExtArgs["result"]["moderationResolution"]>

  export type ModerationResolutionSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    subtitle?: boolean
    banHours?: boolean
    enableMute?: boolean
    muteHours?: boolean
    reminder?: boolean
    message?: boolean
  }


  export type $ModerationResolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationResolution"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.ModerationResolutionType
      title: string
      subtitle: string
      banHours: number
      enableMute: number
      muteHours: number
      reminder: number
      message: string
    }, ExtArgs["result"]["moderationResolution"]>
    composites: {}
  }


  type ModerationResolutionGetPayload<S extends boolean | null | undefined | ModerationResolutionDefaultArgs> = $Result.GetResult<Prisma.$ModerationResolutionPayload, S>

  type ModerationResolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationResolutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationResolutionCountAggregateInputType | true
    }

  export interface ModerationResolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationResolution'], meta: { name: 'ModerationResolution' } }
    /**
     * Find zero or one ModerationResolution that matches the filter.
     * @param {ModerationResolutionFindUniqueArgs} args - Arguments to find a ModerationResolution
     * @example
     * // Get one ModerationResolution
     * const moderationResolution = await prisma.moderationResolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModerationResolutionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationResolutionFindUniqueArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ModerationResolution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModerationResolutionFindUniqueOrThrowArgs} args - Arguments to find a ModerationResolution
     * @example
     * // Get one ModerationResolution
     * const moderationResolution = await prisma.moderationResolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModerationResolutionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationResolutionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ModerationResolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionFindFirstArgs} args - Arguments to find a ModerationResolution
     * @example
     * // Get one ModerationResolution
     * const moderationResolution = await prisma.moderationResolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModerationResolutionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationResolutionFindFirstArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ModerationResolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionFindFirstOrThrowArgs} args - Arguments to find a ModerationResolution
     * @example
     * // Get one ModerationResolution
     * const moderationResolution = await prisma.moderationResolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModerationResolutionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationResolutionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ModerationResolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationResolutions
     * const moderationResolutions = await prisma.moderationResolution.findMany()
     * 
     * // Get first 10 ModerationResolutions
     * const moderationResolutions = await prisma.moderationResolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationResolutionWithIdOnly = await prisma.moderationResolution.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModerationResolutionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationResolutionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ModerationResolution.
     * @param {ModerationResolutionCreateArgs} args - Arguments to create a ModerationResolution.
     * @example
     * // Create one ModerationResolution
     * const ModerationResolution = await prisma.moderationResolution.create({
     *   data: {
     *     // ... data to create a ModerationResolution
     *   }
     * })
     * 
    **/
    create<T extends ModerationResolutionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationResolutionCreateArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ModerationResolutions.
     *     @param {ModerationResolutionCreateManyArgs} args - Arguments to create many ModerationResolutions.
     *     @example
     *     // Create many ModerationResolutions
     *     const moderationResolution = await prisma.moderationResolution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModerationResolutionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationResolutionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModerationResolution.
     * @param {ModerationResolutionDeleteArgs} args - Arguments to delete one ModerationResolution.
     * @example
     * // Delete one ModerationResolution
     * const ModerationResolution = await prisma.moderationResolution.delete({
     *   where: {
     *     // ... filter to delete one ModerationResolution
     *   }
     * })
     * 
    **/
    delete<T extends ModerationResolutionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationResolutionDeleteArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ModerationResolution.
     * @param {ModerationResolutionUpdateArgs} args - Arguments to update one ModerationResolution.
     * @example
     * // Update one ModerationResolution
     * const moderationResolution = await prisma.moderationResolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModerationResolutionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationResolutionUpdateArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ModerationResolutions.
     * @param {ModerationResolutionDeleteManyArgs} args - Arguments to filter ModerationResolutions to delete.
     * @example
     * // Delete a few ModerationResolutions
     * const { count } = await prisma.moderationResolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModerationResolutionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationResolutionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationResolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationResolutions
     * const moderationResolution = await prisma.moderationResolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModerationResolutionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationResolutionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationResolution.
     * @param {ModerationResolutionUpsertArgs} args - Arguments to update or create a ModerationResolution.
     * @example
     * // Update or create a ModerationResolution
     * const moderationResolution = await prisma.moderationResolution.upsert({
     *   create: {
     *     // ... data to create a ModerationResolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationResolution we want to update
     *   }
     * })
    **/
    upsert<T extends ModerationResolutionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationResolutionUpsertArgs<ExtArgs>>
    ): Prisma__ModerationResolutionClient<$Result.GetResult<Prisma.$ModerationResolutionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ModerationResolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionCountArgs} args - Arguments to filter ModerationResolutions to count.
     * @example
     * // Count the number of ModerationResolutions
     * const count = await prisma.moderationResolution.count({
     *   where: {
     *     // ... the filter for the ModerationResolutions we want to count
     *   }
     * })
    **/
    count<T extends ModerationResolutionCountArgs>(
      args?: Subset<T, ModerationResolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationResolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationResolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationResolutionAggregateArgs>(args: Subset<T, ModerationResolutionAggregateArgs>): Prisma.PrismaPromise<GetModerationResolutionAggregateType<T>>

    /**
     * Group by ModerationResolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationResolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationResolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationResolutionGroupByArgs['orderBy'] }
        : { orderBy?: ModerationResolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationResolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationResolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationResolution model
   */
  readonly fields: ModerationResolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationResolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationResolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ModerationResolution model
   */ 
  interface ModerationResolutionFieldRefs {
    readonly id: FieldRef<"ModerationResolution", 'Int'>
    readonly type: FieldRef<"ModerationResolution", 'ModerationResolutionType'>
    readonly title: FieldRef<"ModerationResolution", 'String'>
    readonly subtitle: FieldRef<"ModerationResolution", 'String'>
    readonly banHours: FieldRef<"ModerationResolution", 'Int'>
    readonly enableMute: FieldRef<"ModerationResolution", 'Int'>
    readonly muteHours: FieldRef<"ModerationResolution", 'Int'>
    readonly reminder: FieldRef<"ModerationResolution", 'Int'>
    readonly message: FieldRef<"ModerationResolution", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ModerationResolution findUnique
   */
  export type ModerationResolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationResolution to fetch.
     */
    where: ModerationResolutionWhereUniqueInput
  }


  /**
   * ModerationResolution findUniqueOrThrow
   */
  export type ModerationResolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationResolution to fetch.
     */
    where: ModerationResolutionWhereUniqueInput
  }


  /**
   * ModerationResolution findFirst
   */
  export type ModerationResolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationResolution to fetch.
     */
    where?: ModerationResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationResolutions to fetch.
     */
    orderBy?: ModerationResolutionOrderByWithRelationInput | ModerationResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationResolutions.
     */
    cursor?: ModerationResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationResolutions.
     */
    distinct?: ModerationResolutionScalarFieldEnum | ModerationResolutionScalarFieldEnum[]
  }


  /**
   * ModerationResolution findFirstOrThrow
   */
  export type ModerationResolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationResolution to fetch.
     */
    where?: ModerationResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationResolutions to fetch.
     */
    orderBy?: ModerationResolutionOrderByWithRelationInput | ModerationResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationResolutions.
     */
    cursor?: ModerationResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationResolutions.
     */
    distinct?: ModerationResolutionScalarFieldEnum | ModerationResolutionScalarFieldEnum[]
  }


  /**
   * ModerationResolution findMany
   */
  export type ModerationResolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationResolutions to fetch.
     */
    where?: ModerationResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationResolutions to fetch.
     */
    orderBy?: ModerationResolutionOrderByWithRelationInput | ModerationResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationResolutions.
     */
    cursor?: ModerationResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationResolutions.
     */
    skip?: number
    distinct?: ModerationResolutionScalarFieldEnum | ModerationResolutionScalarFieldEnum[]
  }


  /**
   * ModerationResolution create
   */
  export type ModerationResolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationResolution.
     */
    data: XOR<ModerationResolutionCreateInput, ModerationResolutionUncheckedCreateInput>
  }


  /**
   * ModerationResolution createMany
   */
  export type ModerationResolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationResolutions.
     */
    data: ModerationResolutionCreateManyInput | ModerationResolutionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ModerationResolution update
   */
  export type ModerationResolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationResolution.
     */
    data: XOR<ModerationResolutionUpdateInput, ModerationResolutionUncheckedUpdateInput>
    /**
     * Choose, which ModerationResolution to update.
     */
    where: ModerationResolutionWhereUniqueInput
  }


  /**
   * ModerationResolution updateMany
   */
  export type ModerationResolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationResolutions.
     */
    data: XOR<ModerationResolutionUpdateManyMutationInput, ModerationResolutionUncheckedUpdateManyInput>
    /**
     * Filter which ModerationResolutions to update
     */
    where?: ModerationResolutionWhereInput
  }


  /**
   * ModerationResolution upsert
   */
  export type ModerationResolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationResolution to update in case it exists.
     */
    where: ModerationResolutionWhereUniqueInput
    /**
     * In case the ModerationResolution found by the `where` argument doesn't exist, create a new ModerationResolution with this data.
     */
    create: XOR<ModerationResolutionCreateInput, ModerationResolutionUncheckedCreateInput>
    /**
     * In case the ModerationResolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationResolutionUpdateInput, ModerationResolutionUncheckedUpdateInput>
  }


  /**
   * ModerationResolution delete
   */
  export type ModerationResolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
    /**
     * Filter which ModerationResolution to delete.
     */
    where: ModerationResolutionWhereUniqueInput
  }


  /**
   * ModerationResolution deleteMany
   */
  export type ModerationResolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationResolutions to delete
     */
    where?: ModerationResolutionWhereInput
  }


  /**
   * ModerationResolution without action
   */
  export type ModerationResolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationResolution
     */
    select?: ModerationResolutionSelect<ExtArgs> | null
  }



  /**
   * Model ModerationTicket
   */

  export type AggregateModerationTicket = {
    _count: ModerationTicketCountAggregateOutputType | null
    _avg: ModerationTicketAvgAggregateOutputType | null
    _sum: ModerationTicketSumAggregateOutputType | null
    _min: ModerationTicketMinAggregateOutputType | null
    _max: ModerationTicketMaxAggregateOutputType | null
  }

  export type ModerationTicketAvgAggregateOutputType = {
    id: number | null
    score: number | null
    type: number | null
    senderId: number | null
    reportedId: number | null
    moderatorId: number | null
    roomId: number | null
    timestamp: number | null
  }

  export type ModerationTicketSumAggregateOutputType = {
    id: number | null
    score: number | null
    type: number | null
    senderId: number | null
    reportedId: number | null
    moderatorId: number | null
    roomId: number | null
    timestamp: number | null
  }

  export type ModerationTicketMinAggregateOutputType = {
    id: number | null
    score: number | null
    type: number | null
    status: $Enums.ModerationTicketStatus | null
    senderId: number | null
    reportedId: number | null
    moderatorId: number | null
    message: string | null
    roomId: number | null
    roomName: string | null
    timestamp: number | null
  }

  export type ModerationTicketMaxAggregateOutputType = {
    id: number | null
    score: number | null
    type: number | null
    status: $Enums.ModerationTicketStatus | null
    senderId: number | null
    reportedId: number | null
    moderatorId: number | null
    message: string | null
    roomId: number | null
    roomName: string | null
    timestamp: number | null
  }

  export type ModerationTicketCountAggregateOutputType = {
    id: number
    score: number
    type: number
    status: number
    senderId: number
    reportedId: number
    moderatorId: number
    message: number
    roomId: number
    roomName: number
    timestamp: number
    _all: number
  }


  export type ModerationTicketAvgAggregateInputType = {
    id?: true
    score?: true
    type?: true
    senderId?: true
    reportedId?: true
    moderatorId?: true
    roomId?: true
    timestamp?: true
  }

  export type ModerationTicketSumAggregateInputType = {
    id?: true
    score?: true
    type?: true
    senderId?: true
    reportedId?: true
    moderatorId?: true
    roomId?: true
    timestamp?: true
  }

  export type ModerationTicketMinAggregateInputType = {
    id?: true
    score?: true
    type?: true
    status?: true
    senderId?: true
    reportedId?: true
    moderatorId?: true
    message?: true
    roomId?: true
    roomName?: true
    timestamp?: true
  }

  export type ModerationTicketMaxAggregateInputType = {
    id?: true
    score?: true
    type?: true
    status?: true
    senderId?: true
    reportedId?: true
    moderatorId?: true
    message?: true
    roomId?: true
    roomName?: true
    timestamp?: true
  }

  export type ModerationTicketCountAggregateInputType = {
    id?: true
    score?: true
    type?: true
    status?: true
    senderId?: true
    reportedId?: true
    moderatorId?: true
    message?: true
    roomId?: true
    roomName?: true
    timestamp?: true
    _all?: true
  }

  export type ModerationTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationTicket to aggregate.
     */
    where?: ModerationTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTickets to fetch.
     */
    orderBy?: ModerationTicketOrderByWithRelationInput | ModerationTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationTickets
    **/
    _count?: true | ModerationTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationTicketMaxAggregateInputType
  }

  export type GetModerationTicketAggregateType<T extends ModerationTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationTicket[P]>
      : GetScalarType<T[P], AggregateModerationTicket[P]>
  }




  export type ModerationTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationTicketWhereInput
    orderBy?: ModerationTicketOrderByWithAggregationInput | ModerationTicketOrderByWithAggregationInput[]
    by: ModerationTicketScalarFieldEnum[] | ModerationTicketScalarFieldEnum
    having?: ModerationTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationTicketCountAggregateInputType | true
    _avg?: ModerationTicketAvgAggregateInputType
    _sum?: ModerationTicketSumAggregateInputType
    _min?: ModerationTicketMinAggregateInputType
    _max?: ModerationTicketMaxAggregateInputType
  }

  export type ModerationTicketGroupByOutputType = {
    id: number
    score: number
    type: number
    status: $Enums.ModerationTicketStatus
    senderId: number
    reportedId: number
    moderatorId: number
    message: string
    roomId: number
    roomName: string
    timestamp: number
    _count: ModerationTicketCountAggregateOutputType | null
    _avg: ModerationTicketAvgAggregateOutputType | null
    _sum: ModerationTicketSumAggregateOutputType | null
    _min: ModerationTicketMinAggregateOutputType | null
    _max: ModerationTicketMaxAggregateOutputType | null
  }

  type GetModerationTicketGroupByPayload<T extends ModerationTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationTicketGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationTicketGroupByOutputType[P]>
        }
      >
    >


  export type ModerationTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    type?: boolean
    status?: boolean
    senderId?: boolean
    reportedId?: boolean
    moderatorId?: boolean
    message?: boolean
    roomId?: boolean
    roomName?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["moderationTicket"]>

  export type ModerationTicketSelectScalar = {
    id?: boolean
    score?: boolean
    type?: boolean
    status?: boolean
    senderId?: boolean
    reportedId?: boolean
    moderatorId?: boolean
    message?: boolean
    roomId?: boolean
    roomName?: boolean
    timestamp?: boolean
  }


  export type $ModerationTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationTicket"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      score: number
      type: number
      status: $Enums.ModerationTicketStatus
      senderId: number
      reportedId: number
      moderatorId: number
      message: string
      roomId: number
      roomName: string
      timestamp: number
    }, ExtArgs["result"]["moderationTicket"]>
    composites: {}
  }


  type ModerationTicketGetPayload<S extends boolean | null | undefined | ModerationTicketDefaultArgs> = $Result.GetResult<Prisma.$ModerationTicketPayload, S>

  type ModerationTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationTicketCountAggregateInputType | true
    }

  export interface ModerationTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationTicket'], meta: { name: 'ModerationTicket' } }
    /**
     * Find zero or one ModerationTicket that matches the filter.
     * @param {ModerationTicketFindUniqueArgs} args - Arguments to find a ModerationTicket
     * @example
     * // Get one ModerationTicket
     * const moderationTicket = await prisma.moderationTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModerationTicketFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTicketFindUniqueArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ModerationTicket that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModerationTicketFindUniqueOrThrowArgs} args - Arguments to find a ModerationTicket
     * @example
     * // Get one ModerationTicket
     * const moderationTicket = await prisma.moderationTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModerationTicketFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTicketFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ModerationTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketFindFirstArgs} args - Arguments to find a ModerationTicket
     * @example
     * // Get one ModerationTicket
     * const moderationTicket = await prisma.moderationTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModerationTicketFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTicketFindFirstArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ModerationTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketFindFirstOrThrowArgs} args - Arguments to find a ModerationTicket
     * @example
     * // Get one ModerationTicket
     * const moderationTicket = await prisma.moderationTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModerationTicketFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTicketFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ModerationTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationTickets
     * const moderationTickets = await prisma.moderationTicket.findMany()
     * 
     * // Get first 10 ModerationTickets
     * const moderationTickets = await prisma.moderationTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationTicketWithIdOnly = await prisma.moderationTicket.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModerationTicketFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTicketFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ModerationTicket.
     * @param {ModerationTicketCreateArgs} args - Arguments to create a ModerationTicket.
     * @example
     * // Create one ModerationTicket
     * const ModerationTicket = await prisma.moderationTicket.create({
     *   data: {
     *     // ... data to create a ModerationTicket
     *   }
     * })
     * 
    **/
    create<T extends ModerationTicketCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTicketCreateArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ModerationTickets.
     *     @param {ModerationTicketCreateManyArgs} args - Arguments to create many ModerationTickets.
     *     @example
     *     // Create many ModerationTickets
     *     const moderationTicket = await prisma.moderationTicket.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModerationTicketCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTicketCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModerationTicket.
     * @param {ModerationTicketDeleteArgs} args - Arguments to delete one ModerationTicket.
     * @example
     * // Delete one ModerationTicket
     * const ModerationTicket = await prisma.moderationTicket.delete({
     *   where: {
     *     // ... filter to delete one ModerationTicket
     *   }
     * })
     * 
    **/
    delete<T extends ModerationTicketDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTicketDeleteArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ModerationTicket.
     * @param {ModerationTicketUpdateArgs} args - Arguments to update one ModerationTicket.
     * @example
     * // Update one ModerationTicket
     * const moderationTicket = await prisma.moderationTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModerationTicketUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTicketUpdateArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ModerationTickets.
     * @param {ModerationTicketDeleteManyArgs} args - Arguments to filter ModerationTickets to delete.
     * @example
     * // Delete a few ModerationTickets
     * const { count } = await prisma.moderationTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModerationTicketDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTicketDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationTickets
     * const moderationTicket = await prisma.moderationTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModerationTicketUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTicketUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationTicket.
     * @param {ModerationTicketUpsertArgs} args - Arguments to update or create a ModerationTicket.
     * @example
     * // Update or create a ModerationTicket
     * const moderationTicket = await prisma.moderationTicket.upsert({
     *   create: {
     *     // ... data to create a ModerationTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationTicket we want to update
     *   }
     * })
    **/
    upsert<T extends ModerationTicketUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTicketUpsertArgs<ExtArgs>>
    ): Prisma__ModerationTicketClient<$Result.GetResult<Prisma.$ModerationTicketPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ModerationTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketCountArgs} args - Arguments to filter ModerationTickets to count.
     * @example
     * // Count the number of ModerationTickets
     * const count = await prisma.moderationTicket.count({
     *   where: {
     *     // ... the filter for the ModerationTickets we want to count
     *   }
     * })
    **/
    count<T extends ModerationTicketCountArgs>(
      args?: Subset<T, ModerationTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationTicketAggregateArgs>(args: Subset<T, ModerationTicketAggregateArgs>): Prisma.PrismaPromise<GetModerationTicketAggregateType<T>>

    /**
     * Group by ModerationTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationTicketGroupByArgs['orderBy'] }
        : { orderBy?: ModerationTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationTicket model
   */
  readonly fields: ModerationTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ModerationTicket model
   */ 
  interface ModerationTicketFieldRefs {
    readonly id: FieldRef<"ModerationTicket", 'Int'>
    readonly score: FieldRef<"ModerationTicket", 'Int'>
    readonly type: FieldRef<"ModerationTicket", 'Int'>
    readonly status: FieldRef<"ModerationTicket", 'ModerationTicketStatus'>
    readonly senderId: FieldRef<"ModerationTicket", 'Int'>
    readonly reportedId: FieldRef<"ModerationTicket", 'Int'>
    readonly moderatorId: FieldRef<"ModerationTicket", 'Int'>
    readonly message: FieldRef<"ModerationTicket", 'String'>
    readonly roomId: FieldRef<"ModerationTicket", 'Int'>
    readonly roomName: FieldRef<"ModerationTicket", 'String'>
    readonly timestamp: FieldRef<"ModerationTicket", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ModerationTicket findUnique
   */
  export type ModerationTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTicket to fetch.
     */
    where: ModerationTicketWhereUniqueInput
  }


  /**
   * ModerationTicket findUniqueOrThrow
   */
  export type ModerationTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTicket to fetch.
     */
    where: ModerationTicketWhereUniqueInput
  }


  /**
   * ModerationTicket findFirst
   */
  export type ModerationTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTicket to fetch.
     */
    where?: ModerationTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTickets to fetch.
     */
    orderBy?: ModerationTicketOrderByWithRelationInput | ModerationTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationTickets.
     */
    cursor?: ModerationTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationTickets.
     */
    distinct?: ModerationTicketScalarFieldEnum | ModerationTicketScalarFieldEnum[]
  }


  /**
   * ModerationTicket findFirstOrThrow
   */
  export type ModerationTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTicket to fetch.
     */
    where?: ModerationTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTickets to fetch.
     */
    orderBy?: ModerationTicketOrderByWithRelationInput | ModerationTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationTickets.
     */
    cursor?: ModerationTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationTickets.
     */
    distinct?: ModerationTicketScalarFieldEnum | ModerationTicketScalarFieldEnum[]
  }


  /**
   * ModerationTicket findMany
   */
  export type ModerationTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTickets to fetch.
     */
    where?: ModerationTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTickets to fetch.
     */
    orderBy?: ModerationTicketOrderByWithRelationInput | ModerationTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationTickets.
     */
    cursor?: ModerationTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTickets.
     */
    skip?: number
    distinct?: ModerationTicketScalarFieldEnum | ModerationTicketScalarFieldEnum[]
  }


  /**
   * ModerationTicket create
   */
  export type ModerationTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationTicket.
     */
    data: XOR<ModerationTicketCreateInput, ModerationTicketUncheckedCreateInput>
  }


  /**
   * ModerationTicket createMany
   */
  export type ModerationTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationTickets.
     */
    data: ModerationTicketCreateManyInput | ModerationTicketCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ModerationTicket update
   */
  export type ModerationTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationTicket.
     */
    data: XOR<ModerationTicketUpdateInput, ModerationTicketUncheckedUpdateInput>
    /**
     * Choose, which ModerationTicket to update.
     */
    where: ModerationTicketWhereUniqueInput
  }


  /**
   * ModerationTicket updateMany
   */
  export type ModerationTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationTickets.
     */
    data: XOR<ModerationTicketUpdateManyMutationInput, ModerationTicketUncheckedUpdateManyInput>
    /**
     * Filter which ModerationTickets to update
     */
    where?: ModerationTicketWhereInput
  }


  /**
   * ModerationTicket upsert
   */
  export type ModerationTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationTicket to update in case it exists.
     */
    where: ModerationTicketWhereUniqueInput
    /**
     * In case the ModerationTicket found by the `where` argument doesn't exist, create a new ModerationTicket with this data.
     */
    create: XOR<ModerationTicketCreateInput, ModerationTicketUncheckedCreateInput>
    /**
     * In case the ModerationTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationTicketUpdateInput, ModerationTicketUncheckedUpdateInput>
  }


  /**
   * ModerationTicket delete
   */
  export type ModerationTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
    /**
     * Filter which ModerationTicket to delete.
     */
    where: ModerationTicketWhereUniqueInput
  }


  /**
   * ModerationTicket deleteMany
   */
  export type ModerationTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationTickets to delete
     */
    where?: ModerationTicketWhereInput
  }


  /**
   * ModerationTicket without action
   */
  export type ModerationTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTicket
     */
    select?: ModerationTicketSelect<ExtArgs> | null
  }



  /**
   * Model ModerationTopic
   */

  export type AggregateModerationTopic = {
    _count: ModerationTopicCountAggregateOutputType | null
    _avg: ModerationTopicAvgAggregateOutputType | null
    _sum: ModerationTopicSumAggregateOutputType | null
    _min: ModerationTopicMinAggregateOutputType | null
    _max: ModerationTopicMaxAggregateOutputType | null
  }

  export type ModerationTopicAvgAggregateOutputType = {
    id: number | null
  }

  export type ModerationTopicSumAggregateOutputType = {
    id: number | null
  }

  export type ModerationTopicMinAggregateOutputType = {
    id: number | null
    caption: string | null
  }

  export type ModerationTopicMaxAggregateOutputType = {
    id: number | null
    caption: string | null
  }

  export type ModerationTopicCountAggregateOutputType = {
    id: number
    caption: number
    _all: number
  }


  export type ModerationTopicAvgAggregateInputType = {
    id?: true
  }

  export type ModerationTopicSumAggregateInputType = {
    id?: true
  }

  export type ModerationTopicMinAggregateInputType = {
    id?: true
    caption?: true
  }

  export type ModerationTopicMaxAggregateInputType = {
    id?: true
    caption?: true
  }

  export type ModerationTopicCountAggregateInputType = {
    id?: true
    caption?: true
    _all?: true
  }

  export type ModerationTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationTopic to aggregate.
     */
    where?: ModerationTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopics to fetch.
     */
    orderBy?: ModerationTopicOrderByWithRelationInput | ModerationTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationTopics
    **/
    _count?: true | ModerationTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationTopicMaxAggregateInputType
  }

  export type GetModerationTopicAggregateType<T extends ModerationTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationTopic[P]>
      : GetScalarType<T[P], AggregateModerationTopic[P]>
  }




  export type ModerationTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationTopicWhereInput
    orderBy?: ModerationTopicOrderByWithAggregationInput | ModerationTopicOrderByWithAggregationInput[]
    by: ModerationTopicScalarFieldEnum[] | ModerationTopicScalarFieldEnum
    having?: ModerationTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationTopicCountAggregateInputType | true
    _avg?: ModerationTopicAvgAggregateInputType
    _sum?: ModerationTopicSumAggregateInputType
    _min?: ModerationTopicMinAggregateInputType
    _max?: ModerationTopicMaxAggregateInputType
  }

  export type ModerationTopicGroupByOutputType = {
    id: number
    caption: string
    _count: ModerationTopicCountAggregateOutputType | null
    _avg: ModerationTopicAvgAggregateOutputType | null
    _sum: ModerationTopicSumAggregateOutputType | null
    _min: ModerationTopicMinAggregateOutputType | null
    _max: ModerationTopicMaxAggregateOutputType | null
  }

  type GetModerationTopicGroupByPayload<T extends ModerationTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationTopicGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationTopicGroupByOutputType[P]>
        }
      >
    >


  export type ModerationTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caption?: boolean
  }, ExtArgs["result"]["moderationTopic"]>

  export type ModerationTopicSelectScalar = {
    id?: boolean
    caption?: boolean
  }


  export type $ModerationTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationTopic"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      caption: string
    }, ExtArgs["result"]["moderationTopic"]>
    composites: {}
  }


  type ModerationTopicGetPayload<S extends boolean | null | undefined | ModerationTopicDefaultArgs> = $Result.GetResult<Prisma.$ModerationTopicPayload, S>

  type ModerationTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationTopicCountAggregateInputType | true
    }

  export interface ModerationTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationTopic'], meta: { name: 'ModerationTopic' } }
    /**
     * Find zero or one ModerationTopic that matches the filter.
     * @param {ModerationTopicFindUniqueArgs} args - Arguments to find a ModerationTopic
     * @example
     * // Get one ModerationTopic
     * const moderationTopic = await prisma.moderationTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModerationTopicFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicFindUniqueArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ModerationTopic that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModerationTopicFindUniqueOrThrowArgs} args - Arguments to find a ModerationTopic
     * @example
     * // Get one ModerationTopic
     * const moderationTopic = await prisma.moderationTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModerationTopicFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ModerationTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicFindFirstArgs} args - Arguments to find a ModerationTopic
     * @example
     * // Get one ModerationTopic
     * const moderationTopic = await prisma.moderationTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModerationTopicFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicFindFirstArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ModerationTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicFindFirstOrThrowArgs} args - Arguments to find a ModerationTopic
     * @example
     * // Get one ModerationTopic
     * const moderationTopic = await prisma.moderationTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModerationTopicFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ModerationTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationTopics
     * const moderationTopics = await prisma.moderationTopic.findMany()
     * 
     * // Get first 10 ModerationTopics
     * const moderationTopics = await prisma.moderationTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationTopicWithIdOnly = await prisma.moderationTopic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModerationTopicFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ModerationTopic.
     * @param {ModerationTopicCreateArgs} args - Arguments to create a ModerationTopic.
     * @example
     * // Create one ModerationTopic
     * const ModerationTopic = await prisma.moderationTopic.create({
     *   data: {
     *     // ... data to create a ModerationTopic
     *   }
     * })
     * 
    **/
    create<T extends ModerationTopicCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicCreateArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ModerationTopics.
     *     @param {ModerationTopicCreateManyArgs} args - Arguments to create many ModerationTopics.
     *     @example
     *     // Create many ModerationTopics
     *     const moderationTopic = await prisma.moderationTopic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModerationTopicCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModerationTopic.
     * @param {ModerationTopicDeleteArgs} args - Arguments to delete one ModerationTopic.
     * @example
     * // Delete one ModerationTopic
     * const ModerationTopic = await prisma.moderationTopic.delete({
     *   where: {
     *     // ... filter to delete one ModerationTopic
     *   }
     * })
     * 
    **/
    delete<T extends ModerationTopicDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicDeleteArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ModerationTopic.
     * @param {ModerationTopicUpdateArgs} args - Arguments to update one ModerationTopic.
     * @example
     * // Update one ModerationTopic
     * const moderationTopic = await prisma.moderationTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModerationTopicUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicUpdateArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ModerationTopics.
     * @param {ModerationTopicDeleteManyArgs} args - Arguments to filter ModerationTopics to delete.
     * @example
     * // Delete a few ModerationTopics
     * const { count } = await prisma.moderationTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModerationTopicDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationTopics
     * const moderationTopic = await prisma.moderationTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModerationTopicUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationTopic.
     * @param {ModerationTopicUpsertArgs} args - Arguments to update or create a ModerationTopic.
     * @example
     * // Update or create a ModerationTopic
     * const moderationTopic = await prisma.moderationTopic.upsert({
     *   create: {
     *     // ... data to create a ModerationTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationTopic we want to update
     *   }
     * })
    **/
    upsert<T extends ModerationTopicUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicUpsertArgs<ExtArgs>>
    ): Prisma__ModerationTopicClient<$Result.GetResult<Prisma.$ModerationTopicPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ModerationTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicCountArgs} args - Arguments to filter ModerationTopics to count.
     * @example
     * // Count the number of ModerationTopics
     * const count = await prisma.moderationTopic.count({
     *   where: {
     *     // ... the filter for the ModerationTopics we want to count
     *   }
     * })
    **/
    count<T extends ModerationTopicCountArgs>(
      args?: Subset<T, ModerationTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationTopicAggregateArgs>(args: Subset<T, ModerationTopicAggregateArgs>): Prisma.PrismaPromise<GetModerationTopicAggregateType<T>>

    /**
     * Group by ModerationTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationTopicGroupByArgs['orderBy'] }
        : { orderBy?: ModerationTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationTopic model
   */
  readonly fields: ModerationTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ModerationTopic model
   */ 
  interface ModerationTopicFieldRefs {
    readonly id: FieldRef<"ModerationTopic", 'Int'>
    readonly caption: FieldRef<"ModerationTopic", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ModerationTopic findUnique
   */
  export type ModerationTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopic to fetch.
     */
    where: ModerationTopicWhereUniqueInput
  }


  /**
   * ModerationTopic findUniqueOrThrow
   */
  export type ModerationTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopic to fetch.
     */
    where: ModerationTopicWhereUniqueInput
  }


  /**
   * ModerationTopic findFirst
   */
  export type ModerationTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopic to fetch.
     */
    where?: ModerationTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopics to fetch.
     */
    orderBy?: ModerationTopicOrderByWithRelationInput | ModerationTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationTopics.
     */
    cursor?: ModerationTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationTopics.
     */
    distinct?: ModerationTopicScalarFieldEnum | ModerationTopicScalarFieldEnum[]
  }


  /**
   * ModerationTopic findFirstOrThrow
   */
  export type ModerationTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopic to fetch.
     */
    where?: ModerationTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopics to fetch.
     */
    orderBy?: ModerationTopicOrderByWithRelationInput | ModerationTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationTopics.
     */
    cursor?: ModerationTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationTopics.
     */
    distinct?: ModerationTopicScalarFieldEnum | ModerationTopicScalarFieldEnum[]
  }


  /**
   * ModerationTopic findMany
   */
  export type ModerationTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopics to fetch.
     */
    where?: ModerationTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopics to fetch.
     */
    orderBy?: ModerationTopicOrderByWithRelationInput | ModerationTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationTopics.
     */
    cursor?: ModerationTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopics.
     */
    skip?: number
    distinct?: ModerationTopicScalarFieldEnum | ModerationTopicScalarFieldEnum[]
  }


  /**
   * ModerationTopic create
   */
  export type ModerationTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationTopic.
     */
    data?: XOR<ModerationTopicCreateInput, ModerationTopicUncheckedCreateInput>
  }


  /**
   * ModerationTopic createMany
   */
  export type ModerationTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationTopics.
     */
    data: ModerationTopicCreateManyInput | ModerationTopicCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ModerationTopic update
   */
  export type ModerationTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationTopic.
     */
    data: XOR<ModerationTopicUpdateInput, ModerationTopicUncheckedUpdateInput>
    /**
     * Choose, which ModerationTopic to update.
     */
    where: ModerationTopicWhereUniqueInput
  }


  /**
   * ModerationTopic updateMany
   */
  export type ModerationTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationTopics.
     */
    data: XOR<ModerationTopicUpdateManyMutationInput, ModerationTopicUncheckedUpdateManyInput>
    /**
     * Filter which ModerationTopics to update
     */
    where?: ModerationTopicWhereInput
  }


  /**
   * ModerationTopic upsert
   */
  export type ModerationTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationTopic to update in case it exists.
     */
    where: ModerationTopicWhereUniqueInput
    /**
     * In case the ModerationTopic found by the `where` argument doesn't exist, create a new ModerationTopic with this data.
     */
    create: XOR<ModerationTopicCreateInput, ModerationTopicUncheckedCreateInput>
    /**
     * In case the ModerationTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationTopicUpdateInput, ModerationTopicUncheckedUpdateInput>
  }


  /**
   * ModerationTopic delete
   */
  export type ModerationTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
    /**
     * Filter which ModerationTopic to delete.
     */
    where: ModerationTopicWhereUniqueInput
  }


  /**
   * ModerationTopic deleteMany
   */
  export type ModerationTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationTopics to delete
     */
    where?: ModerationTopicWhereInput
  }


  /**
   * ModerationTopic without action
   */
  export type ModerationTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopic
     */
    select?: ModerationTopicSelect<ExtArgs> | null
  }



  /**
   * Model ModerationTopicAction
   */

  export type AggregateModerationTopicAction = {
    _count: ModerationTopicActionCountAggregateOutputType | null
    _avg: ModerationTopicActionAvgAggregateOutputType | null
    _sum: ModerationTopicActionSumAggregateOutputType | null
    _min: ModerationTopicActionMinAggregateOutputType | null
    _max: ModerationTopicActionMaxAggregateOutputType | null
  }

  export type ModerationTopicActionAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    muteTime: number | null
    banTime: number | null
    ipTime: number | null
    tradeLockTime: number | null
  }

  export type ModerationTopicActionSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    muteTime: number | null
    banTime: number | null
    ipTime: number | null
    tradeLockTime: number | null
  }

  export type ModerationTopicActionMinAggregateOutputType = {
    id: number | null
    parentId: number | null
    type: string | null
    caption: string | null
    messageText: string | null
    defaultSanction: string | null
    muteTime: number | null
    banTime: number | null
    ipTime: number | null
    tradeLockTime: number | null
  }

  export type ModerationTopicActionMaxAggregateOutputType = {
    id: number | null
    parentId: number | null
    type: string | null
    caption: string | null
    messageText: string | null
    defaultSanction: string | null
    muteTime: number | null
    banTime: number | null
    ipTime: number | null
    tradeLockTime: number | null
  }

  export type ModerationTopicActionCountAggregateOutputType = {
    id: number
    parentId: number
    type: number
    caption: number
    messageText: number
    defaultSanction: number
    muteTime: number
    banTime: number
    ipTime: number
    tradeLockTime: number
    _all: number
  }


  export type ModerationTopicActionAvgAggregateInputType = {
    id?: true
    parentId?: true
    muteTime?: true
    banTime?: true
    ipTime?: true
    tradeLockTime?: true
  }

  export type ModerationTopicActionSumAggregateInputType = {
    id?: true
    parentId?: true
    muteTime?: true
    banTime?: true
    ipTime?: true
    tradeLockTime?: true
  }

  export type ModerationTopicActionMinAggregateInputType = {
    id?: true
    parentId?: true
    type?: true
    caption?: true
    messageText?: true
    defaultSanction?: true
    muteTime?: true
    banTime?: true
    ipTime?: true
    tradeLockTime?: true
  }

  export type ModerationTopicActionMaxAggregateInputType = {
    id?: true
    parentId?: true
    type?: true
    caption?: true
    messageText?: true
    defaultSanction?: true
    muteTime?: true
    banTime?: true
    ipTime?: true
    tradeLockTime?: true
  }

  export type ModerationTopicActionCountAggregateInputType = {
    id?: true
    parentId?: true
    type?: true
    caption?: true
    messageText?: true
    defaultSanction?: true
    muteTime?: true
    banTime?: true
    ipTime?: true
    tradeLockTime?: true
    _all?: true
  }

  export type ModerationTopicActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationTopicAction to aggregate.
     */
    where?: ModerationTopicActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopicActions to fetch.
     */
    orderBy?: ModerationTopicActionOrderByWithRelationInput | ModerationTopicActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationTopicActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopicActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopicActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationTopicActions
    **/
    _count?: true | ModerationTopicActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModerationTopicActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModerationTopicActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationTopicActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationTopicActionMaxAggregateInputType
  }

  export type GetModerationTopicActionAggregateType<T extends ModerationTopicActionAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationTopicAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationTopicAction[P]>
      : GetScalarType<T[P], AggregateModerationTopicAction[P]>
  }




  export type ModerationTopicActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationTopicActionWhereInput
    orderBy?: ModerationTopicActionOrderByWithAggregationInput | ModerationTopicActionOrderByWithAggregationInput[]
    by: ModerationTopicActionScalarFieldEnum[] | ModerationTopicActionScalarFieldEnum
    having?: ModerationTopicActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationTopicActionCountAggregateInputType | true
    _avg?: ModerationTopicActionAvgAggregateInputType
    _sum?: ModerationTopicActionSumAggregateInputType
    _min?: ModerationTopicActionMinAggregateInputType
    _max?: ModerationTopicActionMaxAggregateInputType
  }

  export type ModerationTopicActionGroupByOutputType = {
    id: number
    parentId: number
    type: string
    caption: string
    messageText: string
    defaultSanction: string
    muteTime: number
    banTime: number
    ipTime: number
    tradeLockTime: number
    _count: ModerationTopicActionCountAggregateOutputType | null
    _avg: ModerationTopicActionAvgAggregateOutputType | null
    _sum: ModerationTopicActionSumAggregateOutputType | null
    _min: ModerationTopicActionMinAggregateOutputType | null
    _max: ModerationTopicActionMaxAggregateOutputType | null
  }

  type GetModerationTopicActionGroupByPayload<T extends ModerationTopicActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationTopicActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationTopicActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationTopicActionGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationTopicActionGroupByOutputType[P]>
        }
      >
    >


  export type ModerationTopicActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    type?: boolean
    caption?: boolean
    messageText?: boolean
    defaultSanction?: boolean
    muteTime?: boolean
    banTime?: boolean
    ipTime?: boolean
    tradeLockTime?: boolean
  }, ExtArgs["result"]["moderationTopicAction"]>

  export type ModerationTopicActionSelectScalar = {
    id?: boolean
    parentId?: boolean
    type?: boolean
    caption?: boolean
    messageText?: boolean
    defaultSanction?: boolean
    muteTime?: boolean
    banTime?: boolean
    ipTime?: boolean
    tradeLockTime?: boolean
  }


  export type $ModerationTopicActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationTopicAction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parentId: number
      type: string
      caption: string
      messageText: string
      defaultSanction: string
      muteTime: number
      banTime: number
      ipTime: number
      tradeLockTime: number
    }, ExtArgs["result"]["moderationTopicAction"]>
    composites: {}
  }


  type ModerationTopicActionGetPayload<S extends boolean | null | undefined | ModerationTopicActionDefaultArgs> = $Result.GetResult<Prisma.$ModerationTopicActionPayload, S>

  type ModerationTopicActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationTopicActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationTopicActionCountAggregateInputType | true
    }

  export interface ModerationTopicActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationTopicAction'], meta: { name: 'ModerationTopicAction' } }
    /**
     * Find zero or one ModerationTopicAction that matches the filter.
     * @param {ModerationTopicActionFindUniqueArgs} args - Arguments to find a ModerationTopicAction
     * @example
     * // Get one ModerationTopicAction
     * const moderationTopicAction = await prisma.moderationTopicAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModerationTopicActionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicActionFindUniqueArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ModerationTopicAction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModerationTopicActionFindUniqueOrThrowArgs} args - Arguments to find a ModerationTopicAction
     * @example
     * // Get one ModerationTopicAction
     * const moderationTopicAction = await prisma.moderationTopicAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModerationTopicActionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicActionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ModerationTopicAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionFindFirstArgs} args - Arguments to find a ModerationTopicAction
     * @example
     * // Get one ModerationTopicAction
     * const moderationTopicAction = await prisma.moderationTopicAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModerationTopicActionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicActionFindFirstArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ModerationTopicAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionFindFirstOrThrowArgs} args - Arguments to find a ModerationTopicAction
     * @example
     * // Get one ModerationTopicAction
     * const moderationTopicAction = await prisma.moderationTopicAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModerationTopicActionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicActionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ModerationTopicActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationTopicActions
     * const moderationTopicActions = await prisma.moderationTopicAction.findMany()
     * 
     * // Get first 10 ModerationTopicActions
     * const moderationTopicActions = await prisma.moderationTopicAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationTopicActionWithIdOnly = await prisma.moderationTopicAction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModerationTopicActionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicActionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ModerationTopicAction.
     * @param {ModerationTopicActionCreateArgs} args - Arguments to create a ModerationTopicAction.
     * @example
     * // Create one ModerationTopicAction
     * const ModerationTopicAction = await prisma.moderationTopicAction.create({
     *   data: {
     *     // ... data to create a ModerationTopicAction
     *   }
     * })
     * 
    **/
    create<T extends ModerationTopicActionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicActionCreateArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ModerationTopicActions.
     *     @param {ModerationTopicActionCreateManyArgs} args - Arguments to create many ModerationTopicActions.
     *     @example
     *     // Create many ModerationTopicActions
     *     const moderationTopicAction = await prisma.moderationTopicAction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModerationTopicActionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicActionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModerationTopicAction.
     * @param {ModerationTopicActionDeleteArgs} args - Arguments to delete one ModerationTopicAction.
     * @example
     * // Delete one ModerationTopicAction
     * const ModerationTopicAction = await prisma.moderationTopicAction.delete({
     *   where: {
     *     // ... filter to delete one ModerationTopicAction
     *   }
     * })
     * 
    **/
    delete<T extends ModerationTopicActionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicActionDeleteArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ModerationTopicAction.
     * @param {ModerationTopicActionUpdateArgs} args - Arguments to update one ModerationTopicAction.
     * @example
     * // Update one ModerationTopicAction
     * const moderationTopicAction = await prisma.moderationTopicAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModerationTopicActionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicActionUpdateArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ModerationTopicActions.
     * @param {ModerationTopicActionDeleteManyArgs} args - Arguments to filter ModerationTopicActions to delete.
     * @example
     * // Delete a few ModerationTopicActions
     * const { count } = await prisma.moderationTopicAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModerationTopicActionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModerationTopicActionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationTopicActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationTopicActions
     * const moderationTopicAction = await prisma.moderationTopicAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModerationTopicActionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicActionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationTopicAction.
     * @param {ModerationTopicActionUpsertArgs} args - Arguments to update or create a ModerationTopicAction.
     * @example
     * // Update or create a ModerationTopicAction
     * const moderationTopicAction = await prisma.moderationTopicAction.upsert({
     *   create: {
     *     // ... data to create a ModerationTopicAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationTopicAction we want to update
     *   }
     * })
    **/
    upsert<T extends ModerationTopicActionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModerationTopicActionUpsertArgs<ExtArgs>>
    ): Prisma__ModerationTopicActionClient<$Result.GetResult<Prisma.$ModerationTopicActionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ModerationTopicActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionCountArgs} args - Arguments to filter ModerationTopicActions to count.
     * @example
     * // Count the number of ModerationTopicActions
     * const count = await prisma.moderationTopicAction.count({
     *   where: {
     *     // ... the filter for the ModerationTopicActions we want to count
     *   }
     * })
    **/
    count<T extends ModerationTopicActionCountArgs>(
      args?: Subset<T, ModerationTopicActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationTopicActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationTopicAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationTopicActionAggregateArgs>(args: Subset<T, ModerationTopicActionAggregateArgs>): Prisma.PrismaPromise<GetModerationTopicActionAggregateType<T>>

    /**
     * Group by ModerationTopicAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationTopicActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationTopicActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationTopicActionGroupByArgs['orderBy'] }
        : { orderBy?: ModerationTopicActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationTopicActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationTopicActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationTopicAction model
   */
  readonly fields: ModerationTopicActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationTopicAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationTopicActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ModerationTopicAction model
   */ 
  interface ModerationTopicActionFieldRefs {
    readonly id: FieldRef<"ModerationTopicAction", 'Int'>
    readonly parentId: FieldRef<"ModerationTopicAction", 'Int'>
    readonly type: FieldRef<"ModerationTopicAction", 'String'>
    readonly caption: FieldRef<"ModerationTopicAction", 'String'>
    readonly messageText: FieldRef<"ModerationTopicAction", 'String'>
    readonly defaultSanction: FieldRef<"ModerationTopicAction", 'String'>
    readonly muteTime: FieldRef<"ModerationTopicAction", 'Int'>
    readonly banTime: FieldRef<"ModerationTopicAction", 'Int'>
    readonly ipTime: FieldRef<"ModerationTopicAction", 'Int'>
    readonly tradeLockTime: FieldRef<"ModerationTopicAction", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ModerationTopicAction findUnique
   */
  export type ModerationTopicActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopicAction to fetch.
     */
    where: ModerationTopicActionWhereUniqueInput
  }


  /**
   * ModerationTopicAction findUniqueOrThrow
   */
  export type ModerationTopicActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopicAction to fetch.
     */
    where: ModerationTopicActionWhereUniqueInput
  }


  /**
   * ModerationTopicAction findFirst
   */
  export type ModerationTopicActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopicAction to fetch.
     */
    where?: ModerationTopicActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopicActions to fetch.
     */
    orderBy?: ModerationTopicActionOrderByWithRelationInput | ModerationTopicActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationTopicActions.
     */
    cursor?: ModerationTopicActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopicActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopicActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationTopicActions.
     */
    distinct?: ModerationTopicActionScalarFieldEnum | ModerationTopicActionScalarFieldEnum[]
  }


  /**
   * ModerationTopicAction findFirstOrThrow
   */
  export type ModerationTopicActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopicAction to fetch.
     */
    where?: ModerationTopicActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopicActions to fetch.
     */
    orderBy?: ModerationTopicActionOrderByWithRelationInput | ModerationTopicActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationTopicActions.
     */
    cursor?: ModerationTopicActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopicActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopicActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationTopicActions.
     */
    distinct?: ModerationTopicActionScalarFieldEnum | ModerationTopicActionScalarFieldEnum[]
  }


  /**
   * ModerationTopicAction findMany
   */
  export type ModerationTopicActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * Filter, which ModerationTopicActions to fetch.
     */
    where?: ModerationTopicActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationTopicActions to fetch.
     */
    orderBy?: ModerationTopicActionOrderByWithRelationInput | ModerationTopicActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationTopicActions.
     */
    cursor?: ModerationTopicActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationTopicActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationTopicActions.
     */
    skip?: number
    distinct?: ModerationTopicActionScalarFieldEnum | ModerationTopicActionScalarFieldEnum[]
  }


  /**
   * ModerationTopicAction create
   */
  export type ModerationTopicActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * The data needed to create a ModerationTopicAction.
     */
    data: XOR<ModerationTopicActionCreateInput, ModerationTopicActionUncheckedCreateInput>
  }


  /**
   * ModerationTopicAction createMany
   */
  export type ModerationTopicActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationTopicActions.
     */
    data: ModerationTopicActionCreateManyInput | ModerationTopicActionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ModerationTopicAction update
   */
  export type ModerationTopicActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * The data needed to update a ModerationTopicAction.
     */
    data: XOR<ModerationTopicActionUpdateInput, ModerationTopicActionUncheckedUpdateInput>
    /**
     * Choose, which ModerationTopicAction to update.
     */
    where: ModerationTopicActionWhereUniqueInput
  }


  /**
   * ModerationTopicAction updateMany
   */
  export type ModerationTopicActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationTopicActions.
     */
    data: XOR<ModerationTopicActionUpdateManyMutationInput, ModerationTopicActionUncheckedUpdateManyInput>
    /**
     * Filter which ModerationTopicActions to update
     */
    where?: ModerationTopicActionWhereInput
  }


  /**
   * ModerationTopicAction upsert
   */
  export type ModerationTopicActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * The filter to search for the ModerationTopicAction to update in case it exists.
     */
    where: ModerationTopicActionWhereUniqueInput
    /**
     * In case the ModerationTopicAction found by the `where` argument doesn't exist, create a new ModerationTopicAction with this data.
     */
    create: XOR<ModerationTopicActionCreateInput, ModerationTopicActionUncheckedCreateInput>
    /**
     * In case the ModerationTopicAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationTopicActionUpdateInput, ModerationTopicActionUncheckedUpdateInput>
  }


  /**
   * ModerationTopicAction delete
   */
  export type ModerationTopicActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
    /**
     * Filter which ModerationTopicAction to delete.
     */
    where: ModerationTopicActionWhereUniqueInput
  }


  /**
   * ModerationTopicAction deleteMany
   */
  export type ModerationTopicActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationTopicActions to delete
     */
    where?: ModerationTopicActionWhereInput
  }


  /**
   * ModerationTopicAction without action
   */
  export type ModerationTopicActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationTopicAction
     */
    select?: ModerationTopicActionSelect<ExtArgs> | null
  }



  /**
   * Model NavigatorCategory
   */

  export type AggregateNavigatorCategory = {
    _count: NavigatorCategoryCountAggregateOutputType | null
    _avg: NavigatorCategoryAvgAggregateOutputType | null
    _sum: NavigatorCategorySumAggregateOutputType | null
    _min: NavigatorCategoryMinAggregateOutputType | null
    _max: NavigatorCategoryMaxAggregateOutputType | null
  }

  export type NavigatorCategoryAvgAggregateOutputType = {
    id: number | null
    requiredRank: number | null
    orderId: number | null
  }

  export type NavigatorCategorySumAggregateOutputType = {
    id: number | null
    requiredRank: number | null
    orderId: number | null
  }

  export type NavigatorCategoryMinAggregateOutputType = {
    id: number | null
    category: $Enums.NavigatorCategoryCategory | null
    categoryIdentifier: string | null
    publicName: string | null
    viewMode: $Enums.NavigatorCategoryViewMode | null
    requiredRank: number | null
    categoryType: string | null
    searchAllowance: $Enums.NavigatorCategorySearchAllowance | null
    minimized: boolean | null
    enabled: boolean | null
    orderId: number | null
  }

  export type NavigatorCategoryMaxAggregateOutputType = {
    id: number | null
    category: $Enums.NavigatorCategoryCategory | null
    categoryIdentifier: string | null
    publicName: string | null
    viewMode: $Enums.NavigatorCategoryViewMode | null
    requiredRank: number | null
    categoryType: string | null
    searchAllowance: $Enums.NavigatorCategorySearchAllowance | null
    minimized: boolean | null
    enabled: boolean | null
    orderId: number | null
  }

  export type NavigatorCategoryCountAggregateOutputType = {
    id: number
    category: number
    categoryIdentifier: number
    publicName: number
    viewMode: number
    requiredRank: number
    categoryType: number
    searchAllowance: number
    minimized: number
    enabled: number
    orderId: number
    _all: number
  }


  export type NavigatorCategoryAvgAggregateInputType = {
    id?: true
    requiredRank?: true
    orderId?: true
  }

  export type NavigatorCategorySumAggregateInputType = {
    id?: true
    requiredRank?: true
    orderId?: true
  }

  export type NavigatorCategoryMinAggregateInputType = {
    id?: true
    category?: true
    categoryIdentifier?: true
    publicName?: true
    viewMode?: true
    requiredRank?: true
    categoryType?: true
    searchAllowance?: true
    minimized?: true
    enabled?: true
    orderId?: true
  }

  export type NavigatorCategoryMaxAggregateInputType = {
    id?: true
    category?: true
    categoryIdentifier?: true
    publicName?: true
    viewMode?: true
    requiredRank?: true
    categoryType?: true
    searchAllowance?: true
    minimized?: true
    enabled?: true
    orderId?: true
  }

  export type NavigatorCategoryCountAggregateInputType = {
    id?: true
    category?: true
    categoryIdentifier?: true
    publicName?: true
    viewMode?: true
    requiredRank?: true
    categoryType?: true
    searchAllowance?: true
    minimized?: true
    enabled?: true
    orderId?: true
    _all?: true
  }

  export type NavigatorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigatorCategory to aggregate.
     */
    where?: NavigatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorCategories to fetch.
     */
    orderBy?: NavigatorCategoryOrderByWithRelationInput | NavigatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavigatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavigatorCategories
    **/
    _count?: true | NavigatorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NavigatorCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NavigatorCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavigatorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavigatorCategoryMaxAggregateInputType
  }

  export type GetNavigatorCategoryAggregateType<T extends NavigatorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateNavigatorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavigatorCategory[P]>
      : GetScalarType<T[P], AggregateNavigatorCategory[P]>
  }




  export type NavigatorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigatorCategoryWhereInput
    orderBy?: NavigatorCategoryOrderByWithAggregationInput | NavigatorCategoryOrderByWithAggregationInput[]
    by: NavigatorCategoryScalarFieldEnum[] | NavigatorCategoryScalarFieldEnum
    having?: NavigatorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavigatorCategoryCountAggregateInputType | true
    _avg?: NavigatorCategoryAvgAggregateInputType
    _sum?: NavigatorCategorySumAggregateInputType
    _min?: NavigatorCategoryMinAggregateInputType
    _max?: NavigatorCategoryMaxAggregateInputType
  }

  export type NavigatorCategoryGroupByOutputType = {
    id: number
    category: $Enums.NavigatorCategoryCategory
    categoryIdentifier: string
    publicName: string
    viewMode: $Enums.NavigatorCategoryViewMode
    requiredRank: number
    categoryType: string
    searchAllowance: $Enums.NavigatorCategorySearchAllowance
    minimized: boolean
    enabled: boolean
    orderId: number
    _count: NavigatorCategoryCountAggregateOutputType | null
    _avg: NavigatorCategoryAvgAggregateOutputType | null
    _sum: NavigatorCategorySumAggregateOutputType | null
    _min: NavigatorCategoryMinAggregateOutputType | null
    _max: NavigatorCategoryMaxAggregateOutputType | null
  }

  type GetNavigatorCategoryGroupByPayload<T extends NavigatorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavigatorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavigatorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavigatorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], NavigatorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type NavigatorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    categoryIdentifier?: boolean
    publicName?: boolean
    viewMode?: boolean
    requiredRank?: boolean
    categoryType?: boolean
    searchAllowance?: boolean
    minimized?: boolean
    enabled?: boolean
    orderId?: boolean
  }, ExtArgs["result"]["navigatorCategory"]>

  export type NavigatorCategorySelectScalar = {
    id?: boolean
    category?: boolean
    categoryIdentifier?: boolean
    publicName?: boolean
    viewMode?: boolean
    requiredRank?: boolean
    categoryType?: boolean
    searchAllowance?: boolean
    minimized?: boolean
    enabled?: boolean
    orderId?: boolean
  }


  export type $NavigatorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NavigatorCategory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: $Enums.NavigatorCategoryCategory
      categoryIdentifier: string
      publicName: string
      viewMode: $Enums.NavigatorCategoryViewMode
      requiredRank: number
      categoryType: string
      searchAllowance: $Enums.NavigatorCategorySearchAllowance
      minimized: boolean
      enabled: boolean
      orderId: number
    }, ExtArgs["result"]["navigatorCategory"]>
    composites: {}
  }


  type NavigatorCategoryGetPayload<S extends boolean | null | undefined | NavigatorCategoryDefaultArgs> = $Result.GetResult<Prisma.$NavigatorCategoryPayload, S>

  type NavigatorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NavigatorCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NavigatorCategoryCountAggregateInputType | true
    }

  export interface NavigatorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavigatorCategory'], meta: { name: 'NavigatorCategory' } }
    /**
     * Find zero or one NavigatorCategory that matches the filter.
     * @param {NavigatorCategoryFindUniqueArgs} args - Arguments to find a NavigatorCategory
     * @example
     * // Get one NavigatorCategory
     * const navigatorCategory = await prisma.navigatorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NavigatorCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NavigatorCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NavigatorCategoryFindUniqueOrThrowArgs} args - Arguments to find a NavigatorCategory
     * @example
     * // Get one NavigatorCategory
     * const navigatorCategory = await prisma.navigatorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NavigatorCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NavigatorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryFindFirstArgs} args - Arguments to find a NavigatorCategory
     * @example
     * // Get one NavigatorCategory
     * const navigatorCategory = await prisma.navigatorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NavigatorCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NavigatorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryFindFirstOrThrowArgs} args - Arguments to find a NavigatorCategory
     * @example
     * // Get one NavigatorCategory
     * const navigatorCategory = await prisma.navigatorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NavigatorCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NavigatorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavigatorCategories
     * const navigatorCategories = await prisma.navigatorCategory.findMany()
     * 
     * // Get first 10 NavigatorCategories
     * const navigatorCategories = await prisma.navigatorCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const navigatorCategoryWithIdOnly = await prisma.navigatorCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NavigatorCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NavigatorCategory.
     * @param {NavigatorCategoryCreateArgs} args - Arguments to create a NavigatorCategory.
     * @example
     * // Create one NavigatorCategory
     * const NavigatorCategory = await prisma.navigatorCategory.create({
     *   data: {
     *     // ... data to create a NavigatorCategory
     *   }
     * })
     * 
    **/
    create<T extends NavigatorCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorCategoryCreateArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NavigatorCategories.
     *     @param {NavigatorCategoryCreateManyArgs} args - Arguments to create many NavigatorCategories.
     *     @example
     *     // Create many NavigatorCategories
     *     const navigatorCategory = await prisma.navigatorCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NavigatorCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavigatorCategory.
     * @param {NavigatorCategoryDeleteArgs} args - Arguments to delete one NavigatorCategory.
     * @example
     * // Delete one NavigatorCategory
     * const NavigatorCategory = await prisma.navigatorCategory.delete({
     *   where: {
     *     // ... filter to delete one NavigatorCategory
     *   }
     * })
     * 
    **/
    delete<T extends NavigatorCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorCategoryDeleteArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NavigatorCategory.
     * @param {NavigatorCategoryUpdateArgs} args - Arguments to update one NavigatorCategory.
     * @example
     * // Update one NavigatorCategory
     * const navigatorCategory = await prisma.navigatorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NavigatorCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorCategoryUpdateArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NavigatorCategories.
     * @param {NavigatorCategoryDeleteManyArgs} args - Arguments to filter NavigatorCategories to delete.
     * @example
     * // Delete a few NavigatorCategories
     * const { count } = await prisma.navigatorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NavigatorCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavigatorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavigatorCategories
     * const navigatorCategory = await prisma.navigatorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NavigatorCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavigatorCategory.
     * @param {NavigatorCategoryUpsertArgs} args - Arguments to update or create a NavigatorCategory.
     * @example
     * // Update or create a NavigatorCategory
     * const navigatorCategory = await prisma.navigatorCategory.upsert({
     *   create: {
     *     // ... data to create a NavigatorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavigatorCategory we want to update
     *   }
     * })
    **/
    upsert<T extends NavigatorCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorCategoryUpsertArgs<ExtArgs>>
    ): Prisma__NavigatorCategoryClient<$Result.GetResult<Prisma.$NavigatorCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NavigatorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryCountArgs} args - Arguments to filter NavigatorCategories to count.
     * @example
     * // Count the number of NavigatorCategories
     * const count = await prisma.navigatorCategory.count({
     *   where: {
     *     // ... the filter for the NavigatorCategories we want to count
     *   }
     * })
    **/
    count<T extends NavigatorCategoryCountArgs>(
      args?: Subset<T, NavigatorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavigatorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavigatorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavigatorCategoryAggregateArgs>(args: Subset<T, NavigatorCategoryAggregateArgs>): Prisma.PrismaPromise<GetNavigatorCategoryAggregateType<T>>

    /**
     * Group by NavigatorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavigatorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavigatorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: NavigatorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavigatorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavigatorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavigatorCategory model
   */
  readonly fields: NavigatorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavigatorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavigatorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NavigatorCategory model
   */ 
  interface NavigatorCategoryFieldRefs {
    readonly id: FieldRef<"NavigatorCategory", 'Int'>
    readonly category: FieldRef<"NavigatorCategory", 'NavigatorCategoryCategory'>
    readonly categoryIdentifier: FieldRef<"NavigatorCategory", 'String'>
    readonly publicName: FieldRef<"NavigatorCategory", 'String'>
    readonly viewMode: FieldRef<"NavigatorCategory", 'NavigatorCategoryViewMode'>
    readonly requiredRank: FieldRef<"NavigatorCategory", 'Int'>
    readonly categoryType: FieldRef<"NavigatorCategory", 'String'>
    readonly searchAllowance: FieldRef<"NavigatorCategory", 'NavigatorCategorySearchAllowance'>
    readonly minimized: FieldRef<"NavigatorCategory", 'Boolean'>
    readonly enabled: FieldRef<"NavigatorCategory", 'Boolean'>
    readonly orderId: FieldRef<"NavigatorCategory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * NavigatorCategory findUnique
   */
  export type NavigatorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * Filter, which NavigatorCategory to fetch.
     */
    where: NavigatorCategoryWhereUniqueInput
  }


  /**
   * NavigatorCategory findUniqueOrThrow
   */
  export type NavigatorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * Filter, which NavigatorCategory to fetch.
     */
    where: NavigatorCategoryWhereUniqueInput
  }


  /**
   * NavigatorCategory findFirst
   */
  export type NavigatorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * Filter, which NavigatorCategory to fetch.
     */
    where?: NavigatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorCategories to fetch.
     */
    orderBy?: NavigatorCategoryOrderByWithRelationInput | NavigatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigatorCategories.
     */
    cursor?: NavigatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigatorCategories.
     */
    distinct?: NavigatorCategoryScalarFieldEnum | NavigatorCategoryScalarFieldEnum[]
  }


  /**
   * NavigatorCategory findFirstOrThrow
   */
  export type NavigatorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * Filter, which NavigatorCategory to fetch.
     */
    where?: NavigatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorCategories to fetch.
     */
    orderBy?: NavigatorCategoryOrderByWithRelationInput | NavigatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigatorCategories.
     */
    cursor?: NavigatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigatorCategories.
     */
    distinct?: NavigatorCategoryScalarFieldEnum | NavigatorCategoryScalarFieldEnum[]
  }


  /**
   * NavigatorCategory findMany
   */
  export type NavigatorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * Filter, which NavigatorCategories to fetch.
     */
    where?: NavigatorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorCategories to fetch.
     */
    orderBy?: NavigatorCategoryOrderByWithRelationInput | NavigatorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavigatorCategories.
     */
    cursor?: NavigatorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorCategories.
     */
    skip?: number
    distinct?: NavigatorCategoryScalarFieldEnum | NavigatorCategoryScalarFieldEnum[]
  }


  /**
   * NavigatorCategory create
   */
  export type NavigatorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * The data needed to create a NavigatorCategory.
     */
    data: XOR<NavigatorCategoryCreateInput, NavigatorCategoryUncheckedCreateInput>
  }


  /**
   * NavigatorCategory createMany
   */
  export type NavigatorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavigatorCategories.
     */
    data: NavigatorCategoryCreateManyInput | NavigatorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NavigatorCategory update
   */
  export type NavigatorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * The data needed to update a NavigatorCategory.
     */
    data: XOR<NavigatorCategoryUpdateInput, NavigatorCategoryUncheckedUpdateInput>
    /**
     * Choose, which NavigatorCategory to update.
     */
    where: NavigatorCategoryWhereUniqueInput
  }


  /**
   * NavigatorCategory updateMany
   */
  export type NavigatorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavigatorCategories.
     */
    data: XOR<NavigatorCategoryUpdateManyMutationInput, NavigatorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which NavigatorCategories to update
     */
    where?: NavigatorCategoryWhereInput
  }


  /**
   * NavigatorCategory upsert
   */
  export type NavigatorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * The filter to search for the NavigatorCategory to update in case it exists.
     */
    where: NavigatorCategoryWhereUniqueInput
    /**
     * In case the NavigatorCategory found by the `where` argument doesn't exist, create a new NavigatorCategory with this data.
     */
    create: XOR<NavigatorCategoryCreateInput, NavigatorCategoryUncheckedCreateInput>
    /**
     * In case the NavigatorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavigatorCategoryUpdateInput, NavigatorCategoryUncheckedUpdateInput>
  }


  /**
   * NavigatorCategory delete
   */
  export type NavigatorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
    /**
     * Filter which NavigatorCategory to delete.
     */
    where: NavigatorCategoryWhereUniqueInput
  }


  /**
   * NavigatorCategory deleteMany
   */
  export type NavigatorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigatorCategories to delete
     */
    where?: NavigatorCategoryWhereInput
  }


  /**
   * NavigatorCategory without action
   */
  export type NavigatorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorCategory
     */
    select?: NavigatorCategorySelect<ExtArgs> | null
  }



  /**
   * Model NavigatorPublic
   */

  export type AggregateNavigatorPublic = {
    _count: NavigatorPublicCountAggregateOutputType | null
    _avg: NavigatorPublicAvgAggregateOutputType | null
    _sum: NavigatorPublicSumAggregateOutputType | null
    _min: NavigatorPublicMinAggregateOutputType | null
    _max: NavigatorPublicMaxAggregateOutputType | null
  }

  export type NavigatorPublicAvgAggregateOutputType = {
    roomId: number | null
    orderNum: number | null
  }

  export type NavigatorPublicSumAggregateOutputType = {
    roomId: number | null
    orderNum: number | null
  }

  export type NavigatorPublicMinAggregateOutputType = {
    roomId: number | null
    imageUrl: string | null
    orderNum: number | null
    enabled: boolean | null
    langue: $Enums.NavigatorPublicLangue | null
    categoryType: string | null
  }

  export type NavigatorPublicMaxAggregateOutputType = {
    roomId: number | null
    imageUrl: string | null
    orderNum: number | null
    enabled: boolean | null
    langue: $Enums.NavigatorPublicLangue | null
    categoryType: string | null
  }

  export type NavigatorPublicCountAggregateOutputType = {
    roomId: number
    imageUrl: number
    orderNum: number
    enabled: number
    langue: number
    categoryType: number
    _all: number
  }


  export type NavigatorPublicAvgAggregateInputType = {
    roomId?: true
    orderNum?: true
  }

  export type NavigatorPublicSumAggregateInputType = {
    roomId?: true
    orderNum?: true
  }

  export type NavigatorPublicMinAggregateInputType = {
    roomId?: true
    imageUrl?: true
    orderNum?: true
    enabled?: true
    langue?: true
    categoryType?: true
  }

  export type NavigatorPublicMaxAggregateInputType = {
    roomId?: true
    imageUrl?: true
    orderNum?: true
    enabled?: true
    langue?: true
    categoryType?: true
  }

  export type NavigatorPublicCountAggregateInputType = {
    roomId?: true
    imageUrl?: true
    orderNum?: true
    enabled?: true
    langue?: true
    categoryType?: true
    _all?: true
  }

  export type NavigatorPublicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigatorPublic to aggregate.
     */
    where?: NavigatorPublicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorPublics to fetch.
     */
    orderBy?: NavigatorPublicOrderByWithRelationInput | NavigatorPublicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavigatorPublicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorPublics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorPublics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavigatorPublics
    **/
    _count?: true | NavigatorPublicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NavigatorPublicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NavigatorPublicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavigatorPublicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavigatorPublicMaxAggregateInputType
  }

  export type GetNavigatorPublicAggregateType<T extends NavigatorPublicAggregateArgs> = {
        [P in keyof T & keyof AggregateNavigatorPublic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavigatorPublic[P]>
      : GetScalarType<T[P], AggregateNavigatorPublic[P]>
  }




  export type NavigatorPublicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigatorPublicWhereInput
    orderBy?: NavigatorPublicOrderByWithAggregationInput | NavigatorPublicOrderByWithAggregationInput[]
    by: NavigatorPublicScalarFieldEnum[] | NavigatorPublicScalarFieldEnum
    having?: NavigatorPublicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavigatorPublicCountAggregateInputType | true
    _avg?: NavigatorPublicAvgAggregateInputType
    _sum?: NavigatorPublicSumAggregateInputType
    _min?: NavigatorPublicMinAggregateInputType
    _max?: NavigatorPublicMaxAggregateInputType
  }

  export type NavigatorPublicGroupByOutputType = {
    roomId: number
    imageUrl: string | null
    orderNum: number
    enabled: boolean
    langue: $Enums.NavigatorPublicLangue
    categoryType: string
    _count: NavigatorPublicCountAggregateOutputType | null
    _avg: NavigatorPublicAvgAggregateOutputType | null
    _sum: NavigatorPublicSumAggregateOutputType | null
    _min: NavigatorPublicMinAggregateOutputType | null
    _max: NavigatorPublicMaxAggregateOutputType | null
  }

  type GetNavigatorPublicGroupByPayload<T extends NavigatorPublicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavigatorPublicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavigatorPublicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavigatorPublicGroupByOutputType[P]>
            : GetScalarType<T[P], NavigatorPublicGroupByOutputType[P]>
        }
      >
    >


  export type NavigatorPublicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    imageUrl?: boolean
    orderNum?: boolean
    enabled?: boolean
    langue?: boolean
    categoryType?: boolean
  }, ExtArgs["result"]["navigatorPublic"]>

  export type NavigatorPublicSelectScalar = {
    roomId?: boolean
    imageUrl?: boolean
    orderNum?: boolean
    enabled?: boolean
    langue?: boolean
    categoryType?: boolean
  }


  export type $NavigatorPublicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NavigatorPublic"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      roomId: number
      imageUrl: string | null
      orderNum: number
      enabled: boolean
      langue: $Enums.NavigatorPublicLangue
      categoryType: string
    }, ExtArgs["result"]["navigatorPublic"]>
    composites: {}
  }


  type NavigatorPublicGetPayload<S extends boolean | null | undefined | NavigatorPublicDefaultArgs> = $Result.GetResult<Prisma.$NavigatorPublicPayload, S>

  type NavigatorPublicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NavigatorPublicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NavigatorPublicCountAggregateInputType | true
    }

  export interface NavigatorPublicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavigatorPublic'], meta: { name: 'NavigatorPublic' } }
    /**
     * Find zero or one NavigatorPublic that matches the filter.
     * @param {NavigatorPublicFindUniqueArgs} args - Arguments to find a NavigatorPublic
     * @example
     * // Get one NavigatorPublic
     * const navigatorPublic = await prisma.navigatorPublic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NavigatorPublicFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorPublicFindUniqueArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NavigatorPublic that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NavigatorPublicFindUniqueOrThrowArgs} args - Arguments to find a NavigatorPublic
     * @example
     * // Get one NavigatorPublic
     * const navigatorPublic = await prisma.navigatorPublic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NavigatorPublicFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorPublicFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NavigatorPublic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicFindFirstArgs} args - Arguments to find a NavigatorPublic
     * @example
     * // Get one NavigatorPublic
     * const navigatorPublic = await prisma.navigatorPublic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NavigatorPublicFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorPublicFindFirstArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NavigatorPublic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicFindFirstOrThrowArgs} args - Arguments to find a NavigatorPublic
     * @example
     * // Get one NavigatorPublic
     * const navigatorPublic = await prisma.navigatorPublic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NavigatorPublicFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorPublicFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NavigatorPublics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavigatorPublics
     * const navigatorPublics = await prisma.navigatorPublic.findMany()
     * 
     * // Get first 10 NavigatorPublics
     * const navigatorPublics = await prisma.navigatorPublic.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const navigatorPublicWithRoomIdOnly = await prisma.navigatorPublic.findMany({ select: { roomId: true } })
     * 
    **/
    findMany<T extends NavigatorPublicFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorPublicFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NavigatorPublic.
     * @param {NavigatorPublicCreateArgs} args - Arguments to create a NavigatorPublic.
     * @example
     * // Create one NavigatorPublic
     * const NavigatorPublic = await prisma.navigatorPublic.create({
     *   data: {
     *     // ... data to create a NavigatorPublic
     *   }
     * })
     * 
    **/
    create<T extends NavigatorPublicCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorPublicCreateArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NavigatorPublics.
     *     @param {NavigatorPublicCreateManyArgs} args - Arguments to create many NavigatorPublics.
     *     @example
     *     // Create many NavigatorPublics
     *     const navigatorPublic = await prisma.navigatorPublic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NavigatorPublicCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorPublicCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavigatorPublic.
     * @param {NavigatorPublicDeleteArgs} args - Arguments to delete one NavigatorPublic.
     * @example
     * // Delete one NavigatorPublic
     * const NavigatorPublic = await prisma.navigatorPublic.delete({
     *   where: {
     *     // ... filter to delete one NavigatorPublic
     *   }
     * })
     * 
    **/
    delete<T extends NavigatorPublicDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorPublicDeleteArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NavigatorPublic.
     * @param {NavigatorPublicUpdateArgs} args - Arguments to update one NavigatorPublic.
     * @example
     * // Update one NavigatorPublic
     * const navigatorPublic = await prisma.navigatorPublic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NavigatorPublicUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorPublicUpdateArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NavigatorPublics.
     * @param {NavigatorPublicDeleteManyArgs} args - Arguments to filter NavigatorPublics to delete.
     * @example
     * // Delete a few NavigatorPublics
     * const { count } = await prisma.navigatorPublic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NavigatorPublicDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NavigatorPublicDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavigatorPublics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavigatorPublics
     * const navigatorPublic = await prisma.navigatorPublic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NavigatorPublicUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorPublicUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavigatorPublic.
     * @param {NavigatorPublicUpsertArgs} args - Arguments to update or create a NavigatorPublic.
     * @example
     * // Update or create a NavigatorPublic
     * const navigatorPublic = await prisma.navigatorPublic.upsert({
     *   create: {
     *     // ... data to create a NavigatorPublic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavigatorPublic we want to update
     *   }
     * })
    **/
    upsert<T extends NavigatorPublicUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NavigatorPublicUpsertArgs<ExtArgs>>
    ): Prisma__NavigatorPublicClient<$Result.GetResult<Prisma.$NavigatorPublicPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NavigatorPublics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicCountArgs} args - Arguments to filter NavigatorPublics to count.
     * @example
     * // Count the number of NavigatorPublics
     * const count = await prisma.navigatorPublic.count({
     *   where: {
     *     // ... the filter for the NavigatorPublics we want to count
     *   }
     * })
    **/
    count<T extends NavigatorPublicCountArgs>(
      args?: Subset<T, NavigatorPublicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavigatorPublicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavigatorPublic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavigatorPublicAggregateArgs>(args: Subset<T, NavigatorPublicAggregateArgs>): Prisma.PrismaPromise<GetNavigatorPublicAggregateType<T>>

    /**
     * Group by NavigatorPublic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigatorPublicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavigatorPublicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavigatorPublicGroupByArgs['orderBy'] }
        : { orderBy?: NavigatorPublicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavigatorPublicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavigatorPublicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavigatorPublic model
   */
  readonly fields: NavigatorPublicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavigatorPublic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavigatorPublicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NavigatorPublic model
   */ 
  interface NavigatorPublicFieldRefs {
    readonly roomId: FieldRef<"NavigatorPublic", 'Int'>
    readonly imageUrl: FieldRef<"NavigatorPublic", 'String'>
    readonly orderNum: FieldRef<"NavigatorPublic", 'Int'>
    readonly enabled: FieldRef<"NavigatorPublic", 'Boolean'>
    readonly langue: FieldRef<"NavigatorPublic", 'NavigatorPublicLangue'>
    readonly categoryType: FieldRef<"NavigatorPublic", 'String'>
  }
    

  // Custom InputTypes

  /**
   * NavigatorPublic findUnique
   */
  export type NavigatorPublicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * Filter, which NavigatorPublic to fetch.
     */
    where: NavigatorPublicWhereUniqueInput
  }


  /**
   * NavigatorPublic findUniqueOrThrow
   */
  export type NavigatorPublicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * Filter, which NavigatorPublic to fetch.
     */
    where: NavigatorPublicWhereUniqueInput
  }


  /**
   * NavigatorPublic findFirst
   */
  export type NavigatorPublicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * Filter, which NavigatorPublic to fetch.
     */
    where?: NavigatorPublicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorPublics to fetch.
     */
    orderBy?: NavigatorPublicOrderByWithRelationInput | NavigatorPublicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigatorPublics.
     */
    cursor?: NavigatorPublicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorPublics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorPublics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigatorPublics.
     */
    distinct?: NavigatorPublicScalarFieldEnum | NavigatorPublicScalarFieldEnum[]
  }


  /**
   * NavigatorPublic findFirstOrThrow
   */
  export type NavigatorPublicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * Filter, which NavigatorPublic to fetch.
     */
    where?: NavigatorPublicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorPublics to fetch.
     */
    orderBy?: NavigatorPublicOrderByWithRelationInput | NavigatorPublicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigatorPublics.
     */
    cursor?: NavigatorPublicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorPublics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorPublics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigatorPublics.
     */
    distinct?: NavigatorPublicScalarFieldEnum | NavigatorPublicScalarFieldEnum[]
  }


  /**
   * NavigatorPublic findMany
   */
  export type NavigatorPublicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * Filter, which NavigatorPublics to fetch.
     */
    where?: NavigatorPublicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigatorPublics to fetch.
     */
    orderBy?: NavigatorPublicOrderByWithRelationInput | NavigatorPublicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavigatorPublics.
     */
    cursor?: NavigatorPublicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigatorPublics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigatorPublics.
     */
    skip?: number
    distinct?: NavigatorPublicScalarFieldEnum | NavigatorPublicScalarFieldEnum[]
  }


  /**
   * NavigatorPublic create
   */
  export type NavigatorPublicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * The data needed to create a NavigatorPublic.
     */
    data: XOR<NavigatorPublicCreateInput, NavigatorPublicUncheckedCreateInput>
  }


  /**
   * NavigatorPublic createMany
   */
  export type NavigatorPublicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavigatorPublics.
     */
    data: NavigatorPublicCreateManyInput | NavigatorPublicCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NavigatorPublic update
   */
  export type NavigatorPublicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * The data needed to update a NavigatorPublic.
     */
    data: XOR<NavigatorPublicUpdateInput, NavigatorPublicUncheckedUpdateInput>
    /**
     * Choose, which NavigatorPublic to update.
     */
    where: NavigatorPublicWhereUniqueInput
  }


  /**
   * NavigatorPublic updateMany
   */
  export type NavigatorPublicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavigatorPublics.
     */
    data: XOR<NavigatorPublicUpdateManyMutationInput, NavigatorPublicUncheckedUpdateManyInput>
    /**
     * Filter which NavigatorPublics to update
     */
    where?: NavigatorPublicWhereInput
  }


  /**
   * NavigatorPublic upsert
   */
  export type NavigatorPublicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * The filter to search for the NavigatorPublic to update in case it exists.
     */
    where: NavigatorPublicWhereUniqueInput
    /**
     * In case the NavigatorPublic found by the `where` argument doesn't exist, create a new NavigatorPublic with this data.
     */
    create: XOR<NavigatorPublicCreateInput, NavigatorPublicUncheckedCreateInput>
    /**
     * In case the NavigatorPublic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavigatorPublicUpdateInput, NavigatorPublicUncheckedUpdateInput>
  }


  /**
   * NavigatorPublic delete
   */
  export type NavigatorPublicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
    /**
     * Filter which NavigatorPublic to delete.
     */
    where: NavigatorPublicWhereUniqueInput
  }


  /**
   * NavigatorPublic deleteMany
   */
  export type NavigatorPublicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigatorPublics to delete
     */
    where?: NavigatorPublicWhereInput
  }


  /**
   * NavigatorPublic without action
   */
  export type NavigatorPublicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigatorPublic
     */
    select?: NavigatorPublicSelect<ExtArgs> | null
  }



  /**
   * Model Roleplay
   */

  export type AggregateRoleplay = {
    _count: RoleplayCountAggregateOutputType | null
    _avg: RoleplayAvgAggregateOutputType | null
    _sum: RoleplaySumAggregateOutputType | null
    _min: RoleplayMinAggregateOutputType | null
    _max: RoleplayMaxAggregateOutputType | null
  }

  export type RoleplayAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    hopitalId: number | null
    prisonId: number | null
  }

  export type RoleplaySumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    hopitalId: number | null
    prisonId: number | null
  }

  export type RoleplayMinAggregateOutputType = {
    id: number | null
    ownerId: number | null
    hopitalId: number | null
    prisonId: number | null
  }

  export type RoleplayMaxAggregateOutputType = {
    id: number | null
    ownerId: number | null
    hopitalId: number | null
    prisonId: number | null
  }

  export type RoleplayCountAggregateOutputType = {
    id: number
    ownerId: number
    hopitalId: number
    prisonId: number
    _all: number
  }


  export type RoleplayAvgAggregateInputType = {
    id?: true
    ownerId?: true
    hopitalId?: true
    prisonId?: true
  }

  export type RoleplaySumAggregateInputType = {
    id?: true
    ownerId?: true
    hopitalId?: true
    prisonId?: true
  }

  export type RoleplayMinAggregateInputType = {
    id?: true
    ownerId?: true
    hopitalId?: true
    prisonId?: true
  }

  export type RoleplayMaxAggregateInputType = {
    id?: true
    ownerId?: true
    hopitalId?: true
    prisonId?: true
  }

  export type RoleplayCountAggregateInputType = {
    id?: true
    ownerId?: true
    hopitalId?: true
    prisonId?: true
    _all?: true
  }

  export type RoleplayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roleplay to aggregate.
     */
    where?: RoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roleplays to fetch.
     */
    orderBy?: RoleplayOrderByWithRelationInput | RoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roleplays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roleplays
    **/
    _count?: true | RoleplayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleplayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleplaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleplayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleplayMaxAggregateInputType
  }

  export type GetRoleplayAggregateType<T extends RoleplayAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleplay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleplay[P]>
      : GetScalarType<T[P], AggregateRoleplay[P]>
  }




  export type RoleplayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleplayWhereInput
    orderBy?: RoleplayOrderByWithAggregationInput | RoleplayOrderByWithAggregationInput[]
    by: RoleplayScalarFieldEnum[] | RoleplayScalarFieldEnum
    having?: RoleplayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleplayCountAggregateInputType | true
    _avg?: RoleplayAvgAggregateInputType
    _sum?: RoleplaySumAggregateInputType
    _min?: RoleplayMinAggregateInputType
    _max?: RoleplayMaxAggregateInputType
  }

  export type RoleplayGroupByOutputType = {
    id: number
    ownerId: number
    hopitalId: number
    prisonId: number
    _count: RoleplayCountAggregateOutputType | null
    _avg: RoleplayAvgAggregateOutputType | null
    _sum: RoleplaySumAggregateOutputType | null
    _min: RoleplayMinAggregateOutputType | null
    _max: RoleplayMaxAggregateOutputType | null
  }

  type GetRoleplayGroupByPayload<T extends RoleplayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleplayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleplayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleplayGroupByOutputType[P]>
            : GetScalarType<T[P], RoleplayGroupByOutputType[P]>
        }
      >
    >


  export type RoleplaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    hopitalId?: boolean
    prisonId?: boolean
  }, ExtArgs["result"]["roleplay"]>

  export type RoleplaySelectScalar = {
    id?: boolean
    ownerId?: boolean
    hopitalId?: boolean
    prisonId?: boolean
  }


  export type $RoleplayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roleplay"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ownerId: number
      hopitalId: number
      prisonId: number
    }, ExtArgs["result"]["roleplay"]>
    composites: {}
  }


  type RoleplayGetPayload<S extends boolean | null | undefined | RoleplayDefaultArgs> = $Result.GetResult<Prisma.$RoleplayPayload, S>

  type RoleplayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleplayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleplayCountAggregateInputType | true
    }

  export interface RoleplayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roleplay'], meta: { name: 'Roleplay' } }
    /**
     * Find zero or one Roleplay that matches the filter.
     * @param {RoleplayFindUniqueArgs} args - Arguments to find a Roleplay
     * @example
     * // Get one Roleplay
     * const roleplay = await prisma.roleplay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleplayFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Roleplay that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleplayFindUniqueOrThrowArgs} args - Arguments to find a Roleplay
     * @example
     * // Get one Roleplay
     * const roleplay = await prisma.roleplay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleplayFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Roleplay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayFindFirstArgs} args - Arguments to find a Roleplay
     * @example
     * // Get one Roleplay
     * const roleplay = await prisma.roleplay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleplayFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayFindFirstArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Roleplay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayFindFirstOrThrowArgs} args - Arguments to find a Roleplay
     * @example
     * // Get one Roleplay
     * const roleplay = await prisma.roleplay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleplayFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roleplays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roleplays
     * const roleplays = await prisma.roleplay.findMany()
     * 
     * // Get first 10 Roleplays
     * const roleplays = await prisma.roleplay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleplayWithIdOnly = await prisma.roleplay.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleplayFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Roleplay.
     * @param {RoleplayCreateArgs} args - Arguments to create a Roleplay.
     * @example
     * // Create one Roleplay
     * const Roleplay = await prisma.roleplay.create({
     *   data: {
     *     // ... data to create a Roleplay
     *   }
     * })
     * 
    **/
    create<T extends RoleplayCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayCreateArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roleplays.
     *     @param {RoleplayCreateManyArgs} args - Arguments to create many Roleplays.
     *     @example
     *     // Create many Roleplays
     *     const roleplay = await prisma.roleplay.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleplayCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roleplay.
     * @param {RoleplayDeleteArgs} args - Arguments to delete one Roleplay.
     * @example
     * // Delete one Roleplay
     * const Roleplay = await prisma.roleplay.delete({
     *   where: {
     *     // ... filter to delete one Roleplay
     *   }
     * })
     * 
    **/
    delete<T extends RoleplayDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayDeleteArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Roleplay.
     * @param {RoleplayUpdateArgs} args - Arguments to update one Roleplay.
     * @example
     * // Update one Roleplay
     * const roleplay = await prisma.roleplay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleplayUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayUpdateArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roleplays.
     * @param {RoleplayDeleteManyArgs} args - Arguments to filter Roleplays to delete.
     * @example
     * // Delete a few Roleplays
     * const { count } = await prisma.roleplay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleplayDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roleplays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roleplays
     * const roleplay = await prisma.roleplay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleplayUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roleplay.
     * @param {RoleplayUpsertArgs} args - Arguments to update or create a Roleplay.
     * @example
     * // Update or create a Roleplay
     * const roleplay = await prisma.roleplay.upsert({
     *   create: {
     *     // ... data to create a Roleplay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roleplay we want to update
     *   }
     * })
    **/
    upsert<T extends RoleplayUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayUpsertArgs<ExtArgs>>
    ): Prisma__RoleplayClient<$Result.GetResult<Prisma.$RoleplayPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roleplays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayCountArgs} args - Arguments to filter Roleplays to count.
     * @example
     * // Count the number of Roleplays
     * const count = await prisma.roleplay.count({
     *   where: {
     *     // ... the filter for the Roleplays we want to count
     *   }
     * })
    **/
    count<T extends RoleplayCountArgs>(
      args?: Subset<T, RoleplayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleplayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roleplay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleplayAggregateArgs>(args: Subset<T, RoleplayAggregateArgs>): Prisma.PrismaPromise<GetRoleplayAggregateType<T>>

    /**
     * Group by Roleplay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleplayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleplayGroupByArgs['orderBy'] }
        : { orderBy?: RoleplayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleplayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleplayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roleplay model
   */
  readonly fields: RoleplayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roleplay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleplayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Roleplay model
   */ 
  interface RoleplayFieldRefs {
    readonly id: FieldRef<"Roleplay", 'Int'>
    readonly ownerId: FieldRef<"Roleplay", 'Int'>
    readonly hopitalId: FieldRef<"Roleplay", 'Int'>
    readonly prisonId: FieldRef<"Roleplay", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Roleplay findUnique
   */
  export type RoleplayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * Filter, which Roleplay to fetch.
     */
    where: RoleplayWhereUniqueInput
  }


  /**
   * Roleplay findUniqueOrThrow
   */
  export type RoleplayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * Filter, which Roleplay to fetch.
     */
    where: RoleplayWhereUniqueInput
  }


  /**
   * Roleplay findFirst
   */
  export type RoleplayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * Filter, which Roleplay to fetch.
     */
    where?: RoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roleplays to fetch.
     */
    orderBy?: RoleplayOrderByWithRelationInput | RoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roleplays.
     */
    cursor?: RoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roleplays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roleplays.
     */
    distinct?: RoleplayScalarFieldEnum | RoleplayScalarFieldEnum[]
  }


  /**
   * Roleplay findFirstOrThrow
   */
  export type RoleplayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * Filter, which Roleplay to fetch.
     */
    where?: RoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roleplays to fetch.
     */
    orderBy?: RoleplayOrderByWithRelationInput | RoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roleplays.
     */
    cursor?: RoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roleplays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roleplays.
     */
    distinct?: RoleplayScalarFieldEnum | RoleplayScalarFieldEnum[]
  }


  /**
   * Roleplay findMany
   */
  export type RoleplayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * Filter, which Roleplays to fetch.
     */
    where?: RoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roleplays to fetch.
     */
    orderBy?: RoleplayOrderByWithRelationInput | RoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roleplays.
     */
    cursor?: RoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roleplays.
     */
    skip?: number
    distinct?: RoleplayScalarFieldEnum | RoleplayScalarFieldEnum[]
  }


  /**
   * Roleplay create
   */
  export type RoleplayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * The data needed to create a Roleplay.
     */
    data: XOR<RoleplayCreateInput, RoleplayUncheckedCreateInput>
  }


  /**
   * Roleplay createMany
   */
  export type RoleplayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roleplays.
     */
    data: RoleplayCreateManyInput | RoleplayCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Roleplay update
   */
  export type RoleplayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * The data needed to update a Roleplay.
     */
    data: XOR<RoleplayUpdateInput, RoleplayUncheckedUpdateInput>
    /**
     * Choose, which Roleplay to update.
     */
    where: RoleplayWhereUniqueInput
  }


  /**
   * Roleplay updateMany
   */
  export type RoleplayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roleplays.
     */
    data: XOR<RoleplayUpdateManyMutationInput, RoleplayUncheckedUpdateManyInput>
    /**
     * Filter which Roleplays to update
     */
    where?: RoleplayWhereInput
  }


  /**
   * Roleplay upsert
   */
  export type RoleplayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * The filter to search for the Roleplay to update in case it exists.
     */
    where: RoleplayWhereUniqueInput
    /**
     * In case the Roleplay found by the `where` argument doesn't exist, create a new Roleplay with this data.
     */
    create: XOR<RoleplayCreateInput, RoleplayUncheckedCreateInput>
    /**
     * In case the Roleplay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleplayUpdateInput, RoleplayUncheckedUpdateInput>
  }


  /**
   * Roleplay delete
   */
  export type RoleplayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
    /**
     * Filter which Roleplay to delete.
     */
    where: RoleplayWhereUniqueInput
  }


  /**
   * Roleplay deleteMany
   */
  export type RoleplayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roleplays to delete
     */
    where?: RoleplayWhereInput
  }


  /**
   * Roleplay without action
   */
  export type RoleplayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roleplay
     */
    select?: RoleplaySelect<ExtArgs> | null
  }



  /**
   * Model RoleplayEnemy
   */

  export type AggregateRoleplayEnemy = {
    _count: RoleplayEnemyCountAggregateOutputType | null
    _avg: RoleplayEnemyAvgAggregateOutputType | null
    _sum: RoleplayEnemySumAggregateOutputType | null
    _min: RoleplayEnemyMinAggregateOutputType | null
    _max: RoleplayEnemyMaxAggregateOutputType | null
  }

  export type RoleplayEnemyAvgAggregateOutputType = {
    id: number | null
    health: number | null
    weaponFarId: number | null
    weaponCacId: number | null
    deadTimer: number | null
    lootItemId: number | null
    moneyDrop: number | null
    dropScriptId: number | null
    teamId: number | null
    aggroDistance: number | null
    zoneDistance: number | null
    lostAggroDistance: number | null
  }

  export type RoleplayEnemySumAggregateOutputType = {
    id: number | null
    health: number | null
    weaponFarId: number | null
    weaponCacId: number | null
    deadTimer: number | null
    lootItemId: number | null
    moneyDrop: number | null
    dropScriptId: number | null
    teamId: number | null
    aggroDistance: number | null
    zoneDistance: number | null
    lostAggroDistance: number | null
  }

  export type RoleplayEnemyMinAggregateOutputType = {
    id: number | null
    type: $Enums.RoleplayEnemyType | null
    health: number | null
    weaponFarId: number | null
    weaponCacId: number | null
    deadTimer: number | null
    lootItemId: number | null
    moneyDrop: number | null
    dropScriptId: number | null
    teamId: number | null
    aggroDistance: number | null
    zoneDistance: number | null
    resetPosition: boolean | null
    lostAggroDistance: number | null
    zombieMode: boolean | null
  }

  export type RoleplayEnemyMaxAggregateOutputType = {
    id: number | null
    type: $Enums.RoleplayEnemyType | null
    health: number | null
    weaponFarId: number | null
    weaponCacId: number | null
    deadTimer: number | null
    lootItemId: number | null
    moneyDrop: number | null
    dropScriptId: number | null
    teamId: number | null
    aggroDistance: number | null
    zoneDistance: number | null
    resetPosition: boolean | null
    lostAggroDistance: number | null
    zombieMode: boolean | null
  }

  export type RoleplayEnemyCountAggregateOutputType = {
    id: number
    type: number
    health: number
    weaponFarId: number
    weaponCacId: number
    deadTimer: number
    lootItemId: number
    moneyDrop: number
    dropScriptId: number
    teamId: number
    aggroDistance: number
    zoneDistance: number
    resetPosition: number
    lostAggroDistance: number
    zombieMode: number
    _all: number
  }


  export type RoleplayEnemyAvgAggregateInputType = {
    id?: true
    health?: true
    weaponFarId?: true
    weaponCacId?: true
    deadTimer?: true
    lootItemId?: true
    moneyDrop?: true
    dropScriptId?: true
    teamId?: true
    aggroDistance?: true
    zoneDistance?: true
    lostAggroDistance?: true
  }

  export type RoleplayEnemySumAggregateInputType = {
    id?: true
    health?: true
    weaponFarId?: true
    weaponCacId?: true
    deadTimer?: true
    lootItemId?: true
    moneyDrop?: true
    dropScriptId?: true
    teamId?: true
    aggroDistance?: true
    zoneDistance?: true
    lostAggroDistance?: true
  }

  export type RoleplayEnemyMinAggregateInputType = {
    id?: true
    type?: true
    health?: true
    weaponFarId?: true
    weaponCacId?: true
    deadTimer?: true
    lootItemId?: true
    moneyDrop?: true
    dropScriptId?: true
    teamId?: true
    aggroDistance?: true
    zoneDistance?: true
    resetPosition?: true
    lostAggroDistance?: true
    zombieMode?: true
  }

  export type RoleplayEnemyMaxAggregateInputType = {
    id?: true
    type?: true
    health?: true
    weaponFarId?: true
    weaponCacId?: true
    deadTimer?: true
    lootItemId?: true
    moneyDrop?: true
    dropScriptId?: true
    teamId?: true
    aggroDistance?: true
    zoneDistance?: true
    resetPosition?: true
    lostAggroDistance?: true
    zombieMode?: true
  }

  export type RoleplayEnemyCountAggregateInputType = {
    id?: true
    type?: true
    health?: true
    weaponFarId?: true
    weaponCacId?: true
    deadTimer?: true
    lootItemId?: true
    moneyDrop?: true
    dropScriptId?: true
    teamId?: true
    aggroDistance?: true
    zoneDistance?: true
    resetPosition?: true
    lostAggroDistance?: true
    zombieMode?: true
    _all?: true
  }

  export type RoleplayEnemyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleplayEnemy to aggregate.
     */
    where?: RoleplayEnemyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayEnemies to fetch.
     */
    orderBy?: RoleplayEnemyOrderByWithRelationInput | RoleplayEnemyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleplayEnemyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayEnemies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayEnemies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleplayEnemies
    **/
    _count?: true | RoleplayEnemyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleplayEnemyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleplayEnemySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleplayEnemyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleplayEnemyMaxAggregateInputType
  }

  export type GetRoleplayEnemyAggregateType<T extends RoleplayEnemyAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleplayEnemy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleplayEnemy[P]>
      : GetScalarType<T[P], AggregateRoleplayEnemy[P]>
  }




  export type RoleplayEnemyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleplayEnemyWhereInput
    orderBy?: RoleplayEnemyOrderByWithAggregationInput | RoleplayEnemyOrderByWithAggregationInput[]
    by: RoleplayEnemyScalarFieldEnum[] | RoleplayEnemyScalarFieldEnum
    having?: RoleplayEnemyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleplayEnemyCountAggregateInputType | true
    _avg?: RoleplayEnemyAvgAggregateInputType
    _sum?: RoleplayEnemySumAggregateInputType
    _min?: RoleplayEnemyMinAggregateInputType
    _max?: RoleplayEnemyMaxAggregateInputType
  }

  export type RoleplayEnemyGroupByOutputType = {
    id: number
    type: $Enums.RoleplayEnemyType
    health: number
    weaponFarId: number
    weaponCacId: number
    deadTimer: number
    lootItemId: number
    moneyDrop: number
    dropScriptId: number
    teamId: number
    aggroDistance: number
    zoneDistance: number
    resetPosition: boolean
    lostAggroDistance: number
    zombieMode: boolean
    _count: RoleplayEnemyCountAggregateOutputType | null
    _avg: RoleplayEnemyAvgAggregateOutputType | null
    _sum: RoleplayEnemySumAggregateOutputType | null
    _min: RoleplayEnemyMinAggregateOutputType | null
    _max: RoleplayEnemyMaxAggregateOutputType | null
  }

  type GetRoleplayEnemyGroupByPayload<T extends RoleplayEnemyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleplayEnemyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleplayEnemyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleplayEnemyGroupByOutputType[P]>
            : GetScalarType<T[P], RoleplayEnemyGroupByOutputType[P]>
        }
      >
    >


  export type RoleplayEnemySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    health?: boolean
    weaponFarId?: boolean
    weaponCacId?: boolean
    deadTimer?: boolean
    lootItemId?: boolean
    moneyDrop?: boolean
    dropScriptId?: boolean
    teamId?: boolean
    aggroDistance?: boolean
    zoneDistance?: boolean
    resetPosition?: boolean
    lostAggroDistance?: boolean
    zombieMode?: boolean
  }, ExtArgs["result"]["roleplayEnemy"]>

  export type RoleplayEnemySelectScalar = {
    id?: boolean
    type?: boolean
    health?: boolean
    weaponFarId?: boolean
    weaponCacId?: boolean
    deadTimer?: boolean
    lootItemId?: boolean
    moneyDrop?: boolean
    dropScriptId?: boolean
    teamId?: boolean
    aggroDistance?: boolean
    zoneDistance?: boolean
    resetPosition?: boolean
    lostAggroDistance?: boolean
    zombieMode?: boolean
  }


  export type $RoleplayEnemyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleplayEnemy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.RoleplayEnemyType
      health: number
      weaponFarId: number
      weaponCacId: number
      deadTimer: number
      lootItemId: number
      moneyDrop: number
      dropScriptId: number
      teamId: number
      aggroDistance: number
      zoneDistance: number
      resetPosition: boolean
      lostAggroDistance: number
      zombieMode: boolean
    }, ExtArgs["result"]["roleplayEnemy"]>
    composites: {}
  }


  type RoleplayEnemyGetPayload<S extends boolean | null | undefined | RoleplayEnemyDefaultArgs> = $Result.GetResult<Prisma.$RoleplayEnemyPayload, S>

  type RoleplayEnemyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleplayEnemyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleplayEnemyCountAggregateInputType | true
    }

  export interface RoleplayEnemyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleplayEnemy'], meta: { name: 'RoleplayEnemy' } }
    /**
     * Find zero or one RoleplayEnemy that matches the filter.
     * @param {RoleplayEnemyFindUniqueArgs} args - Arguments to find a RoleplayEnemy
     * @example
     * // Get one RoleplayEnemy
     * const roleplayEnemy = await prisma.roleplayEnemy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleplayEnemyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayEnemyFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoleplayEnemy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleplayEnemyFindUniqueOrThrowArgs} args - Arguments to find a RoleplayEnemy
     * @example
     * // Get one RoleplayEnemy
     * const roleplayEnemy = await prisma.roleplayEnemy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleplayEnemyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayEnemyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoleplayEnemy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyFindFirstArgs} args - Arguments to find a RoleplayEnemy
     * @example
     * // Get one RoleplayEnemy
     * const roleplayEnemy = await prisma.roleplayEnemy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleplayEnemyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayEnemyFindFirstArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoleplayEnemy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyFindFirstOrThrowArgs} args - Arguments to find a RoleplayEnemy
     * @example
     * // Get one RoleplayEnemy
     * const roleplayEnemy = await prisma.roleplayEnemy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleplayEnemyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayEnemyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoleplayEnemies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleplayEnemies
     * const roleplayEnemies = await prisma.roleplayEnemy.findMany()
     * 
     * // Get first 10 RoleplayEnemies
     * const roleplayEnemies = await prisma.roleplayEnemy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleplayEnemyWithIdOnly = await prisma.roleplayEnemy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleplayEnemyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayEnemyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoleplayEnemy.
     * @param {RoleplayEnemyCreateArgs} args - Arguments to create a RoleplayEnemy.
     * @example
     * // Create one RoleplayEnemy
     * const RoleplayEnemy = await prisma.roleplayEnemy.create({
     *   data: {
     *     // ... data to create a RoleplayEnemy
     *   }
     * })
     * 
    **/
    create<T extends RoleplayEnemyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayEnemyCreateArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoleplayEnemies.
     *     @param {RoleplayEnemyCreateManyArgs} args - Arguments to create many RoleplayEnemies.
     *     @example
     *     // Create many RoleplayEnemies
     *     const roleplayEnemy = await prisma.roleplayEnemy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleplayEnemyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayEnemyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoleplayEnemy.
     * @param {RoleplayEnemyDeleteArgs} args - Arguments to delete one RoleplayEnemy.
     * @example
     * // Delete one RoleplayEnemy
     * const RoleplayEnemy = await prisma.roleplayEnemy.delete({
     *   where: {
     *     // ... filter to delete one RoleplayEnemy
     *   }
     * })
     * 
    **/
    delete<T extends RoleplayEnemyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayEnemyDeleteArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoleplayEnemy.
     * @param {RoleplayEnemyUpdateArgs} args - Arguments to update one RoleplayEnemy.
     * @example
     * // Update one RoleplayEnemy
     * const roleplayEnemy = await prisma.roleplayEnemy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleplayEnemyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayEnemyUpdateArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoleplayEnemies.
     * @param {RoleplayEnemyDeleteManyArgs} args - Arguments to filter RoleplayEnemies to delete.
     * @example
     * // Delete a few RoleplayEnemies
     * const { count } = await prisma.roleplayEnemy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleplayEnemyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayEnemyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleplayEnemies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleplayEnemies
     * const roleplayEnemy = await prisma.roleplayEnemy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleplayEnemyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayEnemyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleplayEnemy.
     * @param {RoleplayEnemyUpsertArgs} args - Arguments to update or create a RoleplayEnemy.
     * @example
     * // Update or create a RoleplayEnemy
     * const roleplayEnemy = await prisma.roleplayEnemy.upsert({
     *   create: {
     *     // ... data to create a RoleplayEnemy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleplayEnemy we want to update
     *   }
     * })
    **/
    upsert<T extends RoleplayEnemyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayEnemyUpsertArgs<ExtArgs>>
    ): Prisma__RoleplayEnemyClient<$Result.GetResult<Prisma.$RoleplayEnemyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoleplayEnemies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyCountArgs} args - Arguments to filter RoleplayEnemies to count.
     * @example
     * // Count the number of RoleplayEnemies
     * const count = await prisma.roleplayEnemy.count({
     *   where: {
     *     // ... the filter for the RoleplayEnemies we want to count
     *   }
     * })
    **/
    count<T extends RoleplayEnemyCountArgs>(
      args?: Subset<T, RoleplayEnemyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleplayEnemyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleplayEnemy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleplayEnemyAggregateArgs>(args: Subset<T, RoleplayEnemyAggregateArgs>): Prisma.PrismaPromise<GetRoleplayEnemyAggregateType<T>>

    /**
     * Group by RoleplayEnemy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayEnemyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleplayEnemyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleplayEnemyGroupByArgs['orderBy'] }
        : { orderBy?: RoleplayEnemyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleplayEnemyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleplayEnemyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleplayEnemy model
   */
  readonly fields: RoleplayEnemyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleplayEnemy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleplayEnemyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoleplayEnemy model
   */ 
  interface RoleplayEnemyFieldRefs {
    readonly id: FieldRef<"RoleplayEnemy", 'Int'>
    readonly type: FieldRef<"RoleplayEnemy", 'RoleplayEnemyType'>
    readonly health: FieldRef<"RoleplayEnemy", 'Int'>
    readonly weaponFarId: FieldRef<"RoleplayEnemy", 'Int'>
    readonly weaponCacId: FieldRef<"RoleplayEnemy", 'Int'>
    readonly deadTimer: FieldRef<"RoleplayEnemy", 'Int'>
    readonly lootItemId: FieldRef<"RoleplayEnemy", 'Int'>
    readonly moneyDrop: FieldRef<"RoleplayEnemy", 'Int'>
    readonly dropScriptId: FieldRef<"RoleplayEnemy", 'Int'>
    readonly teamId: FieldRef<"RoleplayEnemy", 'Int'>
    readonly aggroDistance: FieldRef<"RoleplayEnemy", 'Int'>
    readonly zoneDistance: FieldRef<"RoleplayEnemy", 'Int'>
    readonly resetPosition: FieldRef<"RoleplayEnemy", 'Boolean'>
    readonly lostAggroDistance: FieldRef<"RoleplayEnemy", 'Int'>
    readonly zombieMode: FieldRef<"RoleplayEnemy", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * RoleplayEnemy findUnique
   */
  export type RoleplayEnemyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * Filter, which RoleplayEnemy to fetch.
     */
    where: RoleplayEnemyWhereUniqueInput
  }


  /**
   * RoleplayEnemy findUniqueOrThrow
   */
  export type RoleplayEnemyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * Filter, which RoleplayEnemy to fetch.
     */
    where: RoleplayEnemyWhereUniqueInput
  }


  /**
   * RoleplayEnemy findFirst
   */
  export type RoleplayEnemyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * Filter, which RoleplayEnemy to fetch.
     */
    where?: RoleplayEnemyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayEnemies to fetch.
     */
    orderBy?: RoleplayEnemyOrderByWithRelationInput | RoleplayEnemyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleplayEnemies.
     */
    cursor?: RoleplayEnemyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayEnemies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayEnemies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleplayEnemies.
     */
    distinct?: RoleplayEnemyScalarFieldEnum | RoleplayEnemyScalarFieldEnum[]
  }


  /**
   * RoleplayEnemy findFirstOrThrow
   */
  export type RoleplayEnemyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * Filter, which RoleplayEnemy to fetch.
     */
    where?: RoleplayEnemyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayEnemies to fetch.
     */
    orderBy?: RoleplayEnemyOrderByWithRelationInput | RoleplayEnemyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleplayEnemies.
     */
    cursor?: RoleplayEnemyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayEnemies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayEnemies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleplayEnemies.
     */
    distinct?: RoleplayEnemyScalarFieldEnum | RoleplayEnemyScalarFieldEnum[]
  }


  /**
   * RoleplayEnemy findMany
   */
  export type RoleplayEnemyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * Filter, which RoleplayEnemies to fetch.
     */
    where?: RoleplayEnemyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayEnemies to fetch.
     */
    orderBy?: RoleplayEnemyOrderByWithRelationInput | RoleplayEnemyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleplayEnemies.
     */
    cursor?: RoleplayEnemyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayEnemies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayEnemies.
     */
    skip?: number
    distinct?: RoleplayEnemyScalarFieldEnum | RoleplayEnemyScalarFieldEnum[]
  }


  /**
   * RoleplayEnemy create
   */
  export type RoleplayEnemyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * The data needed to create a RoleplayEnemy.
     */
    data: XOR<RoleplayEnemyCreateInput, RoleplayEnemyUncheckedCreateInput>
  }


  /**
   * RoleplayEnemy createMany
   */
  export type RoleplayEnemyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleplayEnemies.
     */
    data: RoleplayEnemyCreateManyInput | RoleplayEnemyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoleplayEnemy update
   */
  export type RoleplayEnemyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * The data needed to update a RoleplayEnemy.
     */
    data: XOR<RoleplayEnemyUpdateInput, RoleplayEnemyUncheckedUpdateInput>
    /**
     * Choose, which RoleplayEnemy to update.
     */
    where: RoleplayEnemyWhereUniqueInput
  }


  /**
   * RoleplayEnemy updateMany
   */
  export type RoleplayEnemyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleplayEnemies.
     */
    data: XOR<RoleplayEnemyUpdateManyMutationInput, RoleplayEnemyUncheckedUpdateManyInput>
    /**
     * Filter which RoleplayEnemies to update
     */
    where?: RoleplayEnemyWhereInput
  }


  /**
   * RoleplayEnemy upsert
   */
  export type RoleplayEnemyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * The filter to search for the RoleplayEnemy to update in case it exists.
     */
    where: RoleplayEnemyWhereUniqueInput
    /**
     * In case the RoleplayEnemy found by the `where` argument doesn't exist, create a new RoleplayEnemy with this data.
     */
    create: XOR<RoleplayEnemyCreateInput, RoleplayEnemyUncheckedCreateInput>
    /**
     * In case the RoleplayEnemy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleplayEnemyUpdateInput, RoleplayEnemyUncheckedUpdateInput>
  }


  /**
   * RoleplayEnemy delete
   */
  export type RoleplayEnemyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
    /**
     * Filter which RoleplayEnemy to delete.
     */
    where: RoleplayEnemyWhereUniqueInput
  }


  /**
   * RoleplayEnemy deleteMany
   */
  export type RoleplayEnemyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleplayEnemies to delete
     */
    where?: RoleplayEnemyWhereInput
  }


  /**
   * RoleplayEnemy without action
   */
  export type RoleplayEnemyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayEnemy
     */
    select?: RoleplayEnemySelect<ExtArgs> | null
  }



  /**
   * Model RoleplayItem
   */

  export type AggregateRoleplayItem = {
    _count: RoleplayItemCountAggregateOutputType | null
    _avg: RoleplayItemAvgAggregateOutputType | null
    _sum: RoleplayItemSumAggregateOutputType | null
    _min: RoleplayItemMinAggregateOutputType | null
    _max: RoleplayItemMaxAggregateOutputType | null
  }

  export type RoleplayItemAvgAggregateOutputType = {
    id: number | null
    price: number | null
    value: number | null
  }

  export type RoleplayItemSumAggregateOutputType = {
    id: number | null
    price: number | null
    value: number | null
  }

  export type RoleplayItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    desc: string | null
    price: number | null
    type: $Enums.RoleplayItemType | null
    value: number | null
    allowstack: boolean | null
    category: $Enums.RoleplayItemCategory | null
  }

  export type RoleplayItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    desc: string | null
    price: number | null
    type: $Enums.RoleplayItemType | null
    value: number | null
    allowstack: boolean | null
    category: $Enums.RoleplayItemCategory | null
  }

  export type RoleplayItemCountAggregateOutputType = {
    id: number
    name: number
    desc: number
    price: number
    type: number
    value: number
    allowstack: number
    category: number
    _all: number
  }


  export type RoleplayItemAvgAggregateInputType = {
    id?: true
    price?: true
    value?: true
  }

  export type RoleplayItemSumAggregateInputType = {
    id?: true
    price?: true
    value?: true
  }

  export type RoleplayItemMinAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    price?: true
    type?: true
    value?: true
    allowstack?: true
    category?: true
  }

  export type RoleplayItemMaxAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    price?: true
    type?: true
    value?: true
    allowstack?: true
    category?: true
  }

  export type RoleplayItemCountAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    price?: true
    type?: true
    value?: true
    allowstack?: true
    category?: true
    _all?: true
  }

  export type RoleplayItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleplayItem to aggregate.
     */
    where?: RoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayItems to fetch.
     */
    orderBy?: RoleplayItemOrderByWithRelationInput | RoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleplayItems
    **/
    _count?: true | RoleplayItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleplayItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleplayItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleplayItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleplayItemMaxAggregateInputType
  }

  export type GetRoleplayItemAggregateType<T extends RoleplayItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleplayItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleplayItem[P]>
      : GetScalarType<T[P], AggregateRoleplayItem[P]>
  }




  export type RoleplayItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleplayItemWhereInput
    orderBy?: RoleplayItemOrderByWithAggregationInput | RoleplayItemOrderByWithAggregationInput[]
    by: RoleplayItemScalarFieldEnum[] | RoleplayItemScalarFieldEnum
    having?: RoleplayItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleplayItemCountAggregateInputType | true
    _avg?: RoleplayItemAvgAggregateInputType
    _sum?: RoleplayItemSumAggregateInputType
    _min?: RoleplayItemMinAggregateInputType
    _max?: RoleplayItemMaxAggregateInputType
  }

  export type RoleplayItemGroupByOutputType = {
    id: number
    name: string
    desc: string | null
    price: number
    type: $Enums.RoleplayItemType
    value: number
    allowstack: boolean
    category: $Enums.RoleplayItemCategory
    _count: RoleplayItemCountAggregateOutputType | null
    _avg: RoleplayItemAvgAggregateOutputType | null
    _sum: RoleplayItemSumAggregateOutputType | null
    _min: RoleplayItemMinAggregateOutputType | null
    _max: RoleplayItemMaxAggregateOutputType | null
  }

  type GetRoleplayItemGroupByPayload<T extends RoleplayItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleplayItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleplayItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleplayItemGroupByOutputType[P]>
            : GetScalarType<T[P], RoleplayItemGroupByOutputType[P]>
        }
      >
    >


  export type RoleplayItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    desc?: boolean
    price?: boolean
    type?: boolean
    value?: boolean
    allowstack?: boolean
    category?: boolean
  }, ExtArgs["result"]["roleplayItem"]>

  export type RoleplayItemSelectScalar = {
    id?: boolean
    name?: boolean
    desc?: boolean
    price?: boolean
    type?: boolean
    value?: boolean
    allowstack?: boolean
    category?: boolean
  }


  export type $RoleplayItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleplayItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      desc: string | null
      price: number
      type: $Enums.RoleplayItemType
      value: number
      allowstack: boolean
      category: $Enums.RoleplayItemCategory
    }, ExtArgs["result"]["roleplayItem"]>
    composites: {}
  }


  type RoleplayItemGetPayload<S extends boolean | null | undefined | RoleplayItemDefaultArgs> = $Result.GetResult<Prisma.$RoleplayItemPayload, S>

  type RoleplayItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleplayItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleplayItemCountAggregateInputType | true
    }

  export interface RoleplayItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleplayItem'], meta: { name: 'RoleplayItem' } }
    /**
     * Find zero or one RoleplayItem that matches the filter.
     * @param {RoleplayItemFindUniqueArgs} args - Arguments to find a RoleplayItem
     * @example
     * // Get one RoleplayItem
     * const roleplayItem = await prisma.roleplayItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleplayItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayItemFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoleplayItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleplayItemFindUniqueOrThrowArgs} args - Arguments to find a RoleplayItem
     * @example
     * // Get one RoleplayItem
     * const roleplayItem = await prisma.roleplayItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleplayItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoleplayItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemFindFirstArgs} args - Arguments to find a RoleplayItem
     * @example
     * // Get one RoleplayItem
     * const roleplayItem = await prisma.roleplayItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleplayItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayItemFindFirstArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoleplayItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemFindFirstOrThrowArgs} args - Arguments to find a RoleplayItem
     * @example
     * // Get one RoleplayItem
     * const roleplayItem = await prisma.roleplayItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleplayItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoleplayItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleplayItems
     * const roleplayItems = await prisma.roleplayItem.findMany()
     * 
     * // Get first 10 RoleplayItems
     * const roleplayItems = await prisma.roleplayItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleplayItemWithIdOnly = await prisma.roleplayItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleplayItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoleplayItem.
     * @param {RoleplayItemCreateArgs} args - Arguments to create a RoleplayItem.
     * @example
     * // Create one RoleplayItem
     * const RoleplayItem = await prisma.roleplayItem.create({
     *   data: {
     *     // ... data to create a RoleplayItem
     *   }
     * })
     * 
    **/
    create<T extends RoleplayItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayItemCreateArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoleplayItems.
     *     @param {RoleplayItemCreateManyArgs} args - Arguments to create many RoleplayItems.
     *     @example
     *     // Create many RoleplayItems
     *     const roleplayItem = await prisma.roleplayItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleplayItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoleplayItem.
     * @param {RoleplayItemDeleteArgs} args - Arguments to delete one RoleplayItem.
     * @example
     * // Delete one RoleplayItem
     * const RoleplayItem = await prisma.roleplayItem.delete({
     *   where: {
     *     // ... filter to delete one RoleplayItem
     *   }
     * })
     * 
    **/
    delete<T extends RoleplayItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayItemDeleteArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoleplayItem.
     * @param {RoleplayItemUpdateArgs} args - Arguments to update one RoleplayItem.
     * @example
     * // Update one RoleplayItem
     * const roleplayItem = await prisma.roleplayItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleplayItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayItemUpdateArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoleplayItems.
     * @param {RoleplayItemDeleteManyArgs} args - Arguments to filter RoleplayItems to delete.
     * @example
     * // Delete a few RoleplayItems
     * const { count } = await prisma.roleplayItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleplayItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleplayItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleplayItems
     * const roleplayItem = await prisma.roleplayItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleplayItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleplayItem.
     * @param {RoleplayItemUpsertArgs} args - Arguments to update or create a RoleplayItem.
     * @example
     * // Update or create a RoleplayItem
     * const roleplayItem = await prisma.roleplayItem.upsert({
     *   create: {
     *     // ... data to create a RoleplayItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleplayItem we want to update
     *   }
     * })
    **/
    upsert<T extends RoleplayItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayItemUpsertArgs<ExtArgs>>
    ): Prisma__RoleplayItemClient<$Result.GetResult<Prisma.$RoleplayItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoleplayItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemCountArgs} args - Arguments to filter RoleplayItems to count.
     * @example
     * // Count the number of RoleplayItems
     * const count = await prisma.roleplayItem.count({
     *   where: {
     *     // ... the filter for the RoleplayItems we want to count
     *   }
     * })
    **/
    count<T extends RoleplayItemCountArgs>(
      args?: Subset<T, RoleplayItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleplayItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleplayItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleplayItemAggregateArgs>(args: Subset<T, RoleplayItemAggregateArgs>): Prisma.PrismaPromise<GetRoleplayItemAggregateType<T>>

    /**
     * Group by RoleplayItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleplayItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleplayItemGroupByArgs['orderBy'] }
        : { orderBy?: RoleplayItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleplayItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleplayItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleplayItem model
   */
  readonly fields: RoleplayItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleplayItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleplayItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoleplayItem model
   */ 
  interface RoleplayItemFieldRefs {
    readonly id: FieldRef<"RoleplayItem", 'Int'>
    readonly name: FieldRef<"RoleplayItem", 'String'>
    readonly desc: FieldRef<"RoleplayItem", 'String'>
    readonly price: FieldRef<"RoleplayItem", 'Int'>
    readonly type: FieldRef<"RoleplayItem", 'RoleplayItemType'>
    readonly value: FieldRef<"RoleplayItem", 'Int'>
    readonly allowstack: FieldRef<"RoleplayItem", 'Boolean'>
    readonly category: FieldRef<"RoleplayItem", 'RoleplayItemCategory'>
  }
    

  // Custom InputTypes

  /**
   * RoleplayItem findUnique
   */
  export type RoleplayItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayItem to fetch.
     */
    where: RoleplayItemWhereUniqueInput
  }


  /**
   * RoleplayItem findUniqueOrThrow
   */
  export type RoleplayItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayItem to fetch.
     */
    where: RoleplayItemWhereUniqueInput
  }


  /**
   * RoleplayItem findFirst
   */
  export type RoleplayItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayItem to fetch.
     */
    where?: RoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayItems to fetch.
     */
    orderBy?: RoleplayItemOrderByWithRelationInput | RoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleplayItems.
     */
    cursor?: RoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleplayItems.
     */
    distinct?: RoleplayItemScalarFieldEnum | RoleplayItemScalarFieldEnum[]
  }


  /**
   * RoleplayItem findFirstOrThrow
   */
  export type RoleplayItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayItem to fetch.
     */
    where?: RoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayItems to fetch.
     */
    orderBy?: RoleplayItemOrderByWithRelationInput | RoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleplayItems.
     */
    cursor?: RoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleplayItems.
     */
    distinct?: RoleplayItemScalarFieldEnum | RoleplayItemScalarFieldEnum[]
  }


  /**
   * RoleplayItem findMany
   */
  export type RoleplayItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayItems to fetch.
     */
    where?: RoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayItems to fetch.
     */
    orderBy?: RoleplayItemOrderByWithRelationInput | RoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleplayItems.
     */
    cursor?: RoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayItems.
     */
    skip?: number
    distinct?: RoleplayItemScalarFieldEnum | RoleplayItemScalarFieldEnum[]
  }


  /**
   * RoleplayItem create
   */
  export type RoleplayItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * The data needed to create a RoleplayItem.
     */
    data: XOR<RoleplayItemCreateInput, RoleplayItemUncheckedCreateInput>
  }


  /**
   * RoleplayItem createMany
   */
  export type RoleplayItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleplayItems.
     */
    data: RoleplayItemCreateManyInput | RoleplayItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoleplayItem update
   */
  export type RoleplayItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * The data needed to update a RoleplayItem.
     */
    data: XOR<RoleplayItemUpdateInput, RoleplayItemUncheckedUpdateInput>
    /**
     * Choose, which RoleplayItem to update.
     */
    where: RoleplayItemWhereUniqueInput
  }


  /**
   * RoleplayItem updateMany
   */
  export type RoleplayItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleplayItems.
     */
    data: XOR<RoleplayItemUpdateManyMutationInput, RoleplayItemUncheckedUpdateManyInput>
    /**
     * Filter which RoleplayItems to update
     */
    where?: RoleplayItemWhereInput
  }


  /**
   * RoleplayItem upsert
   */
  export type RoleplayItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * The filter to search for the RoleplayItem to update in case it exists.
     */
    where: RoleplayItemWhereUniqueInput
    /**
     * In case the RoleplayItem found by the `where` argument doesn't exist, create a new RoleplayItem with this data.
     */
    create: XOR<RoleplayItemCreateInput, RoleplayItemUncheckedCreateInput>
    /**
     * In case the RoleplayItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleplayItemUpdateInput, RoleplayItemUncheckedUpdateInput>
  }


  /**
   * RoleplayItem delete
   */
  export type RoleplayItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
    /**
     * Filter which RoleplayItem to delete.
     */
    where: RoleplayItemWhereUniqueInput
  }


  /**
   * RoleplayItem deleteMany
   */
  export type RoleplayItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleplayItems to delete
     */
    where?: RoleplayItemWhereInput
  }


  /**
   * RoleplayItem without action
   */
  export type RoleplayItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayItem
     */
    select?: RoleplayItemSelect<ExtArgs> | null
  }



  /**
   * Model RoleplayWeapon
   */

  export type AggregateRoleplayWeapon = {
    _count: RoleplayWeaponCountAggregateOutputType | null
    _avg: RoleplayWeaponAvgAggregateOutputType | null
    _sum: RoleplayWeaponSumAggregateOutputType | null
    _min: RoleplayWeaponMinAggregateOutputType | null
    _max: RoleplayWeaponMaxAggregateOutputType | null
  }

  export type RoleplayWeaponAvgAggregateOutputType = {
    id: number | null
    domageMin: number | null
    domageMax: number | null
    enable: number | null
    freezeTime: number | null
    distance: number | null
  }

  export type RoleplayWeaponSumAggregateOutputType = {
    id: number | null
    domageMin: number | null
    domageMax: number | null
    enable: number | null
    freezeTime: number | null
    distance: number | null
  }

  export type RoleplayWeaponMinAggregateOutputType = {
    id: number | null
    type: $Enums.RoleplayWeaponType | null
    domageMin: number | null
    domageMax: number | null
    interaction: $Enums.RoleplayWeaponInteraction | null
    enable: number | null
    freezeTime: number | null
    distance: number | null
  }

  export type RoleplayWeaponMaxAggregateOutputType = {
    id: number | null
    type: $Enums.RoleplayWeaponType | null
    domageMin: number | null
    domageMax: number | null
    interaction: $Enums.RoleplayWeaponInteraction | null
    enable: number | null
    freezeTime: number | null
    distance: number | null
  }

  export type RoleplayWeaponCountAggregateOutputType = {
    id: number
    type: number
    domageMin: number
    domageMax: number
    interaction: number
    enable: number
    freezeTime: number
    distance: number
    _all: number
  }


  export type RoleplayWeaponAvgAggregateInputType = {
    id?: true
    domageMin?: true
    domageMax?: true
    enable?: true
    freezeTime?: true
    distance?: true
  }

  export type RoleplayWeaponSumAggregateInputType = {
    id?: true
    domageMin?: true
    domageMax?: true
    enable?: true
    freezeTime?: true
    distance?: true
  }

  export type RoleplayWeaponMinAggregateInputType = {
    id?: true
    type?: true
    domageMin?: true
    domageMax?: true
    interaction?: true
    enable?: true
    freezeTime?: true
    distance?: true
  }

  export type RoleplayWeaponMaxAggregateInputType = {
    id?: true
    type?: true
    domageMin?: true
    domageMax?: true
    interaction?: true
    enable?: true
    freezeTime?: true
    distance?: true
  }

  export type RoleplayWeaponCountAggregateInputType = {
    id?: true
    type?: true
    domageMin?: true
    domageMax?: true
    interaction?: true
    enable?: true
    freezeTime?: true
    distance?: true
    _all?: true
  }

  export type RoleplayWeaponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleplayWeapon to aggregate.
     */
    where?: RoleplayWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayWeapons to fetch.
     */
    orderBy?: RoleplayWeaponOrderByWithRelationInput | RoleplayWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleplayWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleplayWeapons
    **/
    _count?: true | RoleplayWeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleplayWeaponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleplayWeaponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleplayWeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleplayWeaponMaxAggregateInputType
  }

  export type GetRoleplayWeaponAggregateType<T extends RoleplayWeaponAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleplayWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleplayWeapon[P]>
      : GetScalarType<T[P], AggregateRoleplayWeapon[P]>
  }




  export type RoleplayWeaponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleplayWeaponWhereInput
    orderBy?: RoleplayWeaponOrderByWithAggregationInput | RoleplayWeaponOrderByWithAggregationInput[]
    by: RoleplayWeaponScalarFieldEnum[] | RoleplayWeaponScalarFieldEnum
    having?: RoleplayWeaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleplayWeaponCountAggregateInputType | true
    _avg?: RoleplayWeaponAvgAggregateInputType
    _sum?: RoleplayWeaponSumAggregateInputType
    _min?: RoleplayWeaponMinAggregateInputType
    _max?: RoleplayWeaponMaxAggregateInputType
  }

  export type RoleplayWeaponGroupByOutputType = {
    id: number
    type: $Enums.RoleplayWeaponType
    domageMin: number
    domageMax: number
    interaction: $Enums.RoleplayWeaponInteraction
    enable: number
    freezeTime: number
    distance: number
    _count: RoleplayWeaponCountAggregateOutputType | null
    _avg: RoleplayWeaponAvgAggregateOutputType | null
    _sum: RoleplayWeaponSumAggregateOutputType | null
    _min: RoleplayWeaponMinAggregateOutputType | null
    _max: RoleplayWeaponMaxAggregateOutputType | null
  }

  type GetRoleplayWeaponGroupByPayload<T extends RoleplayWeaponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleplayWeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleplayWeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleplayWeaponGroupByOutputType[P]>
            : GetScalarType<T[P], RoleplayWeaponGroupByOutputType[P]>
        }
      >
    >


  export type RoleplayWeaponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    domageMin?: boolean
    domageMax?: boolean
    interaction?: boolean
    enable?: boolean
    freezeTime?: boolean
    distance?: boolean
  }, ExtArgs["result"]["roleplayWeapon"]>

  export type RoleplayWeaponSelectScalar = {
    id?: boolean
    type?: boolean
    domageMin?: boolean
    domageMax?: boolean
    interaction?: boolean
    enable?: boolean
    freezeTime?: boolean
    distance?: boolean
  }


  export type $RoleplayWeaponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleplayWeapon"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.RoleplayWeaponType
      domageMin: number
      domageMax: number
      interaction: $Enums.RoleplayWeaponInteraction
      enable: number
      freezeTime: number
      distance: number
    }, ExtArgs["result"]["roleplayWeapon"]>
    composites: {}
  }


  type RoleplayWeaponGetPayload<S extends boolean | null | undefined | RoleplayWeaponDefaultArgs> = $Result.GetResult<Prisma.$RoleplayWeaponPayload, S>

  type RoleplayWeaponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleplayWeaponFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleplayWeaponCountAggregateInputType | true
    }

  export interface RoleplayWeaponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleplayWeapon'], meta: { name: 'RoleplayWeapon' } }
    /**
     * Find zero or one RoleplayWeapon that matches the filter.
     * @param {RoleplayWeaponFindUniqueArgs} args - Arguments to find a RoleplayWeapon
     * @example
     * // Get one RoleplayWeapon
     * const roleplayWeapon = await prisma.roleplayWeapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleplayWeaponFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayWeaponFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoleplayWeapon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleplayWeaponFindUniqueOrThrowArgs} args - Arguments to find a RoleplayWeapon
     * @example
     * // Get one RoleplayWeapon
     * const roleplayWeapon = await prisma.roleplayWeapon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleplayWeaponFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayWeaponFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoleplayWeapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponFindFirstArgs} args - Arguments to find a RoleplayWeapon
     * @example
     * // Get one RoleplayWeapon
     * const roleplayWeapon = await prisma.roleplayWeapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleplayWeaponFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayWeaponFindFirstArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoleplayWeapon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponFindFirstOrThrowArgs} args - Arguments to find a RoleplayWeapon
     * @example
     * // Get one RoleplayWeapon
     * const roleplayWeapon = await prisma.roleplayWeapon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleplayWeaponFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayWeaponFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoleplayWeapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleplayWeapons
     * const roleplayWeapons = await prisma.roleplayWeapon.findMany()
     * 
     * // Get first 10 RoleplayWeapons
     * const roleplayWeapons = await prisma.roleplayWeapon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleplayWeaponWithIdOnly = await prisma.roleplayWeapon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleplayWeaponFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayWeaponFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoleplayWeapon.
     * @param {RoleplayWeaponCreateArgs} args - Arguments to create a RoleplayWeapon.
     * @example
     * // Create one RoleplayWeapon
     * const RoleplayWeapon = await prisma.roleplayWeapon.create({
     *   data: {
     *     // ... data to create a RoleplayWeapon
     *   }
     * })
     * 
    **/
    create<T extends RoleplayWeaponCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayWeaponCreateArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoleplayWeapons.
     *     @param {RoleplayWeaponCreateManyArgs} args - Arguments to create many RoleplayWeapons.
     *     @example
     *     // Create many RoleplayWeapons
     *     const roleplayWeapon = await prisma.roleplayWeapon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleplayWeaponCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayWeaponCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoleplayWeapon.
     * @param {RoleplayWeaponDeleteArgs} args - Arguments to delete one RoleplayWeapon.
     * @example
     * // Delete one RoleplayWeapon
     * const RoleplayWeapon = await prisma.roleplayWeapon.delete({
     *   where: {
     *     // ... filter to delete one RoleplayWeapon
     *   }
     * })
     * 
    **/
    delete<T extends RoleplayWeaponDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayWeaponDeleteArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoleplayWeapon.
     * @param {RoleplayWeaponUpdateArgs} args - Arguments to update one RoleplayWeapon.
     * @example
     * // Update one RoleplayWeapon
     * const roleplayWeapon = await prisma.roleplayWeapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleplayWeaponUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayWeaponUpdateArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoleplayWeapons.
     * @param {RoleplayWeaponDeleteManyArgs} args - Arguments to filter RoleplayWeapons to delete.
     * @example
     * // Delete a few RoleplayWeapons
     * const { count } = await prisma.roleplayWeapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleplayWeaponDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleplayWeaponDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleplayWeapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleplayWeapons
     * const roleplayWeapon = await prisma.roleplayWeapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleplayWeaponUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayWeaponUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleplayWeapon.
     * @param {RoleplayWeaponUpsertArgs} args - Arguments to update or create a RoleplayWeapon.
     * @example
     * // Update or create a RoleplayWeapon
     * const roleplayWeapon = await prisma.roleplayWeapon.upsert({
     *   create: {
     *     // ... data to create a RoleplayWeapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleplayWeapon we want to update
     *   }
     * })
    **/
    upsert<T extends RoleplayWeaponUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleplayWeaponUpsertArgs<ExtArgs>>
    ): Prisma__RoleplayWeaponClient<$Result.GetResult<Prisma.$RoleplayWeaponPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoleplayWeapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponCountArgs} args - Arguments to filter RoleplayWeapons to count.
     * @example
     * // Count the number of RoleplayWeapons
     * const count = await prisma.roleplayWeapon.count({
     *   where: {
     *     // ... the filter for the RoleplayWeapons we want to count
     *   }
     * })
    **/
    count<T extends RoleplayWeaponCountArgs>(
      args?: Subset<T, RoleplayWeaponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleplayWeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleplayWeapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleplayWeaponAggregateArgs>(args: Subset<T, RoleplayWeaponAggregateArgs>): Prisma.PrismaPromise<GetRoleplayWeaponAggregateType<T>>

    /**
     * Group by RoleplayWeapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleplayWeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleplayWeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleplayWeaponGroupByArgs['orderBy'] }
        : { orderBy?: RoleplayWeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleplayWeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleplayWeaponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleplayWeapon model
   */
  readonly fields: RoleplayWeaponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleplayWeapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleplayWeaponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoleplayWeapon model
   */ 
  interface RoleplayWeaponFieldRefs {
    readonly id: FieldRef<"RoleplayWeapon", 'Int'>
    readonly type: FieldRef<"RoleplayWeapon", 'RoleplayWeaponType'>
    readonly domageMin: FieldRef<"RoleplayWeapon", 'Int'>
    readonly domageMax: FieldRef<"RoleplayWeapon", 'Int'>
    readonly interaction: FieldRef<"RoleplayWeapon", 'RoleplayWeaponInteraction'>
    readonly enable: FieldRef<"RoleplayWeapon", 'Int'>
    readonly freezeTime: FieldRef<"RoleplayWeapon", 'Int'>
    readonly distance: FieldRef<"RoleplayWeapon", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RoleplayWeapon findUnique
   */
  export type RoleplayWeaponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayWeapon to fetch.
     */
    where: RoleplayWeaponWhereUniqueInput
  }


  /**
   * RoleplayWeapon findUniqueOrThrow
   */
  export type RoleplayWeaponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayWeapon to fetch.
     */
    where: RoleplayWeaponWhereUniqueInput
  }


  /**
   * RoleplayWeapon findFirst
   */
  export type RoleplayWeaponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayWeapon to fetch.
     */
    where?: RoleplayWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayWeapons to fetch.
     */
    orderBy?: RoleplayWeaponOrderByWithRelationInput | RoleplayWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleplayWeapons.
     */
    cursor?: RoleplayWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleplayWeapons.
     */
    distinct?: RoleplayWeaponScalarFieldEnum | RoleplayWeaponScalarFieldEnum[]
  }


  /**
   * RoleplayWeapon findFirstOrThrow
   */
  export type RoleplayWeaponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayWeapon to fetch.
     */
    where?: RoleplayWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayWeapons to fetch.
     */
    orderBy?: RoleplayWeaponOrderByWithRelationInput | RoleplayWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleplayWeapons.
     */
    cursor?: RoleplayWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayWeapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleplayWeapons.
     */
    distinct?: RoleplayWeaponScalarFieldEnum | RoleplayWeaponScalarFieldEnum[]
  }


  /**
   * RoleplayWeapon findMany
   */
  export type RoleplayWeaponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * Filter, which RoleplayWeapons to fetch.
     */
    where?: RoleplayWeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleplayWeapons to fetch.
     */
    orderBy?: RoleplayWeaponOrderByWithRelationInput | RoleplayWeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleplayWeapons.
     */
    cursor?: RoleplayWeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleplayWeapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleplayWeapons.
     */
    skip?: number
    distinct?: RoleplayWeaponScalarFieldEnum | RoleplayWeaponScalarFieldEnum[]
  }


  /**
   * RoleplayWeapon create
   */
  export type RoleplayWeaponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * The data needed to create a RoleplayWeapon.
     */
    data?: XOR<RoleplayWeaponCreateInput, RoleplayWeaponUncheckedCreateInput>
  }


  /**
   * RoleplayWeapon createMany
   */
  export type RoleplayWeaponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleplayWeapons.
     */
    data: RoleplayWeaponCreateManyInput | RoleplayWeaponCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoleplayWeapon update
   */
  export type RoleplayWeaponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * The data needed to update a RoleplayWeapon.
     */
    data: XOR<RoleplayWeaponUpdateInput, RoleplayWeaponUncheckedUpdateInput>
    /**
     * Choose, which RoleplayWeapon to update.
     */
    where: RoleplayWeaponWhereUniqueInput
  }


  /**
   * RoleplayWeapon updateMany
   */
  export type RoleplayWeaponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleplayWeapons.
     */
    data: XOR<RoleplayWeaponUpdateManyMutationInput, RoleplayWeaponUncheckedUpdateManyInput>
    /**
     * Filter which RoleplayWeapons to update
     */
    where?: RoleplayWeaponWhereInput
  }


  /**
   * RoleplayWeapon upsert
   */
  export type RoleplayWeaponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * The filter to search for the RoleplayWeapon to update in case it exists.
     */
    where: RoleplayWeaponWhereUniqueInput
    /**
     * In case the RoleplayWeapon found by the `where` argument doesn't exist, create a new RoleplayWeapon with this data.
     */
    create: XOR<RoleplayWeaponCreateInput, RoleplayWeaponUncheckedCreateInput>
    /**
     * In case the RoleplayWeapon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleplayWeaponUpdateInput, RoleplayWeaponUncheckedUpdateInput>
  }


  /**
   * RoleplayWeapon delete
   */
  export type RoleplayWeaponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
    /**
     * Filter which RoleplayWeapon to delete.
     */
    where: RoleplayWeaponWhereUniqueInput
  }


  /**
   * RoleplayWeapon deleteMany
   */
  export type RoleplayWeaponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleplayWeapons to delete
     */
    where?: RoleplayWeaponWhereInput
  }


  /**
   * RoleplayWeapon without action
   */
  export type RoleplayWeaponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleplayWeapon
     */
    select?: RoleplayWeaponSelect<ExtArgs> | null
  }



  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    category: number | null
    usersMax: number | null
    score: number | null
    wallthick: number | null
    floorthick: number | null
    moderationKickFuse: number | null
    groupId: number | null
    chatType: number | null
    chatBalloon: number | null
    chatSpeed: number | null
    chatMaxDistance: number | null
    chatFloodProtection: number | null
    trocStatus: number | null
    usersNow: number | null
    price: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    category: number | null
    usersMax: number | null
    score: number | null
    wallthick: number | null
    floorthick: number | null
    moderationKickFuse: number | null
    groupId: number | null
    chatType: number | null
    chatBalloon: number | null
    chatSpeed: number | null
    chatMaxDistance: number | null
    chatFloodProtection: number | null
    trocStatus: number | null
    usersNow: number | null
    price: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    caption: string | null
    owner: string | null
    description: string | null
    category: number | null
    state: $Enums.RoomState | null
    usersMax: number | null
    modelName: string | null
    score: number | null
    tags: string | null
    password: string | null
    wallpaper: string | null
    floor: string | null
    landscape: string | null
    allowPets: boolean | null
    allowPetsEat: boolean | null
    allowWalkthrough: boolean | null
    allowHidewall: boolean | null
    wallthick: number | null
    floorthick: number | null
    moderationMuteFuse: boolean | null
    allowRightsoverride: boolean | null
    moderationKickFuse: number | null
    moderationBanFuse: boolean | null
    groupId: number | null
    chatType: number | null
    chatBalloon: number | null
    chatSpeed: number | null
    chatMaxDistance: number | null
    chatFloodProtection: number | null
    trocStatus: number | null
    usersNow: number | null
    allowHidewireds: boolean | null
    price: number | null
    wiredSecurity: boolean | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    caption: string | null
    owner: string | null
    description: string | null
    category: number | null
    state: $Enums.RoomState | null
    usersMax: number | null
    modelName: string | null
    score: number | null
    tags: string | null
    password: string | null
    wallpaper: string | null
    floor: string | null
    landscape: string | null
    allowPets: boolean | null
    allowPetsEat: boolean | null
    allowWalkthrough: boolean | null
    allowHidewall: boolean | null
    wallthick: number | null
    floorthick: number | null
    moderationMuteFuse: boolean | null
    allowRightsoverride: boolean | null
    moderationKickFuse: number | null
    moderationBanFuse: boolean | null
    groupId: number | null
    chatType: number | null
    chatBalloon: number | null
    chatSpeed: number | null
    chatMaxDistance: number | null
    chatFloodProtection: number | null
    trocStatus: number | null
    usersNow: number | null
    allowHidewireds: boolean | null
    price: number | null
    wiredSecurity: boolean | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    caption: number
    owner: number
    description: number
    category: number
    state: number
    usersMax: number
    modelName: number
    score: number
    tags: number
    password: number
    wallpaper: number
    floor: number
    landscape: number
    allowPets: number
    allowPetsEat: number
    allowWalkthrough: number
    allowHidewall: number
    wallthick: number
    floorthick: number
    moderationMuteFuse: number
    allowRightsoverride: number
    moderationKickFuse: number
    moderationBanFuse: number
    groupId: number
    chatType: number
    chatBalloon: number
    chatSpeed: number
    chatMaxDistance: number
    chatFloodProtection: number
    trocStatus: number
    usersNow: number
    allowHidewireds: number
    price: number
    wiredSecurity: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    category?: true
    usersMax?: true
    score?: true
    wallthick?: true
    floorthick?: true
    moderationKickFuse?: true
    groupId?: true
    chatType?: true
    chatBalloon?: true
    chatSpeed?: true
    chatMaxDistance?: true
    chatFloodProtection?: true
    trocStatus?: true
    usersNow?: true
    price?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    category?: true
    usersMax?: true
    score?: true
    wallthick?: true
    floorthick?: true
    moderationKickFuse?: true
    groupId?: true
    chatType?: true
    chatBalloon?: true
    chatSpeed?: true
    chatMaxDistance?: true
    chatFloodProtection?: true
    trocStatus?: true
    usersNow?: true
    price?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    caption?: true
    owner?: true
    description?: true
    category?: true
    state?: true
    usersMax?: true
    modelName?: true
    score?: true
    tags?: true
    password?: true
    wallpaper?: true
    floor?: true
    landscape?: true
    allowPets?: true
    allowPetsEat?: true
    allowWalkthrough?: true
    allowHidewall?: true
    wallthick?: true
    floorthick?: true
    moderationMuteFuse?: true
    allowRightsoverride?: true
    moderationKickFuse?: true
    moderationBanFuse?: true
    groupId?: true
    chatType?: true
    chatBalloon?: true
    chatSpeed?: true
    chatMaxDistance?: true
    chatFloodProtection?: true
    trocStatus?: true
    usersNow?: true
    allowHidewireds?: true
    price?: true
    wiredSecurity?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    caption?: true
    owner?: true
    description?: true
    category?: true
    state?: true
    usersMax?: true
    modelName?: true
    score?: true
    tags?: true
    password?: true
    wallpaper?: true
    floor?: true
    landscape?: true
    allowPets?: true
    allowPetsEat?: true
    allowWalkthrough?: true
    allowHidewall?: true
    wallthick?: true
    floorthick?: true
    moderationMuteFuse?: true
    allowRightsoverride?: true
    moderationKickFuse?: true
    moderationBanFuse?: true
    groupId?: true
    chatType?: true
    chatBalloon?: true
    chatSpeed?: true
    chatMaxDistance?: true
    chatFloodProtection?: true
    trocStatus?: true
    usersNow?: true
    allowHidewireds?: true
    price?: true
    wiredSecurity?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    caption?: true
    owner?: true
    description?: true
    category?: true
    state?: true
    usersMax?: true
    modelName?: true
    score?: true
    tags?: true
    password?: true
    wallpaper?: true
    floor?: true
    landscape?: true
    allowPets?: true
    allowPetsEat?: true
    allowWalkthrough?: true
    allowHidewall?: true
    wallthick?: true
    floorthick?: true
    moderationMuteFuse?: true
    allowRightsoverride?: true
    moderationKickFuse?: true
    moderationBanFuse?: true
    groupId?: true
    chatType?: true
    chatBalloon?: true
    chatSpeed?: true
    chatMaxDistance?: true
    chatFloodProtection?: true
    trocStatus?: true
    usersNow?: true
    allowHidewireds?: true
    price?: true
    wiredSecurity?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    caption: string
    owner: string
    description: string | null
    category: number
    state: $Enums.RoomState
    usersMax: number
    modelName: string
    score: number
    tags: string | null
    password: string | null
    wallpaper: string
    floor: string
    landscape: string
    allowPets: boolean
    allowPetsEat: boolean
    allowWalkthrough: boolean
    allowHidewall: boolean
    wallthick: number
    floorthick: number
    moderationMuteFuse: boolean
    allowRightsoverride: boolean
    moderationKickFuse: number
    moderationBanFuse: boolean
    groupId: number
    chatType: number
    chatBalloon: number
    chatSpeed: number
    chatMaxDistance: number
    chatFloodProtection: number
    trocStatus: number
    usersNow: number
    allowHidewireds: boolean
    price: number
    wiredSecurity: boolean
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caption?: boolean
    owner?: boolean
    description?: boolean
    category?: boolean
    state?: boolean
    usersMax?: boolean
    modelName?: boolean
    score?: boolean
    tags?: boolean
    password?: boolean
    wallpaper?: boolean
    floor?: boolean
    landscape?: boolean
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: boolean
    floorthick?: boolean
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: boolean
    moderationBanFuse?: boolean
    groupId?: boolean
    chatType?: boolean
    chatBalloon?: boolean
    chatSpeed?: boolean
    chatMaxDistance?: boolean
    chatFloodProtection?: boolean
    trocStatus?: boolean
    usersNow?: boolean
    allowHidewireds?: boolean
    price?: boolean
    wiredSecurity?: boolean
    LogChat?: boolean | Room$LogChatArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    caption?: boolean
    owner?: boolean
    description?: boolean
    category?: boolean
    state?: boolean
    usersMax?: boolean
    modelName?: boolean
    score?: boolean
    tags?: boolean
    password?: boolean
    wallpaper?: boolean
    floor?: boolean
    landscape?: boolean
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: boolean
    floorthick?: boolean
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: boolean
    moderationBanFuse?: boolean
    groupId?: boolean
    chatType?: boolean
    chatBalloon?: boolean
    chatSpeed?: boolean
    chatMaxDistance?: boolean
    chatFloodProtection?: boolean
    trocStatus?: boolean
    usersNow?: boolean
    allowHidewireds?: boolean
    price?: boolean
    wiredSecurity?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LogChat?: boolean | Room$LogChatArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      LogChat: Prisma.$LogChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      caption: string
      owner: string
      description: string | null
      category: number
      state: $Enums.RoomState
      usersMax: number
      modelName: string
      score: number
      tags: string | null
      password: string | null
      wallpaper: string
      floor: string
      landscape: string
      allowPets: boolean
      allowPetsEat: boolean
      allowWalkthrough: boolean
      allowHidewall: boolean
      wallthick: number
      floorthick: number
      moderationMuteFuse: boolean
      allowRightsoverride: boolean
      moderationKickFuse: number
      moderationBanFuse: boolean
      groupId: number
      chatType: number
      chatBalloon: number
      chatSpeed: number
      chatMaxDistance: number
      chatFloodProtection: number
      trocStatus: number
      usersNow: number
      allowHidewireds: boolean
      price: number
      wiredSecurity: boolean
    }, ExtArgs["result"]["room"]>
    composites: {}
  }


  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
    **/
    create<T extends RoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomCreateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rooms.
     *     @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     *     @example
     *     // Create many Rooms
     *     const room = await prisma.room.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
    **/
    delete<T extends RoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
    **/
    upsert<T extends RoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    LogChat<T extends Room$LogChatArgs<ExtArgs> = {}>(args?: Subset<T, Room$LogChatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly caption: FieldRef<"Room", 'String'>
    readonly owner: FieldRef<"Room", 'String'>
    readonly description: FieldRef<"Room", 'String'>
    readonly category: FieldRef<"Room", 'Int'>
    readonly state: FieldRef<"Room", 'RoomState'>
    readonly usersMax: FieldRef<"Room", 'Int'>
    readonly modelName: FieldRef<"Room", 'String'>
    readonly score: FieldRef<"Room", 'Int'>
    readonly tags: FieldRef<"Room", 'String'>
    readonly password: FieldRef<"Room", 'String'>
    readonly wallpaper: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'String'>
    readonly landscape: FieldRef<"Room", 'String'>
    readonly allowPets: FieldRef<"Room", 'Boolean'>
    readonly allowPetsEat: FieldRef<"Room", 'Boolean'>
    readonly allowWalkthrough: FieldRef<"Room", 'Boolean'>
    readonly allowHidewall: FieldRef<"Room", 'Boolean'>
    readonly wallthick: FieldRef<"Room", 'Int'>
    readonly floorthick: FieldRef<"Room", 'Int'>
    readonly moderationMuteFuse: FieldRef<"Room", 'Boolean'>
    readonly allowRightsoverride: FieldRef<"Room", 'Boolean'>
    readonly moderationKickFuse: FieldRef<"Room", 'Int'>
    readonly moderationBanFuse: FieldRef<"Room", 'Boolean'>
    readonly groupId: FieldRef<"Room", 'Int'>
    readonly chatType: FieldRef<"Room", 'Int'>
    readonly chatBalloon: FieldRef<"Room", 'Int'>
    readonly chatSpeed: FieldRef<"Room", 'Int'>
    readonly chatMaxDistance: FieldRef<"Room", 'Int'>
    readonly chatFloodProtection: FieldRef<"Room", 'Int'>
    readonly trocStatus: FieldRef<"Room", 'Int'>
    readonly usersNow: FieldRef<"Room", 'Int'>
    readonly allowHidewireds: FieldRef<"Room", 'Boolean'>
    readonly price: FieldRef<"Room", 'Int'>
    readonly wiredSecurity: FieldRef<"Room", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }


  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }


  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }


  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }


  /**
   * Room.LogChat
   */
  export type Room$LogChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    where?: LogChatWhereInput
    orderBy?: LogChatOrderByWithRelationInput | LogChatOrderByWithRelationInput[]
    cursor?: LogChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogChatScalarFieldEnum | LogChatScalarFieldEnum[]
  }


  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
  }



  /**
   * Model RoomModel
   */

  export type AggregateRoomModel = {
    _count: RoomModelCountAggregateOutputType | null
    _avg: RoomModelAvgAggregateOutputType | null
    _sum: RoomModelSumAggregateOutputType | null
    _min: RoomModelMinAggregateOutputType | null
    _max: RoomModelMaxAggregateOutputType | null
  }

  export type RoomModelAvgAggregateOutputType = {
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
  }

  export type RoomModelSumAggregateOutputType = {
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
  }

  export type RoomModelMinAggregateOutputType = {
    id: string | null
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
    heightmap: string | null
  }

  export type RoomModelMaxAggregateOutputType = {
    id: string | null
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
    heightmap: string | null
  }

  export type RoomModelCountAggregateOutputType = {
    id: number
    doorX: number
    doorY: number
    doorZ: number
    doorDir: number
    heightmap: number
    _all: number
  }


  export type RoomModelAvgAggregateInputType = {
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
  }

  export type RoomModelSumAggregateInputType = {
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
  }

  export type RoomModelMinAggregateInputType = {
    id?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    heightmap?: true
  }

  export type RoomModelMaxAggregateInputType = {
    id?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    heightmap?: true
  }

  export type RoomModelCountAggregateInputType = {
    id?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    heightmap?: true
    _all?: true
  }

  export type RoomModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomModel to aggregate.
     */
    where?: RoomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModels to fetch.
     */
    orderBy?: RoomModelOrderByWithRelationInput | RoomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomModels
    **/
    _count?: true | RoomModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomModelMaxAggregateInputType
  }

  export type GetRoomModelAggregateType<T extends RoomModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomModel[P]>
      : GetScalarType<T[P], AggregateRoomModel[P]>
  }




  export type RoomModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomModelWhereInput
    orderBy?: RoomModelOrderByWithAggregationInput | RoomModelOrderByWithAggregationInput[]
    by: RoomModelScalarFieldEnum[] | RoomModelScalarFieldEnum
    having?: RoomModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomModelCountAggregateInputType | true
    _avg?: RoomModelAvgAggregateInputType
    _sum?: RoomModelSumAggregateInputType
    _min?: RoomModelMinAggregateInputType
    _max?: RoomModelMaxAggregateInputType
  }

  export type RoomModelGroupByOutputType = {
    id: string
    doorX: number
    doorY: number
    doorZ: number
    doorDir: number
    heightmap: string
    _count: RoomModelCountAggregateOutputType | null
    _avg: RoomModelAvgAggregateOutputType | null
    _sum: RoomModelSumAggregateOutputType | null
    _min: RoomModelMinAggregateOutputType | null
    _max: RoomModelMaxAggregateOutputType | null
  }

  type GetRoomModelGroupByPayload<T extends RoomModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomModelGroupByOutputType[P]>
            : GetScalarType<T[P], RoomModelGroupByOutputType[P]>
        }
      >
    >


  export type RoomModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doorX?: boolean
    doorY?: boolean
    doorZ?: boolean
    doorDir?: boolean
    heightmap?: boolean
  }, ExtArgs["result"]["roomModel"]>

  export type RoomModelSelectScalar = {
    id?: boolean
    doorX?: boolean
    doorY?: boolean
    doorZ?: boolean
    doorDir?: boolean
    heightmap?: boolean
  }


  export type $RoomModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      doorX: number
      doorY: number
      doorZ: number
      doorDir: number
      heightmap: string
    }, ExtArgs["result"]["roomModel"]>
    composites: {}
  }


  type RoomModelGetPayload<S extends boolean | null | undefined | RoomModelDefaultArgs> = $Result.GetResult<Prisma.$RoomModelPayload, S>

  type RoomModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomModelCountAggregateInputType | true
    }

  export interface RoomModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomModel'], meta: { name: 'RoomModel' } }
    /**
     * Find zero or one RoomModel that matches the filter.
     * @param {RoomModelFindUniqueArgs} args - Arguments to find a RoomModel
     * @example
     * // Get one RoomModel
     * const roomModel = await prisma.roomModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomModelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomModelFindUniqueOrThrowArgs} args - Arguments to find a RoomModel
     * @example
     * // Get one RoomModel
     * const roomModel = await prisma.roomModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelFindFirstArgs} args - Arguments to find a RoomModel
     * @example
     * // Get one RoomModel
     * const roomModel = await prisma.roomModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomModelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelFindFirstArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelFindFirstOrThrowArgs} args - Arguments to find a RoomModel
     * @example
     * // Get one RoomModel
     * const roomModel = await prisma.roomModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomModels
     * const roomModels = await prisma.roomModel.findMany()
     * 
     * // Get first 10 RoomModels
     * const roomModels = await prisma.roomModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomModelWithIdOnly = await prisma.roomModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomModel.
     * @param {RoomModelCreateArgs} args - Arguments to create a RoomModel.
     * @example
     * // Create one RoomModel
     * const RoomModel = await prisma.roomModel.create({
     *   data: {
     *     // ... data to create a RoomModel
     *   }
     * })
     * 
    **/
    create<T extends RoomModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCreateArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomModels.
     *     @param {RoomModelCreateManyArgs} args - Arguments to create many RoomModels.
     *     @example
     *     // Create many RoomModels
     *     const roomModel = await prisma.roomModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomModel.
     * @param {RoomModelDeleteArgs} args - Arguments to delete one RoomModel.
     * @example
     * // Delete one RoomModel
     * const RoomModel = await prisma.roomModel.delete({
     *   where: {
     *     // ... filter to delete one RoomModel
     *   }
     * })
     * 
    **/
    delete<T extends RoomModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelDeleteArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomModel.
     * @param {RoomModelUpdateArgs} args - Arguments to update one RoomModel.
     * @example
     * // Update one RoomModel
     * const roomModel = await prisma.roomModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelUpdateArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomModels.
     * @param {RoomModelDeleteManyArgs} args - Arguments to filter RoomModels to delete.
     * @example
     * // Delete a few RoomModels
     * const { count } = await prisma.roomModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomModels
     * const roomModel = await prisma.roomModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomModel.
     * @param {RoomModelUpsertArgs} args - Arguments to update or create a RoomModel.
     * @example
     * // Update or create a RoomModel
     * const roomModel = await prisma.roomModel.upsert({
     *   create: {
     *     // ... data to create a RoomModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomModel we want to update
     *   }
     * })
    **/
    upsert<T extends RoomModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelUpsertArgs<ExtArgs>>
    ): Prisma__RoomModelClient<$Result.GetResult<Prisma.$RoomModelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCountArgs} args - Arguments to filter RoomModels to count.
     * @example
     * // Count the number of RoomModels
     * const count = await prisma.roomModel.count({
     *   where: {
     *     // ... the filter for the RoomModels we want to count
     *   }
     * })
    **/
    count<T extends RoomModelCountArgs>(
      args?: Subset<T, RoomModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomModelAggregateArgs>(args: Subset<T, RoomModelAggregateArgs>): Prisma.PrismaPromise<GetRoomModelAggregateType<T>>

    /**
     * Group by RoomModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomModelGroupByArgs['orderBy'] }
        : { orderBy?: RoomModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomModel model
   */
  readonly fields: RoomModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomModel model
   */ 
  interface RoomModelFieldRefs {
    readonly id: FieldRef<"RoomModel", 'String'>
    readonly doorX: FieldRef<"RoomModel", 'Int'>
    readonly doorY: FieldRef<"RoomModel", 'Int'>
    readonly doorZ: FieldRef<"RoomModel", 'Float'>
    readonly doorDir: FieldRef<"RoomModel", 'Int'>
    readonly heightmap: FieldRef<"RoomModel", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RoomModel findUnique
   */
  export type RoomModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * Filter, which RoomModel to fetch.
     */
    where: RoomModelWhereUniqueInput
  }


  /**
   * RoomModel findUniqueOrThrow
   */
  export type RoomModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * Filter, which RoomModel to fetch.
     */
    where: RoomModelWhereUniqueInput
  }


  /**
   * RoomModel findFirst
   */
  export type RoomModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * Filter, which RoomModel to fetch.
     */
    where?: RoomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModels to fetch.
     */
    orderBy?: RoomModelOrderByWithRelationInput | RoomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomModels.
     */
    cursor?: RoomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomModels.
     */
    distinct?: RoomModelScalarFieldEnum | RoomModelScalarFieldEnum[]
  }


  /**
   * RoomModel findFirstOrThrow
   */
  export type RoomModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * Filter, which RoomModel to fetch.
     */
    where?: RoomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModels to fetch.
     */
    orderBy?: RoomModelOrderByWithRelationInput | RoomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomModels.
     */
    cursor?: RoomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomModels.
     */
    distinct?: RoomModelScalarFieldEnum | RoomModelScalarFieldEnum[]
  }


  /**
   * RoomModel findMany
   */
  export type RoomModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * Filter, which RoomModels to fetch.
     */
    where?: RoomModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModels to fetch.
     */
    orderBy?: RoomModelOrderByWithRelationInput | RoomModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomModels.
     */
    cursor?: RoomModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModels.
     */
    skip?: number
    distinct?: RoomModelScalarFieldEnum | RoomModelScalarFieldEnum[]
  }


  /**
   * RoomModel create
   */
  export type RoomModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * The data needed to create a RoomModel.
     */
    data: XOR<RoomModelCreateInput, RoomModelUncheckedCreateInput>
  }


  /**
   * RoomModel createMany
   */
  export type RoomModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomModels.
     */
    data: RoomModelCreateManyInput | RoomModelCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomModel update
   */
  export type RoomModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * The data needed to update a RoomModel.
     */
    data: XOR<RoomModelUpdateInput, RoomModelUncheckedUpdateInput>
    /**
     * Choose, which RoomModel to update.
     */
    where: RoomModelWhereUniqueInput
  }


  /**
   * RoomModel updateMany
   */
  export type RoomModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomModels.
     */
    data: XOR<RoomModelUpdateManyMutationInput, RoomModelUncheckedUpdateManyInput>
    /**
     * Filter which RoomModels to update
     */
    where?: RoomModelWhereInput
  }


  /**
   * RoomModel upsert
   */
  export type RoomModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * The filter to search for the RoomModel to update in case it exists.
     */
    where: RoomModelWhereUniqueInput
    /**
     * In case the RoomModel found by the `where` argument doesn't exist, create a new RoomModel with this data.
     */
    create: XOR<RoomModelCreateInput, RoomModelUncheckedCreateInput>
    /**
     * In case the RoomModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomModelUpdateInput, RoomModelUncheckedUpdateInput>
  }


  /**
   * RoomModel delete
   */
  export type RoomModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
    /**
     * Filter which RoomModel to delete.
     */
    where: RoomModelWhereUniqueInput
  }


  /**
   * RoomModel deleteMany
   */
  export type RoomModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomModels to delete
     */
    where?: RoomModelWhereInput
  }


  /**
   * RoomModel without action
   */
  export type RoomModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModel
     */
    select?: RoomModelSelect<ExtArgs> | null
  }



  /**
   * Model RoomModelCustom
   */

  export type AggregateRoomModelCustom = {
    _count: RoomModelCustomCountAggregateOutputType | null
    _avg: RoomModelCustomAvgAggregateOutputType | null
    _sum: RoomModelCustomSumAggregateOutputType | null
    _min: RoomModelCustomMinAggregateOutputType | null
    _max: RoomModelCustomMaxAggregateOutputType | null
  }

  export type RoomModelCustomAvgAggregateOutputType = {
    roomId: number | null
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
    wallHeight: number | null
  }

  export type RoomModelCustomSumAggregateOutputType = {
    roomId: number | null
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
    wallHeight: number | null
  }

  export type RoomModelCustomMinAggregateOutputType = {
    roomId: number | null
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
    heightmap: string | null
    wallHeight: number | null
  }

  export type RoomModelCustomMaxAggregateOutputType = {
    roomId: number | null
    doorX: number | null
    doorY: number | null
    doorZ: number | null
    doorDir: number | null
    heightmap: string | null
    wallHeight: number | null
  }

  export type RoomModelCustomCountAggregateOutputType = {
    roomId: number
    doorX: number
    doorY: number
    doorZ: number
    doorDir: number
    heightmap: number
    wallHeight: number
    _all: number
  }


  export type RoomModelCustomAvgAggregateInputType = {
    roomId?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    wallHeight?: true
  }

  export type RoomModelCustomSumAggregateInputType = {
    roomId?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    wallHeight?: true
  }

  export type RoomModelCustomMinAggregateInputType = {
    roomId?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    heightmap?: true
    wallHeight?: true
  }

  export type RoomModelCustomMaxAggregateInputType = {
    roomId?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    heightmap?: true
    wallHeight?: true
  }

  export type RoomModelCustomCountAggregateInputType = {
    roomId?: true
    doorX?: true
    doorY?: true
    doorZ?: true
    doorDir?: true
    heightmap?: true
    wallHeight?: true
    _all?: true
  }

  export type RoomModelCustomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomModelCustom to aggregate.
     */
    where?: RoomModelCustomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModelCustoms to fetch.
     */
    orderBy?: RoomModelCustomOrderByWithRelationInput | RoomModelCustomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomModelCustomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModelCustoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModelCustoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomModelCustoms
    **/
    _count?: true | RoomModelCustomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomModelCustomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomModelCustomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomModelCustomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomModelCustomMaxAggregateInputType
  }

  export type GetRoomModelCustomAggregateType<T extends RoomModelCustomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomModelCustom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomModelCustom[P]>
      : GetScalarType<T[P], AggregateRoomModelCustom[P]>
  }




  export type RoomModelCustomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomModelCustomWhereInput
    orderBy?: RoomModelCustomOrderByWithAggregationInput | RoomModelCustomOrderByWithAggregationInput[]
    by: RoomModelCustomScalarFieldEnum[] | RoomModelCustomScalarFieldEnum
    having?: RoomModelCustomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomModelCustomCountAggregateInputType | true
    _avg?: RoomModelCustomAvgAggregateInputType
    _sum?: RoomModelCustomSumAggregateInputType
    _min?: RoomModelCustomMinAggregateInputType
    _max?: RoomModelCustomMaxAggregateInputType
  }

  export type RoomModelCustomGroupByOutputType = {
    roomId: number
    doorX: number
    doorY: number
    doorZ: number
    doorDir: number
    heightmap: string
    wallHeight: number
    _count: RoomModelCustomCountAggregateOutputType | null
    _avg: RoomModelCustomAvgAggregateOutputType | null
    _sum: RoomModelCustomSumAggregateOutputType | null
    _min: RoomModelCustomMinAggregateOutputType | null
    _max: RoomModelCustomMaxAggregateOutputType | null
  }

  type GetRoomModelCustomGroupByPayload<T extends RoomModelCustomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomModelCustomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomModelCustomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomModelCustomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomModelCustomGroupByOutputType[P]>
        }
      >
    >


  export type RoomModelCustomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    doorX?: boolean
    doorY?: boolean
    doorZ?: boolean
    doorDir?: boolean
    heightmap?: boolean
    wallHeight?: boolean
  }, ExtArgs["result"]["roomModelCustom"]>

  export type RoomModelCustomSelectScalar = {
    roomId?: boolean
    doorX?: boolean
    doorY?: boolean
    doorZ?: boolean
    doorDir?: boolean
    heightmap?: boolean
    wallHeight?: boolean
  }


  export type $RoomModelCustomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomModelCustom"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      roomId: number
      doorX: number
      doorY: number
      doorZ: number
      doorDir: number
      heightmap: string
      wallHeight: number
    }, ExtArgs["result"]["roomModelCustom"]>
    composites: {}
  }


  type RoomModelCustomGetPayload<S extends boolean | null | undefined | RoomModelCustomDefaultArgs> = $Result.GetResult<Prisma.$RoomModelCustomPayload, S>

  type RoomModelCustomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomModelCustomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomModelCustomCountAggregateInputType | true
    }

  export interface RoomModelCustomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomModelCustom'], meta: { name: 'RoomModelCustom' } }
    /**
     * Find zero or one RoomModelCustom that matches the filter.
     * @param {RoomModelCustomFindUniqueArgs} args - Arguments to find a RoomModelCustom
     * @example
     * // Get one RoomModelCustom
     * const roomModelCustom = await prisma.roomModelCustom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomModelCustomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCustomFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomModelCustom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomModelCustomFindUniqueOrThrowArgs} args - Arguments to find a RoomModelCustom
     * @example
     * // Get one RoomModelCustom
     * const roomModelCustom = await prisma.roomModelCustom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomModelCustomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCustomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomModelCustom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomFindFirstArgs} args - Arguments to find a RoomModelCustom
     * @example
     * // Get one RoomModelCustom
     * const roomModelCustom = await prisma.roomModelCustom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomModelCustomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCustomFindFirstArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomModelCustom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomFindFirstOrThrowArgs} args - Arguments to find a RoomModelCustom
     * @example
     * // Get one RoomModelCustom
     * const roomModelCustom = await prisma.roomModelCustom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomModelCustomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCustomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomModelCustoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomModelCustoms
     * const roomModelCustoms = await prisma.roomModelCustom.findMany()
     * 
     * // Get first 10 RoomModelCustoms
     * const roomModelCustoms = await prisma.roomModelCustom.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const roomModelCustomWithRoomIdOnly = await prisma.roomModelCustom.findMany({ select: { roomId: true } })
     * 
    **/
    findMany<T extends RoomModelCustomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCustomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomModelCustom.
     * @param {RoomModelCustomCreateArgs} args - Arguments to create a RoomModelCustom.
     * @example
     * // Create one RoomModelCustom
     * const RoomModelCustom = await prisma.roomModelCustom.create({
     *   data: {
     *     // ... data to create a RoomModelCustom
     *   }
     * })
     * 
    **/
    create<T extends RoomModelCustomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCustomCreateArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomModelCustoms.
     *     @param {RoomModelCustomCreateManyArgs} args - Arguments to create many RoomModelCustoms.
     *     @example
     *     // Create many RoomModelCustoms
     *     const roomModelCustom = await prisma.roomModelCustom.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomModelCustomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCustomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomModelCustom.
     * @param {RoomModelCustomDeleteArgs} args - Arguments to delete one RoomModelCustom.
     * @example
     * // Delete one RoomModelCustom
     * const RoomModelCustom = await prisma.roomModelCustom.delete({
     *   where: {
     *     // ... filter to delete one RoomModelCustom
     *   }
     * })
     * 
    **/
    delete<T extends RoomModelCustomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCustomDeleteArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomModelCustom.
     * @param {RoomModelCustomUpdateArgs} args - Arguments to update one RoomModelCustom.
     * @example
     * // Update one RoomModelCustom
     * const roomModelCustom = await prisma.roomModelCustom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomModelCustomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCustomUpdateArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomModelCustoms.
     * @param {RoomModelCustomDeleteManyArgs} args - Arguments to filter RoomModelCustoms to delete.
     * @example
     * // Delete a few RoomModelCustoms
     * const { count } = await prisma.roomModelCustom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomModelCustomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomModelCustomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomModelCustoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomModelCustoms
     * const roomModelCustom = await prisma.roomModelCustom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomModelCustomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCustomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomModelCustom.
     * @param {RoomModelCustomUpsertArgs} args - Arguments to update or create a RoomModelCustom.
     * @example
     * // Update or create a RoomModelCustom
     * const roomModelCustom = await prisma.roomModelCustom.upsert({
     *   create: {
     *     // ... data to create a RoomModelCustom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomModelCustom we want to update
     *   }
     * })
    **/
    upsert<T extends RoomModelCustomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomModelCustomUpsertArgs<ExtArgs>>
    ): Prisma__RoomModelCustomClient<$Result.GetResult<Prisma.$RoomModelCustomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomModelCustoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomCountArgs} args - Arguments to filter RoomModelCustoms to count.
     * @example
     * // Count the number of RoomModelCustoms
     * const count = await prisma.roomModelCustom.count({
     *   where: {
     *     // ... the filter for the RoomModelCustoms we want to count
     *   }
     * })
    **/
    count<T extends RoomModelCustomCountArgs>(
      args?: Subset<T, RoomModelCustomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomModelCustomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomModelCustom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomModelCustomAggregateArgs>(args: Subset<T, RoomModelCustomAggregateArgs>): Prisma.PrismaPromise<GetRoomModelCustomAggregateType<T>>

    /**
     * Group by RoomModelCustom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomModelCustomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomModelCustomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomModelCustomGroupByArgs['orderBy'] }
        : { orderBy?: RoomModelCustomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomModelCustomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomModelCustomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomModelCustom model
   */
  readonly fields: RoomModelCustomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomModelCustom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomModelCustomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomModelCustom model
   */ 
  interface RoomModelCustomFieldRefs {
    readonly roomId: FieldRef<"RoomModelCustom", 'Int'>
    readonly doorX: FieldRef<"RoomModelCustom", 'Int'>
    readonly doorY: FieldRef<"RoomModelCustom", 'Int'>
    readonly doorZ: FieldRef<"RoomModelCustom", 'Float'>
    readonly doorDir: FieldRef<"RoomModelCustom", 'Int'>
    readonly heightmap: FieldRef<"RoomModelCustom", 'String'>
    readonly wallHeight: FieldRef<"RoomModelCustom", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RoomModelCustom findUnique
   */
  export type RoomModelCustomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * Filter, which RoomModelCustom to fetch.
     */
    where: RoomModelCustomWhereUniqueInput
  }


  /**
   * RoomModelCustom findUniqueOrThrow
   */
  export type RoomModelCustomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * Filter, which RoomModelCustom to fetch.
     */
    where: RoomModelCustomWhereUniqueInput
  }


  /**
   * RoomModelCustom findFirst
   */
  export type RoomModelCustomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * Filter, which RoomModelCustom to fetch.
     */
    where?: RoomModelCustomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModelCustoms to fetch.
     */
    orderBy?: RoomModelCustomOrderByWithRelationInput | RoomModelCustomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomModelCustoms.
     */
    cursor?: RoomModelCustomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModelCustoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModelCustoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomModelCustoms.
     */
    distinct?: RoomModelCustomScalarFieldEnum | RoomModelCustomScalarFieldEnum[]
  }


  /**
   * RoomModelCustom findFirstOrThrow
   */
  export type RoomModelCustomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * Filter, which RoomModelCustom to fetch.
     */
    where?: RoomModelCustomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModelCustoms to fetch.
     */
    orderBy?: RoomModelCustomOrderByWithRelationInput | RoomModelCustomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomModelCustoms.
     */
    cursor?: RoomModelCustomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModelCustoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModelCustoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomModelCustoms.
     */
    distinct?: RoomModelCustomScalarFieldEnum | RoomModelCustomScalarFieldEnum[]
  }


  /**
   * RoomModelCustom findMany
   */
  export type RoomModelCustomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * Filter, which RoomModelCustoms to fetch.
     */
    where?: RoomModelCustomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomModelCustoms to fetch.
     */
    orderBy?: RoomModelCustomOrderByWithRelationInput | RoomModelCustomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomModelCustoms.
     */
    cursor?: RoomModelCustomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomModelCustoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomModelCustoms.
     */
    skip?: number
    distinct?: RoomModelCustomScalarFieldEnum | RoomModelCustomScalarFieldEnum[]
  }


  /**
   * RoomModelCustom create
   */
  export type RoomModelCustomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * The data needed to create a RoomModelCustom.
     */
    data: XOR<RoomModelCustomCreateInput, RoomModelCustomUncheckedCreateInput>
  }


  /**
   * RoomModelCustom createMany
   */
  export type RoomModelCustomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomModelCustoms.
     */
    data: RoomModelCustomCreateManyInput | RoomModelCustomCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomModelCustom update
   */
  export type RoomModelCustomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * The data needed to update a RoomModelCustom.
     */
    data: XOR<RoomModelCustomUpdateInput, RoomModelCustomUncheckedUpdateInput>
    /**
     * Choose, which RoomModelCustom to update.
     */
    where: RoomModelCustomWhereUniqueInput
  }


  /**
   * RoomModelCustom updateMany
   */
  export type RoomModelCustomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomModelCustoms.
     */
    data: XOR<RoomModelCustomUpdateManyMutationInput, RoomModelCustomUncheckedUpdateManyInput>
    /**
     * Filter which RoomModelCustoms to update
     */
    where?: RoomModelCustomWhereInput
  }


  /**
   * RoomModelCustom upsert
   */
  export type RoomModelCustomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * The filter to search for the RoomModelCustom to update in case it exists.
     */
    where: RoomModelCustomWhereUniqueInput
    /**
     * In case the RoomModelCustom found by the `where` argument doesn't exist, create a new RoomModelCustom with this data.
     */
    create: XOR<RoomModelCustomCreateInput, RoomModelCustomUncheckedCreateInput>
    /**
     * In case the RoomModelCustom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomModelCustomUpdateInput, RoomModelCustomUncheckedUpdateInput>
  }


  /**
   * RoomModelCustom delete
   */
  export type RoomModelCustomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
    /**
     * Filter which RoomModelCustom to delete.
     */
    where: RoomModelCustomWhereUniqueInput
  }


  /**
   * RoomModelCustom deleteMany
   */
  export type RoomModelCustomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomModelCustoms to delete
     */
    where?: RoomModelCustomWhereInput
  }


  /**
   * RoomModelCustom without action
   */
  export type RoomModelCustomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomModelCustom
     */
    select?: RoomModelCustomSelect<ExtArgs> | null
  }



  /**
   * Model RoomRight
   */

  export type AggregateRoomRight = {
    _count: RoomRightCountAggregateOutputType | null
    _avg: RoomRightAvgAggregateOutputType | null
    _sum: RoomRightSumAggregateOutputType | null
    _min: RoomRightMinAggregateOutputType | null
    _max: RoomRightMaxAggregateOutputType | null
  }

  export type RoomRightAvgAggregateOutputType = {
    roomId: number | null
    userId: number | null
  }

  export type RoomRightSumAggregateOutputType = {
    roomId: number | null
    userId: number | null
  }

  export type RoomRightMinAggregateOutputType = {
    roomId: number | null
    userId: number | null
  }

  export type RoomRightMaxAggregateOutputType = {
    roomId: number | null
    userId: number | null
  }

  export type RoomRightCountAggregateOutputType = {
    roomId: number
    userId: number
    _all: number
  }


  export type RoomRightAvgAggregateInputType = {
    roomId?: true
    userId?: true
  }

  export type RoomRightSumAggregateInputType = {
    roomId?: true
    userId?: true
  }

  export type RoomRightMinAggregateInputType = {
    roomId?: true
    userId?: true
  }

  export type RoomRightMaxAggregateInputType = {
    roomId?: true
    userId?: true
  }

  export type RoomRightCountAggregateInputType = {
    roomId?: true
    userId?: true
    _all?: true
  }

  export type RoomRightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomRight to aggregate.
     */
    where?: RoomRightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomRights to fetch.
     */
    orderBy?: RoomRightOrderByWithRelationInput | RoomRightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomRightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomRights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomRights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomRights
    **/
    _count?: true | RoomRightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomRightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomRightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomRightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomRightMaxAggregateInputType
  }

  export type GetRoomRightAggregateType<T extends RoomRightAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomRight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomRight[P]>
      : GetScalarType<T[P], AggregateRoomRight[P]>
  }




  export type RoomRightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomRightWhereInput
    orderBy?: RoomRightOrderByWithAggregationInput | RoomRightOrderByWithAggregationInput[]
    by: RoomRightScalarFieldEnum[] | RoomRightScalarFieldEnum
    having?: RoomRightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomRightCountAggregateInputType | true
    _avg?: RoomRightAvgAggregateInputType
    _sum?: RoomRightSumAggregateInputType
    _min?: RoomRightMinAggregateInputType
    _max?: RoomRightMaxAggregateInputType
  }

  export type RoomRightGroupByOutputType = {
    roomId: number
    userId: number
    _count: RoomRightCountAggregateOutputType | null
    _avg: RoomRightAvgAggregateOutputType | null
    _sum: RoomRightSumAggregateOutputType | null
    _min: RoomRightMinAggregateOutputType | null
    _max: RoomRightMaxAggregateOutputType | null
  }

  type GetRoomRightGroupByPayload<T extends RoomRightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomRightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomRightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomRightGroupByOutputType[P]>
            : GetScalarType<T[P], RoomRightGroupByOutputType[P]>
        }
      >
    >


  export type RoomRightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    userId?: boolean
  }, ExtArgs["result"]["roomRight"]>

  export type RoomRightSelectScalar = {
    roomId?: boolean
    userId?: boolean
  }


  export type $RoomRightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomRight"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      roomId: number
      userId: number
    }, ExtArgs["result"]["roomRight"]>
    composites: {}
  }


  type RoomRightGetPayload<S extends boolean | null | undefined | RoomRightDefaultArgs> = $Result.GetResult<Prisma.$RoomRightPayload, S>

  type RoomRightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomRightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomRightCountAggregateInputType | true
    }

  export interface RoomRightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomRight'], meta: { name: 'RoomRight' } }
    /**
     * Find zero or one RoomRight that matches the filter.
     * @param {RoomRightFindUniqueArgs} args - Arguments to find a RoomRight
     * @example
     * // Get one RoomRight
     * const roomRight = await prisma.roomRight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomRightFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomRightFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomRight that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomRightFindUniqueOrThrowArgs} args - Arguments to find a RoomRight
     * @example
     * // Get one RoomRight
     * const roomRight = await prisma.roomRight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomRightFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomRightFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomRight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightFindFirstArgs} args - Arguments to find a RoomRight
     * @example
     * // Get one RoomRight
     * const roomRight = await prisma.roomRight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomRightFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomRightFindFirstArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomRight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightFindFirstOrThrowArgs} args - Arguments to find a RoomRight
     * @example
     * // Get one RoomRight
     * const roomRight = await prisma.roomRight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomRightFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomRightFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomRights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomRights
     * const roomRights = await prisma.roomRight.findMany()
     * 
     * // Get first 10 RoomRights
     * const roomRights = await prisma.roomRight.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const roomRightWithRoomIdOnly = await prisma.roomRight.findMany({ select: { roomId: true } })
     * 
    **/
    findMany<T extends RoomRightFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomRightFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomRight.
     * @param {RoomRightCreateArgs} args - Arguments to create a RoomRight.
     * @example
     * // Create one RoomRight
     * const RoomRight = await prisma.roomRight.create({
     *   data: {
     *     // ... data to create a RoomRight
     *   }
     * })
     * 
    **/
    create<T extends RoomRightCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomRightCreateArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomRights.
     *     @param {RoomRightCreateManyArgs} args - Arguments to create many RoomRights.
     *     @example
     *     // Create many RoomRights
     *     const roomRight = await prisma.roomRight.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomRightCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomRightCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomRight.
     * @param {RoomRightDeleteArgs} args - Arguments to delete one RoomRight.
     * @example
     * // Delete one RoomRight
     * const RoomRight = await prisma.roomRight.delete({
     *   where: {
     *     // ... filter to delete one RoomRight
     *   }
     * })
     * 
    **/
    delete<T extends RoomRightDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomRightDeleteArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomRight.
     * @param {RoomRightUpdateArgs} args - Arguments to update one RoomRight.
     * @example
     * // Update one RoomRight
     * const roomRight = await prisma.roomRight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomRightUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomRightUpdateArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomRights.
     * @param {RoomRightDeleteManyArgs} args - Arguments to filter RoomRights to delete.
     * @example
     * // Delete a few RoomRights
     * const { count } = await prisma.roomRight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomRightDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomRightDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomRights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomRights
     * const roomRight = await prisma.roomRight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomRightUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomRightUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomRight.
     * @param {RoomRightUpsertArgs} args - Arguments to update or create a RoomRight.
     * @example
     * // Update or create a RoomRight
     * const roomRight = await prisma.roomRight.upsert({
     *   create: {
     *     // ... data to create a RoomRight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomRight we want to update
     *   }
     * })
    **/
    upsert<T extends RoomRightUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomRightUpsertArgs<ExtArgs>>
    ): Prisma__RoomRightClient<$Result.GetResult<Prisma.$RoomRightPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomRights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightCountArgs} args - Arguments to filter RoomRights to count.
     * @example
     * // Count the number of RoomRights
     * const count = await prisma.roomRight.count({
     *   where: {
     *     // ... the filter for the RoomRights we want to count
     *   }
     * })
    **/
    count<T extends RoomRightCountArgs>(
      args?: Subset<T, RoomRightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomRightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomRight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomRightAggregateArgs>(args: Subset<T, RoomRightAggregateArgs>): Prisma.PrismaPromise<GetRoomRightAggregateType<T>>

    /**
     * Group by RoomRight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomRightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomRightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomRightGroupByArgs['orderBy'] }
        : { orderBy?: RoomRightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomRightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomRightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomRight model
   */
  readonly fields: RoomRightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomRight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomRightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomRight model
   */ 
  interface RoomRightFieldRefs {
    readonly roomId: FieldRef<"RoomRight", 'Int'>
    readonly userId: FieldRef<"RoomRight", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RoomRight findUnique
   */
  export type RoomRightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * Filter, which RoomRight to fetch.
     */
    where: RoomRightWhereUniqueInput
  }


  /**
   * RoomRight findUniqueOrThrow
   */
  export type RoomRightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * Filter, which RoomRight to fetch.
     */
    where: RoomRightWhereUniqueInput
  }


  /**
   * RoomRight findFirst
   */
  export type RoomRightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * Filter, which RoomRight to fetch.
     */
    where?: RoomRightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomRights to fetch.
     */
    orderBy?: RoomRightOrderByWithRelationInput | RoomRightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomRights.
     */
    cursor?: RoomRightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomRights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomRights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomRights.
     */
    distinct?: RoomRightScalarFieldEnum | RoomRightScalarFieldEnum[]
  }


  /**
   * RoomRight findFirstOrThrow
   */
  export type RoomRightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * Filter, which RoomRight to fetch.
     */
    where?: RoomRightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomRights to fetch.
     */
    orderBy?: RoomRightOrderByWithRelationInput | RoomRightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomRights.
     */
    cursor?: RoomRightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomRights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomRights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomRights.
     */
    distinct?: RoomRightScalarFieldEnum | RoomRightScalarFieldEnum[]
  }


  /**
   * RoomRight findMany
   */
  export type RoomRightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * Filter, which RoomRights to fetch.
     */
    where?: RoomRightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomRights to fetch.
     */
    orderBy?: RoomRightOrderByWithRelationInput | RoomRightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomRights.
     */
    cursor?: RoomRightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomRights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomRights.
     */
    skip?: number
    distinct?: RoomRightScalarFieldEnum | RoomRightScalarFieldEnum[]
  }


  /**
   * RoomRight create
   */
  export type RoomRightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * The data needed to create a RoomRight.
     */
    data: XOR<RoomRightCreateInput, RoomRightUncheckedCreateInput>
  }


  /**
   * RoomRight createMany
   */
  export type RoomRightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomRights.
     */
    data: RoomRightCreateManyInput | RoomRightCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomRight update
   */
  export type RoomRightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * The data needed to update a RoomRight.
     */
    data: XOR<RoomRightUpdateInput, RoomRightUncheckedUpdateInput>
    /**
     * Choose, which RoomRight to update.
     */
    where: RoomRightWhereUniqueInput
  }


  /**
   * RoomRight updateMany
   */
  export type RoomRightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomRights.
     */
    data: XOR<RoomRightUpdateManyMutationInput, RoomRightUncheckedUpdateManyInput>
    /**
     * Filter which RoomRights to update
     */
    where?: RoomRightWhereInput
  }


  /**
   * RoomRight upsert
   */
  export type RoomRightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * The filter to search for the RoomRight to update in case it exists.
     */
    where: RoomRightWhereUniqueInput
    /**
     * In case the RoomRight found by the `where` argument doesn't exist, create a new RoomRight with this data.
     */
    create: XOR<RoomRightCreateInput, RoomRightUncheckedCreateInput>
    /**
     * In case the RoomRight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomRightUpdateInput, RoomRightUncheckedUpdateInput>
  }


  /**
   * RoomRight delete
   */
  export type RoomRightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
    /**
     * Filter which RoomRight to delete.
     */
    where: RoomRightWhereUniqueInput
  }


  /**
   * RoomRight deleteMany
   */
  export type RoomRightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomRights to delete
     */
    where?: RoomRightWhereInput
  }


  /**
   * RoomRight without action
   */
  export type RoomRightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomRight
     */
    select?: RoomRightSelect<ExtArgs> | null
  }



  /**
   * Model RoomSwearwordFilter
   */

  export type AggregateRoomSwearwordFilter = {
    _count: RoomSwearwordFilterCountAggregateOutputType | null
    _min: RoomSwearwordFilterMinAggregateOutputType | null
    _max: RoomSwearwordFilterMaxAggregateOutputType | null
  }

  export type RoomSwearwordFilterMinAggregateOutputType = {
    word: string | null
  }

  export type RoomSwearwordFilterMaxAggregateOutputType = {
    word: string | null
  }

  export type RoomSwearwordFilterCountAggregateOutputType = {
    word: number
    _all: number
  }


  export type RoomSwearwordFilterMinAggregateInputType = {
    word?: true
  }

  export type RoomSwearwordFilterMaxAggregateInputType = {
    word?: true
  }

  export type RoomSwearwordFilterCountAggregateInputType = {
    word?: true
    _all?: true
  }

  export type RoomSwearwordFilterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomSwearwordFilter to aggregate.
     */
    where?: RoomSwearwordFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomSwearwordFilters to fetch.
     */
    orderBy?: RoomSwearwordFilterOrderByWithRelationInput | RoomSwearwordFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomSwearwordFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomSwearwordFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomSwearwordFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomSwearwordFilters
    **/
    _count?: true | RoomSwearwordFilterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomSwearwordFilterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomSwearwordFilterMaxAggregateInputType
  }

  export type GetRoomSwearwordFilterAggregateType<T extends RoomSwearwordFilterAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomSwearwordFilter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomSwearwordFilter[P]>
      : GetScalarType<T[P], AggregateRoomSwearwordFilter[P]>
  }




  export type RoomSwearwordFilterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomSwearwordFilterWhereInput
    orderBy?: RoomSwearwordFilterOrderByWithAggregationInput | RoomSwearwordFilterOrderByWithAggregationInput[]
    by: RoomSwearwordFilterScalarFieldEnum[] | RoomSwearwordFilterScalarFieldEnum
    having?: RoomSwearwordFilterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomSwearwordFilterCountAggregateInputType | true
    _min?: RoomSwearwordFilterMinAggregateInputType
    _max?: RoomSwearwordFilterMaxAggregateInputType
  }

  export type RoomSwearwordFilterGroupByOutputType = {
    word: string
    _count: RoomSwearwordFilterCountAggregateOutputType | null
    _min: RoomSwearwordFilterMinAggregateOutputType | null
    _max: RoomSwearwordFilterMaxAggregateOutputType | null
  }

  type GetRoomSwearwordFilterGroupByPayload<T extends RoomSwearwordFilterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomSwearwordFilterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomSwearwordFilterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomSwearwordFilterGroupByOutputType[P]>
            : GetScalarType<T[P], RoomSwearwordFilterGroupByOutputType[P]>
        }
      >
    >


  export type RoomSwearwordFilterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    word?: boolean
  }, ExtArgs["result"]["roomSwearwordFilter"]>

  export type RoomSwearwordFilterSelectScalar = {
    word?: boolean
  }


  export type $RoomSwearwordFilterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomSwearwordFilter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      word: string
    }, ExtArgs["result"]["roomSwearwordFilter"]>
    composites: {}
  }


  type RoomSwearwordFilterGetPayload<S extends boolean | null | undefined | RoomSwearwordFilterDefaultArgs> = $Result.GetResult<Prisma.$RoomSwearwordFilterPayload, S>

  type RoomSwearwordFilterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomSwearwordFilterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomSwearwordFilterCountAggregateInputType | true
    }

  export interface RoomSwearwordFilterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomSwearwordFilter'], meta: { name: 'RoomSwearwordFilter' } }
    /**
     * Find zero or one RoomSwearwordFilter that matches the filter.
     * @param {RoomSwearwordFilterFindUniqueArgs} args - Arguments to find a RoomSwearwordFilter
     * @example
     * // Get one RoomSwearwordFilter
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomSwearwordFilterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomSwearwordFilterFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomSwearwordFilter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomSwearwordFilterFindUniqueOrThrowArgs} args - Arguments to find a RoomSwearwordFilter
     * @example
     * // Get one RoomSwearwordFilter
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomSwearwordFilterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomSwearwordFilterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomSwearwordFilter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterFindFirstArgs} args - Arguments to find a RoomSwearwordFilter
     * @example
     * // Get one RoomSwearwordFilter
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomSwearwordFilterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomSwearwordFilterFindFirstArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomSwearwordFilter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterFindFirstOrThrowArgs} args - Arguments to find a RoomSwearwordFilter
     * @example
     * // Get one RoomSwearwordFilter
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomSwearwordFilterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomSwearwordFilterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomSwearwordFilters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomSwearwordFilters
     * const roomSwearwordFilters = await prisma.roomSwearwordFilter.findMany()
     * 
     * // Get first 10 RoomSwearwordFilters
     * const roomSwearwordFilters = await prisma.roomSwearwordFilter.findMany({ take: 10 })
     * 
     * // Only select the `word`
     * const roomSwearwordFilterWithWordOnly = await prisma.roomSwearwordFilter.findMany({ select: { word: true } })
     * 
    **/
    findMany<T extends RoomSwearwordFilterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomSwearwordFilterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomSwearwordFilter.
     * @param {RoomSwearwordFilterCreateArgs} args - Arguments to create a RoomSwearwordFilter.
     * @example
     * // Create one RoomSwearwordFilter
     * const RoomSwearwordFilter = await prisma.roomSwearwordFilter.create({
     *   data: {
     *     // ... data to create a RoomSwearwordFilter
     *   }
     * })
     * 
    **/
    create<T extends RoomSwearwordFilterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomSwearwordFilterCreateArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomSwearwordFilters.
     *     @param {RoomSwearwordFilterCreateManyArgs} args - Arguments to create many RoomSwearwordFilters.
     *     @example
     *     // Create many RoomSwearwordFilters
     *     const roomSwearwordFilter = await prisma.roomSwearwordFilter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomSwearwordFilterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomSwearwordFilterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomSwearwordFilter.
     * @param {RoomSwearwordFilterDeleteArgs} args - Arguments to delete one RoomSwearwordFilter.
     * @example
     * // Delete one RoomSwearwordFilter
     * const RoomSwearwordFilter = await prisma.roomSwearwordFilter.delete({
     *   where: {
     *     // ... filter to delete one RoomSwearwordFilter
     *   }
     * })
     * 
    **/
    delete<T extends RoomSwearwordFilterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomSwearwordFilterDeleteArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomSwearwordFilter.
     * @param {RoomSwearwordFilterUpdateArgs} args - Arguments to update one RoomSwearwordFilter.
     * @example
     * // Update one RoomSwearwordFilter
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomSwearwordFilterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomSwearwordFilterUpdateArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomSwearwordFilters.
     * @param {RoomSwearwordFilterDeleteManyArgs} args - Arguments to filter RoomSwearwordFilters to delete.
     * @example
     * // Delete a few RoomSwearwordFilters
     * const { count } = await prisma.roomSwearwordFilter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomSwearwordFilterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomSwearwordFilterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomSwearwordFilters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomSwearwordFilters
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomSwearwordFilterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomSwearwordFilterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomSwearwordFilter.
     * @param {RoomSwearwordFilterUpsertArgs} args - Arguments to update or create a RoomSwearwordFilter.
     * @example
     * // Update or create a RoomSwearwordFilter
     * const roomSwearwordFilter = await prisma.roomSwearwordFilter.upsert({
     *   create: {
     *     // ... data to create a RoomSwearwordFilter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomSwearwordFilter we want to update
     *   }
     * })
    **/
    upsert<T extends RoomSwearwordFilterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomSwearwordFilterUpsertArgs<ExtArgs>>
    ): Prisma__RoomSwearwordFilterClient<$Result.GetResult<Prisma.$RoomSwearwordFilterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomSwearwordFilters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterCountArgs} args - Arguments to filter RoomSwearwordFilters to count.
     * @example
     * // Count the number of RoomSwearwordFilters
     * const count = await prisma.roomSwearwordFilter.count({
     *   where: {
     *     // ... the filter for the RoomSwearwordFilters we want to count
     *   }
     * })
    **/
    count<T extends RoomSwearwordFilterCountArgs>(
      args?: Subset<T, RoomSwearwordFilterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomSwearwordFilterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomSwearwordFilter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomSwearwordFilterAggregateArgs>(args: Subset<T, RoomSwearwordFilterAggregateArgs>): Prisma.PrismaPromise<GetRoomSwearwordFilterAggregateType<T>>

    /**
     * Group by RoomSwearwordFilter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomSwearwordFilterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomSwearwordFilterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomSwearwordFilterGroupByArgs['orderBy'] }
        : { orderBy?: RoomSwearwordFilterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomSwearwordFilterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomSwearwordFilterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomSwearwordFilter model
   */
  readonly fields: RoomSwearwordFilterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomSwearwordFilter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomSwearwordFilterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomSwearwordFilter model
   */ 
  interface RoomSwearwordFilterFieldRefs {
    readonly word: FieldRef<"RoomSwearwordFilter", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RoomSwearwordFilter findUnique
   */
  export type RoomSwearwordFilterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * Filter, which RoomSwearwordFilter to fetch.
     */
    where: RoomSwearwordFilterWhereUniqueInput
  }


  /**
   * RoomSwearwordFilter findUniqueOrThrow
   */
  export type RoomSwearwordFilterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * Filter, which RoomSwearwordFilter to fetch.
     */
    where: RoomSwearwordFilterWhereUniqueInput
  }


  /**
   * RoomSwearwordFilter findFirst
   */
  export type RoomSwearwordFilterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * Filter, which RoomSwearwordFilter to fetch.
     */
    where?: RoomSwearwordFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomSwearwordFilters to fetch.
     */
    orderBy?: RoomSwearwordFilterOrderByWithRelationInput | RoomSwearwordFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomSwearwordFilters.
     */
    cursor?: RoomSwearwordFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomSwearwordFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomSwearwordFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomSwearwordFilters.
     */
    distinct?: RoomSwearwordFilterScalarFieldEnum | RoomSwearwordFilterScalarFieldEnum[]
  }


  /**
   * RoomSwearwordFilter findFirstOrThrow
   */
  export type RoomSwearwordFilterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * Filter, which RoomSwearwordFilter to fetch.
     */
    where?: RoomSwearwordFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomSwearwordFilters to fetch.
     */
    orderBy?: RoomSwearwordFilterOrderByWithRelationInput | RoomSwearwordFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomSwearwordFilters.
     */
    cursor?: RoomSwearwordFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomSwearwordFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomSwearwordFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomSwearwordFilters.
     */
    distinct?: RoomSwearwordFilterScalarFieldEnum | RoomSwearwordFilterScalarFieldEnum[]
  }


  /**
   * RoomSwearwordFilter findMany
   */
  export type RoomSwearwordFilterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * Filter, which RoomSwearwordFilters to fetch.
     */
    where?: RoomSwearwordFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomSwearwordFilters to fetch.
     */
    orderBy?: RoomSwearwordFilterOrderByWithRelationInput | RoomSwearwordFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomSwearwordFilters.
     */
    cursor?: RoomSwearwordFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomSwearwordFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomSwearwordFilters.
     */
    skip?: number
    distinct?: RoomSwearwordFilterScalarFieldEnum | RoomSwearwordFilterScalarFieldEnum[]
  }


  /**
   * RoomSwearwordFilter create
   */
  export type RoomSwearwordFilterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * The data needed to create a RoomSwearwordFilter.
     */
    data: XOR<RoomSwearwordFilterCreateInput, RoomSwearwordFilterUncheckedCreateInput>
  }


  /**
   * RoomSwearwordFilter createMany
   */
  export type RoomSwearwordFilterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomSwearwordFilters.
     */
    data: RoomSwearwordFilterCreateManyInput | RoomSwearwordFilterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomSwearwordFilter update
   */
  export type RoomSwearwordFilterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * The data needed to update a RoomSwearwordFilter.
     */
    data: XOR<RoomSwearwordFilterUpdateInput, RoomSwearwordFilterUncheckedUpdateInput>
    /**
     * Choose, which RoomSwearwordFilter to update.
     */
    where: RoomSwearwordFilterWhereUniqueInput
  }


  /**
   * RoomSwearwordFilter updateMany
   */
  export type RoomSwearwordFilterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomSwearwordFilters.
     */
    data: XOR<RoomSwearwordFilterUpdateManyMutationInput, RoomSwearwordFilterUncheckedUpdateManyInput>
    /**
     * Filter which RoomSwearwordFilters to update
     */
    where?: RoomSwearwordFilterWhereInput
  }


  /**
   * RoomSwearwordFilter upsert
   */
  export type RoomSwearwordFilterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * The filter to search for the RoomSwearwordFilter to update in case it exists.
     */
    where: RoomSwearwordFilterWhereUniqueInput
    /**
     * In case the RoomSwearwordFilter found by the `where` argument doesn't exist, create a new RoomSwearwordFilter with this data.
     */
    create: XOR<RoomSwearwordFilterCreateInput, RoomSwearwordFilterUncheckedCreateInput>
    /**
     * In case the RoomSwearwordFilter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomSwearwordFilterUpdateInput, RoomSwearwordFilterUncheckedUpdateInput>
  }


  /**
   * RoomSwearwordFilter delete
   */
  export type RoomSwearwordFilterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
    /**
     * Filter which RoomSwearwordFilter to delete.
     */
    where: RoomSwearwordFilterWhereUniqueInput
  }


  /**
   * RoomSwearwordFilter deleteMany
   */
  export type RoomSwearwordFilterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomSwearwordFilters to delete
     */
    where?: RoomSwearwordFilterWhereInput
  }


  /**
   * RoomSwearwordFilter without action
   */
  export type RoomSwearwordFilterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomSwearwordFilter
     */
    select?: RoomSwearwordFilterSelect<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    rank: number | null
    credits: number | null
    activityPoints: number | null
    accountCreated: number | null
    lastOnline: number | null
    homeRoom: number | null
    lastOffline: number | null
    moisVip: number | null
    vipPoints: number | null
    limitCoins: number | null
    gamePoints: number | null
    gamePointsMonth: number | null
    mazoscore: number | null
    mazo: number | null
    runPoints: number | null
    runPointsMonth: number | null
    bannerId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    rank: number | null
    credits: number | null
    activityPoints: number | null
    accountCreated: number | null
    lastOnline: number | null
    homeRoom: number | null
    lastOffline: number | null
    moisVip: number | null
    vipPoints: number | null
    limitCoins: number | null
    gamePoints: number | null
    gamePointsMonth: number | null
    mazoscore: number | null
    mazo: number | null
    runPoints: number | null
    runPointsMonth: number | null
    bannerId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    mail: string | null
    authTicket: string | null
    rank: number | null
    credits: number | null
    activityPoints: number | null
    look: string | null
    gender: $Enums.UserGender | null
    motto: string | null
    accountCreated: number | null
    lastOnline: number | null
    online: boolean | null
    ipLast: string | null
    machineId: string | null
    homeRoom: number | null
    blockNewfriends: boolean | null
    hideOnline: boolean | null
    hideInroom: boolean | null
    lastOffline: number | null
    moisVip: number | null
    volume: string | null
    vipPoints: number | null
    limitCoins: number | null
    acceptTrading: boolean | null
    cameraFollowDisabled: boolean | null
    ignoreRoomInvite: boolean | null
    lastdailycredits: string | null
    hideGamealert: boolean | null
    ipcountry: string | null
    gamePoints: number | null
    gamePointsMonth: number | null
    mazoscore: number | null
    mazo: number | null
    nuxEnable: boolean | null
    langue: $Enums.UserLangue | null
    runPoints: number | null
    runPointsMonth: number | null
    isBanned: boolean | null
    bannerId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    mail: string | null
    authTicket: string | null
    rank: number | null
    credits: number | null
    activityPoints: number | null
    look: string | null
    gender: $Enums.UserGender | null
    motto: string | null
    accountCreated: number | null
    lastOnline: number | null
    online: boolean | null
    ipLast: string | null
    machineId: string | null
    homeRoom: number | null
    blockNewfriends: boolean | null
    hideOnline: boolean | null
    hideInroom: boolean | null
    lastOffline: number | null
    moisVip: number | null
    volume: string | null
    vipPoints: number | null
    limitCoins: number | null
    acceptTrading: boolean | null
    cameraFollowDisabled: boolean | null
    ignoreRoomInvite: boolean | null
    lastdailycredits: string | null
    hideGamealert: boolean | null
    ipcountry: string | null
    gamePoints: number | null
    gamePointsMonth: number | null
    mazoscore: number | null
    mazo: number | null
    nuxEnable: boolean | null
    langue: $Enums.UserLangue | null
    runPoints: number | null
    runPointsMonth: number | null
    isBanned: boolean | null
    bannerId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    mail: number
    authTicket: number
    rank: number
    credits: number
    activityPoints: number
    look: number
    gender: number
    motto: number
    accountCreated: number
    lastOnline: number
    online: number
    ipLast: number
    machineId: number
    homeRoom: number
    blockNewfriends: number
    hideOnline: number
    hideInroom: number
    lastOffline: number
    moisVip: number
    volume: number
    vipPoints: number
    limitCoins: number
    acceptTrading: number
    cameraFollowDisabled: number
    ignoreRoomInvite: number
    lastdailycredits: number
    hideGamealert: number
    ipcountry: number
    gamePoints: number
    gamePointsMonth: number
    mazoscore: number
    mazo: number
    nuxEnable: number
    langue: number
    runPoints: number
    runPointsMonth: number
    isBanned: number
    bannerId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    rank?: true
    credits?: true
    activityPoints?: true
    accountCreated?: true
    lastOnline?: true
    homeRoom?: true
    lastOffline?: true
    moisVip?: true
    vipPoints?: true
    limitCoins?: true
    gamePoints?: true
    gamePointsMonth?: true
    mazoscore?: true
    mazo?: true
    runPoints?: true
    runPointsMonth?: true
    bannerId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    rank?: true
    credits?: true
    activityPoints?: true
    accountCreated?: true
    lastOnline?: true
    homeRoom?: true
    lastOffline?: true
    moisVip?: true
    vipPoints?: true
    limitCoins?: true
    gamePoints?: true
    gamePointsMonth?: true
    mazoscore?: true
    mazo?: true
    runPoints?: true
    runPointsMonth?: true
    bannerId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    mail?: true
    authTicket?: true
    rank?: true
    credits?: true
    activityPoints?: true
    look?: true
    gender?: true
    motto?: true
    accountCreated?: true
    lastOnline?: true
    online?: true
    ipLast?: true
    machineId?: true
    homeRoom?: true
    blockNewfriends?: true
    hideOnline?: true
    hideInroom?: true
    lastOffline?: true
    moisVip?: true
    volume?: true
    vipPoints?: true
    limitCoins?: true
    acceptTrading?: true
    cameraFollowDisabled?: true
    ignoreRoomInvite?: true
    lastdailycredits?: true
    hideGamealert?: true
    ipcountry?: true
    gamePoints?: true
    gamePointsMonth?: true
    mazoscore?: true
    mazo?: true
    nuxEnable?: true
    langue?: true
    runPoints?: true
    runPointsMonth?: true
    isBanned?: true
    bannerId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    mail?: true
    authTicket?: true
    rank?: true
    credits?: true
    activityPoints?: true
    look?: true
    gender?: true
    motto?: true
    accountCreated?: true
    lastOnline?: true
    online?: true
    ipLast?: true
    machineId?: true
    homeRoom?: true
    blockNewfriends?: true
    hideOnline?: true
    hideInroom?: true
    lastOffline?: true
    moisVip?: true
    volume?: true
    vipPoints?: true
    limitCoins?: true
    acceptTrading?: true
    cameraFollowDisabled?: true
    ignoreRoomInvite?: true
    lastdailycredits?: true
    hideGamealert?: true
    ipcountry?: true
    gamePoints?: true
    gamePointsMonth?: true
    mazoscore?: true
    mazo?: true
    nuxEnable?: true
    langue?: true
    runPoints?: true
    runPointsMonth?: true
    isBanned?: true
    bannerId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    mail?: true
    authTicket?: true
    rank?: true
    credits?: true
    activityPoints?: true
    look?: true
    gender?: true
    motto?: true
    accountCreated?: true
    lastOnline?: true
    online?: true
    ipLast?: true
    machineId?: true
    homeRoom?: true
    blockNewfriends?: true
    hideOnline?: true
    hideInroom?: true
    lastOffline?: true
    moisVip?: true
    volume?: true
    vipPoints?: true
    limitCoins?: true
    acceptTrading?: true
    cameraFollowDisabled?: true
    ignoreRoomInvite?: true
    lastdailycredits?: true
    hideGamealert?: true
    ipcountry?: true
    gamePoints?: true
    gamePointsMonth?: true
    mazoscore?: true
    mazo?: true
    nuxEnable?: true
    langue?: true
    runPoints?: true
    runPointsMonth?: true
    isBanned?: true
    bannerId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    mail: string | null
    authTicket: string | null
    rank: number
    credits: number
    activityPoints: number
    look: string
    gender: $Enums.UserGender
    motto: string | null
    accountCreated: number
    lastOnline: number
    online: boolean
    ipLast: string | null
    machineId: string | null
    homeRoom: number
    blockNewfriends: boolean
    hideOnline: boolean
    hideInroom: boolean
    lastOffline: number
    moisVip: number
    volume: string
    vipPoints: number
    limitCoins: number
    acceptTrading: boolean
    cameraFollowDisabled: boolean
    ignoreRoomInvite: boolean
    lastdailycredits: string
    hideGamealert: boolean
    ipcountry: string | null
    gamePoints: number
    gamePointsMonth: number
    mazoscore: number
    mazo: number
    nuxEnable: boolean
    langue: $Enums.UserLangue
    runPoints: number
    runPointsMonth: number
    isBanned: boolean
    bannerId: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    mail?: boolean
    authTicket?: boolean
    rank?: boolean
    credits?: boolean
    activityPoints?: boolean
    look?: boolean
    gender?: boolean
    motto?: boolean
    accountCreated?: boolean
    lastOnline?: boolean
    online?: boolean
    ipLast?: boolean
    machineId?: boolean
    homeRoom?: boolean
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: boolean
    moisVip?: boolean
    volume?: boolean
    vipPoints?: boolean
    limitCoins?: boolean
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: boolean
    hideGamealert?: boolean
    ipcountry?: boolean
    gamePoints?: boolean
    gamePointsMonth?: boolean
    mazoscore?: boolean
    mazo?: boolean
    nuxEnable?: boolean
    langue?: boolean
    runPoints?: boolean
    runPointsMonth?: boolean
    isBanned?: boolean
    bannerId?: boolean
    logLogin?: boolean | User$logLoginArgs<ExtArgs>
    logChat?: boolean | User$logChatArgs<ExtArgs>
    logSlotmachine?: boolean | User$logSlotmachineArgs<ExtArgs>
    logShop?: boolean | User$logShopArgs<ExtArgs>
    logLootbox?: boolean | User$logLootboxArgs<ExtArgs>
    logSandbox?: boolean | User$logSandboxArgs<ExtArgs>
    userOneTrade?: boolean | User$userOneTradeArgs<ExtArgs>
    userTwoTrade?: boolean | User$userTwoTradeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    mail?: boolean
    authTicket?: boolean
    rank?: boolean
    credits?: boolean
    activityPoints?: boolean
    look?: boolean
    gender?: boolean
    motto?: boolean
    accountCreated?: boolean
    lastOnline?: boolean
    online?: boolean
    ipLast?: boolean
    machineId?: boolean
    homeRoom?: boolean
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: boolean
    moisVip?: boolean
    volume?: boolean
    vipPoints?: boolean
    limitCoins?: boolean
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: boolean
    hideGamealert?: boolean
    ipcountry?: boolean
    gamePoints?: boolean
    gamePointsMonth?: boolean
    mazoscore?: boolean
    mazo?: boolean
    nuxEnable?: boolean
    langue?: boolean
    runPoints?: boolean
    runPointsMonth?: boolean
    isBanned?: boolean
    bannerId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logLogin?: boolean | User$logLoginArgs<ExtArgs>
    logChat?: boolean | User$logChatArgs<ExtArgs>
    logSlotmachine?: boolean | User$logSlotmachineArgs<ExtArgs>
    logShop?: boolean | User$logShopArgs<ExtArgs>
    logLootbox?: boolean | User$logLootboxArgs<ExtArgs>
    logSandbox?: boolean | User$logSandboxArgs<ExtArgs>
    userOneTrade?: boolean | User$userOneTradeArgs<ExtArgs>
    userTwoTrade?: boolean | User$userTwoTradeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      logLogin: Prisma.$LogLoginPayload<ExtArgs>[]
      logChat: Prisma.$LogChatPayload<ExtArgs>[]
      logSlotmachine: Prisma.$LogSlotmachinePayload<ExtArgs>[]
      logShop: Prisma.$LogShopPayload<ExtArgs>[]
      logLootbox: Prisma.$LogLootboxPayload<ExtArgs>[]
      logSandbox: Prisma.$LogSandboxPayload<ExtArgs>[]
      userOneTrade: Prisma.$LogTradePayload<ExtArgs>[]
      userTwoTrade: Prisma.$LogTradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      mail: string | null
      authTicket: string | null
      rank: number
      credits: number
      activityPoints: number
      look: string
      gender: $Enums.UserGender
      motto: string | null
      accountCreated: number
      lastOnline: number
      online: boolean
      ipLast: string | null
      machineId: string | null
      homeRoom: number
      blockNewfriends: boolean
      hideOnline: boolean
      hideInroom: boolean
      lastOffline: number
      moisVip: number
      volume: string
      vipPoints: number
      limitCoins: number
      acceptTrading: boolean
      cameraFollowDisabled: boolean
      ignoreRoomInvite: boolean
      lastdailycredits: string
      hideGamealert: boolean
      ipcountry: string | null
      gamePoints: number
      gamePointsMonth: number
      mazoscore: number
      mazo: number
      nuxEnable: boolean
      langue: $Enums.UserLangue
      runPoints: number
      runPointsMonth: number
      isBanned: boolean
      bannerId: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    logLogin<T extends User$logLoginArgs<ExtArgs> = {}>(args?: Subset<T, User$logLoginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogLoginPayload<ExtArgs>, T, 'findMany'> | Null>;

    logChat<T extends User$logChatArgs<ExtArgs> = {}>(args?: Subset<T, User$logChatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogChatPayload<ExtArgs>, T, 'findMany'> | Null>;

    logSlotmachine<T extends User$logSlotmachineArgs<ExtArgs> = {}>(args?: Subset<T, User$logSlotmachineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSlotmachinePayload<ExtArgs>, T, 'findMany'> | Null>;

    logShop<T extends User$logShopArgs<ExtArgs> = {}>(args?: Subset<T, User$logShopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogShopPayload<ExtArgs>, T, 'findMany'> | Null>;

    logLootbox<T extends User$logLootboxArgs<ExtArgs> = {}>(args?: Subset<T, User$logLootboxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogLootboxPayload<ExtArgs>, T, 'findMany'> | Null>;

    logSandbox<T extends User$logSandboxArgs<ExtArgs> = {}>(args?: Subset<T, User$logSandboxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSandboxPayload<ExtArgs>, T, 'findMany'> | Null>;

    userOneTrade<T extends User$userOneTradeArgs<ExtArgs> = {}>(args?: Subset<T, User$userOneTradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findMany'> | Null>;

    userTwoTrade<T extends User$userTwoTradeArgs<ExtArgs> = {}>(args?: Subset<T, User$userTwoTradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogTradePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly mail: FieldRef<"User", 'String'>
    readonly authTicket: FieldRef<"User", 'String'>
    readonly rank: FieldRef<"User", 'Int'>
    readonly credits: FieldRef<"User", 'Int'>
    readonly activityPoints: FieldRef<"User", 'Int'>
    readonly look: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'UserGender'>
    readonly motto: FieldRef<"User", 'String'>
    readonly accountCreated: FieldRef<"User", 'Int'>
    readonly lastOnline: FieldRef<"User", 'Int'>
    readonly online: FieldRef<"User", 'Boolean'>
    readonly ipLast: FieldRef<"User", 'String'>
    readonly machineId: FieldRef<"User", 'String'>
    readonly homeRoom: FieldRef<"User", 'Int'>
    readonly blockNewfriends: FieldRef<"User", 'Boolean'>
    readonly hideOnline: FieldRef<"User", 'Boolean'>
    readonly hideInroom: FieldRef<"User", 'Boolean'>
    readonly lastOffline: FieldRef<"User", 'Int'>
    readonly moisVip: FieldRef<"User", 'Int'>
    readonly volume: FieldRef<"User", 'String'>
    readonly vipPoints: FieldRef<"User", 'Int'>
    readonly limitCoins: FieldRef<"User", 'Int'>
    readonly acceptTrading: FieldRef<"User", 'Boolean'>
    readonly cameraFollowDisabled: FieldRef<"User", 'Boolean'>
    readonly ignoreRoomInvite: FieldRef<"User", 'Boolean'>
    readonly lastdailycredits: FieldRef<"User", 'String'>
    readonly hideGamealert: FieldRef<"User", 'Boolean'>
    readonly ipcountry: FieldRef<"User", 'String'>
    readonly gamePoints: FieldRef<"User", 'Int'>
    readonly gamePointsMonth: FieldRef<"User", 'Int'>
    readonly mazoscore: FieldRef<"User", 'Int'>
    readonly mazo: FieldRef<"User", 'Int'>
    readonly nuxEnable: FieldRef<"User", 'Boolean'>
    readonly langue: FieldRef<"User", 'UserLangue'>
    readonly runPoints: FieldRef<"User", 'Int'>
    readonly runPointsMonth: FieldRef<"User", 'Int'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly bannerId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.logLogin
   */
  export type User$logLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLogin
     */
    select?: LogLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLoginInclude<ExtArgs> | null
    where?: LogLoginWhereInput
    orderBy?: LogLoginOrderByWithRelationInput | LogLoginOrderByWithRelationInput[]
    cursor?: LogLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogLoginScalarFieldEnum | LogLoginScalarFieldEnum[]
  }


  /**
   * User.logChat
   */
  export type User$logChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogChat
     */
    select?: LogChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogChatInclude<ExtArgs> | null
    where?: LogChatWhereInput
    orderBy?: LogChatOrderByWithRelationInput | LogChatOrderByWithRelationInput[]
    cursor?: LogChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogChatScalarFieldEnum | LogChatScalarFieldEnum[]
  }


  /**
   * User.logSlotmachine
   */
  export type User$logSlotmachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSlotmachine
     */
    select?: LogSlotmachineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSlotmachineInclude<ExtArgs> | null
    where?: LogSlotmachineWhereInput
    orderBy?: LogSlotmachineOrderByWithRelationInput | LogSlotmachineOrderByWithRelationInput[]
    cursor?: LogSlotmachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogSlotmachineScalarFieldEnum | LogSlotmachineScalarFieldEnum[]
  }


  /**
   * User.logShop
   */
  export type User$logShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogShop
     */
    select?: LogShopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogShopInclude<ExtArgs> | null
    where?: LogShopWhereInput
    orderBy?: LogShopOrderByWithRelationInput | LogShopOrderByWithRelationInput[]
    cursor?: LogShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogShopScalarFieldEnum | LogShopScalarFieldEnum[]
  }


  /**
   * User.logLootbox
   */
  export type User$logLootboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogLootbox
     */
    select?: LogLootboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogLootboxInclude<ExtArgs> | null
    where?: LogLootboxWhereInput
    orderBy?: LogLootboxOrderByWithRelationInput | LogLootboxOrderByWithRelationInput[]
    cursor?: LogLootboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogLootboxScalarFieldEnum | LogLootboxScalarFieldEnum[]
  }


  /**
   * User.logSandbox
   */
  export type User$logSandboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSandbox
     */
    select?: LogSandboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogSandboxInclude<ExtArgs> | null
    where?: LogSandboxWhereInput
    orderBy?: LogSandboxOrderByWithRelationInput | LogSandboxOrderByWithRelationInput[]
    cursor?: LogSandboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogSandboxScalarFieldEnum | LogSandboxScalarFieldEnum[]
  }


  /**
   * User.userOneTrade
   */
  export type User$userOneTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    where?: LogTradeWhereInput
    orderBy?: LogTradeOrderByWithRelationInput | LogTradeOrderByWithRelationInput[]
    cursor?: LogTradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogTradeScalarFieldEnum | LogTradeScalarFieldEnum[]
  }


  /**
   * User.userTwoTrade
   */
  export type User$userTwoTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogTrade
     */
    select?: LogTradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LogTradeInclude<ExtArgs> | null
    where?: LogTradeWhereInput
    orderBy?: LogTradeOrderByWithRelationInput | LogTradeOrderByWithRelationInput[]
    cursor?: LogTradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogTradeScalarFieldEnum | LogTradeScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    userId: number | null
    level: number | null
    progress: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    userId: number | null
    level: number | null
    progress: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    userId: number | null
    group: string | null
    level: number | null
    progress: number | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    userId: number | null
    group: string | null
    level: number | null
    progress: number | null
  }

  export type UserAchievementCountAggregateOutputType = {
    userId: number
    group: number
    level: number
    progress: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    userId?: true
    level?: true
    progress?: true
  }

  export type UserAchievementSumAggregateInputType = {
    userId?: true
    level?: true
    progress?: true
  }

  export type UserAchievementMinAggregateInputType = {
    userId?: true
    group?: true
    level?: true
    progress?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    userId?: true
    group?: true
    level?: true
    progress?: true
  }

  export type UserAchievementCountAggregateInputType = {
    userId?: true
    group?: true
    level?: true
    progress?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    userId: number
    group: string
    level: number
    progress: number
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    group?: boolean
    level?: boolean
    progress?: boolean
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    userId?: boolean
    group?: boolean
    level?: boolean
    progress?: boolean
  }


  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      group: string
      level: number
      progress: number
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }


  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAchievementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAchievementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userAchievementWithUserIdOnly = await prisma.userAchievement.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserAchievementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
    **/
    create<T extends UserAchievementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserAchievements.
     *     @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     *     @example
     *     // Create many UserAchievements
     *     const userAchievement = await prisma.userAchievement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAchievementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
    **/
    delete<T extends UserAchievementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAchievementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAchievementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAchievementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
    **/
    upsert<T extends UserAchievementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>
    ): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly userId: FieldRef<"UserAchievement", 'Int'>
    readonly group: FieldRef<"UserAchievement", 'String'>
    readonly level: FieldRef<"UserAchievement", 'Int'>
    readonly progress: FieldRef<"UserAchievement", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }


  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }


  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }


  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }


  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }


  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }


  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }


  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }


  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }


  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }


  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }


  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
  }



  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeAvgAggregateOutputType = {
    userId: number | null
    badgeSlot: number | null
  }

  export type UserBadgeSumAggregateOutputType = {
    userId: number | null
    badgeSlot: number | null
  }

  export type UserBadgeMinAggregateOutputType = {
    userId: number | null
    badgeId: string | null
    badgeSlot: number | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    userId: number | null
    badgeId: string | null
    badgeSlot: number | null
  }

  export type UserBadgeCountAggregateOutputType = {
    userId: number
    badgeId: number
    badgeSlot: number
    _all: number
  }


  export type UserBadgeAvgAggregateInputType = {
    userId?: true
    badgeSlot?: true
  }

  export type UserBadgeSumAggregateInputType = {
    userId?: true
    badgeSlot?: true
  }

  export type UserBadgeMinAggregateInputType = {
    userId?: true
    badgeId?: true
    badgeSlot?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    userId?: true
    badgeId?: true
    badgeSlot?: true
  }

  export type UserBadgeCountAggregateInputType = {
    userId?: true
    badgeId?: true
    badgeSlot?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _avg?: UserBadgeAvgAggregateInputType
    _sum?: UserBadgeSumAggregateInputType
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    userId: number
    badgeId: string
    badgeSlot: number
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    badgeSlot?: boolean
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    userId?: boolean
    badgeId?: boolean
    badgeSlot?: boolean
  }


  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      badgeId: string
      badgeSlot: number
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }


  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserBadgeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserBadgeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserBadgeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
    **/
    create<T extends UserBadgeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserBadges.
     *     @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     *     @example
     *     // Create many UserBadges
     *     const userBadge = await prisma.userBadge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserBadgeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
    **/
    delete<T extends UserBadgeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserBadgeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserBadgeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserBadgeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
    **/
    upsert<T extends UserBadgeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>
    ): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly userId: FieldRef<"UserBadge", 'Int'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly badgeSlot: FieldRef<"UserBadge", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }


  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }


  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }


  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }


  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }


  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }


  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }


  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }


  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }


  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }


  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }


  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
  }



  /**
   * Model UserBanner
   */

  export type AggregateUserBanner = {
    _count: UserBannerCountAggregateOutputType | null
    _avg: UserBannerAvgAggregateOutputType | null
    _sum: UserBannerSumAggregateOutputType | null
    _min: UserBannerMinAggregateOutputType | null
    _max: UserBannerMaxAggregateOutputType | null
  }

  export type UserBannerAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    banner_id: number | null
  }

  export type UserBannerSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    banner_id: number | null
  }

  export type UserBannerMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    banner_id: number | null
  }

  export type UserBannerMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    banner_id: number | null
  }

  export type UserBannerCountAggregateOutputType = {
    id: number
    user_id: number
    banner_id: number
    _all: number
  }


  export type UserBannerAvgAggregateInputType = {
    id?: true
    user_id?: true
    banner_id?: true
  }

  export type UserBannerSumAggregateInputType = {
    id?: true
    user_id?: true
    banner_id?: true
  }

  export type UserBannerMinAggregateInputType = {
    id?: true
    user_id?: true
    banner_id?: true
  }

  export type UserBannerMaxAggregateInputType = {
    id?: true
    user_id?: true
    banner_id?: true
  }

  export type UserBannerCountAggregateInputType = {
    id?: true
    user_id?: true
    banner_id?: true
    _all?: true
  }

  export type UserBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBanner to aggregate.
     */
    where?: UserBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBanners to fetch.
     */
    orderBy?: UserBannerOrderByWithRelationInput | UserBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBanners
    **/
    _count?: true | UserBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBannerMaxAggregateInputType
  }

  export type GetUserBannerAggregateType<T extends UserBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBanner[P]>
      : GetScalarType<T[P], AggregateUserBanner[P]>
  }




  export type UserBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBannerWhereInput
    orderBy?: UserBannerOrderByWithAggregationInput | UserBannerOrderByWithAggregationInput[]
    by: UserBannerScalarFieldEnum[] | UserBannerScalarFieldEnum
    having?: UserBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBannerCountAggregateInputType | true
    _avg?: UserBannerAvgAggregateInputType
    _sum?: UserBannerSumAggregateInputType
    _min?: UserBannerMinAggregateInputType
    _max?: UserBannerMaxAggregateInputType
  }

  export type UserBannerGroupByOutputType = {
    id: number
    user_id: number
    banner_id: number
    _count: UserBannerCountAggregateOutputType | null
    _avg: UserBannerAvgAggregateOutputType | null
    _sum: UserBannerSumAggregateOutputType | null
    _min: UserBannerMinAggregateOutputType | null
    _max: UserBannerMaxAggregateOutputType | null
  }

  type GetUserBannerGroupByPayload<T extends UserBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBannerGroupByOutputType[P]>
            : GetScalarType<T[P], UserBannerGroupByOutputType[P]>
        }
      >
    >


  export type UserBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    banner_id?: boolean
  }, ExtArgs["result"]["userBanner"]>

  export type UserBannerSelectScalar = {
    id?: boolean
    user_id?: boolean
    banner_id?: boolean
  }


  export type $UserBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBanner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      banner_id: number
    }, ExtArgs["result"]["userBanner"]>
    composites: {}
  }


  type UserBannerGetPayload<S extends boolean | null | undefined | UserBannerDefaultArgs> = $Result.GetResult<Prisma.$UserBannerPayload, S>

  type UserBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBannerCountAggregateInputType | true
    }

  export interface UserBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBanner'], meta: { name: 'UserBanner' } }
    /**
     * Find zero or one UserBanner that matches the filter.
     * @param {UserBannerFindUniqueArgs} args - Arguments to find a UserBanner
     * @example
     * // Get one UserBanner
     * const userBanner = await prisma.userBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserBannerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserBannerFindUniqueArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserBanner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserBannerFindUniqueOrThrowArgs} args - Arguments to find a UserBanner
     * @example
     * // Get one UserBanner
     * const userBanner = await prisma.userBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserBannerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBannerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerFindFirstArgs} args - Arguments to find a UserBanner
     * @example
     * // Get one UserBanner
     * const userBanner = await prisma.userBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserBannerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBannerFindFirstArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerFindFirstOrThrowArgs} args - Arguments to find a UserBanner
     * @example
     * // Get one UserBanner
     * const userBanner = await prisma.userBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserBannerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBannerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBanners
     * const userBanners = await prisma.userBanner.findMany()
     * 
     * // Get first 10 UserBanners
     * const userBanners = await prisma.userBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBannerWithIdOnly = await prisma.userBanner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserBannerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBannerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserBanner.
     * @param {UserBannerCreateArgs} args - Arguments to create a UserBanner.
     * @example
     * // Create one UserBanner
     * const UserBanner = await prisma.userBanner.create({
     *   data: {
     *     // ... data to create a UserBanner
     *   }
     * })
     * 
    **/
    create<T extends UserBannerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserBannerCreateArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserBanners.
     *     @param {UserBannerCreateManyArgs} args - Arguments to create many UserBanners.
     *     @example
     *     // Create many UserBanners
     *     const userBanner = await prisma.userBanner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserBannerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBannerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBanner.
     * @param {UserBannerDeleteArgs} args - Arguments to delete one UserBanner.
     * @example
     * // Delete one UserBanner
     * const UserBanner = await prisma.userBanner.delete({
     *   where: {
     *     // ... filter to delete one UserBanner
     *   }
     * })
     * 
    **/
    delete<T extends UserBannerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserBannerDeleteArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserBanner.
     * @param {UserBannerUpdateArgs} args - Arguments to update one UserBanner.
     * @example
     * // Update one UserBanner
     * const userBanner = await prisma.userBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserBannerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserBannerUpdateArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserBanners.
     * @param {UserBannerDeleteManyArgs} args - Arguments to filter UserBanners to delete.
     * @example
     * // Delete a few UserBanners
     * const { count } = await prisma.userBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserBannerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserBannerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBanners
     * const userBanner = await prisma.userBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserBannerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserBannerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBanner.
     * @param {UserBannerUpsertArgs} args - Arguments to update or create a UserBanner.
     * @example
     * // Update or create a UserBanner
     * const userBanner = await prisma.userBanner.upsert({
     *   create: {
     *     // ... data to create a UserBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBanner we want to update
     *   }
     * })
    **/
    upsert<T extends UserBannerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserBannerUpsertArgs<ExtArgs>>
    ): Prisma__UserBannerClient<$Result.GetResult<Prisma.$UserBannerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerCountArgs} args - Arguments to filter UserBanners to count.
     * @example
     * // Count the number of UserBanners
     * const count = await prisma.userBanner.count({
     *   where: {
     *     // ... the filter for the UserBanners we want to count
     *   }
     * })
    **/
    count<T extends UserBannerCountArgs>(
      args?: Subset<T, UserBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBannerAggregateArgs>(args: Subset<T, UserBannerAggregateArgs>): Prisma.PrismaPromise<GetUserBannerAggregateType<T>>

    /**
     * Group by UserBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBannerGroupByArgs['orderBy'] }
        : { orderBy?: UserBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBanner model
   */
  readonly fields: UserBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserBanner model
   */ 
  interface UserBannerFieldRefs {
    readonly id: FieldRef<"UserBanner", 'Int'>
    readonly user_id: FieldRef<"UserBanner", 'Int'>
    readonly banner_id: FieldRef<"UserBanner", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserBanner findUnique
   */
  export type UserBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * Filter, which UserBanner to fetch.
     */
    where: UserBannerWhereUniqueInput
  }


  /**
   * UserBanner findUniqueOrThrow
   */
  export type UserBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * Filter, which UserBanner to fetch.
     */
    where: UserBannerWhereUniqueInput
  }


  /**
   * UserBanner findFirst
   */
  export type UserBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * Filter, which UserBanner to fetch.
     */
    where?: UserBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBanners to fetch.
     */
    orderBy?: UserBannerOrderByWithRelationInput | UserBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBanners.
     */
    cursor?: UserBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBanners.
     */
    distinct?: UserBannerScalarFieldEnum | UserBannerScalarFieldEnum[]
  }


  /**
   * UserBanner findFirstOrThrow
   */
  export type UserBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * Filter, which UserBanner to fetch.
     */
    where?: UserBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBanners to fetch.
     */
    orderBy?: UserBannerOrderByWithRelationInput | UserBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBanners.
     */
    cursor?: UserBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBanners.
     */
    distinct?: UserBannerScalarFieldEnum | UserBannerScalarFieldEnum[]
  }


  /**
   * UserBanner findMany
   */
  export type UserBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * Filter, which UserBanners to fetch.
     */
    where?: UserBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBanners to fetch.
     */
    orderBy?: UserBannerOrderByWithRelationInput | UserBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBanners.
     */
    cursor?: UserBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBanners.
     */
    skip?: number
    distinct?: UserBannerScalarFieldEnum | UserBannerScalarFieldEnum[]
  }


  /**
   * UserBanner create
   */
  export type UserBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * The data needed to create a UserBanner.
     */
    data: XOR<UserBannerCreateInput, UserBannerUncheckedCreateInput>
  }


  /**
   * UserBanner createMany
   */
  export type UserBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBanners.
     */
    data: UserBannerCreateManyInput | UserBannerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserBanner update
   */
  export type UserBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * The data needed to update a UserBanner.
     */
    data: XOR<UserBannerUpdateInput, UserBannerUncheckedUpdateInput>
    /**
     * Choose, which UserBanner to update.
     */
    where: UserBannerWhereUniqueInput
  }


  /**
   * UserBanner updateMany
   */
  export type UserBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBanners.
     */
    data: XOR<UserBannerUpdateManyMutationInput, UserBannerUncheckedUpdateManyInput>
    /**
     * Filter which UserBanners to update
     */
    where?: UserBannerWhereInput
  }


  /**
   * UserBanner upsert
   */
  export type UserBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * The filter to search for the UserBanner to update in case it exists.
     */
    where: UserBannerWhereUniqueInput
    /**
     * In case the UserBanner found by the `where` argument doesn't exist, create a new UserBanner with this data.
     */
    create: XOR<UserBannerCreateInput, UserBannerUncheckedCreateInput>
    /**
     * In case the UserBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBannerUpdateInput, UserBannerUncheckedUpdateInput>
  }


  /**
   * UserBanner delete
   */
  export type UserBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
    /**
     * Filter which UserBanner to delete.
     */
    where: UserBannerWhereUniqueInput
  }


  /**
   * UserBanner deleteMany
   */
  export type UserBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBanners to delete
     */
    where?: UserBannerWhereInput
  }


  /**
   * UserBanner without action
   */
  export type UserBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBanner
     */
    select?: UserBannerSelect<ExtArgs> | null
  }



  /**
   * Model UserPhoto
   */

  export type AggregateUserPhoto = {
    _count: UserPhotoCountAggregateOutputType | null
    _avg: UserPhotoAvgAggregateOutputType | null
    _sum: UserPhotoSumAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  export type UserPhotoAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    time: number | null
  }

  export type UserPhotoSumAggregateOutputType = {
    id: number | null
    userId: number | null
    time: number | null
  }

  export type UserPhotoMinAggregateOutputType = {
    id: number | null
    userId: number | null
    photo: string | null
    time: number | null
  }

  export type UserPhotoMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    photo: string | null
    time: number | null
  }

  export type UserPhotoCountAggregateOutputType = {
    id: number
    userId: number
    photo: number
    time: number
    _all: number
  }


  export type UserPhotoAvgAggregateInputType = {
    id?: true
    userId?: true
    time?: true
  }

  export type UserPhotoSumAggregateInputType = {
    id?: true
    userId?: true
    time?: true
  }

  export type UserPhotoMinAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    time?: true
  }

  export type UserPhotoMaxAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    time?: true
  }

  export type UserPhotoCountAggregateInputType = {
    id?: true
    userId?: true
    photo?: true
    time?: true
    _all?: true
  }

  export type UserPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhoto to aggregate.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhotos
    **/
    _count?: true | UserPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhotoMaxAggregateInputType
  }

  export type GetUserPhotoAggregateType<T extends UserPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhoto[P]>
      : GetScalarType<T[P], AggregateUserPhoto[P]>
  }




  export type UserPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithAggregationInput | UserPhotoOrderByWithAggregationInput[]
    by: UserPhotoScalarFieldEnum[] | UserPhotoScalarFieldEnum
    having?: UserPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhotoCountAggregateInputType | true
    _avg?: UserPhotoAvgAggregateInputType
    _sum?: UserPhotoSumAggregateInputType
    _min?: UserPhotoMinAggregateInputType
    _max?: UserPhotoMaxAggregateInputType
  }

  export type UserPhotoGroupByOutputType = {
    id: number
    userId: number
    photo: string
    time: number
    _count: UserPhotoCountAggregateOutputType | null
    _avg: UserPhotoAvgAggregateOutputType | null
    _sum: UserPhotoSumAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  type GetUserPhotoGroupByPayload<T extends UserPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
        }
      >
    >


  export type UserPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    photo?: boolean
    time?: boolean
  }, ExtArgs["result"]["userPhoto"]>

  export type UserPhotoSelectScalar = {
    id?: boolean
    userId?: boolean
    photo?: boolean
    time?: boolean
  }


  export type $UserPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhoto"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      photo: string
      time: number
    }, ExtArgs["result"]["userPhoto"]>
    composites: {}
  }


  type UserPhotoGetPayload<S extends boolean | null | undefined | UserPhotoDefaultArgs> = $Result.GetResult<Prisma.$UserPhotoPayload, S>

  type UserPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPhotoCountAggregateInputType | true
    }

  export interface UserPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhoto'], meta: { name: 'UserPhoto' } }
    /**
     * Find zero or one UserPhoto that matches the filter.
     * @param {UserPhotoFindUniqueArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserPhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPhotoFindUniqueOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPhotoFindFirstArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany()
     * 
     * // Get first 10 UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhotoWithIdOnly = await prisma.userPhoto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPhoto.
     * @param {UserPhotoCreateArgs} args - Arguments to create a UserPhoto.
     * @example
     * // Create one UserPhoto
     * const UserPhoto = await prisma.userPhoto.create({
     *   data: {
     *     // ... data to create a UserPhoto
     *   }
     * })
     * 
    **/
    create<T extends UserPhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPhotoCreateArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPhotos.
     *     @param {UserPhotoCreateManyArgs} args - Arguments to create many UserPhotos.
     *     @example
     *     // Create many UserPhotos
     *     const userPhoto = await prisma.userPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPhoto.
     * @param {UserPhotoDeleteArgs} args - Arguments to delete one UserPhoto.
     * @example
     * // Delete one UserPhoto
     * const UserPhoto = await prisma.userPhoto.delete({
     *   where: {
     *     // ... filter to delete one UserPhoto
     *   }
     * })
     * 
    **/
    delete<T extends UserPhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPhotoDeleteArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPhoto.
     * @param {UserPhotoUpdateArgs} args - Arguments to update one UserPhoto.
     * @example
     * // Update one UserPhoto
     * const userPhoto = await prisma.userPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPhotoUpdateArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPhotos.
     * @param {UserPhotoDeleteManyArgs} args - Arguments to filter UserPhotos to delete.
     * @example
     * // Delete a few UserPhotos
     * const { count } = await prisma.userPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhotos
     * const userPhoto = await prisma.userPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPhoto.
     * @param {UserPhotoUpsertArgs} args - Arguments to update or create a UserPhoto.
     * @example
     * // Update or create a UserPhoto
     * const userPhoto = await prisma.userPhoto.upsert({
     *   create: {
     *     // ... data to create a UserPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends UserPhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPhotoUpsertArgs<ExtArgs>>
    ): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoCountArgs} args - Arguments to filter UserPhotos to count.
     * @example
     * // Count the number of UserPhotos
     * const count = await prisma.userPhoto.count({
     *   where: {
     *     // ... the filter for the UserPhotos we want to count
     *   }
     * })
    **/
    count<T extends UserPhotoCountArgs>(
      args?: Subset<T, UserPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhotoAggregateArgs>(args: Subset<T, UserPhotoAggregateArgs>): Prisma.PrismaPromise<GetUserPhotoAggregateType<T>>

    /**
     * Group by UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhotoGroupByArgs['orderBy'] }
        : { orderBy?: UserPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhoto model
   */
  readonly fields: UserPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserPhoto model
   */ 
  interface UserPhotoFieldRefs {
    readonly id: FieldRef<"UserPhoto", 'Int'>
    readonly userId: FieldRef<"UserPhoto", 'Int'>
    readonly photo: FieldRef<"UserPhoto", 'String'>
    readonly time: FieldRef<"UserPhoto", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserPhoto findUnique
   */
  export type UserPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }


  /**
   * UserPhoto findUniqueOrThrow
   */
  export type UserPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }


  /**
   * UserPhoto findFirst
   */
  export type UserPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }


  /**
   * UserPhoto findFirstOrThrow
   */
  export type UserPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }


  /**
   * UserPhoto findMany
   */
  export type UserPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Filter, which UserPhotos to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }


  /**
   * UserPhoto create
   */
  export type UserPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * The data needed to create a UserPhoto.
     */
    data: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
  }


  /**
   * UserPhoto createMany
   */
  export type UserPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhotos.
     */
    data: UserPhotoCreateManyInput | UserPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserPhoto update
   */
  export type UserPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * The data needed to update a UserPhoto.
     */
    data: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
    /**
     * Choose, which UserPhoto to update.
     */
    where: UserPhotoWhereUniqueInput
  }


  /**
   * UserPhoto updateMany
   */
  export type UserPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhotos.
     */
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyInput>
    /**
     * Filter which UserPhotos to update
     */
    where?: UserPhotoWhereInput
  }


  /**
   * UserPhoto upsert
   */
  export type UserPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * The filter to search for the UserPhoto to update in case it exists.
     */
    where: UserPhotoWhereUniqueInput
    /**
     * In case the UserPhoto found by the `where` argument doesn't exist, create a new UserPhoto with this data.
     */
    create: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
    /**
     * In case the UserPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
  }


  /**
   * UserPhoto delete
   */
  export type UserPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Filter which UserPhoto to delete.
     */
    where: UserPhotoWhereUniqueInput
  }


  /**
   * UserPhoto deleteMany
   */
  export type UserPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhotos to delete
     */
    where?: UserPhotoWhereInput
  }


  /**
   * UserPhoto without action
   */
  export type UserPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
  }



  /**
   * Model UserPremium
   */

  export type AggregateUserPremium = {
    _count: UserPremiumCountAggregateOutputType | null
    _avg: UserPremiumAvgAggregateOutputType | null
    _sum: UserPremiumSumAggregateOutputType | null
    _min: UserPremiumMinAggregateOutputType | null
    _max: UserPremiumMaxAggregateOutputType | null
  }

  export type UserPremiumAvgAggregateOutputType = {
    userId: number | null
    timestampActivated: number | null
    timestampExpireClassic: number | null
    timestampExpireEpic: number | null
    timestampExpireLegend: number | null
  }

  export type UserPremiumSumAggregateOutputType = {
    userId: number | null
    timestampActivated: number | null
    timestampExpireClassic: number | null
    timestampExpireEpic: number | null
    timestampExpireLegend: number | null
  }

  export type UserPremiumMinAggregateOutputType = {
    userId: number | null
    timestampActivated: number | null
    timestampExpireClassic: number | null
    timestampExpireEpic: number | null
    timestampExpireLegend: number | null
  }

  export type UserPremiumMaxAggregateOutputType = {
    userId: number | null
    timestampActivated: number | null
    timestampExpireClassic: number | null
    timestampExpireEpic: number | null
    timestampExpireLegend: number | null
  }

  export type UserPremiumCountAggregateOutputType = {
    userId: number
    timestampActivated: number
    timestampExpireClassic: number
    timestampExpireEpic: number
    timestampExpireLegend: number
    _all: number
  }


  export type UserPremiumAvgAggregateInputType = {
    userId?: true
    timestampActivated?: true
    timestampExpireClassic?: true
    timestampExpireEpic?: true
    timestampExpireLegend?: true
  }

  export type UserPremiumSumAggregateInputType = {
    userId?: true
    timestampActivated?: true
    timestampExpireClassic?: true
    timestampExpireEpic?: true
    timestampExpireLegend?: true
  }

  export type UserPremiumMinAggregateInputType = {
    userId?: true
    timestampActivated?: true
    timestampExpireClassic?: true
    timestampExpireEpic?: true
    timestampExpireLegend?: true
  }

  export type UserPremiumMaxAggregateInputType = {
    userId?: true
    timestampActivated?: true
    timestampExpireClassic?: true
    timestampExpireEpic?: true
    timestampExpireLegend?: true
  }

  export type UserPremiumCountAggregateInputType = {
    userId?: true
    timestampActivated?: true
    timestampExpireClassic?: true
    timestampExpireEpic?: true
    timestampExpireLegend?: true
    _all?: true
  }

  export type UserPremiumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPremium to aggregate.
     */
    where?: UserPremiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPremiums to fetch.
     */
    orderBy?: UserPremiumOrderByWithRelationInput | UserPremiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPremiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPremiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPremiums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPremiums
    **/
    _count?: true | UserPremiumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPremiumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPremiumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPremiumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPremiumMaxAggregateInputType
  }

  export type GetUserPremiumAggregateType<T extends UserPremiumAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPremium]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPremium[P]>
      : GetScalarType<T[P], AggregateUserPremium[P]>
  }




  export type UserPremiumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPremiumWhereInput
    orderBy?: UserPremiumOrderByWithAggregationInput | UserPremiumOrderByWithAggregationInput[]
    by: UserPremiumScalarFieldEnum[] | UserPremiumScalarFieldEnum
    having?: UserPremiumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPremiumCountAggregateInputType | true
    _avg?: UserPremiumAvgAggregateInputType
    _sum?: UserPremiumSumAggregateInputType
    _min?: UserPremiumMinAggregateInputType
    _max?: UserPremiumMaxAggregateInputType
  }

  export type UserPremiumGroupByOutputType = {
    userId: number
    timestampActivated: number
    timestampExpireClassic: number
    timestampExpireEpic: number
    timestampExpireLegend: number
    _count: UserPremiumCountAggregateOutputType | null
    _avg: UserPremiumAvgAggregateOutputType | null
    _sum: UserPremiumSumAggregateOutputType | null
    _min: UserPremiumMinAggregateOutputType | null
    _max: UserPremiumMaxAggregateOutputType | null
  }

  type GetUserPremiumGroupByPayload<T extends UserPremiumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPremiumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPremiumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPremiumGroupByOutputType[P]>
            : GetScalarType<T[P], UserPremiumGroupByOutputType[P]>
        }
      >
    >


  export type UserPremiumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    timestampActivated?: boolean
    timestampExpireClassic?: boolean
    timestampExpireEpic?: boolean
    timestampExpireLegend?: boolean
  }, ExtArgs["result"]["userPremium"]>

  export type UserPremiumSelectScalar = {
    userId?: boolean
    timestampActivated?: boolean
    timestampExpireClassic?: boolean
    timestampExpireEpic?: boolean
    timestampExpireLegend?: boolean
  }


  export type $UserPremiumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPremium"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      timestampActivated: number
      timestampExpireClassic: number
      timestampExpireEpic: number
      timestampExpireLegend: number
    }, ExtArgs["result"]["userPremium"]>
    composites: {}
  }


  type UserPremiumGetPayload<S extends boolean | null | undefined | UserPremiumDefaultArgs> = $Result.GetResult<Prisma.$UserPremiumPayload, S>

  type UserPremiumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPremiumFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPremiumCountAggregateInputType | true
    }

  export interface UserPremiumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPremium'], meta: { name: 'UserPremium' } }
    /**
     * Find zero or one UserPremium that matches the filter.
     * @param {UserPremiumFindUniqueArgs} args - Arguments to find a UserPremium
     * @example
     * // Get one UserPremium
     * const userPremium = await prisma.userPremium.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPremiumFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserPremiumFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPremium that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPremiumFindUniqueOrThrowArgs} args - Arguments to find a UserPremium
     * @example
     * // Get one UserPremium
     * const userPremium = await prisma.userPremium.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPremiumFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPremiumFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPremium that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumFindFirstArgs} args - Arguments to find a UserPremium
     * @example
     * // Get one UserPremium
     * const userPremium = await prisma.userPremium.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPremiumFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPremiumFindFirstArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPremium that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumFindFirstOrThrowArgs} args - Arguments to find a UserPremium
     * @example
     * // Get one UserPremium
     * const userPremium = await prisma.userPremium.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPremiumFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPremiumFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPremiums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPremiums
     * const userPremiums = await prisma.userPremium.findMany()
     * 
     * // Get first 10 UserPremiums
     * const userPremiums = await prisma.userPremium.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPremiumWithUserIdOnly = await prisma.userPremium.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserPremiumFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPremiumFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPremium.
     * @param {UserPremiumCreateArgs} args - Arguments to create a UserPremium.
     * @example
     * // Create one UserPremium
     * const UserPremium = await prisma.userPremium.create({
     *   data: {
     *     // ... data to create a UserPremium
     *   }
     * })
     * 
    **/
    create<T extends UserPremiumCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPremiumCreateArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPremiums.
     *     @param {UserPremiumCreateManyArgs} args - Arguments to create many UserPremiums.
     *     @example
     *     // Create many UserPremiums
     *     const userPremium = await prisma.userPremium.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPremiumCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPremiumCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPremium.
     * @param {UserPremiumDeleteArgs} args - Arguments to delete one UserPremium.
     * @example
     * // Delete one UserPremium
     * const UserPremium = await prisma.userPremium.delete({
     *   where: {
     *     // ... filter to delete one UserPremium
     *   }
     * })
     * 
    **/
    delete<T extends UserPremiumDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPremiumDeleteArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPremium.
     * @param {UserPremiumUpdateArgs} args - Arguments to update one UserPremium.
     * @example
     * // Update one UserPremium
     * const userPremium = await prisma.userPremium.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPremiumUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPremiumUpdateArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPremiums.
     * @param {UserPremiumDeleteManyArgs} args - Arguments to filter UserPremiums to delete.
     * @example
     * // Delete a few UserPremiums
     * const { count } = await prisma.userPremium.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPremiumDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPremiumDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPremiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPremiums
     * const userPremium = await prisma.userPremium.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPremiumUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPremiumUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPremium.
     * @param {UserPremiumUpsertArgs} args - Arguments to update or create a UserPremium.
     * @example
     * // Update or create a UserPremium
     * const userPremium = await prisma.userPremium.upsert({
     *   create: {
     *     // ... data to create a UserPremium
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPremium we want to update
     *   }
     * })
    **/
    upsert<T extends UserPremiumUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPremiumUpsertArgs<ExtArgs>>
    ): Prisma__UserPremiumClient<$Result.GetResult<Prisma.$UserPremiumPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPremiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumCountArgs} args - Arguments to filter UserPremiums to count.
     * @example
     * // Count the number of UserPremiums
     * const count = await prisma.userPremium.count({
     *   where: {
     *     // ... the filter for the UserPremiums we want to count
     *   }
     * })
    **/
    count<T extends UserPremiumCountArgs>(
      args?: Subset<T, UserPremiumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPremiumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPremium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPremiumAggregateArgs>(args: Subset<T, UserPremiumAggregateArgs>): Prisma.PrismaPromise<GetUserPremiumAggregateType<T>>

    /**
     * Group by UserPremium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPremiumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPremiumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPremiumGroupByArgs['orderBy'] }
        : { orderBy?: UserPremiumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPremiumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPremiumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPremium model
   */
  readonly fields: UserPremiumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPremium.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPremiumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserPremium model
   */ 
  interface UserPremiumFieldRefs {
    readonly userId: FieldRef<"UserPremium", 'Int'>
    readonly timestampActivated: FieldRef<"UserPremium", 'Int'>
    readonly timestampExpireClassic: FieldRef<"UserPremium", 'Int'>
    readonly timestampExpireEpic: FieldRef<"UserPremium", 'Int'>
    readonly timestampExpireLegend: FieldRef<"UserPremium", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserPremium findUnique
   */
  export type UserPremiumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * Filter, which UserPremium to fetch.
     */
    where: UserPremiumWhereUniqueInput
  }


  /**
   * UserPremium findUniqueOrThrow
   */
  export type UserPremiumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * Filter, which UserPremium to fetch.
     */
    where: UserPremiumWhereUniqueInput
  }


  /**
   * UserPremium findFirst
   */
  export type UserPremiumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * Filter, which UserPremium to fetch.
     */
    where?: UserPremiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPremiums to fetch.
     */
    orderBy?: UserPremiumOrderByWithRelationInput | UserPremiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPremiums.
     */
    cursor?: UserPremiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPremiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPremiums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPremiums.
     */
    distinct?: UserPremiumScalarFieldEnum | UserPremiumScalarFieldEnum[]
  }


  /**
   * UserPremium findFirstOrThrow
   */
  export type UserPremiumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * Filter, which UserPremium to fetch.
     */
    where?: UserPremiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPremiums to fetch.
     */
    orderBy?: UserPremiumOrderByWithRelationInput | UserPremiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPremiums.
     */
    cursor?: UserPremiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPremiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPremiums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPremiums.
     */
    distinct?: UserPremiumScalarFieldEnum | UserPremiumScalarFieldEnum[]
  }


  /**
   * UserPremium findMany
   */
  export type UserPremiumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * Filter, which UserPremiums to fetch.
     */
    where?: UserPremiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPremiums to fetch.
     */
    orderBy?: UserPremiumOrderByWithRelationInput | UserPremiumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPremiums.
     */
    cursor?: UserPremiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPremiums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPremiums.
     */
    skip?: number
    distinct?: UserPremiumScalarFieldEnum | UserPremiumScalarFieldEnum[]
  }


  /**
   * UserPremium create
   */
  export type UserPremiumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * The data needed to create a UserPremium.
     */
    data: XOR<UserPremiumCreateInput, UserPremiumUncheckedCreateInput>
  }


  /**
   * UserPremium createMany
   */
  export type UserPremiumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPremiums.
     */
    data: UserPremiumCreateManyInput | UserPremiumCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserPremium update
   */
  export type UserPremiumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * The data needed to update a UserPremium.
     */
    data: XOR<UserPremiumUpdateInput, UserPremiumUncheckedUpdateInput>
    /**
     * Choose, which UserPremium to update.
     */
    where: UserPremiumWhereUniqueInput
  }


  /**
   * UserPremium updateMany
   */
  export type UserPremiumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPremiums.
     */
    data: XOR<UserPremiumUpdateManyMutationInput, UserPremiumUncheckedUpdateManyInput>
    /**
     * Filter which UserPremiums to update
     */
    where?: UserPremiumWhereInput
  }


  /**
   * UserPremium upsert
   */
  export type UserPremiumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * The filter to search for the UserPremium to update in case it exists.
     */
    where: UserPremiumWhereUniqueInput
    /**
     * In case the UserPremium found by the `where` argument doesn't exist, create a new UserPremium with this data.
     */
    create: XOR<UserPremiumCreateInput, UserPremiumUncheckedCreateInput>
    /**
     * In case the UserPremium was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPremiumUpdateInput, UserPremiumUncheckedUpdateInput>
  }


  /**
   * UserPremium delete
   */
  export type UserPremiumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
    /**
     * Filter which UserPremium to delete.
     */
    where: UserPremiumWhereUniqueInput
  }


  /**
   * UserPremium deleteMany
   */
  export type UserPremiumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPremiums to delete
     */
    where?: UserPremiumWhereInput
  }


  /**
   * UserPremium without action
   */
  export type UserPremiumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPremium
     */
    select?: UserPremiumSelect<ExtArgs> | null
  }



  /**
   * Model UserQuest
   */

  export type AggregateUserQuest = {
    _count: UserQuestCountAggregateOutputType | null
    _avg: UserQuestAvgAggregateOutputType | null
    _sum: UserQuestSumAggregateOutputType | null
    _min: UserQuestMinAggregateOutputType | null
    _max: UserQuestMaxAggregateOutputType | null
  }

  export type UserQuestAvgAggregateOutputType = {
    userId: number | null
    questId: number | null
    progress: number | null
  }

  export type UserQuestSumAggregateOutputType = {
    userId: number | null
    questId: number | null
    progress: number | null
  }

  export type UserQuestMinAggregateOutputType = {
    userId: number | null
    questId: number | null
    progress: number | null
  }

  export type UserQuestMaxAggregateOutputType = {
    userId: number | null
    questId: number | null
    progress: number | null
  }

  export type UserQuestCountAggregateOutputType = {
    userId: number
    questId: number
    progress: number
    _all: number
  }


  export type UserQuestAvgAggregateInputType = {
    userId?: true
    questId?: true
    progress?: true
  }

  export type UserQuestSumAggregateInputType = {
    userId?: true
    questId?: true
    progress?: true
  }

  export type UserQuestMinAggregateInputType = {
    userId?: true
    questId?: true
    progress?: true
  }

  export type UserQuestMaxAggregateInputType = {
    userId?: true
    questId?: true
    progress?: true
  }

  export type UserQuestCountAggregateInputType = {
    userId?: true
    questId?: true
    progress?: true
    _all?: true
  }

  export type UserQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuest to aggregate.
     */
    where?: UserQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestOrderByWithRelationInput | UserQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuests
    **/
    _count?: true | UserQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuestMaxAggregateInputType
  }

  export type GetUserQuestAggregateType<T extends UserQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuest[P]>
      : GetScalarType<T[P], AggregateUserQuest[P]>
  }




  export type UserQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestWhereInput
    orderBy?: UserQuestOrderByWithAggregationInput | UserQuestOrderByWithAggregationInput[]
    by: UserQuestScalarFieldEnum[] | UserQuestScalarFieldEnum
    having?: UserQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuestCountAggregateInputType | true
    _avg?: UserQuestAvgAggregateInputType
    _sum?: UserQuestSumAggregateInputType
    _min?: UserQuestMinAggregateInputType
    _max?: UserQuestMaxAggregateInputType
  }

  export type UserQuestGroupByOutputType = {
    userId: number
    questId: number
    progress: number
    _count: UserQuestCountAggregateOutputType | null
    _avg: UserQuestAvgAggregateOutputType | null
    _sum: UserQuestSumAggregateOutputType | null
    _min: UserQuestMinAggregateOutputType | null
    _max: UserQuestMaxAggregateOutputType | null
  }

  type GetUserQuestGroupByPayload<T extends UserQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuestGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuestGroupByOutputType[P]>
        }
      >
    >


  export type UserQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    questId?: boolean
    progress?: boolean
  }, ExtArgs["result"]["userQuest"]>

  export type UserQuestSelectScalar = {
    userId?: boolean
    questId?: boolean
    progress?: boolean
  }


  export type $UserQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      questId: number
      progress: number
    }, ExtArgs["result"]["userQuest"]>
    composites: {}
  }


  type UserQuestGetPayload<S extends boolean | null | undefined | UserQuestDefaultArgs> = $Result.GetResult<Prisma.$UserQuestPayload, S>

  type UserQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserQuestCountAggregateInputType | true
    }

  export interface UserQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuest'], meta: { name: 'UserQuest' } }
    /**
     * Find zero or one UserQuest that matches the filter.
     * @param {UserQuestFindUniqueArgs} args - Arguments to find a UserQuest
     * @example
     * // Get one UserQuest
     * const userQuest = await prisma.userQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserQuestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestFindUniqueArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserQuest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserQuestFindUniqueOrThrowArgs} args - Arguments to find a UserQuest
     * @example
     * // Get one UserQuest
     * const userQuest = await prisma.userQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserQuestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestFindFirstArgs} args - Arguments to find a UserQuest
     * @example
     * // Get one UserQuest
     * const userQuest = await prisma.userQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserQuestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestFindFirstArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestFindFirstOrThrowArgs} args - Arguments to find a UserQuest
     * @example
     * // Get one UserQuest
     * const userQuest = await prisma.userQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserQuestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuests
     * const userQuests = await prisma.userQuest.findMany()
     * 
     * // Get first 10 UserQuests
     * const userQuests = await prisma.userQuest.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userQuestWithUserIdOnly = await prisma.userQuest.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserQuestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserQuest.
     * @param {UserQuestCreateArgs} args - Arguments to create a UserQuest.
     * @example
     * // Create one UserQuest
     * const UserQuest = await prisma.userQuest.create({
     *   data: {
     *     // ... data to create a UserQuest
     *   }
     * })
     * 
    **/
    create<T extends UserQuestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestCreateArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserQuests.
     *     @param {UserQuestCreateManyArgs} args - Arguments to create many UserQuests.
     *     @example
     *     // Create many UserQuests
     *     const userQuest = await prisma.userQuest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserQuestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserQuest.
     * @param {UserQuestDeleteArgs} args - Arguments to delete one UserQuest.
     * @example
     * // Delete one UserQuest
     * const UserQuest = await prisma.userQuest.delete({
     *   where: {
     *     // ... filter to delete one UserQuest
     *   }
     * })
     * 
    **/
    delete<T extends UserQuestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestDeleteArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserQuest.
     * @param {UserQuestUpdateArgs} args - Arguments to update one UserQuest.
     * @example
     * // Update one UserQuest
     * const userQuest = await prisma.userQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserQuestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestUpdateArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserQuests.
     * @param {UserQuestDeleteManyArgs} args - Arguments to filter UserQuests to delete.
     * @example
     * // Delete a few UserQuests
     * const { count } = await prisma.userQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserQuestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserQuestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuests
     * const userQuest = await prisma.userQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserQuestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQuest.
     * @param {UserQuestUpsertArgs} args - Arguments to update or create a UserQuest.
     * @example
     * // Update or create a UserQuest
     * const userQuest = await prisma.userQuest.upsert({
     *   create: {
     *     // ... data to create a UserQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuest we want to update
     *   }
     * })
    **/
    upsert<T extends UserQuestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserQuestUpsertArgs<ExtArgs>>
    ): Prisma__UserQuestClient<$Result.GetResult<Prisma.$UserQuestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestCountArgs} args - Arguments to filter UserQuests to count.
     * @example
     * // Count the number of UserQuests
     * const count = await prisma.userQuest.count({
     *   where: {
     *     // ... the filter for the UserQuests we want to count
     *   }
     * })
    **/
    count<T extends UserQuestCountArgs>(
      args?: Subset<T, UserQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuestAggregateArgs>(args: Subset<T, UserQuestAggregateArgs>): Prisma.PrismaPromise<GetUserQuestAggregateType<T>>

    /**
     * Group by UserQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuestGroupByArgs['orderBy'] }
        : { orderBy?: UserQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuest model
   */
  readonly fields: UserQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserQuest model
   */ 
  interface UserQuestFieldRefs {
    readonly userId: FieldRef<"UserQuest", 'Int'>
    readonly questId: FieldRef<"UserQuest", 'Int'>
    readonly progress: FieldRef<"UserQuest", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserQuest findUnique
   */
  export type UserQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * Filter, which UserQuest to fetch.
     */
    where: UserQuestWhereUniqueInput
  }


  /**
   * UserQuest findUniqueOrThrow
   */
  export type UserQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * Filter, which UserQuest to fetch.
     */
    where: UserQuestWhereUniqueInput
  }


  /**
   * UserQuest findFirst
   */
  export type UserQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * Filter, which UserQuest to fetch.
     */
    where?: UserQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestOrderByWithRelationInput | UserQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuests.
     */
    cursor?: UserQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuests.
     */
    distinct?: UserQuestScalarFieldEnum | UserQuestScalarFieldEnum[]
  }


  /**
   * UserQuest findFirstOrThrow
   */
  export type UserQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * Filter, which UserQuest to fetch.
     */
    where?: UserQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestOrderByWithRelationInput | UserQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuests.
     */
    cursor?: UserQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuests.
     */
    distinct?: UserQuestScalarFieldEnum | UserQuestScalarFieldEnum[]
  }


  /**
   * UserQuest findMany
   */
  export type UserQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * Filter, which UserQuests to fetch.
     */
    where?: UserQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuests to fetch.
     */
    orderBy?: UserQuestOrderByWithRelationInput | UserQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuests.
     */
    cursor?: UserQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuests.
     */
    skip?: number
    distinct?: UserQuestScalarFieldEnum | UserQuestScalarFieldEnum[]
  }


  /**
   * UserQuest create
   */
  export type UserQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * The data needed to create a UserQuest.
     */
    data: XOR<UserQuestCreateInput, UserQuestUncheckedCreateInput>
  }


  /**
   * UserQuest createMany
   */
  export type UserQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuests.
     */
    data: UserQuestCreateManyInput | UserQuestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserQuest update
   */
  export type UserQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * The data needed to update a UserQuest.
     */
    data: XOR<UserQuestUpdateInput, UserQuestUncheckedUpdateInput>
    /**
     * Choose, which UserQuest to update.
     */
    where: UserQuestWhereUniqueInput
  }


  /**
   * UserQuest updateMany
   */
  export type UserQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuests.
     */
    data: XOR<UserQuestUpdateManyMutationInput, UserQuestUncheckedUpdateManyInput>
    /**
     * Filter which UserQuests to update
     */
    where?: UserQuestWhereInput
  }


  /**
   * UserQuest upsert
   */
  export type UserQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * The filter to search for the UserQuest to update in case it exists.
     */
    where: UserQuestWhereUniqueInput
    /**
     * In case the UserQuest found by the `where` argument doesn't exist, create a new UserQuest with this data.
     */
    create: XOR<UserQuestCreateInput, UserQuestUncheckedCreateInput>
    /**
     * In case the UserQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuestUpdateInput, UserQuestUncheckedUpdateInput>
  }


  /**
   * UserQuest delete
   */
  export type UserQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
    /**
     * Filter which UserQuest to delete.
     */
    where: UserQuestWhereUniqueInput
  }


  /**
   * UserQuest deleteMany
   */
  export type UserQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuests to delete
     */
    where?: UserQuestWhereInput
  }


  /**
   * UserQuest without action
   */
  export type UserQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuest
     */
    select?: UserQuestSelect<ExtArgs> | null
  }



  /**
   * Model UserRoleplay
   */

  export type AggregateUserRoleplay = {
    _count: UserRoleplayCountAggregateOutputType | null
    _avg: UserRoleplayAvgAggregateOutputType | null
    _sum: UserRoleplaySumAggregateOutputType | null
    _min: UserRoleplayMinAggregateOutputType | null
    _max: UserRoleplayMaxAggregateOutputType | null
  }

  export type UserRoleplayAvgAggregateOutputType = {
    userId: number | null
    roleplayId: number | null
    health: number | null
    energy: number | null
    money: number | null
    munition: number | null
    exp: number | null
    weaponFar: number | null
    weaponCac: number | null
    hygiene: number | null
    money1: number | null
    money2: number | null
    money3: number | null
    money4: number | null
  }

  export type UserRoleplaySumAggregateOutputType = {
    userId: number | null
    roleplayId: number | null
    health: number | null
    energy: number | null
    money: number | null
    munition: number | null
    exp: number | null
    weaponFar: number | null
    weaponCac: number | null
    hygiene: number | null
    money1: number | null
    money2: number | null
    money3: number | null
    money4: number | null
  }

  export type UserRoleplayMinAggregateOutputType = {
    userId: number | null
    roleplayId: number | null
    health: number | null
    energy: number | null
    money: number | null
    munition: number | null
    exp: number | null
    weaponFar: number | null
    weaponCac: number | null
    hygiene: number | null
    money1: number | null
    money2: number | null
    money3: number | null
    money4: number | null
  }

  export type UserRoleplayMaxAggregateOutputType = {
    userId: number | null
    roleplayId: number | null
    health: number | null
    energy: number | null
    money: number | null
    munition: number | null
    exp: number | null
    weaponFar: number | null
    weaponCac: number | null
    hygiene: number | null
    money1: number | null
    money2: number | null
    money3: number | null
    money4: number | null
  }

  export type UserRoleplayCountAggregateOutputType = {
    userId: number
    roleplayId: number
    health: number
    energy: number
    money: number
    munition: number
    exp: number
    weaponFar: number
    weaponCac: number
    hygiene: number
    money1: number
    money2: number
    money3: number
    money4: number
    _all: number
  }


  export type UserRoleplayAvgAggregateInputType = {
    userId?: true
    roleplayId?: true
    health?: true
    energy?: true
    money?: true
    munition?: true
    exp?: true
    weaponFar?: true
    weaponCac?: true
    hygiene?: true
    money1?: true
    money2?: true
    money3?: true
    money4?: true
  }

  export type UserRoleplaySumAggregateInputType = {
    userId?: true
    roleplayId?: true
    health?: true
    energy?: true
    money?: true
    munition?: true
    exp?: true
    weaponFar?: true
    weaponCac?: true
    hygiene?: true
    money1?: true
    money2?: true
    money3?: true
    money4?: true
  }

  export type UserRoleplayMinAggregateInputType = {
    userId?: true
    roleplayId?: true
    health?: true
    energy?: true
    money?: true
    munition?: true
    exp?: true
    weaponFar?: true
    weaponCac?: true
    hygiene?: true
    money1?: true
    money2?: true
    money3?: true
    money4?: true
  }

  export type UserRoleplayMaxAggregateInputType = {
    userId?: true
    roleplayId?: true
    health?: true
    energy?: true
    money?: true
    munition?: true
    exp?: true
    weaponFar?: true
    weaponCac?: true
    hygiene?: true
    money1?: true
    money2?: true
    money3?: true
    money4?: true
  }

  export type UserRoleplayCountAggregateInputType = {
    userId?: true
    roleplayId?: true
    health?: true
    energy?: true
    money?: true
    munition?: true
    exp?: true
    weaponFar?: true
    weaponCac?: true
    hygiene?: true
    money1?: true
    money2?: true
    money3?: true
    money4?: true
    _all?: true
  }

  export type UserRoleplayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleplay to aggregate.
     */
    where?: UserRoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplays to fetch.
     */
    orderBy?: UserRoleplayOrderByWithRelationInput | UserRoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleplays
    **/
    _count?: true | UserRoleplayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleplayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleplaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleplayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleplayMaxAggregateInputType
  }

  export type GetUserRoleplayAggregateType<T extends UserRoleplayAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleplay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleplay[P]>
      : GetScalarType<T[P], AggregateUserRoleplay[P]>
  }




  export type UserRoleplayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleplayWhereInput
    orderBy?: UserRoleplayOrderByWithAggregationInput | UserRoleplayOrderByWithAggregationInput[]
    by: UserRoleplayScalarFieldEnum[] | UserRoleplayScalarFieldEnum
    having?: UserRoleplayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleplayCountAggregateInputType | true
    _avg?: UserRoleplayAvgAggregateInputType
    _sum?: UserRoleplaySumAggregateInputType
    _min?: UserRoleplayMinAggregateInputType
    _max?: UserRoleplayMaxAggregateInputType
  }

  export type UserRoleplayGroupByOutputType = {
    userId: number
    roleplayId: number
    health: number
    energy: number
    money: number
    munition: number
    exp: number
    weaponFar: number
    weaponCac: number
    hygiene: number
    money1: number
    money2: number
    money3: number
    money4: number
    _count: UserRoleplayCountAggregateOutputType | null
    _avg: UserRoleplayAvgAggregateOutputType | null
    _sum: UserRoleplaySumAggregateOutputType | null
    _min: UserRoleplayMinAggregateOutputType | null
    _max: UserRoleplayMaxAggregateOutputType | null
  }

  type GetUserRoleplayGroupByPayload<T extends UserRoleplayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleplayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleplayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleplayGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleplayGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleplaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleplayId?: boolean
    health?: boolean
    energy?: boolean
    money?: boolean
    munition?: boolean
    exp?: boolean
    weaponFar?: boolean
    weaponCac?: boolean
    hygiene?: boolean
    money1?: boolean
    money2?: boolean
    money3?: boolean
    money4?: boolean
  }, ExtArgs["result"]["userRoleplay"]>

  export type UserRoleplaySelectScalar = {
    userId?: boolean
    roleplayId?: boolean
    health?: boolean
    energy?: boolean
    money?: boolean
    munition?: boolean
    exp?: boolean
    weaponFar?: boolean
    weaponCac?: boolean
    hygiene?: boolean
    money1?: boolean
    money2?: boolean
    money3?: boolean
    money4?: boolean
  }


  export type $UserRoleplayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoleplay"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      roleplayId: number
      health: number
      energy: number
      money: number
      munition: number
      exp: number
      weaponFar: number
      weaponCac: number
      hygiene: number
      money1: number
      money2: number
      money3: number
      money4: number
    }, ExtArgs["result"]["userRoleplay"]>
    composites: {}
  }


  type UserRoleplayGetPayload<S extends boolean | null | undefined | UserRoleplayDefaultArgs> = $Result.GetResult<Prisma.$UserRoleplayPayload, S>

  type UserRoleplayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleplayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleplayCountAggregateInputType | true
    }

  export interface UserRoleplayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoleplay'], meta: { name: 'UserRoleplay' } }
    /**
     * Find zero or one UserRoleplay that matches the filter.
     * @param {UserRoleplayFindUniqueArgs} args - Arguments to find a UserRoleplay
     * @example
     * // Get one UserRoleplay
     * const userRoleplay = await prisma.userRoleplay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRoleplayFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayFindUniqueArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserRoleplay that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRoleplayFindUniqueOrThrowArgs} args - Arguments to find a UserRoleplay
     * @example
     * // Get one UserRoleplay
     * const userRoleplay = await prisma.userRoleplay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRoleplayFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserRoleplay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayFindFirstArgs} args - Arguments to find a UserRoleplay
     * @example
     * // Get one UserRoleplay
     * const userRoleplay = await prisma.userRoleplay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRoleplayFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayFindFirstArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserRoleplay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayFindFirstOrThrowArgs} args - Arguments to find a UserRoleplay
     * @example
     * // Get one UserRoleplay
     * const userRoleplay = await prisma.userRoleplay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRoleplayFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserRoleplays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleplays
     * const userRoleplays = await prisma.userRoleplay.findMany()
     * 
     * // Get first 10 UserRoleplays
     * const userRoleplays = await prisma.userRoleplay.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleplayWithUserIdOnly = await prisma.userRoleplay.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserRoleplayFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserRoleplay.
     * @param {UserRoleplayCreateArgs} args - Arguments to create a UserRoleplay.
     * @example
     * // Create one UserRoleplay
     * const UserRoleplay = await prisma.userRoleplay.create({
     *   data: {
     *     // ... data to create a UserRoleplay
     *   }
     * })
     * 
    **/
    create<T extends UserRoleplayCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayCreateArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserRoleplays.
     *     @param {UserRoleplayCreateManyArgs} args - Arguments to create many UserRoleplays.
     *     @example
     *     // Create many UserRoleplays
     *     const userRoleplay = await prisma.userRoleplay.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRoleplayCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoleplay.
     * @param {UserRoleplayDeleteArgs} args - Arguments to delete one UserRoleplay.
     * @example
     * // Delete one UserRoleplay
     * const UserRoleplay = await prisma.userRoleplay.delete({
     *   where: {
     *     // ... filter to delete one UserRoleplay
     *   }
     * })
     * 
    **/
    delete<T extends UserRoleplayDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayDeleteArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserRoleplay.
     * @param {UserRoleplayUpdateArgs} args - Arguments to update one UserRoleplay.
     * @example
     * // Update one UserRoleplay
     * const userRoleplay = await prisma.userRoleplay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRoleplayUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayUpdateArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserRoleplays.
     * @param {UserRoleplayDeleteManyArgs} args - Arguments to filter UserRoleplays to delete.
     * @example
     * // Delete a few UserRoleplays
     * const { count } = await prisma.userRoleplay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRoleplayDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleplays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleplays
     * const userRoleplay = await prisma.userRoleplay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRoleplayUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoleplay.
     * @param {UserRoleplayUpsertArgs} args - Arguments to update or create a UserRoleplay.
     * @example
     * // Update or create a UserRoleplay
     * const userRoleplay = await prisma.userRoleplay.upsert({
     *   create: {
     *     // ... data to create a UserRoleplay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleplay we want to update
     *   }
     * })
    **/
    upsert<T extends UserRoleplayUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayUpsertArgs<ExtArgs>>
    ): Prisma__UserRoleplayClient<$Result.GetResult<Prisma.$UserRoleplayPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserRoleplays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayCountArgs} args - Arguments to filter UserRoleplays to count.
     * @example
     * // Count the number of UserRoleplays
     * const count = await prisma.userRoleplay.count({
     *   where: {
     *     // ... the filter for the UserRoleplays we want to count
     *   }
     * })
    **/
    count<T extends UserRoleplayCountArgs>(
      args?: Subset<T, UserRoleplayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleplayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleplay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleplayAggregateArgs>(args: Subset<T, UserRoleplayAggregateArgs>): Prisma.PrismaPromise<GetUserRoleplayAggregateType<T>>

    /**
     * Group by UserRoleplay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleplayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleplayGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleplayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleplayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleplayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoleplay model
   */
  readonly fields: UserRoleplayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleplay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleplayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserRoleplay model
   */ 
  interface UserRoleplayFieldRefs {
    readonly userId: FieldRef<"UserRoleplay", 'Int'>
    readonly roleplayId: FieldRef<"UserRoleplay", 'Int'>
    readonly health: FieldRef<"UserRoleplay", 'Int'>
    readonly energy: FieldRef<"UserRoleplay", 'Int'>
    readonly money: FieldRef<"UserRoleplay", 'Int'>
    readonly munition: FieldRef<"UserRoleplay", 'Int'>
    readonly exp: FieldRef<"UserRoleplay", 'Int'>
    readonly weaponFar: FieldRef<"UserRoleplay", 'Int'>
    readonly weaponCac: FieldRef<"UserRoleplay", 'Int'>
    readonly hygiene: FieldRef<"UserRoleplay", 'Int'>
    readonly money1: FieldRef<"UserRoleplay", 'Int'>
    readonly money2: FieldRef<"UserRoleplay", 'Int'>
    readonly money3: FieldRef<"UserRoleplay", 'Int'>
    readonly money4: FieldRef<"UserRoleplay", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserRoleplay findUnique
   */
  export type UserRoleplayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplay to fetch.
     */
    where: UserRoleplayWhereUniqueInput
  }


  /**
   * UserRoleplay findUniqueOrThrow
   */
  export type UserRoleplayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplay to fetch.
     */
    where: UserRoleplayWhereUniqueInput
  }


  /**
   * UserRoleplay findFirst
   */
  export type UserRoleplayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplay to fetch.
     */
    where?: UserRoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplays to fetch.
     */
    orderBy?: UserRoleplayOrderByWithRelationInput | UserRoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleplays.
     */
    cursor?: UserRoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleplays.
     */
    distinct?: UserRoleplayScalarFieldEnum | UserRoleplayScalarFieldEnum[]
  }


  /**
   * UserRoleplay findFirstOrThrow
   */
  export type UserRoleplayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplay to fetch.
     */
    where?: UserRoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplays to fetch.
     */
    orderBy?: UserRoleplayOrderByWithRelationInput | UserRoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleplays.
     */
    cursor?: UserRoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleplays.
     */
    distinct?: UserRoleplayScalarFieldEnum | UserRoleplayScalarFieldEnum[]
  }


  /**
   * UserRoleplay findMany
   */
  export type UserRoleplayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplays to fetch.
     */
    where?: UserRoleplayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplays to fetch.
     */
    orderBy?: UserRoleplayOrderByWithRelationInput | UserRoleplayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleplays.
     */
    cursor?: UserRoleplayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplays.
     */
    skip?: number
    distinct?: UserRoleplayScalarFieldEnum | UserRoleplayScalarFieldEnum[]
  }


  /**
   * UserRoleplay create
   */
  export type UserRoleplayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * The data needed to create a UserRoleplay.
     */
    data: XOR<UserRoleplayCreateInput, UserRoleplayUncheckedCreateInput>
  }


  /**
   * UserRoleplay createMany
   */
  export type UserRoleplayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoleplays.
     */
    data: UserRoleplayCreateManyInput | UserRoleplayCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserRoleplay update
   */
  export type UserRoleplayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * The data needed to update a UserRoleplay.
     */
    data: XOR<UserRoleplayUpdateInput, UserRoleplayUncheckedUpdateInput>
    /**
     * Choose, which UserRoleplay to update.
     */
    where: UserRoleplayWhereUniqueInput
  }


  /**
   * UserRoleplay updateMany
   */
  export type UserRoleplayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoleplays.
     */
    data: XOR<UserRoleplayUpdateManyMutationInput, UserRoleplayUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleplays to update
     */
    where?: UserRoleplayWhereInput
  }


  /**
   * UserRoleplay upsert
   */
  export type UserRoleplayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * The filter to search for the UserRoleplay to update in case it exists.
     */
    where: UserRoleplayWhereUniqueInput
    /**
     * In case the UserRoleplay found by the `where` argument doesn't exist, create a new UserRoleplay with this data.
     */
    create: XOR<UserRoleplayCreateInput, UserRoleplayUncheckedCreateInput>
    /**
     * In case the UserRoleplay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleplayUpdateInput, UserRoleplayUncheckedUpdateInput>
  }


  /**
   * UserRoleplay delete
   */
  export type UserRoleplayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
    /**
     * Filter which UserRoleplay to delete.
     */
    where: UserRoleplayWhereUniqueInput
  }


  /**
   * UserRoleplay deleteMany
   */
  export type UserRoleplayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleplays to delete
     */
    where?: UserRoleplayWhereInput
  }


  /**
   * UserRoleplay without action
   */
  export type UserRoleplayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplay
     */
    select?: UserRoleplaySelect<ExtArgs> | null
  }



  /**
   * Model UserRoleplayItem
   */

  export type AggregateUserRoleplayItem = {
    _count: UserRoleplayItemCountAggregateOutputType | null
    _avg: UserRoleplayItemAvgAggregateOutputType | null
    _sum: UserRoleplayItemSumAggregateOutputType | null
    _min: UserRoleplayItemMinAggregateOutputType | null
    _max: UserRoleplayItemMaxAggregateOutputType | null
  }

  export type UserRoleplayItemAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    rpId: number | null
    itemId: number | null
    count: number | null
  }

  export type UserRoleplayItemSumAggregateOutputType = {
    id: number | null
    userId: number | null
    rpId: number | null
    itemId: number | null
    count: number | null
  }

  export type UserRoleplayItemMinAggregateOutputType = {
    id: number | null
    userId: number | null
    rpId: number | null
    itemId: number | null
    count: number | null
  }

  export type UserRoleplayItemMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    rpId: number | null
    itemId: number | null
    count: number | null
  }

  export type UserRoleplayItemCountAggregateOutputType = {
    id: number
    userId: number
    rpId: number
    itemId: number
    count: number
    _all: number
  }


  export type UserRoleplayItemAvgAggregateInputType = {
    id?: true
    userId?: true
    rpId?: true
    itemId?: true
    count?: true
  }

  export type UserRoleplayItemSumAggregateInputType = {
    id?: true
    userId?: true
    rpId?: true
    itemId?: true
    count?: true
  }

  export type UserRoleplayItemMinAggregateInputType = {
    id?: true
    userId?: true
    rpId?: true
    itemId?: true
    count?: true
  }

  export type UserRoleplayItemMaxAggregateInputType = {
    id?: true
    userId?: true
    rpId?: true
    itemId?: true
    count?: true
  }

  export type UserRoleplayItemCountAggregateInputType = {
    id?: true
    userId?: true
    rpId?: true
    itemId?: true
    count?: true
    _all?: true
  }

  export type UserRoleplayItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleplayItem to aggregate.
     */
    where?: UserRoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplayItems to fetch.
     */
    orderBy?: UserRoleplayItemOrderByWithRelationInput | UserRoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplayItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleplayItems
    **/
    _count?: true | UserRoleplayItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleplayItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleplayItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleplayItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleplayItemMaxAggregateInputType
  }

  export type GetUserRoleplayItemAggregateType<T extends UserRoleplayItemAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleplayItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleplayItem[P]>
      : GetScalarType<T[P], AggregateUserRoleplayItem[P]>
  }




  export type UserRoleplayItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleplayItemWhereInput
    orderBy?: UserRoleplayItemOrderByWithAggregationInput | UserRoleplayItemOrderByWithAggregationInput[]
    by: UserRoleplayItemScalarFieldEnum[] | UserRoleplayItemScalarFieldEnum
    having?: UserRoleplayItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleplayItemCountAggregateInputType | true
    _avg?: UserRoleplayItemAvgAggregateInputType
    _sum?: UserRoleplayItemSumAggregateInputType
    _min?: UserRoleplayItemMinAggregateInputType
    _max?: UserRoleplayItemMaxAggregateInputType
  }

  export type UserRoleplayItemGroupByOutputType = {
    id: number
    userId: number
    rpId: number
    itemId: number
    count: number
    _count: UserRoleplayItemCountAggregateOutputType | null
    _avg: UserRoleplayItemAvgAggregateOutputType | null
    _sum: UserRoleplayItemSumAggregateOutputType | null
    _min: UserRoleplayItemMinAggregateOutputType | null
    _max: UserRoleplayItemMaxAggregateOutputType | null
  }

  type GetUserRoleplayItemGroupByPayload<T extends UserRoleplayItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleplayItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleplayItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleplayItemGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleplayItemGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleplayItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rpId?: boolean
    itemId?: boolean
    count?: boolean
  }, ExtArgs["result"]["userRoleplayItem"]>

  export type UserRoleplayItemSelectScalar = {
    id?: boolean
    userId?: boolean
    rpId?: boolean
    itemId?: boolean
    count?: boolean
  }


  export type $UserRoleplayItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoleplayItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      rpId: number
      itemId: number
      count: number
    }, ExtArgs["result"]["userRoleplayItem"]>
    composites: {}
  }


  type UserRoleplayItemGetPayload<S extends boolean | null | undefined | UserRoleplayItemDefaultArgs> = $Result.GetResult<Prisma.$UserRoleplayItemPayload, S>

  type UserRoleplayItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleplayItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleplayItemCountAggregateInputType | true
    }

  export interface UserRoleplayItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoleplayItem'], meta: { name: 'UserRoleplayItem' } }
    /**
     * Find zero or one UserRoleplayItem that matches the filter.
     * @param {UserRoleplayItemFindUniqueArgs} args - Arguments to find a UserRoleplayItem
     * @example
     * // Get one UserRoleplayItem
     * const userRoleplayItem = await prisma.userRoleplayItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRoleplayItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayItemFindUniqueArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserRoleplayItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRoleplayItemFindUniqueOrThrowArgs} args - Arguments to find a UserRoleplayItem
     * @example
     * // Get one UserRoleplayItem
     * const userRoleplayItem = await prisma.userRoleplayItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRoleplayItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserRoleplayItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemFindFirstArgs} args - Arguments to find a UserRoleplayItem
     * @example
     * // Get one UserRoleplayItem
     * const userRoleplayItem = await prisma.userRoleplayItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRoleplayItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayItemFindFirstArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserRoleplayItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemFindFirstOrThrowArgs} args - Arguments to find a UserRoleplayItem
     * @example
     * // Get one UserRoleplayItem
     * const userRoleplayItem = await prisma.userRoleplayItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRoleplayItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserRoleplayItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleplayItems
     * const userRoleplayItems = await prisma.userRoleplayItem.findMany()
     * 
     * // Get first 10 UserRoleplayItems
     * const userRoleplayItems = await prisma.userRoleplayItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleplayItemWithIdOnly = await prisma.userRoleplayItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserRoleplayItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserRoleplayItem.
     * @param {UserRoleplayItemCreateArgs} args - Arguments to create a UserRoleplayItem.
     * @example
     * // Create one UserRoleplayItem
     * const UserRoleplayItem = await prisma.userRoleplayItem.create({
     *   data: {
     *     // ... data to create a UserRoleplayItem
     *   }
     * })
     * 
    **/
    create<T extends UserRoleplayItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayItemCreateArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserRoleplayItems.
     *     @param {UserRoleplayItemCreateManyArgs} args - Arguments to create many UserRoleplayItems.
     *     @example
     *     // Create many UserRoleplayItems
     *     const userRoleplayItem = await prisma.userRoleplayItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRoleplayItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoleplayItem.
     * @param {UserRoleplayItemDeleteArgs} args - Arguments to delete one UserRoleplayItem.
     * @example
     * // Delete one UserRoleplayItem
     * const UserRoleplayItem = await prisma.userRoleplayItem.delete({
     *   where: {
     *     // ... filter to delete one UserRoleplayItem
     *   }
     * })
     * 
    **/
    delete<T extends UserRoleplayItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayItemDeleteArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserRoleplayItem.
     * @param {UserRoleplayItemUpdateArgs} args - Arguments to update one UserRoleplayItem.
     * @example
     * // Update one UserRoleplayItem
     * const userRoleplayItem = await prisma.userRoleplayItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRoleplayItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayItemUpdateArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserRoleplayItems.
     * @param {UserRoleplayItemDeleteManyArgs} args - Arguments to filter UserRoleplayItems to delete.
     * @example
     * // Delete a few UserRoleplayItems
     * const { count } = await prisma.userRoleplayItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRoleplayItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserRoleplayItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleplayItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleplayItems
     * const userRoleplayItem = await prisma.userRoleplayItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRoleplayItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoleplayItem.
     * @param {UserRoleplayItemUpsertArgs} args - Arguments to update or create a UserRoleplayItem.
     * @example
     * // Update or create a UserRoleplayItem
     * const userRoleplayItem = await prisma.userRoleplayItem.upsert({
     *   create: {
     *     // ... data to create a UserRoleplayItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleplayItem we want to update
     *   }
     * })
    **/
    upsert<T extends UserRoleplayItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserRoleplayItemUpsertArgs<ExtArgs>>
    ): Prisma__UserRoleplayItemClient<$Result.GetResult<Prisma.$UserRoleplayItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserRoleplayItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemCountArgs} args - Arguments to filter UserRoleplayItems to count.
     * @example
     * // Count the number of UserRoleplayItems
     * const count = await prisma.userRoleplayItem.count({
     *   where: {
     *     // ... the filter for the UserRoleplayItems we want to count
     *   }
     * })
    **/
    count<T extends UserRoleplayItemCountArgs>(
      args?: Subset<T, UserRoleplayItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleplayItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleplayItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleplayItemAggregateArgs>(args: Subset<T, UserRoleplayItemAggregateArgs>): Prisma.PrismaPromise<GetUserRoleplayItemAggregateType<T>>

    /**
     * Group by UserRoleplayItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleplayItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleplayItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleplayItemGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleplayItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleplayItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleplayItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoleplayItem model
   */
  readonly fields: UserRoleplayItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleplayItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleplayItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserRoleplayItem model
   */ 
  interface UserRoleplayItemFieldRefs {
    readonly id: FieldRef<"UserRoleplayItem", 'Int'>
    readonly userId: FieldRef<"UserRoleplayItem", 'Int'>
    readonly rpId: FieldRef<"UserRoleplayItem", 'Int'>
    readonly itemId: FieldRef<"UserRoleplayItem", 'Int'>
    readonly count: FieldRef<"UserRoleplayItem", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserRoleplayItem findUnique
   */
  export type UserRoleplayItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplayItem to fetch.
     */
    where: UserRoleplayItemWhereUniqueInput
  }


  /**
   * UserRoleplayItem findUniqueOrThrow
   */
  export type UserRoleplayItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplayItem to fetch.
     */
    where: UserRoleplayItemWhereUniqueInput
  }


  /**
   * UserRoleplayItem findFirst
   */
  export type UserRoleplayItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplayItem to fetch.
     */
    where?: UserRoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplayItems to fetch.
     */
    orderBy?: UserRoleplayItemOrderByWithRelationInput | UserRoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleplayItems.
     */
    cursor?: UserRoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplayItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleplayItems.
     */
    distinct?: UserRoleplayItemScalarFieldEnum | UserRoleplayItemScalarFieldEnum[]
  }


  /**
   * UserRoleplayItem findFirstOrThrow
   */
  export type UserRoleplayItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplayItem to fetch.
     */
    where?: UserRoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplayItems to fetch.
     */
    orderBy?: UserRoleplayItemOrderByWithRelationInput | UserRoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleplayItems.
     */
    cursor?: UserRoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplayItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleplayItems.
     */
    distinct?: UserRoleplayItemScalarFieldEnum | UserRoleplayItemScalarFieldEnum[]
  }


  /**
   * UserRoleplayItem findMany
   */
  export type UserRoleplayItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * Filter, which UserRoleplayItems to fetch.
     */
    where?: UserRoleplayItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleplayItems to fetch.
     */
    orderBy?: UserRoleplayItemOrderByWithRelationInput | UserRoleplayItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleplayItems.
     */
    cursor?: UserRoleplayItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleplayItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleplayItems.
     */
    skip?: number
    distinct?: UserRoleplayItemScalarFieldEnum | UserRoleplayItemScalarFieldEnum[]
  }


  /**
   * UserRoleplayItem create
   */
  export type UserRoleplayItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * The data needed to create a UserRoleplayItem.
     */
    data: XOR<UserRoleplayItemCreateInput, UserRoleplayItemUncheckedCreateInput>
  }


  /**
   * UserRoleplayItem createMany
   */
  export type UserRoleplayItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoleplayItems.
     */
    data: UserRoleplayItemCreateManyInput | UserRoleplayItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserRoleplayItem update
   */
  export type UserRoleplayItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * The data needed to update a UserRoleplayItem.
     */
    data: XOR<UserRoleplayItemUpdateInput, UserRoleplayItemUncheckedUpdateInput>
    /**
     * Choose, which UserRoleplayItem to update.
     */
    where: UserRoleplayItemWhereUniqueInput
  }


  /**
   * UserRoleplayItem updateMany
   */
  export type UserRoleplayItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoleplayItems.
     */
    data: XOR<UserRoleplayItemUpdateManyMutationInput, UserRoleplayItemUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleplayItems to update
     */
    where?: UserRoleplayItemWhereInput
  }


  /**
   * UserRoleplayItem upsert
   */
  export type UserRoleplayItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * The filter to search for the UserRoleplayItem to update in case it exists.
     */
    where: UserRoleplayItemWhereUniqueInput
    /**
     * In case the UserRoleplayItem found by the `where` argument doesn't exist, create a new UserRoleplayItem with this data.
     */
    create: XOR<UserRoleplayItemCreateInput, UserRoleplayItemUncheckedCreateInput>
    /**
     * In case the UserRoleplayItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleplayItemUpdateInput, UserRoleplayItemUncheckedUpdateInput>
  }


  /**
   * UserRoleplayItem delete
   */
  export type UserRoleplayItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
    /**
     * Filter which UserRoleplayItem to delete.
     */
    where: UserRoleplayItemWhereUniqueInput
  }


  /**
   * UserRoleplayItem deleteMany
   */
  export type UserRoleplayItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleplayItems to delete
     */
    where?: UserRoleplayItemWhereInput
  }


  /**
   * UserRoleplayItem without action
   */
  export type UserRoleplayItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleplayItem
     */
    select?: UserRoleplayItemSelect<ExtArgs> | null
  }



  /**
   * Model UserStats
   */

  export type AggregateUserStats = {
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  export type UserStatsAvgAggregateOutputType = {
    id: number | null
    onlineTime: number | null
    respect: number | null
    respectGiven: number | null
    giftsGiven: number | null
    giftsReceived: number | null
    dailyRespectPoints: number | null
    dailyPetRespectPoints: number | null
    achievementScore: number | null
    questId: number | null
    questProgress: number | null
    levBuilder: number | null
    levSocial: number | null
    levIdentity: number | null
    levExplore: number | null
    groupId: number | null
  }

  export type UserStatsSumAggregateOutputType = {
    id: number | null
    onlineTime: number | null
    respect: number | null
    respectGiven: number | null
    giftsGiven: number | null
    giftsReceived: number | null
    dailyRespectPoints: number | null
    dailyPetRespectPoints: number | null
    achievementScore: number | null
    questId: number | null
    questProgress: number | null
    levBuilder: number | null
    levSocial: number | null
    levIdentity: number | null
    levExplore: number | null
    groupId: number | null
  }

  export type UserStatsMinAggregateOutputType = {
    id: number | null
    onlineTime: number | null
    respect: number | null
    respectGiven: number | null
    giftsGiven: number | null
    giftsReceived: number | null
    dailyRespectPoints: number | null
    dailyPetRespectPoints: number | null
    achievementScore: number | null
    questId: number | null
    questProgress: number | null
    levBuilder: number | null
    levSocial: number | null
    levIdentity: number | null
    levExplore: number | null
    groupId: number | null
  }

  export type UserStatsMaxAggregateOutputType = {
    id: number | null
    onlineTime: number | null
    respect: number | null
    respectGiven: number | null
    giftsGiven: number | null
    giftsReceived: number | null
    dailyRespectPoints: number | null
    dailyPetRespectPoints: number | null
    achievementScore: number | null
    questId: number | null
    questProgress: number | null
    levBuilder: number | null
    levSocial: number | null
    levIdentity: number | null
    levExplore: number | null
    groupId: number | null
  }

  export type UserStatsCountAggregateOutputType = {
    id: number
    onlineTime: number
    respect: number
    respectGiven: number
    giftsGiven: number
    giftsReceived: number
    dailyRespectPoints: number
    dailyPetRespectPoints: number
    achievementScore: number
    questId: number
    questProgress: number
    levBuilder: number
    levSocial: number
    levIdentity: number
    levExplore: number
    groupId: number
    _all: number
  }


  export type UserStatsAvgAggregateInputType = {
    id?: true
    onlineTime?: true
    respect?: true
    respectGiven?: true
    giftsGiven?: true
    giftsReceived?: true
    dailyRespectPoints?: true
    dailyPetRespectPoints?: true
    achievementScore?: true
    questId?: true
    questProgress?: true
    levBuilder?: true
    levSocial?: true
    levIdentity?: true
    levExplore?: true
    groupId?: true
  }

  export type UserStatsSumAggregateInputType = {
    id?: true
    onlineTime?: true
    respect?: true
    respectGiven?: true
    giftsGiven?: true
    giftsReceived?: true
    dailyRespectPoints?: true
    dailyPetRespectPoints?: true
    achievementScore?: true
    questId?: true
    questProgress?: true
    levBuilder?: true
    levSocial?: true
    levIdentity?: true
    levExplore?: true
    groupId?: true
  }

  export type UserStatsMinAggregateInputType = {
    id?: true
    onlineTime?: true
    respect?: true
    respectGiven?: true
    giftsGiven?: true
    giftsReceived?: true
    dailyRespectPoints?: true
    dailyPetRespectPoints?: true
    achievementScore?: true
    questId?: true
    questProgress?: true
    levBuilder?: true
    levSocial?: true
    levIdentity?: true
    levExplore?: true
    groupId?: true
  }

  export type UserStatsMaxAggregateInputType = {
    id?: true
    onlineTime?: true
    respect?: true
    respectGiven?: true
    giftsGiven?: true
    giftsReceived?: true
    dailyRespectPoints?: true
    dailyPetRespectPoints?: true
    achievementScore?: true
    questId?: true
    questProgress?: true
    levBuilder?: true
    levSocial?: true
    levIdentity?: true
    levExplore?: true
    groupId?: true
  }

  export type UserStatsCountAggregateInputType = {
    id?: true
    onlineTime?: true
    respect?: true
    respectGiven?: true
    giftsGiven?: true
    giftsReceived?: true
    dailyRespectPoints?: true
    dailyPetRespectPoints?: true
    achievementScore?: true
    questId?: true
    questProgress?: true
    levBuilder?: true
    levSocial?: true
    levIdentity?: true
    levExplore?: true
    groupId?: true
    _all?: true
  }

  export type UserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to aggregate.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStats
    **/
    _count?: true | UserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatsMaxAggregateInputType
  }

  export type GetUserStatsAggregateType<T extends UserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStats[P]>
      : GetScalarType<T[P], AggregateUserStats[P]>
  }




  export type UserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatsWhereInput
    orderBy?: UserStatsOrderByWithAggregationInput | UserStatsOrderByWithAggregationInput[]
    by: UserStatsScalarFieldEnum[] | UserStatsScalarFieldEnum
    having?: UserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatsCountAggregateInputType | true
    _avg?: UserStatsAvgAggregateInputType
    _sum?: UserStatsSumAggregateInputType
    _min?: UserStatsMinAggregateInputType
    _max?: UserStatsMaxAggregateInputType
  }

  export type UserStatsGroupByOutputType = {
    id: number
    onlineTime: number
    respect: number
    respectGiven: number
    giftsGiven: number
    giftsReceived: number
    dailyRespectPoints: number
    dailyPetRespectPoints: number
    achievementScore: number
    questId: number
    questProgress: number
    levBuilder: number
    levSocial: number
    levIdentity: number
    levExplore: number
    groupId: number
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  type GetUserStatsGroupByPayload<T extends UserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
        }
      >
    >


  export type UserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    onlineTime?: boolean
    respect?: boolean
    respectGiven?: boolean
    giftsGiven?: boolean
    giftsReceived?: boolean
    dailyRespectPoints?: boolean
    dailyPetRespectPoints?: boolean
    achievementScore?: boolean
    questId?: boolean
    questProgress?: boolean
    levBuilder?: boolean
    levSocial?: boolean
    levIdentity?: boolean
    levExplore?: boolean
    groupId?: boolean
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectScalar = {
    id?: boolean
    onlineTime?: boolean
    respect?: boolean
    respectGiven?: boolean
    giftsGiven?: boolean
    giftsReceived?: boolean
    dailyRespectPoints?: boolean
    dailyPetRespectPoints?: boolean
    achievementScore?: boolean
    questId?: boolean
    questProgress?: boolean
    levBuilder?: boolean
    levSocial?: boolean
    levIdentity?: boolean
    levExplore?: boolean
    groupId?: boolean
  }


  export type $UserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      onlineTime: number
      respect: number
      respectGiven: number
      giftsGiven: number
      giftsReceived: number
      dailyRespectPoints: number
      dailyPetRespectPoints: number
      achievementScore: number
      questId: number
      questProgress: number
      levBuilder: number
      levSocial: number
      levIdentity: number
      levExplore: number
      groupId: number
    }, ExtArgs["result"]["userStats"]>
    composites: {}
  }


  type UserStatsGetPayload<S extends boolean | null | undefined | UserStatsDefaultArgs> = $Result.GetResult<Prisma.$UserStatsPayload, S>

  type UserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserStatsCountAggregateInputType | true
    }

  export interface UserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStats'], meta: { name: 'UserStats' } }
    /**
     * Find zero or one UserStats that matches the filter.
     * @param {UserStatsFindUniqueArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserStatsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserStatsFindUniqueArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserStats that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserStatsFindUniqueOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserStatsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserStatsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserStatsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserStatsFindFirstArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserStatsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserStatsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStats
     * const userStats = await prisma.userStats.findMany()
     * 
     * // Get first 10 UserStats
     * const userStats = await prisma.userStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatsWithIdOnly = await prisma.userStats.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserStatsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserStatsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserStats.
     * @param {UserStatsCreateArgs} args - Arguments to create a UserStats.
     * @example
     * // Create one UserStats
     * const UserStats = await prisma.userStats.create({
     *   data: {
     *     // ... data to create a UserStats
     *   }
     * })
     * 
    **/
    create<T extends UserStatsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserStatsCreateArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserStats.
     *     @param {UserStatsCreateManyArgs} args - Arguments to create many UserStats.
     *     @example
     *     // Create many UserStats
     *     const userStats = await prisma.userStats.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserStatsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserStatsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserStats.
     * @param {UserStatsDeleteArgs} args - Arguments to delete one UserStats.
     * @example
     * // Delete one UserStats
     * const UserStats = await prisma.userStats.delete({
     *   where: {
     *     // ... filter to delete one UserStats
     *   }
     * })
     * 
    **/
    delete<T extends UserStatsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserStatsDeleteArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserStats.
     * @param {UserStatsUpdateArgs} args - Arguments to update one UserStats.
     * @example
     * // Update one UserStats
     * const userStats = await prisma.userStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserStatsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserStatsUpdateArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserStats.
     * @param {UserStatsDeleteManyArgs} args - Arguments to filter UserStats to delete.
     * @example
     * // Delete a few UserStats
     * const { count } = await prisma.userStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserStatsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserStatsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserStatsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserStatsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserStats.
     * @param {UserStatsUpsertArgs} args - Arguments to update or create a UserStats.
     * @example
     * // Update or create a UserStats
     * const userStats = await prisma.userStats.upsert({
     *   create: {
     *     // ... data to create a UserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStats we want to update
     *   }
     * })
    **/
    upsert<T extends UserStatsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserStatsUpsertArgs<ExtArgs>>
    ): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsCountArgs} args - Arguments to filter UserStats to count.
     * @example
     * // Count the number of UserStats
     * const count = await prisma.userStats.count({
     *   where: {
     *     // ... the filter for the UserStats we want to count
     *   }
     * })
    **/
    count<T extends UserStatsCountArgs>(
      args?: Subset<T, UserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatsAggregateArgs>(args: Subset<T, UserStatsAggregateArgs>): Prisma.PrismaPromise<GetUserStatsAggregateType<T>>

    /**
     * Group by UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatsGroupByArgs['orderBy'] }
        : { orderBy?: UserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStats model
   */
  readonly fields: UserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserStats model
   */ 
  interface UserStatsFieldRefs {
    readonly id: FieldRef<"UserStats", 'Int'>
    readonly onlineTime: FieldRef<"UserStats", 'Int'>
    readonly respect: FieldRef<"UserStats", 'Int'>
    readonly respectGiven: FieldRef<"UserStats", 'Int'>
    readonly giftsGiven: FieldRef<"UserStats", 'Int'>
    readonly giftsReceived: FieldRef<"UserStats", 'Int'>
    readonly dailyRespectPoints: FieldRef<"UserStats", 'Int'>
    readonly dailyPetRespectPoints: FieldRef<"UserStats", 'Int'>
    readonly achievementScore: FieldRef<"UserStats", 'Int'>
    readonly questId: FieldRef<"UserStats", 'Int'>
    readonly questProgress: FieldRef<"UserStats", 'Int'>
    readonly levBuilder: FieldRef<"UserStats", 'Int'>
    readonly levSocial: FieldRef<"UserStats", 'Int'>
    readonly levIdentity: FieldRef<"UserStats", 'Int'>
    readonly levExplore: FieldRef<"UserStats", 'Int'>
    readonly groupId: FieldRef<"UserStats", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * UserStats findUnique
   */
  export type UserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }


  /**
   * UserStats findUniqueOrThrow
   */
  export type UserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }


  /**
   * UserStats findFirst
   */
  export type UserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }


  /**
   * UserStats findFirstOrThrow
   */
  export type UserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }


  /**
   * UserStats findMany
   */
  export type UserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }


  /**
   * UserStats create
   */
  export type UserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * The data needed to create a UserStats.
     */
    data: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
  }


  /**
   * UserStats createMany
   */
  export type UserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserStats update
   */
  export type UserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * The data needed to update a UserStats.
     */
    data: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
    /**
     * Choose, which UserStats to update.
     */
    where: UserStatsWhereUniqueInput
  }


  /**
   * UserStats updateMany
   */
  export type UserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
  }


  /**
   * UserStats upsert
   */
  export type UserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * The filter to search for the UserStats to update in case it exists.
     */
    where: UserStatsWhereUniqueInput
    /**
     * In case the UserStats found by the `where` argument doesn't exist, create a new UserStats with this data.
     */
    create: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
    /**
     * In case the UserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
  }


  /**
   * UserStats delete
   */
  export type UserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Filter which UserStats to delete.
     */
    where: UserStatsWhereUniqueInput
  }


  /**
   * UserStats deleteMany
   */
  export type UserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to delete
     */
    where?: UserStatsWhereInput
  }


  /**
   * UserStats without action
   */
  export type UserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
  }



  /**
   * Model UserWardrobe
   */

  export type AggregateUserWardrobe = {
    _count: UserWardrobeCountAggregateOutputType | null
    _avg: UserWardrobeAvgAggregateOutputType | null
    _sum: UserWardrobeSumAggregateOutputType | null
    _min: UserWardrobeMinAggregateOutputType | null
    _max: UserWardrobeMaxAggregateOutputType | null
  }

  export type UserWardrobeAvgAggregateOutputType = {
    userId: number | null
    slotId: number | null
  }

  export type UserWardrobeSumAggregateOutputType = {
    userId: number | null
    slotId: number | null
  }

  export type UserWardrobeMinAggregateOutputType = {
    userId: number | null
    slotId: number | null
    look: string | null
    gender: $Enums.UserWardrobeGender | null
  }

  export type UserWardrobeMaxAggregateOutputType = {
    userId: number | null
    slotId: number | null
    look: string | null
    gender: $Enums.UserWardrobeGender | null
  }

  export type UserWardrobeCountAggregateOutputType = {
    userId: number
    slotId: number
    look: number
    gender: number
    _all: number
  }


  export type UserWardrobeAvgAggregateInputType = {
    userId?: true
    slotId?: true
  }

  export type UserWardrobeSumAggregateInputType = {
    userId?: true
    slotId?: true
  }

  export type UserWardrobeMinAggregateInputType = {
    userId?: true
    slotId?: true
    look?: true
    gender?: true
  }

  export type UserWardrobeMaxAggregateInputType = {
    userId?: true
    slotId?: true
    look?: true
    gender?: true
  }

  export type UserWardrobeCountAggregateInputType = {
    userId?: true
    slotId?: true
    look?: true
    gender?: true
    _all?: true
  }

  export type UserWardrobeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWardrobe to aggregate.
     */
    where?: UserWardrobeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWardrobes to fetch.
     */
    orderBy?: UserWardrobeOrderByWithRelationInput | UserWardrobeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWardrobeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWardrobes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWardrobes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWardrobes
    **/
    _count?: true | UserWardrobeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserWardrobeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserWardrobeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWardrobeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWardrobeMaxAggregateInputType
  }

  export type GetUserWardrobeAggregateType<T extends UserWardrobeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWardrobe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWardrobe[P]>
      : GetScalarType<T[P], AggregateUserWardrobe[P]>
  }




  export type UserWardrobeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWardrobeWhereInput
    orderBy?: UserWardrobeOrderByWithAggregationInput | UserWardrobeOrderByWithAggregationInput[]
    by: UserWardrobeScalarFieldEnum[] | UserWardrobeScalarFieldEnum
    having?: UserWardrobeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserWardrobeCountAggregateInputType | true
    _avg?: UserWardrobeAvgAggregateInputType
    _sum?: UserWardrobeSumAggregateInputType
    _min?: UserWardrobeMinAggregateInputType
    _max?: UserWardrobeMaxAggregateInputType
  }

  export type UserWardrobeGroupByOutputType = {
    userId: number
    slotId: number
    look: string
    gender: $Enums.UserWardrobeGender
    _count: UserWardrobeCountAggregateOutputType | null
    _avg: UserWardrobeAvgAggregateOutputType | null
    _sum: UserWardrobeSumAggregateOutputType | null
    _min: UserWardrobeMinAggregateOutputType | null
    _max: UserWardrobeMaxAggregateOutputType | null
  }

  type GetUserWardrobeGroupByPayload<T extends UserWardrobeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWardrobeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWardrobeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWardrobeGroupByOutputType[P]>
            : GetScalarType<T[P], UserWardrobeGroupByOutputType[P]>
        }
      >
    >


  export type UserWardrobeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    slotId?: boolean
    look?: boolean
    gender?: boolean
  }, ExtArgs["result"]["userWardrobe"]>

  export type UserWardrobeSelectScalar = {
    userId?: boolean
    slotId?: boolean
    look?: boolean
    gender?: boolean
  }


  export type $UserWardrobePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWardrobe"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      slotId: number
      look: string
      gender: $Enums.UserWardrobeGender
    }, ExtArgs["result"]["userWardrobe"]>
    composites: {}
  }


  type UserWardrobeGetPayload<S extends boolean | null | undefined | UserWardrobeDefaultArgs> = $Result.GetResult<Prisma.$UserWardrobePayload, S>

  type UserWardrobeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserWardrobeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserWardrobeCountAggregateInputType | true
    }

  export interface UserWardrobeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWardrobe'], meta: { name: 'UserWardrobe' } }
    /**
     * Find zero or one UserWardrobe that matches the filter.
     * @param {UserWardrobeFindUniqueArgs} args - Arguments to find a UserWardrobe
     * @example
     * // Get one UserWardrobe
     * const userWardrobe = await prisma.userWardrobe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserWardrobeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserWardrobeFindUniqueArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserWardrobe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserWardrobeFindUniqueOrThrowArgs} args - Arguments to find a UserWardrobe
     * @example
     * // Get one UserWardrobe
     * const userWardrobe = await prisma.userWardrobe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserWardrobeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserWardrobeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserWardrobe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeFindFirstArgs} args - Arguments to find a UserWardrobe
     * @example
     * // Get one UserWardrobe
     * const userWardrobe = await prisma.userWardrobe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserWardrobeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserWardrobeFindFirstArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserWardrobe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeFindFirstOrThrowArgs} args - Arguments to find a UserWardrobe
     * @example
     * // Get one UserWardrobe
     * const userWardrobe = await prisma.userWardrobe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserWardrobeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserWardrobeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserWardrobes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWardrobes
     * const userWardrobes = await prisma.userWardrobe.findMany()
     * 
     * // Get first 10 UserWardrobes
     * const userWardrobes = await prisma.userWardrobe.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWardrobeWithUserIdOnly = await prisma.userWardrobe.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserWardrobeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserWardrobeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserWardrobe.
     * @param {UserWardrobeCreateArgs} args - Arguments to create a UserWardrobe.
     * @example
     * // Create one UserWardrobe
     * const UserWardrobe = await prisma.userWardrobe.create({
     *   data: {
     *     // ... data to create a UserWardrobe
     *   }
     * })
     * 
    **/
    create<T extends UserWardrobeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserWardrobeCreateArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserWardrobes.
     *     @param {UserWardrobeCreateManyArgs} args - Arguments to create many UserWardrobes.
     *     @example
     *     // Create many UserWardrobes
     *     const userWardrobe = await prisma.userWardrobe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserWardrobeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserWardrobeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserWardrobe.
     * @param {UserWardrobeDeleteArgs} args - Arguments to delete one UserWardrobe.
     * @example
     * // Delete one UserWardrobe
     * const UserWardrobe = await prisma.userWardrobe.delete({
     *   where: {
     *     // ... filter to delete one UserWardrobe
     *   }
     * })
     * 
    **/
    delete<T extends UserWardrobeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserWardrobeDeleteArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserWardrobe.
     * @param {UserWardrobeUpdateArgs} args - Arguments to update one UserWardrobe.
     * @example
     * // Update one UserWardrobe
     * const userWardrobe = await prisma.userWardrobe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserWardrobeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserWardrobeUpdateArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserWardrobes.
     * @param {UserWardrobeDeleteManyArgs} args - Arguments to filter UserWardrobes to delete.
     * @example
     * // Delete a few UserWardrobes
     * const { count } = await prisma.userWardrobe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserWardrobeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserWardrobeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWardrobes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWardrobes
     * const userWardrobe = await prisma.userWardrobe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserWardrobeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserWardrobeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserWardrobe.
     * @param {UserWardrobeUpsertArgs} args - Arguments to update or create a UserWardrobe.
     * @example
     * // Update or create a UserWardrobe
     * const userWardrobe = await prisma.userWardrobe.upsert({
     *   create: {
     *     // ... data to create a UserWardrobe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWardrobe we want to update
     *   }
     * })
    **/
    upsert<T extends UserWardrobeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserWardrobeUpsertArgs<ExtArgs>>
    ): Prisma__UserWardrobeClient<$Result.GetResult<Prisma.$UserWardrobePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserWardrobes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeCountArgs} args - Arguments to filter UserWardrobes to count.
     * @example
     * // Count the number of UserWardrobes
     * const count = await prisma.userWardrobe.count({
     *   where: {
     *     // ... the filter for the UserWardrobes we want to count
     *   }
     * })
    **/
    count<T extends UserWardrobeCountArgs>(
      args?: Subset<T, UserWardrobeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWardrobeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWardrobe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWardrobeAggregateArgs>(args: Subset<T, UserWardrobeAggregateArgs>): Prisma.PrismaPromise<GetUserWardrobeAggregateType<T>>

    /**
     * Group by UserWardrobe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWardrobeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWardrobeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWardrobeGroupByArgs['orderBy'] }
        : { orderBy?: UserWardrobeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWardrobeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWardrobeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWardrobe model
   */
  readonly fields: UserWardrobeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWardrobe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWardrobeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserWardrobe model
   */ 
  interface UserWardrobeFieldRefs {
    readonly userId: FieldRef<"UserWardrobe", 'Int'>
    readonly slotId: FieldRef<"UserWardrobe", 'Int'>
    readonly look: FieldRef<"UserWardrobe", 'String'>
    readonly gender: FieldRef<"UserWardrobe", 'UserWardrobeGender'>
  }
    

  // Custom InputTypes

  /**
   * UserWardrobe findUnique
   */
  export type UserWardrobeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * Filter, which UserWardrobe to fetch.
     */
    where: UserWardrobeWhereUniqueInput
  }


  /**
   * UserWardrobe findUniqueOrThrow
   */
  export type UserWardrobeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * Filter, which UserWardrobe to fetch.
     */
    where: UserWardrobeWhereUniqueInput
  }


  /**
   * UserWardrobe findFirst
   */
  export type UserWardrobeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * Filter, which UserWardrobe to fetch.
     */
    where?: UserWardrobeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWardrobes to fetch.
     */
    orderBy?: UserWardrobeOrderByWithRelationInput | UserWardrobeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWardrobes.
     */
    cursor?: UserWardrobeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWardrobes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWardrobes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWardrobes.
     */
    distinct?: UserWardrobeScalarFieldEnum | UserWardrobeScalarFieldEnum[]
  }


  /**
   * UserWardrobe findFirstOrThrow
   */
  export type UserWardrobeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * Filter, which UserWardrobe to fetch.
     */
    where?: UserWardrobeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWardrobes to fetch.
     */
    orderBy?: UserWardrobeOrderByWithRelationInput | UserWardrobeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWardrobes.
     */
    cursor?: UserWardrobeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWardrobes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWardrobes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWardrobes.
     */
    distinct?: UserWardrobeScalarFieldEnum | UserWardrobeScalarFieldEnum[]
  }


  /**
   * UserWardrobe findMany
   */
  export type UserWardrobeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * Filter, which UserWardrobes to fetch.
     */
    where?: UserWardrobeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWardrobes to fetch.
     */
    orderBy?: UserWardrobeOrderByWithRelationInput | UserWardrobeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWardrobes.
     */
    cursor?: UserWardrobeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWardrobes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWardrobes.
     */
    skip?: number
    distinct?: UserWardrobeScalarFieldEnum | UserWardrobeScalarFieldEnum[]
  }


  /**
   * UserWardrobe create
   */
  export type UserWardrobeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * The data needed to create a UserWardrobe.
     */
    data: XOR<UserWardrobeCreateInput, UserWardrobeUncheckedCreateInput>
  }


  /**
   * UserWardrobe createMany
   */
  export type UserWardrobeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWardrobes.
     */
    data: UserWardrobeCreateManyInput | UserWardrobeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserWardrobe update
   */
  export type UserWardrobeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * The data needed to update a UserWardrobe.
     */
    data: XOR<UserWardrobeUpdateInput, UserWardrobeUncheckedUpdateInput>
    /**
     * Choose, which UserWardrobe to update.
     */
    where: UserWardrobeWhereUniqueInput
  }


  /**
   * UserWardrobe updateMany
   */
  export type UserWardrobeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWardrobes.
     */
    data: XOR<UserWardrobeUpdateManyMutationInput, UserWardrobeUncheckedUpdateManyInput>
    /**
     * Filter which UserWardrobes to update
     */
    where?: UserWardrobeWhereInput
  }


  /**
   * UserWardrobe upsert
   */
  export type UserWardrobeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * The filter to search for the UserWardrobe to update in case it exists.
     */
    where: UserWardrobeWhereUniqueInput
    /**
     * In case the UserWardrobe found by the `where` argument doesn't exist, create a new UserWardrobe with this data.
     */
    create: XOR<UserWardrobeCreateInput, UserWardrobeUncheckedCreateInput>
    /**
     * In case the UserWardrobe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWardrobeUpdateInput, UserWardrobeUncheckedUpdateInput>
  }


  /**
   * UserWardrobe delete
   */
  export type UserWardrobeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
    /**
     * Filter which UserWardrobe to delete.
     */
    where: UserWardrobeWhereUniqueInput
  }


  /**
   * UserWardrobe deleteMany
   */
  export type UserWardrobeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWardrobes to delete
     */
    where?: UserWardrobeWhereInput
  }


  /**
   * UserWardrobe without action
   */
  export type UserWardrobeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWardrobe
     */
    select?: UserWardrobeSelect<ExtArgs> | null
  }



  /**
   * Model WordFilterRetro
   */

  export type AggregateWordFilterRetro = {
    _count: WordFilterRetroCountAggregateOutputType | null
    _min: WordFilterRetroMinAggregateOutputType | null
    _max: WordFilterRetroMaxAggregateOutputType | null
  }

  export type WordFilterRetroMinAggregateOutputType = {
    word: string | null
  }

  export type WordFilterRetroMaxAggregateOutputType = {
    word: string | null
  }

  export type WordFilterRetroCountAggregateOutputType = {
    word: number
    _all: number
  }


  export type WordFilterRetroMinAggregateInputType = {
    word?: true
  }

  export type WordFilterRetroMaxAggregateInputType = {
    word?: true
  }

  export type WordFilterRetroCountAggregateInputType = {
    word?: true
    _all?: true
  }

  export type WordFilterRetroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordFilterRetro to aggregate.
     */
    where?: WordFilterRetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordFilterRetros to fetch.
     */
    orderBy?: WordFilterRetroOrderByWithRelationInput | WordFilterRetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WordFilterRetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordFilterRetros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordFilterRetros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WordFilterRetros
    **/
    _count?: true | WordFilterRetroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WordFilterRetroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WordFilterRetroMaxAggregateInputType
  }

  export type GetWordFilterRetroAggregateType<T extends WordFilterRetroAggregateArgs> = {
        [P in keyof T & keyof AggregateWordFilterRetro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWordFilterRetro[P]>
      : GetScalarType<T[P], AggregateWordFilterRetro[P]>
  }




  export type WordFilterRetroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordFilterRetroWhereInput
    orderBy?: WordFilterRetroOrderByWithAggregationInput | WordFilterRetroOrderByWithAggregationInput[]
    by: WordFilterRetroScalarFieldEnum[] | WordFilterRetroScalarFieldEnum
    having?: WordFilterRetroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WordFilterRetroCountAggregateInputType | true
    _min?: WordFilterRetroMinAggregateInputType
    _max?: WordFilterRetroMaxAggregateInputType
  }

  export type WordFilterRetroGroupByOutputType = {
    word: string
    _count: WordFilterRetroCountAggregateOutputType | null
    _min: WordFilterRetroMinAggregateOutputType | null
    _max: WordFilterRetroMaxAggregateOutputType | null
  }

  type GetWordFilterRetroGroupByPayload<T extends WordFilterRetroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WordFilterRetroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WordFilterRetroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WordFilterRetroGroupByOutputType[P]>
            : GetScalarType<T[P], WordFilterRetroGroupByOutputType[P]>
        }
      >
    >


  export type WordFilterRetroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    word?: boolean
  }, ExtArgs["result"]["wordFilterRetro"]>

  export type WordFilterRetroSelectScalar = {
    word?: boolean
  }


  export type $WordFilterRetroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WordFilterRetro"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      word: string
    }, ExtArgs["result"]["wordFilterRetro"]>
    composites: {}
  }


  type WordFilterRetroGetPayload<S extends boolean | null | undefined | WordFilterRetroDefaultArgs> = $Result.GetResult<Prisma.$WordFilterRetroPayload, S>

  type WordFilterRetroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WordFilterRetroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WordFilterRetroCountAggregateInputType | true
    }

  export interface WordFilterRetroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WordFilterRetro'], meta: { name: 'WordFilterRetro' } }
    /**
     * Find zero or one WordFilterRetro that matches the filter.
     * @param {WordFilterRetroFindUniqueArgs} args - Arguments to find a WordFilterRetro
     * @example
     * // Get one WordFilterRetro
     * const wordFilterRetro = await prisma.wordFilterRetro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WordFilterRetroFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WordFilterRetroFindUniqueArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WordFilterRetro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WordFilterRetroFindUniqueOrThrowArgs} args - Arguments to find a WordFilterRetro
     * @example
     * // Get one WordFilterRetro
     * const wordFilterRetro = await prisma.wordFilterRetro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WordFilterRetroFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFilterRetroFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WordFilterRetro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroFindFirstArgs} args - Arguments to find a WordFilterRetro
     * @example
     * // Get one WordFilterRetro
     * const wordFilterRetro = await prisma.wordFilterRetro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WordFilterRetroFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFilterRetroFindFirstArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WordFilterRetro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroFindFirstOrThrowArgs} args - Arguments to find a WordFilterRetro
     * @example
     * // Get one WordFilterRetro
     * const wordFilterRetro = await prisma.wordFilterRetro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WordFilterRetroFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFilterRetroFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WordFilterRetros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WordFilterRetros
     * const wordFilterRetros = await prisma.wordFilterRetro.findMany()
     * 
     * // Get first 10 WordFilterRetros
     * const wordFilterRetros = await prisma.wordFilterRetro.findMany({ take: 10 })
     * 
     * // Only select the `word`
     * const wordFilterRetroWithWordOnly = await prisma.wordFilterRetro.findMany({ select: { word: true } })
     * 
    **/
    findMany<T extends WordFilterRetroFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFilterRetroFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WordFilterRetro.
     * @param {WordFilterRetroCreateArgs} args - Arguments to create a WordFilterRetro.
     * @example
     * // Create one WordFilterRetro
     * const WordFilterRetro = await prisma.wordFilterRetro.create({
     *   data: {
     *     // ... data to create a WordFilterRetro
     *   }
     * })
     * 
    **/
    create<T extends WordFilterRetroCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WordFilterRetroCreateArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WordFilterRetros.
     *     @param {WordFilterRetroCreateManyArgs} args - Arguments to create many WordFilterRetros.
     *     @example
     *     // Create many WordFilterRetros
     *     const wordFilterRetro = await prisma.wordFilterRetro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WordFilterRetroCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFilterRetroCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WordFilterRetro.
     * @param {WordFilterRetroDeleteArgs} args - Arguments to delete one WordFilterRetro.
     * @example
     * // Delete one WordFilterRetro
     * const WordFilterRetro = await prisma.wordFilterRetro.delete({
     *   where: {
     *     // ... filter to delete one WordFilterRetro
     *   }
     * })
     * 
    **/
    delete<T extends WordFilterRetroDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WordFilterRetroDeleteArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WordFilterRetro.
     * @param {WordFilterRetroUpdateArgs} args - Arguments to update one WordFilterRetro.
     * @example
     * // Update one WordFilterRetro
     * const wordFilterRetro = await prisma.wordFilterRetro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WordFilterRetroUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WordFilterRetroUpdateArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WordFilterRetros.
     * @param {WordFilterRetroDeleteManyArgs} args - Arguments to filter WordFilterRetros to delete.
     * @example
     * // Delete a few WordFilterRetros
     * const { count } = await prisma.wordFilterRetro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WordFilterRetroDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFilterRetroDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WordFilterRetros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WordFilterRetros
     * const wordFilterRetro = await prisma.wordFilterRetro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WordFilterRetroUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WordFilterRetroUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WordFilterRetro.
     * @param {WordFilterRetroUpsertArgs} args - Arguments to update or create a WordFilterRetro.
     * @example
     * // Update or create a WordFilterRetro
     * const wordFilterRetro = await prisma.wordFilterRetro.upsert({
     *   create: {
     *     // ... data to create a WordFilterRetro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WordFilterRetro we want to update
     *   }
     * })
    **/
    upsert<T extends WordFilterRetroUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WordFilterRetroUpsertArgs<ExtArgs>>
    ): Prisma__WordFilterRetroClient<$Result.GetResult<Prisma.$WordFilterRetroPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WordFilterRetros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroCountArgs} args - Arguments to filter WordFilterRetros to count.
     * @example
     * // Count the number of WordFilterRetros
     * const count = await prisma.wordFilterRetro.count({
     *   where: {
     *     // ... the filter for the WordFilterRetros we want to count
     *   }
     * })
    **/
    count<T extends WordFilterRetroCountArgs>(
      args?: Subset<T, WordFilterRetroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WordFilterRetroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WordFilterRetro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WordFilterRetroAggregateArgs>(args: Subset<T, WordFilterRetroAggregateArgs>): Prisma.PrismaPromise<GetWordFilterRetroAggregateType<T>>

    /**
     * Group by WordFilterRetro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFilterRetroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WordFilterRetroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WordFilterRetroGroupByArgs['orderBy'] }
        : { orderBy?: WordFilterRetroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WordFilterRetroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWordFilterRetroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WordFilterRetro model
   */
  readonly fields: WordFilterRetroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WordFilterRetro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WordFilterRetroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WordFilterRetro model
   */ 
  interface WordFilterRetroFieldRefs {
    readonly word: FieldRef<"WordFilterRetro", 'String'>
  }
    

  // Custom InputTypes

  /**
   * WordFilterRetro findUnique
   */
  export type WordFilterRetroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * Filter, which WordFilterRetro to fetch.
     */
    where: WordFilterRetroWhereUniqueInput
  }


  /**
   * WordFilterRetro findUniqueOrThrow
   */
  export type WordFilterRetroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * Filter, which WordFilterRetro to fetch.
     */
    where: WordFilterRetroWhereUniqueInput
  }


  /**
   * WordFilterRetro findFirst
   */
  export type WordFilterRetroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * Filter, which WordFilterRetro to fetch.
     */
    where?: WordFilterRetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordFilterRetros to fetch.
     */
    orderBy?: WordFilterRetroOrderByWithRelationInput | WordFilterRetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordFilterRetros.
     */
    cursor?: WordFilterRetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordFilterRetros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordFilterRetros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordFilterRetros.
     */
    distinct?: WordFilterRetroScalarFieldEnum | WordFilterRetroScalarFieldEnum[]
  }


  /**
   * WordFilterRetro findFirstOrThrow
   */
  export type WordFilterRetroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * Filter, which WordFilterRetro to fetch.
     */
    where?: WordFilterRetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordFilterRetros to fetch.
     */
    orderBy?: WordFilterRetroOrderByWithRelationInput | WordFilterRetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordFilterRetros.
     */
    cursor?: WordFilterRetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordFilterRetros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordFilterRetros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordFilterRetros.
     */
    distinct?: WordFilterRetroScalarFieldEnum | WordFilterRetroScalarFieldEnum[]
  }


  /**
   * WordFilterRetro findMany
   */
  export type WordFilterRetroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * Filter, which WordFilterRetros to fetch.
     */
    where?: WordFilterRetroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordFilterRetros to fetch.
     */
    orderBy?: WordFilterRetroOrderByWithRelationInput | WordFilterRetroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WordFilterRetros.
     */
    cursor?: WordFilterRetroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordFilterRetros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordFilterRetros.
     */
    skip?: number
    distinct?: WordFilterRetroScalarFieldEnum | WordFilterRetroScalarFieldEnum[]
  }


  /**
   * WordFilterRetro create
   */
  export type WordFilterRetroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * The data needed to create a WordFilterRetro.
     */
    data: XOR<WordFilterRetroCreateInput, WordFilterRetroUncheckedCreateInput>
  }


  /**
   * WordFilterRetro createMany
   */
  export type WordFilterRetroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WordFilterRetros.
     */
    data: WordFilterRetroCreateManyInput | WordFilterRetroCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WordFilterRetro update
   */
  export type WordFilterRetroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * The data needed to update a WordFilterRetro.
     */
    data: XOR<WordFilterRetroUpdateInput, WordFilterRetroUncheckedUpdateInput>
    /**
     * Choose, which WordFilterRetro to update.
     */
    where: WordFilterRetroWhereUniqueInput
  }


  /**
   * WordFilterRetro updateMany
   */
  export type WordFilterRetroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WordFilterRetros.
     */
    data: XOR<WordFilterRetroUpdateManyMutationInput, WordFilterRetroUncheckedUpdateManyInput>
    /**
     * Filter which WordFilterRetros to update
     */
    where?: WordFilterRetroWhereInput
  }


  /**
   * WordFilterRetro upsert
   */
  export type WordFilterRetroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * The filter to search for the WordFilterRetro to update in case it exists.
     */
    where: WordFilterRetroWhereUniqueInput
    /**
     * In case the WordFilterRetro found by the `where` argument doesn't exist, create a new WordFilterRetro with this data.
     */
    create: XOR<WordFilterRetroCreateInput, WordFilterRetroUncheckedCreateInput>
    /**
     * In case the WordFilterRetro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WordFilterRetroUpdateInput, WordFilterRetroUncheckedUpdateInput>
  }


  /**
   * WordFilterRetro delete
   */
  export type WordFilterRetroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
    /**
     * Filter which WordFilterRetro to delete.
     */
    where: WordFilterRetroWhereUniqueInput
  }


  /**
   * WordFilterRetro deleteMany
   */
  export type WordFilterRetroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordFilterRetros to delete
     */
    where?: WordFilterRetroWhereInput
  }


  /**
   * WordFilterRetro without action
   */
  export type WordFilterRetroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordFilterRetro
     */
    select?: WordFilterRetroSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BanScalarFieldEnum: {
    id: 'id',
    bantype: 'bantype',
    value: 'value',
    reason: 'reason',
    expire: 'expire',
    addedBy: 'addedBy',
    addedDate: 'addedDate'
  };

  export type BanScalarFieldEnum = (typeof BanScalarFieldEnum)[keyof typeof BanScalarFieldEnum]


  export const BotPetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roomId: 'roomId',
    name: 'name',
    race: 'race',
    color: 'color',
    type: 'type',
    experience: 'experience',
    energy: 'energy',
    nutrition: 'nutrition',
    respect: 'respect',
    createstamp: 'createstamp',
    x: 'x',
    y: 'y',
    z: 'z',
    haveSaddle: 'haveSaddle',
    hairdye: 'hairdye',
    pethair: 'pethair',
    anyoneRide: 'anyoneRide'
  };

  export type BotPetScalarFieldEnum = (typeof BotPetScalarFieldEnum)[keyof typeof BotPetScalarFieldEnum]


  export const BotUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    motto: 'motto',
    gender: 'gender',
    look: 'look',
    roomId: 'roomId',
    walkEnabled: 'walkEnabled',
    x: 'x',
    y: 'y',
    z: 'z',
    rotation: 'rotation',
    chatEnabled: 'chatEnabled',
    chatText: 'chatText',
    chatSeconds: 'chatSeconds',
    isDancing: 'isDancing',
    isMixchat: 'isMixchat',
    status: 'status',
    enable: 'enable',
    handitem: 'handitem',
    aiType: 'aiType'
  };

  export type BotUserScalarFieldEnum = (typeof BotUserScalarFieldEnum)[keyof typeof BotUserScalarFieldEnum]


  export const CatalogBotPresetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    figure: 'figure',
    gender: 'gender',
    motto: 'motto',
    aiType: 'aiType'
  };

  export type CatalogBotPresetScalarFieldEnum = (typeof CatalogBotPresetScalarFieldEnum)[keyof typeof CatalogBotPresetScalarFieldEnum]


  export const CatalogItemScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    itemId: 'itemId',
    catalogName: 'catalogName',
    costCredits: 'costCredits',
    costPixels: 'costPixels',
    costDiamonds: 'costDiamonds',
    costLimitcoins: 'costLimitcoins',
    amount: 'amount',
    offerActive: 'offerActive',
    badge: 'badge'
  };

  export type CatalogItemScalarFieldEnum = (typeof CatalogItemScalarFieldEnum)[keyof typeof CatalogItemScalarFieldEnum]


  export const CatalogItemLimitedScalarFieldEnum: {
    catalogItemId: 'catalogItemId',
    limitedSells: 'limitedSells',
    limitedStack: 'limitedStack'
  };

  export type CatalogItemLimitedScalarFieldEnum = (typeof CatalogItemLimitedScalarFieldEnum)[keyof typeof CatalogItemLimitedScalarFieldEnum]


  export const CatalogMarketplaceDataScalarFieldEnum: {
    id: 'id',
    sprite: 'sprite',
    sold: 'sold',
    avgprice: 'avgprice'
  };

  export type CatalogMarketplaceDataScalarFieldEnum = (typeof CatalogMarketplaceDataScalarFieldEnum)[keyof typeof CatalogMarketplaceDataScalarFieldEnum]


  export const CatalogMarketplaceOfferScalarFieldEnum: {
    offerId: 'offerId',
    userId: 'userId',
    itemId: 'itemId',
    askingPrice: 'askingPrice',
    totalPrice: 'totalPrice',
    publicName: 'publicName',
    spriteId: 'spriteId',
    itemType: 'itemType',
    timestamp: 'timestamp',
    state: 'state',
    extraData: 'extraData',
    furniId: 'furniId',
    limitedNumber: 'limitedNumber',
    limitedStack: 'limitedStack'
  };

  export type CatalogMarketplaceOfferScalarFieldEnum = (typeof CatalogMarketplaceOfferScalarFieldEnum)[keyof typeof CatalogMarketplaceOfferScalarFieldEnum]


  export const CatalogPageScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    caption: 'caption',
    iconImage: 'iconImage',
    enabled: 'enabled',
    requiredRight: 'requiredRight',
    orderNum: 'orderNum',
    pageLayout: 'pageLayout',
    pageLink: 'pageLink',
    pageStrings1: 'pageStrings1',
    pageStrings2: 'pageStrings2',
    isPremium: 'isPremium'
  };

  export type CatalogPageScalarFieldEnum = (typeof CatalogPageScalarFieldEnum)[keyof typeof CatalogPageScalarFieldEnum]


  export const CatalogPageLangueScalarFieldEnum: {
    pageId: 'pageId',
    captionFr: 'captionFr',
    captionEn: 'captionEn',
    captionBr: 'captionBr',
    pageStrings2Fr: 'pageStrings2Fr',
    pageStrings2En: 'pageStrings2En',
    pageStrings2Br: 'pageStrings2Br'
  };

  export type CatalogPageLangueScalarFieldEnum = (typeof CatalogPageLangueScalarFieldEnum)[keyof typeof CatalogPageLangueScalarFieldEnum]


  export const CatalogPetRaceScalarFieldEnum: {
    id: 'id',
    raceid: 'raceid',
    color1: 'color1',
    color2: 'color2',
    has1color: 'has1color',
    has2color: 'has2color'
  };

  export type CatalogPetRaceScalarFieldEnum = (typeof CatalogPetRaceScalarFieldEnum)[keyof typeof CatalogPetRaceScalarFieldEnum]


  export const CatalogPromotionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleEn: 'titleEn',
    titleBr: 'titleBr',
    image: 'image',
    unknown: 'unknown',
    pageLink: 'pageLink',
    parentId: 'parentId'
  };

  export type CatalogPromotionScalarFieldEnum = (typeof CatalogPromotionScalarFieldEnum)[keyof typeof CatalogPromotionScalarFieldEnum]


  export const CatalogVoucherScalarFieldEnum: {
    voucher: 'voucher',
    type: 'type',
    value: 'value',
    currentUses: 'currentUses',
    maxUses: 'maxUses',
    enabled: 'enabled'
  };

  export type CatalogVoucherScalarFieldEnum = (typeof CatalogVoucherScalarFieldEnum)[keyof typeof CatalogVoucherScalarFieldEnum]


  export const CmsForumPostScalarFieldEnum: {
    id: 'id',
    threadid: 'threadid',
    message: 'message',
    author: 'author',
    date: 'date',
    motto: 'motto',
    look: 'look',
    idAuteur: 'idAuteur',
    rank: 'rank'
  };

  export type CmsForumPostScalarFieldEnum = (typeof CmsForumPostScalarFieldEnum)[keyof typeof CmsForumPostScalarFieldEnum]


  export const CmsForumThreadScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    author: 'author',
    date: 'date',
    lastpostAuthor: 'lastpostAuthor',
    lastpostDate: 'lastpostDate',
    posts: 'posts',
    mainPost: 'mainPost',
    statut: 'statut',
    categorie: 'categorie',
    views: 'views'
  };

  export type CmsForumThreadScalarFieldEnum = (typeof CmsForumThreadScalarFieldEnum)[keyof typeof CmsForumThreadScalarFieldEnum]


  export const CmsFourmCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order'
  };

  export type CmsFourmCategoryScalarFieldEnum = (typeof CmsFourmCategoryScalarFieldEnum)[keyof typeof CmsFourmCategoryScalarFieldEnum]


  export const CmsMailConfirmScalarFieldEnum: {
    userId: 'userId',
    codedevalidation: 'codedevalidation',
    email: 'email',
    temps: 'temps',
    type: 'type'
  };

  export type CmsMailConfirmScalarFieldEnum = (typeof CmsMailConfirmScalarFieldEnum)[keyof typeof CmsMailConfirmScalarFieldEnum]


  export const CmsMailForgotScalarFieldEnum: {
    id: 'id',
    pass: 'pass',
    email: 'email',
    expire: 'expire',
    users: 'users'
  };

  export type CmsMailForgotScalarFieldEnum = (typeof CmsMailForgotScalarFieldEnum)[keyof typeof CmsMailForgotScalarFieldEnum]


  export const CmsNewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    categoryId: 'categoryId',
    topstoryImage: 'topstoryImage',
    body: 'body',
    snippet: 'snippet',
    timestamp: 'timestamp',
    author: 'author',
    authorId: 'authorId',
    link_keyword: 'link_keyword'
  };

  export type CmsNewsScalarFieldEnum = (typeof CmsNewsScalarFieldEnum)[keyof typeof CmsNewsScalarFieldEnum]


  export const CmsStaffScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    rank: 'rank',
    function: 'function',
    socialInsta: 'socialInsta',
    socialDiscord: 'socialDiscord'
  };

  export type CmsStaffScalarFieldEnum = (typeof CmsStaffScalarFieldEnum)[keyof typeof CmsStaffScalarFieldEnum]


  export const CmsStaffProtectScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    username: 'username',
    hide: 'hide'
  };

  export type CmsStaffProtectScalarFieldEnum = (typeof CmsStaffProtectScalarFieldEnum)[keyof typeof CmsStaffProtectScalarFieldEnum]


  export const EmulatorAchievementScalarFieldEnum: {
    id: 'id',
    groupName: 'groupName',
    category: 'category',
    level: 'level',
    rewardPixels: 'rewardPixels',
    rewardPoints: 'rewardPoints',
    progressNeeded: 'progressNeeded'
  };

  export type EmulatorAchievementScalarFieldEnum = (typeof EmulatorAchievementScalarFieldEnum)[keyof typeof EmulatorAchievementScalarFieldEnum]


  export const EmulatorBannerScalarFieldEnum: {
    id: 'id',
    haveLayer: 'haveLayer',
    canTrade: 'canTrade'
  };

  export type EmulatorBannerScalarFieldEnum = (typeof EmulatorBannerScalarFieldEnum)[keyof typeof EmulatorBannerScalarFieldEnum]


  export const EmulatorChatStyleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    requiredRight: 'requiredRight'
  };

  export type EmulatorChatStyleScalarFieldEnum = (typeof EmulatorChatStyleScalarFieldEnum)[keyof typeof EmulatorChatStyleScalarFieldEnum]


  export const EmulatorCommandScalarFieldEnum: {
    id: 'id',
    input: 'input',
    minrank: 'minrank',
    descriptionFr: 'descriptionFr',
    descriptionEn: 'descriptionEn',
    descriptionBr: 'descriptionBr'
  };

  export type EmulatorCommandScalarFieldEnum = (typeof EmulatorCommandScalarFieldEnum)[keyof typeof EmulatorCommandScalarFieldEnum]


  export const EmulatorCommandPetScalarFieldEnum: {
    id: 'id',
    command: 'command'
  };

  export type EmulatorCommandPetScalarFieldEnum = (typeof EmulatorCommandPetScalarFieldEnum)[keyof typeof EmulatorCommandPetScalarFieldEnum]


  export const EmulatorEffectScalarFieldEnum: {
    id: 'id',
    onlyStaff: 'onlyStaff'
  };

  export type EmulatorEffectScalarFieldEnum = (typeof EmulatorEffectScalarFieldEnum)[keyof typeof EmulatorEffectScalarFieldEnum]


  export const EmulatorLandingviewScalarFieldEnum: {
    index: 'index',
    header: 'header',
    body: 'body',
    button: 'button',
    inGamePromo: 'inGamePromo',
    specialAction: 'specialAction',
    image: 'image',
    enabled: 'enabled'
  };

  export type EmulatorLandingviewScalarFieldEnum = (typeof EmulatorLandingviewScalarFieldEnum)[keyof typeof EmulatorLandingviewScalarFieldEnum]


  export const EmulatorLootboxScalarFieldEnum: {
    id: 'id',
    interactionType: 'interactionType',
    probability: 'probability',
    pageId: 'pageId',
    itemId: 'itemId',
    category: 'category',
    amount: 'amount'
  };

  export type EmulatorLootboxScalarFieldEnum = (typeof EmulatorLootboxScalarFieldEnum)[keyof typeof EmulatorLootboxScalarFieldEnum]


  export const EmulatorPermissionScalarFieldEnum: {
    id: 'id',
    rank: 'rank',
    permission: 'permission'
  };

  export type EmulatorPermissionScalarFieldEnum = (typeof EmulatorPermissionScalarFieldEnum)[keyof typeof EmulatorPermissionScalarFieldEnum]


  export const EmulatorQuestScalarFieldEnum: {
    id: 'id',
    category: 'category',
    seriesNumber: 'seriesNumber',
    goalType: 'goalType',
    goalData: 'goalData',
    name: 'name',
    reward: 'reward',
    dataBit: 'dataBit'
  };

  export type EmulatorQuestScalarFieldEnum = (typeof EmulatorQuestScalarFieldEnum)[keyof typeof EmulatorQuestScalarFieldEnum]


  export const EmulatorSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type EmulatorSettingScalarFieldEnum = (typeof EmulatorSettingScalarFieldEnum)[keyof typeof EmulatorSettingScalarFieldEnum]


  export const EmulatorStatsScalarFieldEnum: {
    id: 'id',
    online: 'online',
    time: 'time',
    room: 'room'
  };

  export type EmulatorStatsScalarFieldEnum = (typeof EmulatorStatsScalarFieldEnum)[keyof typeof EmulatorStatsScalarFieldEnum]


  export const EmulatorStatusScalarFieldEnum: {
    id: 'id',
    status: 'status',
    usersOnline: 'usersOnline',
    roomsLoaded: 'roomsLoaded',
    stamp: 'stamp',
    userpeak: 'userpeak'
  };

  export type EmulatorStatusScalarFieldEnum = (typeof EmulatorStatusScalarFieldEnum)[keyof typeof EmulatorStatusScalarFieldEnum]


  export const EmulatorTextScalarFieldEnum: {
    id: 'id',
    identifiant: 'identifiant',
    valueFr: 'valueFr',
    valueEn: 'valueEn',
    valueBr: 'valueBr'
  };

  export type EmulatorTextScalarFieldEnum = (typeof EmulatorTextScalarFieldEnum)[keyof typeof EmulatorTextScalarFieldEnum]


  export const GuildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    desc: 'desc',
    badge: 'badge',
    ownerId: 'ownerId',
    created: 'created',
    roomId: 'roomId',
    state: 'state',
    colour1: 'colour1',
    colour2: 'colour2',
    admindeco: 'admindeco',
    hasForum: 'hasForum'
  };

  export type GuildScalarFieldEnum = (typeof GuildScalarFieldEnum)[keyof typeof GuildScalarFieldEnum]


  export const GuildItemScalarFieldEnum: {
    id: 'id',
    type: 'type',
    firstvalue: 'firstvalue',
    secondvalue: 'secondvalue',
    enabled: 'enabled'
  };

  export type GuildItemScalarFieldEnum = (typeof GuildItemScalarFieldEnum)[keyof typeof GuildItemScalarFieldEnum]


  export const GuildMembershipScalarFieldEnum: {
    groupId: 'groupId',
    userId: 'userId',
    rank: 'rank'
  };

  export type GuildMembershipScalarFieldEnum = (typeof GuildMembershipScalarFieldEnum)[keyof typeof GuildMembershipScalarFieldEnum]


  export const GuildRequestScalarFieldEnum: {
    groupId: 'groupId',
    userId: 'userId'
  };

  export type GuildRequestScalarFieldEnum = (typeof GuildRequestScalarFieldEnum)[keyof typeof GuildRequestScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roomId: 'roomId',
    baseItem: 'baseItem',
    extraData: 'extraData',
    x: 'x',
    y: 'y',
    z: 'z',
    rot: 'rot',
    wallPos: 'wallPos'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ItemBaseScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    type: 'type',
    width: 'width',
    length: 'length',
    stackHeight: 'stackHeight',
    canStack: 'canStack',
    canSit: 'canSit',
    isWalkable: 'isWalkable',
    spriteId: 'spriteId',
    allowRecycle: 'allowRecycle',
    allowTrade: 'allowTrade',
    allowMarketplaceSell: 'allowMarketplaceSell',
    allowGift: 'allowGift',
    allowInventoryStack: 'allowInventoryStack',
    interactionType: 'interactionType',
    interactionModesCount: 'interactionModesCount',
    vendingIds: 'vendingIds',
    heightAdjustable: 'heightAdjustable',
    effectId: 'effectId',
    isRare: 'isRare',
    rarityLevel: 'rarityLevel'
  };

  export type ItemBaseScalarFieldEnum = (typeof ItemBaseScalarFieldEnum)[keyof typeof ItemBaseScalarFieldEnum]


  export const ItemLimitedScalarFieldEnum: {
    itemId: 'itemId',
    limitedNumber: 'limitedNumber',
    limitedStack: 'limitedStack'
  };

  export type ItemLimitedScalarFieldEnum = (typeof ItemLimitedScalarFieldEnum)[keyof typeof ItemLimitedScalarFieldEnum]


  export const ItemMoodlightScalarFieldEnum: {
    itemId: 'itemId',
    enabled: 'enabled',
    currentPreset: 'currentPreset',
    presetOne: 'presetOne',
    presetTwo: 'presetTwo',
    presetThree: 'presetThree'
  };

  export type ItemMoodlightScalarFieldEnum = (typeof ItemMoodlightScalarFieldEnum)[keyof typeof ItemMoodlightScalarFieldEnum]


  export const ItemPresentScalarFieldEnum: {
    itemId: 'itemId',
    baseId: 'baseId',
    extraData: 'extraData'
  };

  export type ItemPresentScalarFieldEnum = (typeof ItemPresentScalarFieldEnum)[keyof typeof ItemPresentScalarFieldEnum]


  export const ItemStatScalarFieldEnum: {
    baseId: 'baseId',
    amount: 'amount'
  };

  export type ItemStatScalarFieldEnum = (typeof ItemStatScalarFieldEnum)[keyof typeof ItemStatScalarFieldEnum]


  export const ItemTeleportScalarFieldEnum: {
    teleOneId: 'teleOneId',
    teleTwoId: 'teleTwoId'
  };

  export type ItemTeleportScalarFieldEnum = (typeof ItemTeleportScalarFieldEnum)[keyof typeof ItemTeleportScalarFieldEnum]


  export const ItemWiredScalarFieldEnum: {
    triggerId: 'triggerId',
    triggerData2: 'triggerData2',
    triggerData: 'triggerData',
    allUserTriggerable: 'allUserTriggerable',
    triggersItem: 'triggersItem',
    delay: 'delay'
  };

  export type ItemWiredScalarFieldEnum = (typeof ItemWiredScalarFieldEnum)[keyof typeof ItemWiredScalarFieldEnum]


  export const LogChatScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roomId: 'roomId',
    userName: 'userName',
    timestamp: 'timestamp',
    message: 'message',
    type: 'type'
  };

  export type LogChatScalarFieldEnum = (typeof LogChatScalarFieldEnum)[keyof typeof LogChatScalarFieldEnum]


  export const LogChatPubScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    timestamp: 'timestamp',
    message: 'message'
  };

  export type LogChatPubScalarFieldEnum = (typeof LogChatPubScalarFieldEnum)[keyof typeof LogChatPubScalarFieldEnum]


  export const LogCommandScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    roomid: 'roomid',
    command: 'command',
    extraData: 'extraData',
    timestamp: 'timestamp'
  };

  export type LogCommandScalarFieldEnum = (typeof LogCommandScalarFieldEnum)[keyof typeof LogCommandScalarFieldEnum]


  export const LogFlagmeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    oldusername: 'oldusername',
    newusername: 'newusername',
    time: 'time'
  };

  export type LogFlagmeScalarFieldEnum = (typeof LogFlagmeScalarFieldEnum)[keyof typeof LogFlagmeScalarFieldEnum]


  export const LogLoginScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    ip: 'ip',
    userAgent: 'userAgent'
  };

  export type LogLoginScalarFieldEnum = (typeof LogLoginScalarFieldEnum)[keyof typeof LogLoginScalarFieldEnum]


  export const LogLootboxScalarFieldEnum: {
    id: 'id',
    interactionType: 'interactionType',
    userId: 'userId',
    itemId: 'itemId',
    baseId: 'baseId',
    timestamp: 'timestamp'
  };

  export type LogLootboxScalarFieldEnum = (typeof LogLootboxScalarFieldEnum)[keyof typeof LogLootboxScalarFieldEnum]


  export const LogPaymentScalarFieldEnum: {
    historyPaymentId: 'historyPaymentId',
    docId: 'docId',
    userId: 'userId',
    awards: 'awards',
    externalReference: 'externalReference',
    promoId: 'promoId',
    date: 'date'
  };

  export type LogPaymentScalarFieldEnum = (typeof LogPaymentScalarFieldEnum)[keyof typeof LogPaymentScalarFieldEnum]


  export const LogShopScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    price: 'price',
    content: 'content',
    type: 'type',
    catalogItemId: 'catalogItemId'
  };

  export type LogShopScalarFieldEnum = (typeof LogShopScalarFieldEnum)[keyof typeof LogShopScalarFieldEnum]


  export const LogSlotmachineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    isWin: 'isWin',
    date: 'date'
  };

  export type LogSlotmachineScalarFieldEnum = (typeof LogSlotmachineScalarFieldEnum)[keyof typeof LogSlotmachineScalarFieldEnum]


  export const LogStaffScalarFieldEnum: {
    id: 'id',
    pseudo: 'pseudo',
    action: 'action',
    date: 'date'
  };

  export type LogStaffScalarFieldEnum = (typeof LogStaffScalarFieldEnum)[keyof typeof LogStaffScalarFieldEnum]


  export const LogTradeScalarFieldEnum: {
    id: 'id',
    userOneId: 'userOneId',
    userTwoId: 'userTwoId',
    userOneItems: 'userOneItems',
    userTwoItems: 'userTwoItems',
    roomId: 'roomId',
    time: 'time'
  };

  export type LogTradeScalarFieldEnum = (typeof LogTradeScalarFieldEnum)[keyof typeof LogTradeScalarFieldEnum]


  export const LogVpnScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    ipCountry: 'ipCountry',
    host: 'host',
    timestampCreated: 'timestampCreated',
    isVpn: 'isVpn'
  };

  export type LogVpnScalarFieldEnum = (typeof LogVpnScalarFieldEnum)[keyof typeof LogVpnScalarFieldEnum]


  export const LogSandboxScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    method: 'method',
    editName: 'editName',
    editKey: 'editKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LogSandboxScalarFieldEnum = (typeof LogSandboxScalarFieldEnum)[keyof typeof LogSandboxScalarFieldEnum]


  export const MessengerFriendshipScalarFieldEnum: {
    userOneId: 'userOneId',
    userTwoId: 'userTwoId',
    relation: 'relation'
  };

  export type MessengerFriendshipScalarFieldEnum = (typeof MessengerFriendshipScalarFieldEnum)[keyof typeof MessengerFriendshipScalarFieldEnum]


  export const MessengerOfflineMessageScalarFieldEnum: {
    id: 'id',
    toId: 'toId',
    fromId: 'fromId',
    message: 'message',
    timestamp: 'timestamp'
  };

  export type MessengerOfflineMessageScalarFieldEnum = (typeof MessengerOfflineMessageScalarFieldEnum)[keyof typeof MessengerOfflineMessageScalarFieldEnum]


  export const MessengerRequestScalarFieldEnum: {
    fromId: 'fromId',
    toId: 'toId'
  };

  export type MessengerRequestScalarFieldEnum = (typeof MessengerRequestScalarFieldEnum)[keyof typeof MessengerRequestScalarFieldEnum]


  export const ModerationPresetScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    type: 'type',
    message: 'message'
  };

  export type ModerationPresetScalarFieldEnum = (typeof ModerationPresetScalarFieldEnum)[keyof typeof ModerationPresetScalarFieldEnum]


  export const ModerationResolutionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    subtitle: 'subtitle',
    banHours: 'banHours',
    enableMute: 'enableMute',
    muteHours: 'muteHours',
    reminder: 'reminder',
    message: 'message'
  };

  export type ModerationResolutionScalarFieldEnum = (typeof ModerationResolutionScalarFieldEnum)[keyof typeof ModerationResolutionScalarFieldEnum]


  export const ModerationTicketScalarFieldEnum: {
    id: 'id',
    score: 'score',
    type: 'type',
    status: 'status',
    senderId: 'senderId',
    reportedId: 'reportedId',
    moderatorId: 'moderatorId',
    message: 'message',
    roomId: 'roomId',
    roomName: 'roomName',
    timestamp: 'timestamp'
  };

  export type ModerationTicketScalarFieldEnum = (typeof ModerationTicketScalarFieldEnum)[keyof typeof ModerationTicketScalarFieldEnum]


  export const ModerationTopicScalarFieldEnum: {
    id: 'id',
    caption: 'caption'
  };

  export type ModerationTopicScalarFieldEnum = (typeof ModerationTopicScalarFieldEnum)[keyof typeof ModerationTopicScalarFieldEnum]


  export const ModerationTopicActionScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    type: 'type',
    caption: 'caption',
    messageText: 'messageText',
    defaultSanction: 'defaultSanction',
    muteTime: 'muteTime',
    banTime: 'banTime',
    ipTime: 'ipTime',
    tradeLockTime: 'tradeLockTime'
  };

  export type ModerationTopicActionScalarFieldEnum = (typeof ModerationTopicActionScalarFieldEnum)[keyof typeof ModerationTopicActionScalarFieldEnum]


  export const NavigatorCategoryScalarFieldEnum: {
    id: 'id',
    category: 'category',
    categoryIdentifier: 'categoryIdentifier',
    publicName: 'publicName',
    viewMode: 'viewMode',
    requiredRank: 'requiredRank',
    categoryType: 'categoryType',
    searchAllowance: 'searchAllowance',
    minimized: 'minimized',
    enabled: 'enabled',
    orderId: 'orderId'
  };

  export type NavigatorCategoryScalarFieldEnum = (typeof NavigatorCategoryScalarFieldEnum)[keyof typeof NavigatorCategoryScalarFieldEnum]


  export const NavigatorPublicScalarFieldEnum: {
    roomId: 'roomId',
    imageUrl: 'imageUrl',
    orderNum: 'orderNum',
    enabled: 'enabled',
    langue: 'langue',
    categoryType: 'categoryType'
  };

  export type NavigatorPublicScalarFieldEnum = (typeof NavigatorPublicScalarFieldEnum)[keyof typeof NavigatorPublicScalarFieldEnum]


  export const RoleplayScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    hopitalId: 'hopitalId',
    prisonId: 'prisonId'
  };

  export type RoleplayScalarFieldEnum = (typeof RoleplayScalarFieldEnum)[keyof typeof RoleplayScalarFieldEnum]


  export const RoleplayEnemyScalarFieldEnum: {
    id: 'id',
    type: 'type',
    health: 'health',
    weaponFarId: 'weaponFarId',
    weaponCacId: 'weaponCacId',
    deadTimer: 'deadTimer',
    lootItemId: 'lootItemId',
    moneyDrop: 'moneyDrop',
    dropScriptId: 'dropScriptId',
    teamId: 'teamId',
    aggroDistance: 'aggroDistance',
    zoneDistance: 'zoneDistance',
    resetPosition: 'resetPosition',
    lostAggroDistance: 'lostAggroDistance',
    zombieMode: 'zombieMode'
  };

  export type RoleplayEnemyScalarFieldEnum = (typeof RoleplayEnemyScalarFieldEnum)[keyof typeof RoleplayEnemyScalarFieldEnum]


  export const RoleplayItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    desc: 'desc',
    price: 'price',
    type: 'type',
    value: 'value',
    allowstack: 'allowstack',
    category: 'category'
  };

  export type RoleplayItemScalarFieldEnum = (typeof RoleplayItemScalarFieldEnum)[keyof typeof RoleplayItemScalarFieldEnum]


  export const RoleplayWeaponScalarFieldEnum: {
    id: 'id',
    type: 'type',
    domageMin: 'domageMin',
    domageMax: 'domageMax',
    interaction: 'interaction',
    enable: 'enable',
    freezeTime: 'freezeTime',
    distance: 'distance'
  };

  export type RoleplayWeaponScalarFieldEnum = (typeof RoleplayWeaponScalarFieldEnum)[keyof typeof RoleplayWeaponScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    caption: 'caption',
    owner: 'owner',
    description: 'description',
    category: 'category',
    state: 'state',
    usersMax: 'usersMax',
    modelName: 'modelName',
    score: 'score',
    tags: 'tags',
    password: 'password',
    wallpaper: 'wallpaper',
    floor: 'floor',
    landscape: 'landscape',
    allowPets: 'allowPets',
    allowPetsEat: 'allowPetsEat',
    allowWalkthrough: 'allowWalkthrough',
    allowHidewall: 'allowHidewall',
    wallthick: 'wallthick',
    floorthick: 'floorthick',
    moderationMuteFuse: 'moderationMuteFuse',
    allowRightsoverride: 'allowRightsoverride',
    moderationKickFuse: 'moderationKickFuse',
    moderationBanFuse: 'moderationBanFuse',
    groupId: 'groupId',
    chatType: 'chatType',
    chatBalloon: 'chatBalloon',
    chatSpeed: 'chatSpeed',
    chatMaxDistance: 'chatMaxDistance',
    chatFloodProtection: 'chatFloodProtection',
    trocStatus: 'trocStatus',
    usersNow: 'usersNow',
    allowHidewireds: 'allowHidewireds',
    price: 'price',
    wiredSecurity: 'wiredSecurity'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomModelScalarFieldEnum: {
    id: 'id',
    doorX: 'doorX',
    doorY: 'doorY',
    doorZ: 'doorZ',
    doorDir: 'doorDir',
    heightmap: 'heightmap'
  };

  export type RoomModelScalarFieldEnum = (typeof RoomModelScalarFieldEnum)[keyof typeof RoomModelScalarFieldEnum]


  export const RoomModelCustomScalarFieldEnum: {
    roomId: 'roomId',
    doorX: 'doorX',
    doorY: 'doorY',
    doorZ: 'doorZ',
    doorDir: 'doorDir',
    heightmap: 'heightmap',
    wallHeight: 'wallHeight'
  };

  export type RoomModelCustomScalarFieldEnum = (typeof RoomModelCustomScalarFieldEnum)[keyof typeof RoomModelCustomScalarFieldEnum]


  export const RoomRightScalarFieldEnum: {
    roomId: 'roomId',
    userId: 'userId'
  };

  export type RoomRightScalarFieldEnum = (typeof RoomRightScalarFieldEnum)[keyof typeof RoomRightScalarFieldEnum]


  export const RoomSwearwordFilterScalarFieldEnum: {
    word: 'word'
  };

  export type RoomSwearwordFilterScalarFieldEnum = (typeof RoomSwearwordFilterScalarFieldEnum)[keyof typeof RoomSwearwordFilterScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    mail: 'mail',
    authTicket: 'authTicket',
    rank: 'rank',
    credits: 'credits',
    activityPoints: 'activityPoints',
    look: 'look',
    gender: 'gender',
    motto: 'motto',
    accountCreated: 'accountCreated',
    lastOnline: 'lastOnline',
    online: 'online',
    ipLast: 'ipLast',
    machineId: 'machineId',
    homeRoom: 'homeRoom',
    blockNewfriends: 'blockNewfriends',
    hideOnline: 'hideOnline',
    hideInroom: 'hideInroom',
    lastOffline: 'lastOffline',
    moisVip: 'moisVip',
    volume: 'volume',
    vipPoints: 'vipPoints',
    limitCoins: 'limitCoins',
    acceptTrading: 'acceptTrading',
    cameraFollowDisabled: 'cameraFollowDisabled',
    ignoreRoomInvite: 'ignoreRoomInvite',
    lastdailycredits: 'lastdailycredits',
    hideGamealert: 'hideGamealert',
    ipcountry: 'ipcountry',
    gamePoints: 'gamePoints',
    gamePointsMonth: 'gamePointsMonth',
    mazoscore: 'mazoscore',
    mazo: 'mazo',
    nuxEnable: 'nuxEnable',
    langue: 'langue',
    runPoints: 'runPoints',
    runPointsMonth: 'runPointsMonth',
    isBanned: 'isBanned',
    bannerId: 'bannerId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    userId: 'userId',
    group: 'group',
    level: 'level',
    progress: 'progress'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    userId: 'userId',
    badgeId: 'badgeId',
    badgeSlot: 'badgeSlot'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const UserBannerScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    banner_id: 'banner_id'
  };

  export type UserBannerScalarFieldEnum = (typeof UserBannerScalarFieldEnum)[keyof typeof UserBannerScalarFieldEnum]


  export const UserPhotoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    photo: 'photo',
    time: 'time'
  };

  export type UserPhotoScalarFieldEnum = (typeof UserPhotoScalarFieldEnum)[keyof typeof UserPhotoScalarFieldEnum]


  export const UserPremiumScalarFieldEnum: {
    userId: 'userId',
    timestampActivated: 'timestampActivated',
    timestampExpireClassic: 'timestampExpireClassic',
    timestampExpireEpic: 'timestampExpireEpic',
    timestampExpireLegend: 'timestampExpireLegend'
  };

  export type UserPremiumScalarFieldEnum = (typeof UserPremiumScalarFieldEnum)[keyof typeof UserPremiumScalarFieldEnum]


  export const UserQuestScalarFieldEnum: {
    userId: 'userId',
    questId: 'questId',
    progress: 'progress'
  };

  export type UserQuestScalarFieldEnum = (typeof UserQuestScalarFieldEnum)[keyof typeof UserQuestScalarFieldEnum]


  export const UserRoleplayScalarFieldEnum: {
    userId: 'userId',
    roleplayId: 'roleplayId',
    health: 'health',
    energy: 'energy',
    money: 'money',
    munition: 'munition',
    exp: 'exp',
    weaponFar: 'weaponFar',
    weaponCac: 'weaponCac',
    hygiene: 'hygiene',
    money1: 'money1',
    money2: 'money2',
    money3: 'money3',
    money4: 'money4'
  };

  export type UserRoleplayScalarFieldEnum = (typeof UserRoleplayScalarFieldEnum)[keyof typeof UserRoleplayScalarFieldEnum]


  export const UserRoleplayItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rpId: 'rpId',
    itemId: 'itemId',
    count: 'count'
  };

  export type UserRoleplayItemScalarFieldEnum = (typeof UserRoleplayItemScalarFieldEnum)[keyof typeof UserRoleplayItemScalarFieldEnum]


  export const UserStatsScalarFieldEnum: {
    id: 'id',
    onlineTime: 'onlineTime',
    respect: 'respect',
    respectGiven: 'respectGiven',
    giftsGiven: 'giftsGiven',
    giftsReceived: 'giftsReceived',
    dailyRespectPoints: 'dailyRespectPoints',
    dailyPetRespectPoints: 'dailyPetRespectPoints',
    achievementScore: 'achievementScore',
    questId: 'questId',
    questProgress: 'questProgress',
    levBuilder: 'levBuilder',
    levSocial: 'levSocial',
    levIdentity: 'levIdentity',
    levExplore: 'levExplore',
    groupId: 'groupId'
  };

  export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


  export const UserWardrobeScalarFieldEnum: {
    userId: 'userId',
    slotId: 'slotId',
    look: 'look',
    gender: 'gender'
  };

  export type UserWardrobeScalarFieldEnum = (typeof UserWardrobeScalarFieldEnum)[keyof typeof UserWardrobeScalarFieldEnum]


  export const WordFilterRetroScalarFieldEnum: {
    word: 'word'
  };

  export type WordFilterRetroScalarFieldEnum = (typeof WordFilterRetroScalarFieldEnum)[keyof typeof WordFilterRetroScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'BanBantype'
   */
  export type EnumBanBantypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BanBantype'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BotUserAiType'
   */
  export type EnumBotUserAiTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BotUserAiType'>
    


  /**
   * Reference to a field of type 'CatalogBotPresetAiType'
   */
  export type EnumCatalogBotPresetAiTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CatalogBotPresetAiType'>
    


  /**
   * Reference to a field of type 'CatalogVoucherType'
   */
  export type EnumCatalogVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CatalogVoucherType'>
    


  /**
   * Reference to a field of type 'EmulatorLootboxCategory'
   */
  export type EnumEmulatorLootboxCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmulatorLootboxCategory'>
    


  /**
   * Reference to a field of type 'GuildItemType'
   */
  export type EnumGuildItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GuildItemType'>
    


  /**
   * Reference to a field of type 'ItemBaseType'
   */
  export type EnumItemBaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemBaseType'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'ModerationPresetType'
   */
  export type EnumModerationPresetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationPresetType'>
    


  /**
   * Reference to a field of type 'ModerationResolutionType'
   */
  export type EnumModerationResolutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationResolutionType'>
    


  /**
   * Reference to a field of type 'ModerationTicketStatus'
   */
  export type EnumModerationTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationTicketStatus'>
    


  /**
   * Reference to a field of type 'NavigatorCategoryCategory'
   */
  export type EnumNavigatorCategoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NavigatorCategoryCategory'>
    


  /**
   * Reference to a field of type 'NavigatorCategoryViewMode'
   */
  export type EnumNavigatorCategoryViewModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NavigatorCategoryViewMode'>
    


  /**
   * Reference to a field of type 'NavigatorCategorySearchAllowance'
   */
  export type EnumNavigatorCategorySearchAllowanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NavigatorCategorySearchAllowance'>
    


  /**
   * Reference to a field of type 'NavigatorPublicLangue'
   */
  export type EnumNavigatorPublicLangueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NavigatorPublicLangue'>
    


  /**
   * Reference to a field of type 'RoleplayEnemyType'
   */
  export type EnumRoleplayEnemyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleplayEnemyType'>
    


  /**
   * Reference to a field of type 'RoleplayItemType'
   */
  export type EnumRoleplayItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleplayItemType'>
    


  /**
   * Reference to a field of type 'RoleplayItemCategory'
   */
  export type EnumRoleplayItemCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleplayItemCategory'>
    


  /**
   * Reference to a field of type 'RoleplayWeaponType'
   */
  export type EnumRoleplayWeaponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleplayWeaponType'>
    


  /**
   * Reference to a field of type 'RoleplayWeaponInteraction'
   */
  export type EnumRoleplayWeaponInteractionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleplayWeaponInteraction'>
    


  /**
   * Reference to a field of type 'RoomState'
   */
  export type EnumRoomStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomState'>
    


  /**
   * Reference to a field of type 'UserGender'
   */
  export type EnumUserGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserGender'>
    


  /**
   * Reference to a field of type 'UserLangue'
   */
  export type EnumUserLangueFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLangue'>
    


  /**
   * Reference to a field of type 'UserWardrobeGender'
   */
  export type EnumUserWardrobeGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserWardrobeGender'>
    
  /**
   * Deep Input Types
   */


  export type BanWhereInput = {
    AND?: BanWhereInput | BanWhereInput[]
    OR?: BanWhereInput[]
    NOT?: BanWhereInput | BanWhereInput[]
    id?: IntFilter<"Ban"> | number
    bantype?: EnumBanBantypeFilter<"Ban"> | $Enums.BanBantype
    value?: StringFilter<"Ban"> | string
    reason?: StringFilter<"Ban"> | string
    expire?: IntFilter<"Ban"> | number
    addedBy?: StringFilter<"Ban"> | string
    addedDate?: IntFilter<"Ban"> | number
  }

  export type BanOrderByWithRelationInput = {
    id?: SortOrder
    bantype?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    expire?: SortOrder
    addedBy?: SortOrder
    addedDate?: SortOrder
  }

  export type BanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BanWhereInput | BanWhereInput[]
    OR?: BanWhereInput[]
    NOT?: BanWhereInput | BanWhereInput[]
    bantype?: EnumBanBantypeFilter<"Ban"> | $Enums.BanBantype
    value?: StringFilter<"Ban"> | string
    reason?: StringFilter<"Ban"> | string
    expire?: IntFilter<"Ban"> | number
    addedBy?: StringFilter<"Ban"> | string
    addedDate?: IntFilter<"Ban"> | number
  }, "id">

  export type BanOrderByWithAggregationInput = {
    id?: SortOrder
    bantype?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    expire?: SortOrder
    addedBy?: SortOrder
    addedDate?: SortOrder
    _count?: BanCountOrderByAggregateInput
    _avg?: BanAvgOrderByAggregateInput
    _max?: BanMaxOrderByAggregateInput
    _min?: BanMinOrderByAggregateInput
    _sum?: BanSumOrderByAggregateInput
  }

  export type BanScalarWhereWithAggregatesInput = {
    AND?: BanScalarWhereWithAggregatesInput | BanScalarWhereWithAggregatesInput[]
    OR?: BanScalarWhereWithAggregatesInput[]
    NOT?: BanScalarWhereWithAggregatesInput | BanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ban"> | number
    bantype?: EnumBanBantypeWithAggregatesFilter<"Ban"> | $Enums.BanBantype
    value?: StringWithAggregatesFilter<"Ban"> | string
    reason?: StringWithAggregatesFilter<"Ban"> | string
    expire?: IntWithAggregatesFilter<"Ban"> | number
    addedBy?: StringWithAggregatesFilter<"Ban"> | string
    addedDate?: IntWithAggregatesFilter<"Ban"> | number
  }

  export type BotPetWhereInput = {
    AND?: BotPetWhereInput | BotPetWhereInput[]
    OR?: BotPetWhereInput[]
    NOT?: BotPetWhereInput | BotPetWhereInput[]
    id?: IntFilter<"BotPet"> | number
    userId?: IntFilter<"BotPet"> | number
    roomId?: IntFilter<"BotPet"> | number
    name?: StringFilter<"BotPet"> | string
    race?: StringFilter<"BotPet"> | string
    color?: StringFilter<"BotPet"> | string
    type?: IntFilter<"BotPet"> | number
    experience?: IntFilter<"BotPet"> | number
    energy?: IntFilter<"BotPet"> | number
    nutrition?: IntFilter<"BotPet"> | number
    respect?: IntFilter<"BotPet"> | number
    createstamp?: IntFilter<"BotPet"> | number
    x?: IntFilter<"BotPet"> | number
    y?: IntFilter<"BotPet"> | number
    z?: FloatFilter<"BotPet"> | number
    haveSaddle?: IntFilter<"BotPet"> | number
    hairdye?: IntFilter<"BotPet"> | number
    pethair?: IntFilter<"BotPet"> | number
    anyoneRide?: BoolFilter<"BotPet"> | boolean
  }

  export type BotPetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    race?: SortOrder
    color?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
    anyoneRide?: SortOrder
  }

  export type BotPetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BotPetWhereInput | BotPetWhereInput[]
    OR?: BotPetWhereInput[]
    NOT?: BotPetWhereInput | BotPetWhereInput[]
    userId?: IntFilter<"BotPet"> | number
    roomId?: IntFilter<"BotPet"> | number
    name?: StringFilter<"BotPet"> | string
    race?: StringFilter<"BotPet"> | string
    color?: StringFilter<"BotPet"> | string
    type?: IntFilter<"BotPet"> | number
    experience?: IntFilter<"BotPet"> | number
    energy?: IntFilter<"BotPet"> | number
    nutrition?: IntFilter<"BotPet"> | number
    respect?: IntFilter<"BotPet"> | number
    createstamp?: IntFilter<"BotPet"> | number
    x?: IntFilter<"BotPet"> | number
    y?: IntFilter<"BotPet"> | number
    z?: FloatFilter<"BotPet"> | number
    haveSaddle?: IntFilter<"BotPet"> | number
    hairdye?: IntFilter<"BotPet"> | number
    pethair?: IntFilter<"BotPet"> | number
    anyoneRide?: BoolFilter<"BotPet"> | boolean
  }, "id">

  export type BotPetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    race?: SortOrder
    color?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
    anyoneRide?: SortOrder
    _count?: BotPetCountOrderByAggregateInput
    _avg?: BotPetAvgOrderByAggregateInput
    _max?: BotPetMaxOrderByAggregateInput
    _min?: BotPetMinOrderByAggregateInput
    _sum?: BotPetSumOrderByAggregateInput
  }

  export type BotPetScalarWhereWithAggregatesInput = {
    AND?: BotPetScalarWhereWithAggregatesInput | BotPetScalarWhereWithAggregatesInput[]
    OR?: BotPetScalarWhereWithAggregatesInput[]
    NOT?: BotPetScalarWhereWithAggregatesInput | BotPetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BotPet"> | number
    userId?: IntWithAggregatesFilter<"BotPet"> | number
    roomId?: IntWithAggregatesFilter<"BotPet"> | number
    name?: StringWithAggregatesFilter<"BotPet"> | string
    race?: StringWithAggregatesFilter<"BotPet"> | string
    color?: StringWithAggregatesFilter<"BotPet"> | string
    type?: IntWithAggregatesFilter<"BotPet"> | number
    experience?: IntWithAggregatesFilter<"BotPet"> | number
    energy?: IntWithAggregatesFilter<"BotPet"> | number
    nutrition?: IntWithAggregatesFilter<"BotPet"> | number
    respect?: IntWithAggregatesFilter<"BotPet"> | number
    createstamp?: IntWithAggregatesFilter<"BotPet"> | number
    x?: IntWithAggregatesFilter<"BotPet"> | number
    y?: IntWithAggregatesFilter<"BotPet"> | number
    z?: FloatWithAggregatesFilter<"BotPet"> | number
    haveSaddle?: IntWithAggregatesFilter<"BotPet"> | number
    hairdye?: IntWithAggregatesFilter<"BotPet"> | number
    pethair?: IntWithAggregatesFilter<"BotPet"> | number
    anyoneRide?: BoolWithAggregatesFilter<"BotPet"> | boolean
  }

  export type BotUserWhereInput = {
    AND?: BotUserWhereInput | BotUserWhereInput[]
    OR?: BotUserWhereInput[]
    NOT?: BotUserWhereInput | BotUserWhereInput[]
    id?: IntFilter<"BotUser"> | number
    userId?: IntFilter<"BotUser"> | number
    name?: StringFilter<"BotUser"> | string
    motto?: StringFilter<"BotUser"> | string
    gender?: StringFilter<"BotUser"> | string
    look?: StringFilter<"BotUser"> | string
    roomId?: IntFilter<"BotUser"> | number
    walkEnabled?: BoolFilter<"BotUser"> | boolean
    x?: IntFilter<"BotUser"> | number
    y?: IntFilter<"BotUser"> | number
    z?: IntFilter<"BotUser"> | number
    rotation?: IntFilter<"BotUser"> | number
    chatEnabled?: BoolFilter<"BotUser"> | boolean
    chatText?: StringFilter<"BotUser"> | string
    chatSeconds?: IntFilter<"BotUser"> | number
    isDancing?: BoolFilter<"BotUser"> | boolean
    isMixchat?: BoolFilter<"BotUser"> | boolean
    status?: IntFilter<"BotUser"> | number
    enable?: IntFilter<"BotUser"> | number
    handitem?: IntFilter<"BotUser"> | number
    aiType?: EnumBotUserAiTypeFilter<"BotUser"> | $Enums.BotUserAiType
  }

  export type BotUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    motto?: SortOrder
    gender?: SortOrder
    look?: SortOrder
    roomId?: SortOrder
    walkEnabled?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatEnabled?: SortOrder
    chatText?: SortOrder
    chatSeconds?: SortOrder
    isDancing?: SortOrder
    isMixchat?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
    aiType?: SortOrder
  }

  export type BotUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BotUserWhereInput | BotUserWhereInput[]
    OR?: BotUserWhereInput[]
    NOT?: BotUserWhereInput | BotUserWhereInput[]
    userId?: IntFilter<"BotUser"> | number
    name?: StringFilter<"BotUser"> | string
    motto?: StringFilter<"BotUser"> | string
    gender?: StringFilter<"BotUser"> | string
    look?: StringFilter<"BotUser"> | string
    roomId?: IntFilter<"BotUser"> | number
    walkEnabled?: BoolFilter<"BotUser"> | boolean
    x?: IntFilter<"BotUser"> | number
    y?: IntFilter<"BotUser"> | number
    z?: IntFilter<"BotUser"> | number
    rotation?: IntFilter<"BotUser"> | number
    chatEnabled?: BoolFilter<"BotUser"> | boolean
    chatText?: StringFilter<"BotUser"> | string
    chatSeconds?: IntFilter<"BotUser"> | number
    isDancing?: BoolFilter<"BotUser"> | boolean
    isMixchat?: BoolFilter<"BotUser"> | boolean
    status?: IntFilter<"BotUser"> | number
    enable?: IntFilter<"BotUser"> | number
    handitem?: IntFilter<"BotUser"> | number
    aiType?: EnumBotUserAiTypeFilter<"BotUser"> | $Enums.BotUserAiType
  }, "id">

  export type BotUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    motto?: SortOrder
    gender?: SortOrder
    look?: SortOrder
    roomId?: SortOrder
    walkEnabled?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatEnabled?: SortOrder
    chatText?: SortOrder
    chatSeconds?: SortOrder
    isDancing?: SortOrder
    isMixchat?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
    aiType?: SortOrder
    _count?: BotUserCountOrderByAggregateInput
    _avg?: BotUserAvgOrderByAggregateInput
    _max?: BotUserMaxOrderByAggregateInput
    _min?: BotUserMinOrderByAggregateInput
    _sum?: BotUserSumOrderByAggregateInput
  }

  export type BotUserScalarWhereWithAggregatesInput = {
    AND?: BotUserScalarWhereWithAggregatesInput | BotUserScalarWhereWithAggregatesInput[]
    OR?: BotUserScalarWhereWithAggregatesInput[]
    NOT?: BotUserScalarWhereWithAggregatesInput | BotUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BotUser"> | number
    userId?: IntWithAggregatesFilter<"BotUser"> | number
    name?: StringWithAggregatesFilter<"BotUser"> | string
    motto?: StringWithAggregatesFilter<"BotUser"> | string
    gender?: StringWithAggregatesFilter<"BotUser"> | string
    look?: StringWithAggregatesFilter<"BotUser"> | string
    roomId?: IntWithAggregatesFilter<"BotUser"> | number
    walkEnabled?: BoolWithAggregatesFilter<"BotUser"> | boolean
    x?: IntWithAggregatesFilter<"BotUser"> | number
    y?: IntWithAggregatesFilter<"BotUser"> | number
    z?: IntWithAggregatesFilter<"BotUser"> | number
    rotation?: IntWithAggregatesFilter<"BotUser"> | number
    chatEnabled?: BoolWithAggregatesFilter<"BotUser"> | boolean
    chatText?: StringWithAggregatesFilter<"BotUser"> | string
    chatSeconds?: IntWithAggregatesFilter<"BotUser"> | number
    isDancing?: BoolWithAggregatesFilter<"BotUser"> | boolean
    isMixchat?: BoolWithAggregatesFilter<"BotUser"> | boolean
    status?: IntWithAggregatesFilter<"BotUser"> | number
    enable?: IntWithAggregatesFilter<"BotUser"> | number
    handitem?: IntWithAggregatesFilter<"BotUser"> | number
    aiType?: EnumBotUserAiTypeWithAggregatesFilter<"BotUser"> | $Enums.BotUserAiType
  }

  export type CatalogBotPresetWhereInput = {
    AND?: CatalogBotPresetWhereInput | CatalogBotPresetWhereInput[]
    OR?: CatalogBotPresetWhereInput[]
    NOT?: CatalogBotPresetWhereInput | CatalogBotPresetWhereInput[]
    id?: IntFilter<"CatalogBotPreset"> | number
    name?: StringFilter<"CatalogBotPreset"> | string
    figure?: StringFilter<"CatalogBotPreset"> | string
    gender?: StringFilter<"CatalogBotPreset"> | string
    motto?: StringFilter<"CatalogBotPreset"> | string
    aiType?: EnumCatalogBotPresetAiTypeFilter<"CatalogBotPreset"> | $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    figure?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    aiType?: SortOrder
  }

  export type CatalogBotPresetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogBotPresetWhereInput | CatalogBotPresetWhereInput[]
    OR?: CatalogBotPresetWhereInput[]
    NOT?: CatalogBotPresetWhereInput | CatalogBotPresetWhereInput[]
    name?: StringFilter<"CatalogBotPreset"> | string
    figure?: StringFilter<"CatalogBotPreset"> | string
    gender?: StringFilter<"CatalogBotPreset"> | string
    motto?: StringFilter<"CatalogBotPreset"> | string
    aiType?: EnumCatalogBotPresetAiTypeFilter<"CatalogBotPreset"> | $Enums.CatalogBotPresetAiType
  }, "id">

  export type CatalogBotPresetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    figure?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    aiType?: SortOrder
    _count?: CatalogBotPresetCountOrderByAggregateInput
    _avg?: CatalogBotPresetAvgOrderByAggregateInput
    _max?: CatalogBotPresetMaxOrderByAggregateInput
    _min?: CatalogBotPresetMinOrderByAggregateInput
    _sum?: CatalogBotPresetSumOrderByAggregateInput
  }

  export type CatalogBotPresetScalarWhereWithAggregatesInput = {
    AND?: CatalogBotPresetScalarWhereWithAggregatesInput | CatalogBotPresetScalarWhereWithAggregatesInput[]
    OR?: CatalogBotPresetScalarWhereWithAggregatesInput[]
    NOT?: CatalogBotPresetScalarWhereWithAggregatesInput | CatalogBotPresetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogBotPreset"> | number
    name?: StringWithAggregatesFilter<"CatalogBotPreset"> | string
    figure?: StringWithAggregatesFilter<"CatalogBotPreset"> | string
    gender?: StringWithAggregatesFilter<"CatalogBotPreset"> | string
    motto?: StringWithAggregatesFilter<"CatalogBotPreset"> | string
    aiType?: EnumCatalogBotPresetAiTypeWithAggregatesFilter<"CatalogBotPreset"> | $Enums.CatalogBotPresetAiType
  }

  export type CatalogItemWhereInput = {
    AND?: CatalogItemWhereInput | CatalogItemWhereInput[]
    OR?: CatalogItemWhereInput[]
    NOT?: CatalogItemWhereInput | CatalogItemWhereInput[]
    id?: IntFilter<"CatalogItem"> | number
    pageId?: IntFilter<"CatalogItem"> | number
    itemId?: IntFilter<"CatalogItem"> | number
    catalogName?: StringFilter<"CatalogItem"> | string
    costCredits?: IntFilter<"CatalogItem"> | number
    costPixels?: IntFilter<"CatalogItem"> | number
    costDiamonds?: IntFilter<"CatalogItem"> | number
    costLimitcoins?: IntFilter<"CatalogItem"> | number
    amount?: IntFilter<"CatalogItem"> | number
    offerActive?: BoolFilter<"CatalogItem"> | boolean
    badge?: StringFilter<"CatalogItem"> | string
    catalogItemLimited?: XOR<CatalogItemLimitedNullableRelationFilter, CatalogItemLimitedWhereInput> | null
    itemBase?: XOR<ItemBaseRelationFilter, ItemBaseWhereInput>
  }

  export type CatalogItemOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    catalogName?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
    offerActive?: SortOrder
    badge?: SortOrder
    catalogItemLimited?: CatalogItemLimitedOrderByWithRelationInput
    itemBase?: ItemBaseOrderByWithRelationInput
  }

  export type CatalogItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogItemWhereInput | CatalogItemWhereInput[]
    OR?: CatalogItemWhereInput[]
    NOT?: CatalogItemWhereInput | CatalogItemWhereInput[]
    pageId?: IntFilter<"CatalogItem"> | number
    itemId?: IntFilter<"CatalogItem"> | number
    catalogName?: StringFilter<"CatalogItem"> | string
    costCredits?: IntFilter<"CatalogItem"> | number
    costPixels?: IntFilter<"CatalogItem"> | number
    costDiamonds?: IntFilter<"CatalogItem"> | number
    costLimitcoins?: IntFilter<"CatalogItem"> | number
    amount?: IntFilter<"CatalogItem"> | number
    offerActive?: BoolFilter<"CatalogItem"> | boolean
    badge?: StringFilter<"CatalogItem"> | string
    catalogItemLimited?: XOR<CatalogItemLimitedNullableRelationFilter, CatalogItemLimitedWhereInput> | null
    itemBase?: XOR<ItemBaseRelationFilter, ItemBaseWhereInput>
  }, "id">

  export type CatalogItemOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    catalogName?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
    offerActive?: SortOrder
    badge?: SortOrder
    _count?: CatalogItemCountOrderByAggregateInput
    _avg?: CatalogItemAvgOrderByAggregateInput
    _max?: CatalogItemMaxOrderByAggregateInput
    _min?: CatalogItemMinOrderByAggregateInput
    _sum?: CatalogItemSumOrderByAggregateInput
  }

  export type CatalogItemScalarWhereWithAggregatesInput = {
    AND?: CatalogItemScalarWhereWithAggregatesInput | CatalogItemScalarWhereWithAggregatesInput[]
    OR?: CatalogItemScalarWhereWithAggregatesInput[]
    NOT?: CatalogItemScalarWhereWithAggregatesInput | CatalogItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogItem"> | number
    pageId?: IntWithAggregatesFilter<"CatalogItem"> | number
    itemId?: IntWithAggregatesFilter<"CatalogItem"> | number
    catalogName?: StringWithAggregatesFilter<"CatalogItem"> | string
    costCredits?: IntWithAggregatesFilter<"CatalogItem"> | number
    costPixels?: IntWithAggregatesFilter<"CatalogItem"> | number
    costDiamonds?: IntWithAggregatesFilter<"CatalogItem"> | number
    costLimitcoins?: IntWithAggregatesFilter<"CatalogItem"> | number
    amount?: IntWithAggregatesFilter<"CatalogItem"> | number
    offerActive?: BoolWithAggregatesFilter<"CatalogItem"> | boolean
    badge?: StringWithAggregatesFilter<"CatalogItem"> | string
  }

  export type CatalogItemLimitedWhereInput = {
    AND?: CatalogItemLimitedWhereInput | CatalogItemLimitedWhereInput[]
    OR?: CatalogItemLimitedWhereInput[]
    NOT?: CatalogItemLimitedWhereInput | CatalogItemLimitedWhereInput[]
    catalogItemId?: IntFilter<"CatalogItemLimited"> | number
    limitedSells?: IntFilter<"CatalogItemLimited"> | number
    limitedStack?: IntFilter<"CatalogItemLimited"> | number
    catalogItem?: XOR<CatalogItemRelationFilter, CatalogItemWhereInput>
  }

  export type CatalogItemLimitedOrderByWithRelationInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
    catalogItem?: CatalogItemOrderByWithRelationInput
  }

  export type CatalogItemLimitedWhereUniqueInput = Prisma.AtLeast<{
    catalogItemId?: number
    AND?: CatalogItemLimitedWhereInput | CatalogItemLimitedWhereInput[]
    OR?: CatalogItemLimitedWhereInput[]
    NOT?: CatalogItemLimitedWhereInput | CatalogItemLimitedWhereInput[]
    limitedSells?: IntFilter<"CatalogItemLimited"> | number
    limitedStack?: IntFilter<"CatalogItemLimited"> | number
    catalogItem?: XOR<CatalogItemRelationFilter, CatalogItemWhereInput>
  }, "catalogItemId">

  export type CatalogItemLimitedOrderByWithAggregationInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
    _count?: CatalogItemLimitedCountOrderByAggregateInput
    _avg?: CatalogItemLimitedAvgOrderByAggregateInput
    _max?: CatalogItemLimitedMaxOrderByAggregateInput
    _min?: CatalogItemLimitedMinOrderByAggregateInput
    _sum?: CatalogItemLimitedSumOrderByAggregateInput
  }

  export type CatalogItemLimitedScalarWhereWithAggregatesInput = {
    AND?: CatalogItemLimitedScalarWhereWithAggregatesInput | CatalogItemLimitedScalarWhereWithAggregatesInput[]
    OR?: CatalogItemLimitedScalarWhereWithAggregatesInput[]
    NOT?: CatalogItemLimitedScalarWhereWithAggregatesInput | CatalogItemLimitedScalarWhereWithAggregatesInput[]
    catalogItemId?: IntWithAggregatesFilter<"CatalogItemLimited"> | number
    limitedSells?: IntWithAggregatesFilter<"CatalogItemLimited"> | number
    limitedStack?: IntWithAggregatesFilter<"CatalogItemLimited"> | number
  }

  export type CatalogMarketplaceDataWhereInput = {
    AND?: CatalogMarketplaceDataWhereInput | CatalogMarketplaceDataWhereInput[]
    OR?: CatalogMarketplaceDataWhereInput[]
    NOT?: CatalogMarketplaceDataWhereInput | CatalogMarketplaceDataWhereInput[]
    id?: IntFilter<"CatalogMarketplaceData"> | number
    sprite?: IntFilter<"CatalogMarketplaceData"> | number
    sold?: IntFilter<"CatalogMarketplaceData"> | number
    avgprice?: IntFilter<"CatalogMarketplaceData"> | number
  }

  export type CatalogMarketplaceDataOrderByWithRelationInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
  }

  export type CatalogMarketplaceDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogMarketplaceDataWhereInput | CatalogMarketplaceDataWhereInput[]
    OR?: CatalogMarketplaceDataWhereInput[]
    NOT?: CatalogMarketplaceDataWhereInput | CatalogMarketplaceDataWhereInput[]
    sprite?: IntFilter<"CatalogMarketplaceData"> | number
    sold?: IntFilter<"CatalogMarketplaceData"> | number
    avgprice?: IntFilter<"CatalogMarketplaceData"> | number
  }, "id">

  export type CatalogMarketplaceDataOrderByWithAggregationInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
    _count?: CatalogMarketplaceDataCountOrderByAggregateInput
    _avg?: CatalogMarketplaceDataAvgOrderByAggregateInput
    _max?: CatalogMarketplaceDataMaxOrderByAggregateInput
    _min?: CatalogMarketplaceDataMinOrderByAggregateInput
    _sum?: CatalogMarketplaceDataSumOrderByAggregateInput
  }

  export type CatalogMarketplaceDataScalarWhereWithAggregatesInput = {
    AND?: CatalogMarketplaceDataScalarWhereWithAggregatesInput | CatalogMarketplaceDataScalarWhereWithAggregatesInput[]
    OR?: CatalogMarketplaceDataScalarWhereWithAggregatesInput[]
    NOT?: CatalogMarketplaceDataScalarWhereWithAggregatesInput | CatalogMarketplaceDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogMarketplaceData"> | number
    sprite?: IntWithAggregatesFilter<"CatalogMarketplaceData"> | number
    sold?: IntWithAggregatesFilter<"CatalogMarketplaceData"> | number
    avgprice?: IntWithAggregatesFilter<"CatalogMarketplaceData"> | number
  }

  export type CatalogMarketplaceOfferWhereInput = {
    AND?: CatalogMarketplaceOfferWhereInput | CatalogMarketplaceOfferWhereInput[]
    OR?: CatalogMarketplaceOfferWhereInput[]
    NOT?: CatalogMarketplaceOfferWhereInput | CatalogMarketplaceOfferWhereInput[]
    offerId?: IntFilter<"CatalogMarketplaceOffer"> | number
    userId?: IntFilter<"CatalogMarketplaceOffer"> | number
    itemId?: IntFilter<"CatalogMarketplaceOffer"> | number
    askingPrice?: IntFilter<"CatalogMarketplaceOffer"> | number
    totalPrice?: IntFilter<"CatalogMarketplaceOffer"> | number
    publicName?: StringFilter<"CatalogMarketplaceOffer"> | string
    spriteId?: IntFilter<"CatalogMarketplaceOffer"> | number
    itemType?: IntFilter<"CatalogMarketplaceOffer"> | number
    timestamp?: IntFilter<"CatalogMarketplaceOffer"> | number
    state?: IntFilter<"CatalogMarketplaceOffer"> | number
    extraData?: StringFilter<"CatalogMarketplaceOffer"> | string
    furniId?: IntFilter<"CatalogMarketplaceOffer"> | number
    limitedNumber?: IntFilter<"CatalogMarketplaceOffer"> | number
    limitedStack?: IntFilter<"CatalogMarketplaceOffer"> | number
  }

  export type CatalogMarketplaceOfferOrderByWithRelationInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    publicName?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    extraData?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogMarketplaceOfferWhereUniqueInput = Prisma.AtLeast<{
    offerId?: number
    AND?: CatalogMarketplaceOfferWhereInput | CatalogMarketplaceOfferWhereInput[]
    OR?: CatalogMarketplaceOfferWhereInput[]
    NOT?: CatalogMarketplaceOfferWhereInput | CatalogMarketplaceOfferWhereInput[]
    userId?: IntFilter<"CatalogMarketplaceOffer"> | number
    itemId?: IntFilter<"CatalogMarketplaceOffer"> | number
    askingPrice?: IntFilter<"CatalogMarketplaceOffer"> | number
    totalPrice?: IntFilter<"CatalogMarketplaceOffer"> | number
    publicName?: StringFilter<"CatalogMarketplaceOffer"> | string
    spriteId?: IntFilter<"CatalogMarketplaceOffer"> | number
    itemType?: IntFilter<"CatalogMarketplaceOffer"> | number
    timestamp?: IntFilter<"CatalogMarketplaceOffer"> | number
    state?: IntFilter<"CatalogMarketplaceOffer"> | number
    extraData?: StringFilter<"CatalogMarketplaceOffer"> | string
    furniId?: IntFilter<"CatalogMarketplaceOffer"> | number
    limitedNumber?: IntFilter<"CatalogMarketplaceOffer"> | number
    limitedStack?: IntFilter<"CatalogMarketplaceOffer"> | number
  }, "offerId">

  export type CatalogMarketplaceOfferOrderByWithAggregationInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    publicName?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    extraData?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
    _count?: CatalogMarketplaceOfferCountOrderByAggregateInput
    _avg?: CatalogMarketplaceOfferAvgOrderByAggregateInput
    _max?: CatalogMarketplaceOfferMaxOrderByAggregateInput
    _min?: CatalogMarketplaceOfferMinOrderByAggregateInput
    _sum?: CatalogMarketplaceOfferSumOrderByAggregateInput
  }

  export type CatalogMarketplaceOfferScalarWhereWithAggregatesInput = {
    AND?: CatalogMarketplaceOfferScalarWhereWithAggregatesInput | CatalogMarketplaceOfferScalarWhereWithAggregatesInput[]
    OR?: CatalogMarketplaceOfferScalarWhereWithAggregatesInput[]
    NOT?: CatalogMarketplaceOfferScalarWhereWithAggregatesInput | CatalogMarketplaceOfferScalarWhereWithAggregatesInput[]
    offerId?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    userId?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    itemId?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    askingPrice?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    totalPrice?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    publicName?: StringWithAggregatesFilter<"CatalogMarketplaceOffer"> | string
    spriteId?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    itemType?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    timestamp?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    state?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    extraData?: StringWithAggregatesFilter<"CatalogMarketplaceOffer"> | string
    furniId?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    limitedNumber?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
    limitedStack?: IntWithAggregatesFilter<"CatalogMarketplaceOffer"> | number
  }

  export type CatalogPageWhereInput = {
    AND?: CatalogPageWhereInput | CatalogPageWhereInput[]
    OR?: CatalogPageWhereInput[]
    NOT?: CatalogPageWhereInput | CatalogPageWhereInput[]
    id?: IntFilter<"CatalogPage"> | number
    parentId?: IntFilter<"CatalogPage"> | number
    caption?: StringFilter<"CatalogPage"> | string
    iconImage?: IntFilter<"CatalogPage"> | number
    enabled?: BoolFilter<"CatalogPage"> | boolean
    requiredRight?: StringFilter<"CatalogPage"> | string
    orderNum?: IntFilter<"CatalogPage"> | number
    pageLayout?: StringFilter<"CatalogPage"> | string
    pageLink?: StringFilter<"CatalogPage"> | string
    pageStrings1?: StringFilter<"CatalogPage"> | string
    pageStrings2?: StringFilter<"CatalogPage"> | string
    isPremium?: BoolFilter<"CatalogPage"> | boolean
  }

  export type CatalogPageOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    caption?: SortOrder
    iconImage?: SortOrder
    enabled?: SortOrder
    requiredRight?: SortOrder
    orderNum?: SortOrder
    pageLayout?: SortOrder
    pageLink?: SortOrder
    pageStrings1?: SortOrder
    pageStrings2?: SortOrder
    isPremium?: SortOrder
  }

  export type CatalogPageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogPageWhereInput | CatalogPageWhereInput[]
    OR?: CatalogPageWhereInput[]
    NOT?: CatalogPageWhereInput | CatalogPageWhereInput[]
    parentId?: IntFilter<"CatalogPage"> | number
    caption?: StringFilter<"CatalogPage"> | string
    iconImage?: IntFilter<"CatalogPage"> | number
    enabled?: BoolFilter<"CatalogPage"> | boolean
    requiredRight?: StringFilter<"CatalogPage"> | string
    orderNum?: IntFilter<"CatalogPage"> | number
    pageLayout?: StringFilter<"CatalogPage"> | string
    pageLink?: StringFilter<"CatalogPage"> | string
    pageStrings1?: StringFilter<"CatalogPage"> | string
    pageStrings2?: StringFilter<"CatalogPage"> | string
    isPremium?: BoolFilter<"CatalogPage"> | boolean
  }, "id">

  export type CatalogPageOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    caption?: SortOrder
    iconImage?: SortOrder
    enabled?: SortOrder
    requiredRight?: SortOrder
    orderNum?: SortOrder
    pageLayout?: SortOrder
    pageLink?: SortOrder
    pageStrings1?: SortOrder
    pageStrings2?: SortOrder
    isPremium?: SortOrder
    _count?: CatalogPageCountOrderByAggregateInput
    _avg?: CatalogPageAvgOrderByAggregateInput
    _max?: CatalogPageMaxOrderByAggregateInput
    _min?: CatalogPageMinOrderByAggregateInput
    _sum?: CatalogPageSumOrderByAggregateInput
  }

  export type CatalogPageScalarWhereWithAggregatesInput = {
    AND?: CatalogPageScalarWhereWithAggregatesInput | CatalogPageScalarWhereWithAggregatesInput[]
    OR?: CatalogPageScalarWhereWithAggregatesInput[]
    NOT?: CatalogPageScalarWhereWithAggregatesInput | CatalogPageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogPage"> | number
    parentId?: IntWithAggregatesFilter<"CatalogPage"> | number
    caption?: StringWithAggregatesFilter<"CatalogPage"> | string
    iconImage?: IntWithAggregatesFilter<"CatalogPage"> | number
    enabled?: BoolWithAggregatesFilter<"CatalogPage"> | boolean
    requiredRight?: StringWithAggregatesFilter<"CatalogPage"> | string
    orderNum?: IntWithAggregatesFilter<"CatalogPage"> | number
    pageLayout?: StringWithAggregatesFilter<"CatalogPage"> | string
    pageLink?: StringWithAggregatesFilter<"CatalogPage"> | string
    pageStrings1?: StringWithAggregatesFilter<"CatalogPage"> | string
    pageStrings2?: StringWithAggregatesFilter<"CatalogPage"> | string
    isPremium?: BoolWithAggregatesFilter<"CatalogPage"> | boolean
  }

  export type CatalogPageLangueWhereInput = {
    AND?: CatalogPageLangueWhereInput | CatalogPageLangueWhereInput[]
    OR?: CatalogPageLangueWhereInput[]
    NOT?: CatalogPageLangueWhereInput | CatalogPageLangueWhereInput[]
    pageId?: IntFilter<"CatalogPageLangue"> | number
    captionFr?: StringNullableFilter<"CatalogPageLangue"> | string | null
    captionEn?: StringNullableFilter<"CatalogPageLangue"> | string | null
    captionBr?: StringNullableFilter<"CatalogPageLangue"> | string | null
    pageStrings2Fr?: StringNullableFilter<"CatalogPageLangue"> | string | null
    pageStrings2En?: StringNullableFilter<"CatalogPageLangue"> | string | null
    pageStrings2Br?: StringNullableFilter<"CatalogPageLangue"> | string | null
  }

  export type CatalogPageLangueOrderByWithRelationInput = {
    pageId?: SortOrder
    captionFr?: SortOrderInput | SortOrder
    captionEn?: SortOrderInput | SortOrder
    captionBr?: SortOrderInput | SortOrder
    pageStrings2Fr?: SortOrderInput | SortOrder
    pageStrings2En?: SortOrderInput | SortOrder
    pageStrings2Br?: SortOrderInput | SortOrder
  }

  export type CatalogPageLangueWhereUniqueInput = Prisma.AtLeast<{
    pageId?: number
    AND?: CatalogPageLangueWhereInput | CatalogPageLangueWhereInput[]
    OR?: CatalogPageLangueWhereInput[]
    NOT?: CatalogPageLangueWhereInput | CatalogPageLangueWhereInput[]
    captionFr?: StringNullableFilter<"CatalogPageLangue"> | string | null
    captionEn?: StringNullableFilter<"CatalogPageLangue"> | string | null
    captionBr?: StringNullableFilter<"CatalogPageLangue"> | string | null
    pageStrings2Fr?: StringNullableFilter<"CatalogPageLangue"> | string | null
    pageStrings2En?: StringNullableFilter<"CatalogPageLangue"> | string | null
    pageStrings2Br?: StringNullableFilter<"CatalogPageLangue"> | string | null
  }, "pageId">

  export type CatalogPageLangueOrderByWithAggregationInput = {
    pageId?: SortOrder
    captionFr?: SortOrderInput | SortOrder
    captionEn?: SortOrderInput | SortOrder
    captionBr?: SortOrderInput | SortOrder
    pageStrings2Fr?: SortOrderInput | SortOrder
    pageStrings2En?: SortOrderInput | SortOrder
    pageStrings2Br?: SortOrderInput | SortOrder
    _count?: CatalogPageLangueCountOrderByAggregateInput
    _avg?: CatalogPageLangueAvgOrderByAggregateInput
    _max?: CatalogPageLangueMaxOrderByAggregateInput
    _min?: CatalogPageLangueMinOrderByAggregateInput
    _sum?: CatalogPageLangueSumOrderByAggregateInput
  }

  export type CatalogPageLangueScalarWhereWithAggregatesInput = {
    AND?: CatalogPageLangueScalarWhereWithAggregatesInput | CatalogPageLangueScalarWhereWithAggregatesInput[]
    OR?: CatalogPageLangueScalarWhereWithAggregatesInput[]
    NOT?: CatalogPageLangueScalarWhereWithAggregatesInput | CatalogPageLangueScalarWhereWithAggregatesInput[]
    pageId?: IntWithAggregatesFilter<"CatalogPageLangue"> | number
    captionFr?: StringNullableWithAggregatesFilter<"CatalogPageLangue"> | string | null
    captionEn?: StringNullableWithAggregatesFilter<"CatalogPageLangue"> | string | null
    captionBr?: StringNullableWithAggregatesFilter<"CatalogPageLangue"> | string | null
    pageStrings2Fr?: StringNullableWithAggregatesFilter<"CatalogPageLangue"> | string | null
    pageStrings2En?: StringNullableWithAggregatesFilter<"CatalogPageLangue"> | string | null
    pageStrings2Br?: StringNullableWithAggregatesFilter<"CatalogPageLangue"> | string | null
  }

  export type CatalogPetRaceWhereInput = {
    AND?: CatalogPetRaceWhereInput | CatalogPetRaceWhereInput[]
    OR?: CatalogPetRaceWhereInput[]
    NOT?: CatalogPetRaceWhereInput | CatalogPetRaceWhereInput[]
    id?: IntFilter<"CatalogPetRace"> | number
    raceid?: IntFilter<"CatalogPetRace"> | number
    color1?: IntNullableFilter<"CatalogPetRace"> | number | null
    color2?: IntNullableFilter<"CatalogPetRace"> | number | null
    has1color?: BoolFilter<"CatalogPetRace"> | boolean
    has2color?: BoolFilter<"CatalogPetRace"> | boolean
  }

  export type CatalogPetRaceOrderByWithRelationInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrderInput | SortOrder
    color2?: SortOrderInput | SortOrder
    has1color?: SortOrder
    has2color?: SortOrder
  }

  export type CatalogPetRaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogPetRaceWhereInput | CatalogPetRaceWhereInput[]
    OR?: CatalogPetRaceWhereInput[]
    NOT?: CatalogPetRaceWhereInput | CatalogPetRaceWhereInput[]
    raceid?: IntFilter<"CatalogPetRace"> | number
    color1?: IntNullableFilter<"CatalogPetRace"> | number | null
    color2?: IntNullableFilter<"CatalogPetRace"> | number | null
    has1color?: BoolFilter<"CatalogPetRace"> | boolean
    has2color?: BoolFilter<"CatalogPetRace"> | boolean
  }, "id">

  export type CatalogPetRaceOrderByWithAggregationInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrderInput | SortOrder
    color2?: SortOrderInput | SortOrder
    has1color?: SortOrder
    has2color?: SortOrder
    _count?: CatalogPetRaceCountOrderByAggregateInput
    _avg?: CatalogPetRaceAvgOrderByAggregateInput
    _max?: CatalogPetRaceMaxOrderByAggregateInput
    _min?: CatalogPetRaceMinOrderByAggregateInput
    _sum?: CatalogPetRaceSumOrderByAggregateInput
  }

  export type CatalogPetRaceScalarWhereWithAggregatesInput = {
    AND?: CatalogPetRaceScalarWhereWithAggregatesInput | CatalogPetRaceScalarWhereWithAggregatesInput[]
    OR?: CatalogPetRaceScalarWhereWithAggregatesInput[]
    NOT?: CatalogPetRaceScalarWhereWithAggregatesInput | CatalogPetRaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogPetRace"> | number
    raceid?: IntWithAggregatesFilter<"CatalogPetRace"> | number
    color1?: IntNullableWithAggregatesFilter<"CatalogPetRace"> | number | null
    color2?: IntNullableWithAggregatesFilter<"CatalogPetRace"> | number | null
    has1color?: BoolWithAggregatesFilter<"CatalogPetRace"> | boolean
    has2color?: BoolWithAggregatesFilter<"CatalogPetRace"> | boolean
  }

  export type CatalogPromotionWhereInput = {
    AND?: CatalogPromotionWhereInput | CatalogPromotionWhereInput[]
    OR?: CatalogPromotionWhereInput[]
    NOT?: CatalogPromotionWhereInput | CatalogPromotionWhereInput[]
    id?: IntFilter<"CatalogPromotion"> | number
    title?: StringNullableFilter<"CatalogPromotion"> | string | null
    titleEn?: StringNullableFilter<"CatalogPromotion"> | string | null
    titleBr?: StringNullableFilter<"CatalogPromotion"> | string | null
    image?: StringNullableFilter<"CatalogPromotion"> | string | null
    unknown?: IntNullableFilter<"CatalogPromotion"> | number | null
    pageLink?: StringNullableFilter<"CatalogPromotion"> | string | null
    parentId?: IntNullableFilter<"CatalogPromotion"> | number | null
  }

  export type CatalogPromotionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    titleEn?: SortOrderInput | SortOrder
    titleBr?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    unknown?: SortOrderInput | SortOrder
    pageLink?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
  }

  export type CatalogPromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogPromotionWhereInput | CatalogPromotionWhereInput[]
    OR?: CatalogPromotionWhereInput[]
    NOT?: CatalogPromotionWhereInput | CatalogPromotionWhereInput[]
    title?: StringNullableFilter<"CatalogPromotion"> | string | null
    titleEn?: StringNullableFilter<"CatalogPromotion"> | string | null
    titleBr?: StringNullableFilter<"CatalogPromotion"> | string | null
    image?: StringNullableFilter<"CatalogPromotion"> | string | null
    unknown?: IntNullableFilter<"CatalogPromotion"> | number | null
    pageLink?: StringNullableFilter<"CatalogPromotion"> | string | null
    parentId?: IntNullableFilter<"CatalogPromotion"> | number | null
  }, "id">

  export type CatalogPromotionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    titleEn?: SortOrderInput | SortOrder
    titleBr?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    unknown?: SortOrderInput | SortOrder
    pageLink?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: CatalogPromotionCountOrderByAggregateInput
    _avg?: CatalogPromotionAvgOrderByAggregateInput
    _max?: CatalogPromotionMaxOrderByAggregateInput
    _min?: CatalogPromotionMinOrderByAggregateInput
    _sum?: CatalogPromotionSumOrderByAggregateInput
  }

  export type CatalogPromotionScalarWhereWithAggregatesInput = {
    AND?: CatalogPromotionScalarWhereWithAggregatesInput | CatalogPromotionScalarWhereWithAggregatesInput[]
    OR?: CatalogPromotionScalarWhereWithAggregatesInput[]
    NOT?: CatalogPromotionScalarWhereWithAggregatesInput | CatalogPromotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogPromotion"> | number
    title?: StringNullableWithAggregatesFilter<"CatalogPromotion"> | string | null
    titleEn?: StringNullableWithAggregatesFilter<"CatalogPromotion"> | string | null
    titleBr?: StringNullableWithAggregatesFilter<"CatalogPromotion"> | string | null
    image?: StringNullableWithAggregatesFilter<"CatalogPromotion"> | string | null
    unknown?: IntNullableWithAggregatesFilter<"CatalogPromotion"> | number | null
    pageLink?: StringNullableWithAggregatesFilter<"CatalogPromotion"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"CatalogPromotion"> | number | null
  }

  export type CatalogVoucherWhereInput = {
    AND?: CatalogVoucherWhereInput | CatalogVoucherWhereInput[]
    OR?: CatalogVoucherWhereInput[]
    NOT?: CatalogVoucherWhereInput | CatalogVoucherWhereInput[]
    voucher?: StringFilter<"CatalogVoucher"> | string
    type?: EnumCatalogVoucherTypeFilter<"CatalogVoucher"> | $Enums.CatalogVoucherType
    value?: IntFilter<"CatalogVoucher"> | number
    currentUses?: IntFilter<"CatalogVoucher"> | number
    maxUses?: IntFilter<"CatalogVoucher"> | number
    enabled?: BoolFilter<"CatalogVoucher"> | boolean
  }

  export type CatalogVoucherOrderByWithRelationInput = {
    voucher?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
    enabled?: SortOrder
  }

  export type CatalogVoucherWhereUniqueInput = Prisma.AtLeast<{
    voucher?: string
    AND?: CatalogVoucherWhereInput | CatalogVoucherWhereInput[]
    OR?: CatalogVoucherWhereInput[]
    NOT?: CatalogVoucherWhereInput | CatalogVoucherWhereInput[]
    type?: EnumCatalogVoucherTypeFilter<"CatalogVoucher"> | $Enums.CatalogVoucherType
    value?: IntFilter<"CatalogVoucher"> | number
    currentUses?: IntFilter<"CatalogVoucher"> | number
    maxUses?: IntFilter<"CatalogVoucher"> | number
    enabled?: BoolFilter<"CatalogVoucher"> | boolean
  }, "voucher">

  export type CatalogVoucherOrderByWithAggregationInput = {
    voucher?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
    enabled?: SortOrder
    _count?: CatalogVoucherCountOrderByAggregateInput
    _avg?: CatalogVoucherAvgOrderByAggregateInput
    _max?: CatalogVoucherMaxOrderByAggregateInput
    _min?: CatalogVoucherMinOrderByAggregateInput
    _sum?: CatalogVoucherSumOrderByAggregateInput
  }

  export type CatalogVoucherScalarWhereWithAggregatesInput = {
    AND?: CatalogVoucherScalarWhereWithAggregatesInput | CatalogVoucherScalarWhereWithAggregatesInput[]
    OR?: CatalogVoucherScalarWhereWithAggregatesInput[]
    NOT?: CatalogVoucherScalarWhereWithAggregatesInput | CatalogVoucherScalarWhereWithAggregatesInput[]
    voucher?: StringWithAggregatesFilter<"CatalogVoucher"> | string
    type?: EnumCatalogVoucherTypeWithAggregatesFilter<"CatalogVoucher"> | $Enums.CatalogVoucherType
    value?: IntWithAggregatesFilter<"CatalogVoucher"> | number
    currentUses?: IntWithAggregatesFilter<"CatalogVoucher"> | number
    maxUses?: IntWithAggregatesFilter<"CatalogVoucher"> | number
    enabled?: BoolWithAggregatesFilter<"CatalogVoucher"> | boolean
  }

  export type CmsForumPostWhereInput = {
    AND?: CmsForumPostWhereInput | CmsForumPostWhereInput[]
    OR?: CmsForumPostWhereInput[]
    NOT?: CmsForumPostWhereInput | CmsForumPostWhereInput[]
    id?: IntFilter<"CmsForumPost"> | number
    threadid?: IntFilter<"CmsForumPost"> | number
    message?: StringFilter<"CmsForumPost"> | string
    author?: StringFilter<"CmsForumPost"> | string
    date?: StringFilter<"CmsForumPost"> | string
    motto?: StringFilter<"CmsForumPost"> | string
    look?: StringFilter<"CmsForumPost"> | string
    idAuteur?: IntFilter<"CmsForumPost"> | number
    rank?: BoolFilter<"CmsForumPost"> | boolean
  }

  export type CmsForumPostOrderByWithRelationInput = {
    id?: SortOrder
    threadid?: SortOrder
    message?: SortOrder
    author?: SortOrder
    date?: SortOrder
    motto?: SortOrder
    look?: SortOrder
    idAuteur?: SortOrder
    rank?: SortOrder
  }

  export type CmsForumPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CmsForumPostWhereInput | CmsForumPostWhereInput[]
    OR?: CmsForumPostWhereInput[]
    NOT?: CmsForumPostWhereInput | CmsForumPostWhereInput[]
    threadid?: IntFilter<"CmsForumPost"> | number
    message?: StringFilter<"CmsForumPost"> | string
    author?: StringFilter<"CmsForumPost"> | string
    date?: StringFilter<"CmsForumPost"> | string
    motto?: StringFilter<"CmsForumPost"> | string
    look?: StringFilter<"CmsForumPost"> | string
    idAuteur?: IntFilter<"CmsForumPost"> | number
    rank?: BoolFilter<"CmsForumPost"> | boolean
  }, "id" | "id">

  export type CmsForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    threadid?: SortOrder
    message?: SortOrder
    author?: SortOrder
    date?: SortOrder
    motto?: SortOrder
    look?: SortOrder
    idAuteur?: SortOrder
    rank?: SortOrder
    _count?: CmsForumPostCountOrderByAggregateInput
    _avg?: CmsForumPostAvgOrderByAggregateInput
    _max?: CmsForumPostMaxOrderByAggregateInput
    _min?: CmsForumPostMinOrderByAggregateInput
    _sum?: CmsForumPostSumOrderByAggregateInput
  }

  export type CmsForumPostScalarWhereWithAggregatesInput = {
    AND?: CmsForumPostScalarWhereWithAggregatesInput | CmsForumPostScalarWhereWithAggregatesInput[]
    OR?: CmsForumPostScalarWhereWithAggregatesInput[]
    NOT?: CmsForumPostScalarWhereWithAggregatesInput | CmsForumPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsForumPost"> | number
    threadid?: IntWithAggregatesFilter<"CmsForumPost"> | number
    message?: StringWithAggregatesFilter<"CmsForumPost"> | string
    author?: StringWithAggregatesFilter<"CmsForumPost"> | string
    date?: StringWithAggregatesFilter<"CmsForumPost"> | string
    motto?: StringWithAggregatesFilter<"CmsForumPost"> | string
    look?: StringWithAggregatesFilter<"CmsForumPost"> | string
    idAuteur?: IntWithAggregatesFilter<"CmsForumPost"> | number
    rank?: BoolWithAggregatesFilter<"CmsForumPost"> | boolean
  }

  export type CmsForumThreadWhereInput = {
    AND?: CmsForumThreadWhereInput | CmsForumThreadWhereInput[]
    OR?: CmsForumThreadWhereInput[]
    NOT?: CmsForumThreadWhereInput | CmsForumThreadWhereInput[]
    id?: IntFilter<"CmsForumThread"> | number
    type?: IntFilter<"CmsForumThread"> | number
    title?: StringFilter<"CmsForumThread"> | string
    author?: StringFilter<"CmsForumThread"> | string
    date?: StringFilter<"CmsForumThread"> | string
    lastpostAuthor?: StringFilter<"CmsForumThread"> | string
    lastpostDate?: StringFilter<"CmsForumThread"> | string
    posts?: IntFilter<"CmsForumThread"> | number
    mainPost?: IntFilter<"CmsForumThread"> | number
    statut?: IntFilter<"CmsForumThread"> | number
    categorie?: BoolFilter<"CmsForumThread"> | boolean
    views?: IntFilter<"CmsForumThread"> | number
  }

  export type CmsForumThreadOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    author?: SortOrder
    date?: SortOrder
    lastpostAuthor?: SortOrder
    lastpostDate?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    categorie?: SortOrder
    views?: SortOrder
  }

  export type CmsForumThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CmsForumThreadWhereInput | CmsForumThreadWhereInput[]
    OR?: CmsForumThreadWhereInput[]
    NOT?: CmsForumThreadWhereInput | CmsForumThreadWhereInput[]
    type?: IntFilter<"CmsForumThread"> | number
    title?: StringFilter<"CmsForumThread"> | string
    author?: StringFilter<"CmsForumThread"> | string
    date?: StringFilter<"CmsForumThread"> | string
    lastpostAuthor?: StringFilter<"CmsForumThread"> | string
    lastpostDate?: StringFilter<"CmsForumThread"> | string
    posts?: IntFilter<"CmsForumThread"> | number
    mainPost?: IntFilter<"CmsForumThread"> | number
    statut?: IntFilter<"CmsForumThread"> | number
    categorie?: BoolFilter<"CmsForumThread"> | boolean
    views?: IntFilter<"CmsForumThread"> | number
  }, "id" | "id">

  export type CmsForumThreadOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    author?: SortOrder
    date?: SortOrder
    lastpostAuthor?: SortOrder
    lastpostDate?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    categorie?: SortOrder
    views?: SortOrder
    _count?: CmsForumThreadCountOrderByAggregateInput
    _avg?: CmsForumThreadAvgOrderByAggregateInput
    _max?: CmsForumThreadMaxOrderByAggregateInput
    _min?: CmsForumThreadMinOrderByAggregateInput
    _sum?: CmsForumThreadSumOrderByAggregateInput
  }

  export type CmsForumThreadScalarWhereWithAggregatesInput = {
    AND?: CmsForumThreadScalarWhereWithAggregatesInput | CmsForumThreadScalarWhereWithAggregatesInput[]
    OR?: CmsForumThreadScalarWhereWithAggregatesInput[]
    NOT?: CmsForumThreadScalarWhereWithAggregatesInput | CmsForumThreadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsForumThread"> | number
    type?: IntWithAggregatesFilter<"CmsForumThread"> | number
    title?: StringWithAggregatesFilter<"CmsForumThread"> | string
    author?: StringWithAggregatesFilter<"CmsForumThread"> | string
    date?: StringWithAggregatesFilter<"CmsForumThread"> | string
    lastpostAuthor?: StringWithAggregatesFilter<"CmsForumThread"> | string
    lastpostDate?: StringWithAggregatesFilter<"CmsForumThread"> | string
    posts?: IntWithAggregatesFilter<"CmsForumThread"> | number
    mainPost?: IntWithAggregatesFilter<"CmsForumThread"> | number
    statut?: IntWithAggregatesFilter<"CmsForumThread"> | number
    categorie?: BoolWithAggregatesFilter<"CmsForumThread"> | boolean
    views?: IntWithAggregatesFilter<"CmsForumThread"> | number
  }

  export type CmsFourmCategoryWhereInput = {
    AND?: CmsFourmCategoryWhereInput | CmsFourmCategoryWhereInput[]
    OR?: CmsFourmCategoryWhereInput[]
    NOT?: CmsFourmCategoryWhereInput | CmsFourmCategoryWhereInput[]
    id?: IntFilter<"CmsFourmCategory"> | number
    name?: StringNullableFilter<"CmsFourmCategory"> | string | null
    order?: IntFilter<"CmsFourmCategory"> | number
  }

  export type CmsFourmCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    order?: SortOrder
  }

  export type CmsFourmCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CmsFourmCategoryWhereInput | CmsFourmCategoryWhereInput[]
    OR?: CmsFourmCategoryWhereInput[]
    NOT?: CmsFourmCategoryWhereInput | CmsFourmCategoryWhereInput[]
    name?: StringNullableFilter<"CmsFourmCategory"> | string | null
    order?: IntFilter<"CmsFourmCategory"> | number
  }, "id">

  export type CmsFourmCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: CmsFourmCategoryCountOrderByAggregateInput
    _avg?: CmsFourmCategoryAvgOrderByAggregateInput
    _max?: CmsFourmCategoryMaxOrderByAggregateInput
    _min?: CmsFourmCategoryMinOrderByAggregateInput
    _sum?: CmsFourmCategorySumOrderByAggregateInput
  }

  export type CmsFourmCategoryScalarWhereWithAggregatesInput = {
    AND?: CmsFourmCategoryScalarWhereWithAggregatesInput | CmsFourmCategoryScalarWhereWithAggregatesInput[]
    OR?: CmsFourmCategoryScalarWhereWithAggregatesInput[]
    NOT?: CmsFourmCategoryScalarWhereWithAggregatesInput | CmsFourmCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsFourmCategory"> | number
    name?: StringNullableWithAggregatesFilter<"CmsFourmCategory"> | string | null
    order?: IntWithAggregatesFilter<"CmsFourmCategory"> | number
  }

  export type CmsMailConfirmWhereInput = {
    AND?: CmsMailConfirmWhereInput | CmsMailConfirmWhereInput[]
    OR?: CmsMailConfirmWhereInput[]
    NOT?: CmsMailConfirmWhereInput | CmsMailConfirmWhereInput[]
    userId?: IntFilter<"CmsMailConfirm"> | number
    codedevalidation?: StringFilter<"CmsMailConfirm"> | string
    email?: StringFilter<"CmsMailConfirm"> | string
    temps?: IntFilter<"CmsMailConfirm"> | number
    type?: IntFilter<"CmsMailConfirm"> | number
  }

  export type CmsMailConfirmOrderByWithRelationInput = {
    userId?: SortOrder
    codedevalidation?: SortOrder
    email?: SortOrder
    temps?: SortOrder
    type?: SortOrder
  }

  export type CmsMailConfirmWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: CmsMailConfirmWhereInput | CmsMailConfirmWhereInput[]
    OR?: CmsMailConfirmWhereInput[]
    NOT?: CmsMailConfirmWhereInput | CmsMailConfirmWhereInput[]
    codedevalidation?: StringFilter<"CmsMailConfirm"> | string
    email?: StringFilter<"CmsMailConfirm"> | string
    temps?: IntFilter<"CmsMailConfirm"> | number
    type?: IntFilter<"CmsMailConfirm"> | number
  }, "userId" | "userId">

  export type CmsMailConfirmOrderByWithAggregationInput = {
    userId?: SortOrder
    codedevalidation?: SortOrder
    email?: SortOrder
    temps?: SortOrder
    type?: SortOrder
    _count?: CmsMailConfirmCountOrderByAggregateInput
    _avg?: CmsMailConfirmAvgOrderByAggregateInput
    _max?: CmsMailConfirmMaxOrderByAggregateInput
    _min?: CmsMailConfirmMinOrderByAggregateInput
    _sum?: CmsMailConfirmSumOrderByAggregateInput
  }

  export type CmsMailConfirmScalarWhereWithAggregatesInput = {
    AND?: CmsMailConfirmScalarWhereWithAggregatesInput | CmsMailConfirmScalarWhereWithAggregatesInput[]
    OR?: CmsMailConfirmScalarWhereWithAggregatesInput[]
    NOT?: CmsMailConfirmScalarWhereWithAggregatesInput | CmsMailConfirmScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"CmsMailConfirm"> | number
    codedevalidation?: StringWithAggregatesFilter<"CmsMailConfirm"> | string
    email?: StringWithAggregatesFilter<"CmsMailConfirm"> | string
    temps?: IntWithAggregatesFilter<"CmsMailConfirm"> | number
    type?: IntWithAggregatesFilter<"CmsMailConfirm"> | number
  }

  export type CmsMailForgotWhereInput = {
    AND?: CmsMailForgotWhereInput | CmsMailForgotWhereInput[]
    OR?: CmsMailForgotWhereInput[]
    NOT?: CmsMailForgotWhereInput | CmsMailForgotWhereInput[]
    id?: IntFilter<"CmsMailForgot"> | number
    pass?: StringFilter<"CmsMailForgot"> | string
    email?: StringFilter<"CmsMailForgot"> | string
    expire?: IntFilter<"CmsMailForgot"> | number
    users?: StringFilter<"CmsMailForgot"> | string
  }

  export type CmsMailForgotOrderByWithRelationInput = {
    id?: SortOrder
    pass?: SortOrder
    email?: SortOrder
    expire?: SortOrder
    users?: SortOrder
  }

  export type CmsMailForgotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CmsMailForgotWhereInput | CmsMailForgotWhereInput[]
    OR?: CmsMailForgotWhereInput[]
    NOT?: CmsMailForgotWhereInput | CmsMailForgotWhereInput[]
    pass?: StringFilter<"CmsMailForgot"> | string
    email?: StringFilter<"CmsMailForgot"> | string
    expire?: IntFilter<"CmsMailForgot"> | number
    users?: StringFilter<"CmsMailForgot"> | string
  }, "id">

  export type CmsMailForgotOrderByWithAggregationInput = {
    id?: SortOrder
    pass?: SortOrder
    email?: SortOrder
    expire?: SortOrder
    users?: SortOrder
    _count?: CmsMailForgotCountOrderByAggregateInput
    _avg?: CmsMailForgotAvgOrderByAggregateInput
    _max?: CmsMailForgotMaxOrderByAggregateInput
    _min?: CmsMailForgotMinOrderByAggregateInput
    _sum?: CmsMailForgotSumOrderByAggregateInput
  }

  export type CmsMailForgotScalarWhereWithAggregatesInput = {
    AND?: CmsMailForgotScalarWhereWithAggregatesInput | CmsMailForgotScalarWhereWithAggregatesInput[]
    OR?: CmsMailForgotScalarWhereWithAggregatesInput[]
    NOT?: CmsMailForgotScalarWhereWithAggregatesInput | CmsMailForgotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsMailForgot"> | number
    pass?: StringWithAggregatesFilter<"CmsMailForgot"> | string
    email?: StringWithAggregatesFilter<"CmsMailForgot"> | string
    expire?: IntWithAggregatesFilter<"CmsMailForgot"> | number
    users?: StringWithAggregatesFilter<"CmsMailForgot"> | string
  }

  export type CmsNewsWhereInput = {
    AND?: CmsNewsWhereInput | CmsNewsWhereInput[]
    OR?: CmsNewsWhereInput[]
    NOT?: CmsNewsWhereInput | CmsNewsWhereInput[]
    id?: IntFilter<"CmsNews"> | number
    title?: StringFilter<"CmsNews"> | string
    categoryId?: IntFilter<"CmsNews"> | number
    topstoryImage?: StringFilter<"CmsNews"> | string
    body?: StringFilter<"CmsNews"> | string
    snippet?: StringFilter<"CmsNews"> | string
    timestamp?: IntFilter<"CmsNews"> | number
    author?: StringFilter<"CmsNews"> | string
    authorId?: IntFilter<"CmsNews"> | number
    link_keyword?: StringFilter<"CmsNews"> | string
  }

  export type CmsNewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    topstoryImage?: SortOrder
    body?: SortOrder
    snippet?: SortOrder
    timestamp?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    link_keyword?: SortOrder
  }

  export type CmsNewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    timestamp?: number
    AND?: CmsNewsWhereInput | CmsNewsWhereInput[]
    OR?: CmsNewsWhereInput[]
    NOT?: CmsNewsWhereInput | CmsNewsWhereInput[]
    title?: StringFilter<"CmsNews"> | string
    categoryId?: IntFilter<"CmsNews"> | number
    topstoryImage?: StringFilter<"CmsNews"> | string
    body?: StringFilter<"CmsNews"> | string
    snippet?: StringFilter<"CmsNews"> | string
    author?: StringFilter<"CmsNews"> | string
    authorId?: IntFilter<"CmsNews"> | number
    link_keyword?: StringFilter<"CmsNews"> | string
  }, "id" | "timestamp">

  export type CmsNewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    topstoryImage?: SortOrder
    body?: SortOrder
    snippet?: SortOrder
    timestamp?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    link_keyword?: SortOrder
    _count?: CmsNewsCountOrderByAggregateInput
    _avg?: CmsNewsAvgOrderByAggregateInput
    _max?: CmsNewsMaxOrderByAggregateInput
    _min?: CmsNewsMinOrderByAggregateInput
    _sum?: CmsNewsSumOrderByAggregateInput
  }

  export type CmsNewsScalarWhereWithAggregatesInput = {
    AND?: CmsNewsScalarWhereWithAggregatesInput | CmsNewsScalarWhereWithAggregatesInput[]
    OR?: CmsNewsScalarWhereWithAggregatesInput[]
    NOT?: CmsNewsScalarWhereWithAggregatesInput | CmsNewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsNews"> | number
    title?: StringWithAggregatesFilter<"CmsNews"> | string
    categoryId?: IntWithAggregatesFilter<"CmsNews"> | number
    topstoryImage?: StringWithAggregatesFilter<"CmsNews"> | string
    body?: StringWithAggregatesFilter<"CmsNews"> | string
    snippet?: StringWithAggregatesFilter<"CmsNews"> | string
    timestamp?: IntWithAggregatesFilter<"CmsNews"> | number
    author?: StringWithAggregatesFilter<"CmsNews"> | string
    authorId?: IntWithAggregatesFilter<"CmsNews"> | number
    link_keyword?: StringWithAggregatesFilter<"CmsNews"> | string
  }

  export type CmsStaffWhereInput = {
    AND?: CmsStaffWhereInput | CmsStaffWhereInput[]
    OR?: CmsStaffWhereInput[]
    NOT?: CmsStaffWhereInput | CmsStaffWhereInput[]
    id?: IntFilter<"CmsStaff"> | number
    userid?: IntFilter<"CmsStaff"> | number
    rank?: IntFilter<"CmsStaff"> | number
    function?: StringNullableFilter<"CmsStaff"> | string | null
    socialInsta?: StringNullableFilter<"CmsStaff"> | string | null
    socialDiscord?: StringNullableFilter<"CmsStaff"> | string | null
  }

  export type CmsStaffOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
    function?: SortOrderInput | SortOrder
    socialInsta?: SortOrderInput | SortOrder
    socialDiscord?: SortOrderInput | SortOrder
  }

  export type CmsStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CmsStaffWhereInput | CmsStaffWhereInput[]
    OR?: CmsStaffWhereInput[]
    NOT?: CmsStaffWhereInput | CmsStaffWhereInput[]
    userid?: IntFilter<"CmsStaff"> | number
    rank?: IntFilter<"CmsStaff"> | number
    function?: StringNullableFilter<"CmsStaff"> | string | null
    socialInsta?: StringNullableFilter<"CmsStaff"> | string | null
    socialDiscord?: StringNullableFilter<"CmsStaff"> | string | null
  }, "id">

  export type CmsStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
    function?: SortOrderInput | SortOrder
    socialInsta?: SortOrderInput | SortOrder
    socialDiscord?: SortOrderInput | SortOrder
    _count?: CmsStaffCountOrderByAggregateInput
    _avg?: CmsStaffAvgOrderByAggregateInput
    _max?: CmsStaffMaxOrderByAggregateInput
    _min?: CmsStaffMinOrderByAggregateInput
    _sum?: CmsStaffSumOrderByAggregateInput
  }

  export type CmsStaffScalarWhereWithAggregatesInput = {
    AND?: CmsStaffScalarWhereWithAggregatesInput | CmsStaffScalarWhereWithAggregatesInput[]
    OR?: CmsStaffScalarWhereWithAggregatesInput[]
    NOT?: CmsStaffScalarWhereWithAggregatesInput | CmsStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsStaff"> | number
    userid?: IntWithAggregatesFilter<"CmsStaff"> | number
    rank?: IntWithAggregatesFilter<"CmsStaff"> | number
    function?: StringNullableWithAggregatesFilter<"CmsStaff"> | string | null
    socialInsta?: StringNullableWithAggregatesFilter<"CmsStaff"> | string | null
    socialDiscord?: StringNullableWithAggregatesFilter<"CmsStaff"> | string | null
  }

  export type CmsStaffProtectWhereInput = {
    AND?: CmsStaffProtectWhereInput | CmsStaffProtectWhereInput[]
    OR?: CmsStaffProtectWhereInput[]
    NOT?: CmsStaffProtectWhereInput | CmsStaffProtectWhereInput[]
    id?: IntFilter<"CmsStaffProtect"> | number
    ip?: StringNullableFilter<"CmsStaffProtect"> | string | null
    username?: StringFilter<"CmsStaffProtect"> | string
    hide?: BoolFilter<"CmsStaffProtect"> | boolean
  }

  export type CmsStaffProtectOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrderInput | SortOrder
    username?: SortOrder
    hide?: SortOrder
  }

  export type CmsStaffProtectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CmsStaffProtectWhereInput | CmsStaffProtectWhereInput[]
    OR?: CmsStaffProtectWhereInput[]
    NOT?: CmsStaffProtectWhereInput | CmsStaffProtectWhereInput[]
    ip?: StringNullableFilter<"CmsStaffProtect"> | string | null
    username?: StringFilter<"CmsStaffProtect"> | string
    hide?: BoolFilter<"CmsStaffProtect"> | boolean
  }, "id">

  export type CmsStaffProtectOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrderInput | SortOrder
    username?: SortOrder
    hide?: SortOrder
    _count?: CmsStaffProtectCountOrderByAggregateInput
    _avg?: CmsStaffProtectAvgOrderByAggregateInput
    _max?: CmsStaffProtectMaxOrderByAggregateInput
    _min?: CmsStaffProtectMinOrderByAggregateInput
    _sum?: CmsStaffProtectSumOrderByAggregateInput
  }

  export type CmsStaffProtectScalarWhereWithAggregatesInput = {
    AND?: CmsStaffProtectScalarWhereWithAggregatesInput | CmsStaffProtectScalarWhereWithAggregatesInput[]
    OR?: CmsStaffProtectScalarWhereWithAggregatesInput[]
    NOT?: CmsStaffProtectScalarWhereWithAggregatesInput | CmsStaffProtectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CmsStaffProtect"> | number
    ip?: StringNullableWithAggregatesFilter<"CmsStaffProtect"> | string | null
    username?: StringWithAggregatesFilter<"CmsStaffProtect"> | string
    hide?: BoolWithAggregatesFilter<"CmsStaffProtect"> | boolean
  }

  export type EmulatorAchievementWhereInput = {
    AND?: EmulatorAchievementWhereInput | EmulatorAchievementWhereInput[]
    OR?: EmulatorAchievementWhereInput[]
    NOT?: EmulatorAchievementWhereInput | EmulatorAchievementWhereInput[]
    id?: IntFilter<"EmulatorAchievement"> | number
    groupName?: StringFilter<"EmulatorAchievement"> | string
    category?: StringFilter<"EmulatorAchievement"> | string
    level?: IntFilter<"EmulatorAchievement"> | number
    rewardPixels?: IntFilter<"EmulatorAchievement"> | number
    rewardPoints?: IntFilter<"EmulatorAchievement"> | number
    progressNeeded?: IntFilter<"EmulatorAchievement"> | number
  }

  export type EmulatorAchievementOrderByWithRelationInput = {
    id?: SortOrder
    groupName?: SortOrder
    category?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
  }

  export type EmulatorAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorAchievementWhereInput | EmulatorAchievementWhereInput[]
    OR?: EmulatorAchievementWhereInput[]
    NOT?: EmulatorAchievementWhereInput | EmulatorAchievementWhereInput[]
    groupName?: StringFilter<"EmulatorAchievement"> | string
    category?: StringFilter<"EmulatorAchievement"> | string
    level?: IntFilter<"EmulatorAchievement"> | number
    rewardPixels?: IntFilter<"EmulatorAchievement"> | number
    rewardPoints?: IntFilter<"EmulatorAchievement"> | number
    progressNeeded?: IntFilter<"EmulatorAchievement"> | number
  }, "id">

  export type EmulatorAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    groupName?: SortOrder
    category?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
    _count?: EmulatorAchievementCountOrderByAggregateInput
    _avg?: EmulatorAchievementAvgOrderByAggregateInput
    _max?: EmulatorAchievementMaxOrderByAggregateInput
    _min?: EmulatorAchievementMinOrderByAggregateInput
    _sum?: EmulatorAchievementSumOrderByAggregateInput
  }

  export type EmulatorAchievementScalarWhereWithAggregatesInput = {
    AND?: EmulatorAchievementScalarWhereWithAggregatesInput | EmulatorAchievementScalarWhereWithAggregatesInput[]
    OR?: EmulatorAchievementScalarWhereWithAggregatesInput[]
    NOT?: EmulatorAchievementScalarWhereWithAggregatesInput | EmulatorAchievementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorAchievement"> | number
    groupName?: StringWithAggregatesFilter<"EmulatorAchievement"> | string
    category?: StringWithAggregatesFilter<"EmulatorAchievement"> | string
    level?: IntWithAggregatesFilter<"EmulatorAchievement"> | number
    rewardPixels?: IntWithAggregatesFilter<"EmulatorAchievement"> | number
    rewardPoints?: IntWithAggregatesFilter<"EmulatorAchievement"> | number
    progressNeeded?: IntWithAggregatesFilter<"EmulatorAchievement"> | number
  }

  export type EmulatorBannerWhereInput = {
    AND?: EmulatorBannerWhereInput | EmulatorBannerWhereInput[]
    OR?: EmulatorBannerWhereInput[]
    NOT?: EmulatorBannerWhereInput | EmulatorBannerWhereInput[]
    id?: IntFilter<"EmulatorBanner"> | number
    haveLayer?: BoolFilter<"EmulatorBanner"> | boolean
    canTrade?: BoolFilter<"EmulatorBanner"> | boolean
  }

  export type EmulatorBannerOrderByWithRelationInput = {
    id?: SortOrder
    haveLayer?: SortOrder
    canTrade?: SortOrder
  }

  export type EmulatorBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorBannerWhereInput | EmulatorBannerWhereInput[]
    OR?: EmulatorBannerWhereInput[]
    NOT?: EmulatorBannerWhereInput | EmulatorBannerWhereInput[]
    haveLayer?: BoolFilter<"EmulatorBanner"> | boolean
    canTrade?: BoolFilter<"EmulatorBanner"> | boolean
  }, "id">

  export type EmulatorBannerOrderByWithAggregationInput = {
    id?: SortOrder
    haveLayer?: SortOrder
    canTrade?: SortOrder
    _count?: EmulatorBannerCountOrderByAggregateInput
    _avg?: EmulatorBannerAvgOrderByAggregateInput
    _max?: EmulatorBannerMaxOrderByAggregateInput
    _min?: EmulatorBannerMinOrderByAggregateInput
    _sum?: EmulatorBannerSumOrderByAggregateInput
  }

  export type EmulatorBannerScalarWhereWithAggregatesInput = {
    AND?: EmulatorBannerScalarWhereWithAggregatesInput | EmulatorBannerScalarWhereWithAggregatesInput[]
    OR?: EmulatorBannerScalarWhereWithAggregatesInput[]
    NOT?: EmulatorBannerScalarWhereWithAggregatesInput | EmulatorBannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorBanner"> | number
    haveLayer?: BoolWithAggregatesFilter<"EmulatorBanner"> | boolean
    canTrade?: BoolWithAggregatesFilter<"EmulatorBanner"> | boolean
  }

  export type EmulatorChatStyleWhereInput = {
    AND?: EmulatorChatStyleWhereInput | EmulatorChatStyleWhereInput[]
    OR?: EmulatorChatStyleWhereInput[]
    NOT?: EmulatorChatStyleWhereInput | EmulatorChatStyleWhereInput[]
    id?: IntFilter<"EmulatorChatStyle"> | number
    name?: StringFilter<"EmulatorChatStyle"> | string
    requiredRight?: StringFilter<"EmulatorChatStyle"> | string
  }

  export type EmulatorChatStyleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    requiredRight?: SortOrder
  }

  export type EmulatorChatStyleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorChatStyleWhereInput | EmulatorChatStyleWhereInput[]
    OR?: EmulatorChatStyleWhereInput[]
    NOT?: EmulatorChatStyleWhereInput | EmulatorChatStyleWhereInput[]
    name?: StringFilter<"EmulatorChatStyle"> | string
    requiredRight?: StringFilter<"EmulatorChatStyle"> | string
  }, "id">

  export type EmulatorChatStyleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    requiredRight?: SortOrder
    _count?: EmulatorChatStyleCountOrderByAggregateInput
    _avg?: EmulatorChatStyleAvgOrderByAggregateInput
    _max?: EmulatorChatStyleMaxOrderByAggregateInput
    _min?: EmulatorChatStyleMinOrderByAggregateInput
    _sum?: EmulatorChatStyleSumOrderByAggregateInput
  }

  export type EmulatorChatStyleScalarWhereWithAggregatesInput = {
    AND?: EmulatorChatStyleScalarWhereWithAggregatesInput | EmulatorChatStyleScalarWhereWithAggregatesInput[]
    OR?: EmulatorChatStyleScalarWhereWithAggregatesInput[]
    NOT?: EmulatorChatStyleScalarWhereWithAggregatesInput | EmulatorChatStyleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorChatStyle"> | number
    name?: StringWithAggregatesFilter<"EmulatorChatStyle"> | string
    requiredRight?: StringWithAggregatesFilter<"EmulatorChatStyle"> | string
  }

  export type EmulatorCommandWhereInput = {
    AND?: EmulatorCommandWhereInput | EmulatorCommandWhereInput[]
    OR?: EmulatorCommandWhereInput[]
    NOT?: EmulatorCommandWhereInput | EmulatorCommandWhereInput[]
    id?: IntFilter<"EmulatorCommand"> | number
    input?: StringFilter<"EmulatorCommand"> | string
    minrank?: IntFilter<"EmulatorCommand"> | number
    descriptionFr?: StringNullableFilter<"EmulatorCommand"> | string | null
    descriptionEn?: StringNullableFilter<"EmulatorCommand"> | string | null
    descriptionBr?: StringNullableFilter<"EmulatorCommand"> | string | null
  }

  export type EmulatorCommandOrderByWithRelationInput = {
    id?: SortOrder
    input?: SortOrder
    minrank?: SortOrder
    descriptionFr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    descriptionBr?: SortOrderInput | SortOrder
  }

  export type EmulatorCommandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorCommandWhereInput | EmulatorCommandWhereInput[]
    OR?: EmulatorCommandWhereInput[]
    NOT?: EmulatorCommandWhereInput | EmulatorCommandWhereInput[]
    input?: StringFilter<"EmulatorCommand"> | string
    minrank?: IntFilter<"EmulatorCommand"> | number
    descriptionFr?: StringNullableFilter<"EmulatorCommand"> | string | null
    descriptionEn?: StringNullableFilter<"EmulatorCommand"> | string | null
    descriptionBr?: StringNullableFilter<"EmulatorCommand"> | string | null
  }, "id">

  export type EmulatorCommandOrderByWithAggregationInput = {
    id?: SortOrder
    input?: SortOrder
    minrank?: SortOrder
    descriptionFr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    descriptionBr?: SortOrderInput | SortOrder
    _count?: EmulatorCommandCountOrderByAggregateInput
    _avg?: EmulatorCommandAvgOrderByAggregateInput
    _max?: EmulatorCommandMaxOrderByAggregateInput
    _min?: EmulatorCommandMinOrderByAggregateInput
    _sum?: EmulatorCommandSumOrderByAggregateInput
  }

  export type EmulatorCommandScalarWhereWithAggregatesInput = {
    AND?: EmulatorCommandScalarWhereWithAggregatesInput | EmulatorCommandScalarWhereWithAggregatesInput[]
    OR?: EmulatorCommandScalarWhereWithAggregatesInput[]
    NOT?: EmulatorCommandScalarWhereWithAggregatesInput | EmulatorCommandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorCommand"> | number
    input?: StringWithAggregatesFilter<"EmulatorCommand"> | string
    minrank?: IntWithAggregatesFilter<"EmulatorCommand"> | number
    descriptionFr?: StringNullableWithAggregatesFilter<"EmulatorCommand"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"EmulatorCommand"> | string | null
    descriptionBr?: StringNullableWithAggregatesFilter<"EmulatorCommand"> | string | null
  }

  export type EmulatorCommandPetWhereInput = {
    AND?: EmulatorCommandPetWhereInput | EmulatorCommandPetWhereInput[]
    OR?: EmulatorCommandPetWhereInput[]
    NOT?: EmulatorCommandPetWhereInput | EmulatorCommandPetWhereInput[]
    id?: IntFilter<"EmulatorCommandPet"> | number
    command?: StringFilter<"EmulatorCommandPet"> | string
  }

  export type EmulatorCommandPetOrderByWithRelationInput = {
    id?: SortOrder
    command?: SortOrder
  }

  export type EmulatorCommandPetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorCommandPetWhereInput | EmulatorCommandPetWhereInput[]
    OR?: EmulatorCommandPetWhereInput[]
    NOT?: EmulatorCommandPetWhereInput | EmulatorCommandPetWhereInput[]
    command?: StringFilter<"EmulatorCommandPet"> | string
  }, "id">

  export type EmulatorCommandPetOrderByWithAggregationInput = {
    id?: SortOrder
    command?: SortOrder
    _count?: EmulatorCommandPetCountOrderByAggregateInput
    _avg?: EmulatorCommandPetAvgOrderByAggregateInput
    _max?: EmulatorCommandPetMaxOrderByAggregateInput
    _min?: EmulatorCommandPetMinOrderByAggregateInput
    _sum?: EmulatorCommandPetSumOrderByAggregateInput
  }

  export type EmulatorCommandPetScalarWhereWithAggregatesInput = {
    AND?: EmulatorCommandPetScalarWhereWithAggregatesInput | EmulatorCommandPetScalarWhereWithAggregatesInput[]
    OR?: EmulatorCommandPetScalarWhereWithAggregatesInput[]
    NOT?: EmulatorCommandPetScalarWhereWithAggregatesInput | EmulatorCommandPetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorCommandPet"> | number
    command?: StringWithAggregatesFilter<"EmulatorCommandPet"> | string
  }

  export type EmulatorEffectWhereInput = {
    AND?: EmulatorEffectWhereInput | EmulatorEffectWhereInput[]
    OR?: EmulatorEffectWhereInput[]
    NOT?: EmulatorEffectWhereInput | EmulatorEffectWhereInput[]
    id?: IntFilter<"EmulatorEffect"> | number
    onlyStaff?: BoolFilter<"EmulatorEffect"> | boolean
  }

  export type EmulatorEffectOrderByWithRelationInput = {
    id?: SortOrder
    onlyStaff?: SortOrder
  }

  export type EmulatorEffectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorEffectWhereInput | EmulatorEffectWhereInput[]
    OR?: EmulatorEffectWhereInput[]
    NOT?: EmulatorEffectWhereInput | EmulatorEffectWhereInput[]
    onlyStaff?: BoolFilter<"EmulatorEffect"> | boolean
  }, "id">

  export type EmulatorEffectOrderByWithAggregationInput = {
    id?: SortOrder
    onlyStaff?: SortOrder
    _count?: EmulatorEffectCountOrderByAggregateInput
    _avg?: EmulatorEffectAvgOrderByAggregateInput
    _max?: EmulatorEffectMaxOrderByAggregateInput
    _min?: EmulatorEffectMinOrderByAggregateInput
    _sum?: EmulatorEffectSumOrderByAggregateInput
  }

  export type EmulatorEffectScalarWhereWithAggregatesInput = {
    AND?: EmulatorEffectScalarWhereWithAggregatesInput | EmulatorEffectScalarWhereWithAggregatesInput[]
    OR?: EmulatorEffectScalarWhereWithAggregatesInput[]
    NOT?: EmulatorEffectScalarWhereWithAggregatesInput | EmulatorEffectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorEffect"> | number
    onlyStaff?: BoolWithAggregatesFilter<"EmulatorEffect"> | boolean
  }

  export type EmulatorLandingviewWhereInput = {
    AND?: EmulatorLandingviewWhereInput | EmulatorLandingviewWhereInput[]
    OR?: EmulatorLandingviewWhereInput[]
    NOT?: EmulatorLandingviewWhereInput | EmulatorLandingviewWhereInput[]
    index?: IntFilter<"EmulatorLandingview"> | number
    header?: StringFilter<"EmulatorLandingview"> | string
    body?: StringFilter<"EmulatorLandingview"> | string
    button?: StringFilter<"EmulatorLandingview"> | string
    inGamePromo?: BoolFilter<"EmulatorLandingview"> | boolean
    specialAction?: StringFilter<"EmulatorLandingview"> | string
    image?: StringFilter<"EmulatorLandingview"> | string
    enabled?: BoolFilter<"EmulatorLandingview"> | boolean
  }

  export type EmulatorLandingviewOrderByWithRelationInput = {
    index?: SortOrder
    header?: SortOrder
    body?: SortOrder
    button?: SortOrder
    inGamePromo?: SortOrder
    specialAction?: SortOrder
    image?: SortOrder
    enabled?: SortOrder
  }

  export type EmulatorLandingviewWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: EmulatorLandingviewWhereInput | EmulatorLandingviewWhereInput[]
    OR?: EmulatorLandingviewWhereInput[]
    NOT?: EmulatorLandingviewWhereInput | EmulatorLandingviewWhereInput[]
    header?: StringFilter<"EmulatorLandingview"> | string
    body?: StringFilter<"EmulatorLandingview"> | string
    button?: StringFilter<"EmulatorLandingview"> | string
    inGamePromo?: BoolFilter<"EmulatorLandingview"> | boolean
    specialAction?: StringFilter<"EmulatorLandingview"> | string
    image?: StringFilter<"EmulatorLandingview"> | string
    enabled?: BoolFilter<"EmulatorLandingview"> | boolean
  }, "index">

  export type EmulatorLandingviewOrderByWithAggregationInput = {
    index?: SortOrder
    header?: SortOrder
    body?: SortOrder
    button?: SortOrder
    inGamePromo?: SortOrder
    specialAction?: SortOrder
    image?: SortOrder
    enabled?: SortOrder
    _count?: EmulatorLandingviewCountOrderByAggregateInput
    _avg?: EmulatorLandingviewAvgOrderByAggregateInput
    _max?: EmulatorLandingviewMaxOrderByAggregateInput
    _min?: EmulatorLandingviewMinOrderByAggregateInput
    _sum?: EmulatorLandingviewSumOrderByAggregateInput
  }

  export type EmulatorLandingviewScalarWhereWithAggregatesInput = {
    AND?: EmulatorLandingviewScalarWhereWithAggregatesInput | EmulatorLandingviewScalarWhereWithAggregatesInput[]
    OR?: EmulatorLandingviewScalarWhereWithAggregatesInput[]
    NOT?: EmulatorLandingviewScalarWhereWithAggregatesInput | EmulatorLandingviewScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"EmulatorLandingview"> | number
    header?: StringWithAggregatesFilter<"EmulatorLandingview"> | string
    body?: StringWithAggregatesFilter<"EmulatorLandingview"> | string
    button?: StringWithAggregatesFilter<"EmulatorLandingview"> | string
    inGamePromo?: BoolWithAggregatesFilter<"EmulatorLandingview"> | boolean
    specialAction?: StringWithAggregatesFilter<"EmulatorLandingview"> | string
    image?: StringWithAggregatesFilter<"EmulatorLandingview"> | string
    enabled?: BoolWithAggregatesFilter<"EmulatorLandingview"> | boolean
  }

  export type EmulatorLootboxWhereInput = {
    AND?: EmulatorLootboxWhereInput | EmulatorLootboxWhereInput[]
    OR?: EmulatorLootboxWhereInput[]
    NOT?: EmulatorLootboxWhereInput | EmulatorLootboxWhereInput[]
    id?: IntFilter<"EmulatorLootbox"> | number
    interactionType?: StringFilter<"EmulatorLootbox"> | string
    probability?: IntFilter<"EmulatorLootbox"> | number
    pageId?: IntFilter<"EmulatorLootbox"> | number
    itemId?: IntFilter<"EmulatorLootbox"> | number
    category?: EnumEmulatorLootboxCategoryFilter<"EmulatorLootbox"> | $Enums.EmulatorLootboxCategory
    amount?: IntFilter<"EmulatorLootbox"> | number
  }

  export type EmulatorLootboxOrderByWithRelationInput = {
    id?: SortOrder
    interactionType?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
  }

  export type EmulatorLootboxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorLootboxWhereInput | EmulatorLootboxWhereInput[]
    OR?: EmulatorLootboxWhereInput[]
    NOT?: EmulatorLootboxWhereInput | EmulatorLootboxWhereInput[]
    interactionType?: StringFilter<"EmulatorLootbox"> | string
    probability?: IntFilter<"EmulatorLootbox"> | number
    pageId?: IntFilter<"EmulatorLootbox"> | number
    itemId?: IntFilter<"EmulatorLootbox"> | number
    category?: EnumEmulatorLootboxCategoryFilter<"EmulatorLootbox"> | $Enums.EmulatorLootboxCategory
    amount?: IntFilter<"EmulatorLootbox"> | number
  }, "id">

  export type EmulatorLootboxOrderByWithAggregationInput = {
    id?: SortOrder
    interactionType?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    _count?: EmulatorLootboxCountOrderByAggregateInput
    _avg?: EmulatorLootboxAvgOrderByAggregateInput
    _max?: EmulatorLootboxMaxOrderByAggregateInput
    _min?: EmulatorLootboxMinOrderByAggregateInput
    _sum?: EmulatorLootboxSumOrderByAggregateInput
  }

  export type EmulatorLootboxScalarWhereWithAggregatesInput = {
    AND?: EmulatorLootboxScalarWhereWithAggregatesInput | EmulatorLootboxScalarWhereWithAggregatesInput[]
    OR?: EmulatorLootboxScalarWhereWithAggregatesInput[]
    NOT?: EmulatorLootboxScalarWhereWithAggregatesInput | EmulatorLootboxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorLootbox"> | number
    interactionType?: StringWithAggregatesFilter<"EmulatorLootbox"> | string
    probability?: IntWithAggregatesFilter<"EmulatorLootbox"> | number
    pageId?: IntWithAggregatesFilter<"EmulatorLootbox"> | number
    itemId?: IntWithAggregatesFilter<"EmulatorLootbox"> | number
    category?: EnumEmulatorLootboxCategoryWithAggregatesFilter<"EmulatorLootbox"> | $Enums.EmulatorLootboxCategory
    amount?: IntWithAggregatesFilter<"EmulatorLootbox"> | number
  }

  export type EmulatorPermissionWhereInput = {
    AND?: EmulatorPermissionWhereInput | EmulatorPermissionWhereInput[]
    OR?: EmulatorPermissionWhereInput[]
    NOT?: EmulatorPermissionWhereInput | EmulatorPermissionWhereInput[]
    id?: IntFilter<"EmulatorPermission"> | number
    rank?: IntFilter<"EmulatorPermission"> | number
    permission?: StringFilter<"EmulatorPermission"> | string
  }

  export type EmulatorPermissionOrderByWithRelationInput = {
    id?: SortOrder
    rank?: SortOrder
    permission?: SortOrder
  }

  export type EmulatorPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorPermissionWhereInput | EmulatorPermissionWhereInput[]
    OR?: EmulatorPermissionWhereInput[]
    NOT?: EmulatorPermissionWhereInput | EmulatorPermissionWhereInput[]
    rank?: IntFilter<"EmulatorPermission"> | number
    permission?: StringFilter<"EmulatorPermission"> | string
  }, "id">

  export type EmulatorPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    rank?: SortOrder
    permission?: SortOrder
    _count?: EmulatorPermissionCountOrderByAggregateInput
    _avg?: EmulatorPermissionAvgOrderByAggregateInput
    _max?: EmulatorPermissionMaxOrderByAggregateInput
    _min?: EmulatorPermissionMinOrderByAggregateInput
    _sum?: EmulatorPermissionSumOrderByAggregateInput
  }

  export type EmulatorPermissionScalarWhereWithAggregatesInput = {
    AND?: EmulatorPermissionScalarWhereWithAggregatesInput | EmulatorPermissionScalarWhereWithAggregatesInput[]
    OR?: EmulatorPermissionScalarWhereWithAggregatesInput[]
    NOT?: EmulatorPermissionScalarWhereWithAggregatesInput | EmulatorPermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorPermission"> | number
    rank?: IntWithAggregatesFilter<"EmulatorPermission"> | number
    permission?: StringWithAggregatesFilter<"EmulatorPermission"> | string
  }

  export type EmulatorQuestWhereInput = {
    AND?: EmulatorQuestWhereInput | EmulatorQuestWhereInput[]
    OR?: EmulatorQuestWhereInput[]
    NOT?: EmulatorQuestWhereInput | EmulatorQuestWhereInput[]
    id?: IntFilter<"EmulatorQuest"> | number
    category?: StringFilter<"EmulatorQuest"> | string
    seriesNumber?: IntFilter<"EmulatorQuest"> | number
    goalType?: IntFilter<"EmulatorQuest"> | number
    goalData?: IntFilter<"EmulatorQuest"> | number
    name?: StringFilter<"EmulatorQuest"> | string
    reward?: IntFilter<"EmulatorQuest"> | number
    dataBit?: StringFilter<"EmulatorQuest"> | string
  }

  export type EmulatorQuestOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    name?: SortOrder
    reward?: SortOrder
    dataBit?: SortOrder
  }

  export type EmulatorQuestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorQuestWhereInput | EmulatorQuestWhereInput[]
    OR?: EmulatorQuestWhereInput[]
    NOT?: EmulatorQuestWhereInput | EmulatorQuestWhereInput[]
    category?: StringFilter<"EmulatorQuest"> | string
    seriesNumber?: IntFilter<"EmulatorQuest"> | number
    goalType?: IntFilter<"EmulatorQuest"> | number
    goalData?: IntFilter<"EmulatorQuest"> | number
    name?: StringFilter<"EmulatorQuest"> | string
    reward?: IntFilter<"EmulatorQuest"> | number
    dataBit?: StringFilter<"EmulatorQuest"> | string
  }, "id">

  export type EmulatorQuestOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    name?: SortOrder
    reward?: SortOrder
    dataBit?: SortOrder
    _count?: EmulatorQuestCountOrderByAggregateInput
    _avg?: EmulatorQuestAvgOrderByAggregateInput
    _max?: EmulatorQuestMaxOrderByAggregateInput
    _min?: EmulatorQuestMinOrderByAggregateInput
    _sum?: EmulatorQuestSumOrderByAggregateInput
  }

  export type EmulatorQuestScalarWhereWithAggregatesInput = {
    AND?: EmulatorQuestScalarWhereWithAggregatesInput | EmulatorQuestScalarWhereWithAggregatesInput[]
    OR?: EmulatorQuestScalarWhereWithAggregatesInput[]
    NOT?: EmulatorQuestScalarWhereWithAggregatesInput | EmulatorQuestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorQuest"> | number
    category?: StringWithAggregatesFilter<"EmulatorQuest"> | string
    seriesNumber?: IntWithAggregatesFilter<"EmulatorQuest"> | number
    goalType?: IntWithAggregatesFilter<"EmulatorQuest"> | number
    goalData?: IntWithAggregatesFilter<"EmulatorQuest"> | number
    name?: StringWithAggregatesFilter<"EmulatorQuest"> | string
    reward?: IntWithAggregatesFilter<"EmulatorQuest"> | number
    dataBit?: StringWithAggregatesFilter<"EmulatorQuest"> | string
  }

  export type EmulatorSettingWhereInput = {
    AND?: EmulatorSettingWhereInput | EmulatorSettingWhereInput[]
    OR?: EmulatorSettingWhereInput[]
    NOT?: EmulatorSettingWhereInput | EmulatorSettingWhereInput[]
    id?: IntFilter<"EmulatorSetting"> | number
    key?: StringFilter<"EmulatorSetting"> | string
    value?: StringFilter<"EmulatorSetting"> | string
  }

  export type EmulatorSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type EmulatorSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorSettingWhereInput | EmulatorSettingWhereInput[]
    OR?: EmulatorSettingWhereInput[]
    NOT?: EmulatorSettingWhereInput | EmulatorSettingWhereInput[]
    key?: StringFilter<"EmulatorSetting"> | string
    value?: StringFilter<"EmulatorSetting"> | string
  }, "id">

  export type EmulatorSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: EmulatorSettingCountOrderByAggregateInput
    _avg?: EmulatorSettingAvgOrderByAggregateInput
    _max?: EmulatorSettingMaxOrderByAggregateInput
    _min?: EmulatorSettingMinOrderByAggregateInput
    _sum?: EmulatorSettingSumOrderByAggregateInput
  }

  export type EmulatorSettingScalarWhereWithAggregatesInput = {
    AND?: EmulatorSettingScalarWhereWithAggregatesInput | EmulatorSettingScalarWhereWithAggregatesInput[]
    OR?: EmulatorSettingScalarWhereWithAggregatesInput[]
    NOT?: EmulatorSettingScalarWhereWithAggregatesInput | EmulatorSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorSetting"> | number
    key?: StringWithAggregatesFilter<"EmulatorSetting"> | string
    value?: StringWithAggregatesFilter<"EmulatorSetting"> | string
  }

  export type EmulatorStatsWhereInput = {
    AND?: EmulatorStatsWhereInput | EmulatorStatsWhereInput[]
    OR?: EmulatorStatsWhereInput[]
    NOT?: EmulatorStatsWhereInput | EmulatorStatsWhereInput[]
    id?: IntFilter<"EmulatorStats"> | number
    online?: IntFilter<"EmulatorStats"> | number
    time?: IntFilter<"EmulatorStats"> | number
    room?: IntFilter<"EmulatorStats"> | number
  }

  export type EmulatorStatsOrderByWithRelationInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
  }

  export type EmulatorStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    time?: number
    AND?: EmulatorStatsWhereInput | EmulatorStatsWhereInput[]
    OR?: EmulatorStatsWhereInput[]
    NOT?: EmulatorStatsWhereInput | EmulatorStatsWhereInput[]
    online?: IntFilter<"EmulatorStats"> | number
    room?: IntFilter<"EmulatorStats"> | number
  }, "id" | "time">

  export type EmulatorStatsOrderByWithAggregationInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
    _count?: EmulatorStatsCountOrderByAggregateInput
    _avg?: EmulatorStatsAvgOrderByAggregateInput
    _max?: EmulatorStatsMaxOrderByAggregateInput
    _min?: EmulatorStatsMinOrderByAggregateInput
    _sum?: EmulatorStatsSumOrderByAggregateInput
  }

  export type EmulatorStatsScalarWhereWithAggregatesInput = {
    AND?: EmulatorStatsScalarWhereWithAggregatesInput | EmulatorStatsScalarWhereWithAggregatesInput[]
    OR?: EmulatorStatsScalarWhereWithAggregatesInput[]
    NOT?: EmulatorStatsScalarWhereWithAggregatesInput | EmulatorStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorStats"> | number
    online?: IntWithAggregatesFilter<"EmulatorStats"> | number
    time?: IntWithAggregatesFilter<"EmulatorStats"> | number
    room?: IntWithAggregatesFilter<"EmulatorStats"> | number
  }

  export type EmulatorStatusWhereInput = {
    AND?: EmulatorStatusWhereInput | EmulatorStatusWhereInput[]
    OR?: EmulatorStatusWhereInput[]
    NOT?: EmulatorStatusWhereInput | EmulatorStatusWhereInput[]
    id?: IntFilter<"EmulatorStatus"> | number
    status?: IntFilter<"EmulatorStatus"> | number
    usersOnline?: IntFilter<"EmulatorStatus"> | number
    roomsLoaded?: IntFilter<"EmulatorStatus"> | number
    stamp?: IntFilter<"EmulatorStatus"> | number
    userpeak?: IntFilter<"EmulatorStatus"> | number
  }

  export type EmulatorStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
  }

  export type EmulatorStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmulatorStatusWhereInput | EmulatorStatusWhereInput[]
    OR?: EmulatorStatusWhereInput[]
    NOT?: EmulatorStatusWhereInput | EmulatorStatusWhereInput[]
    status?: IntFilter<"EmulatorStatus"> | number
    usersOnline?: IntFilter<"EmulatorStatus"> | number
    roomsLoaded?: IntFilter<"EmulatorStatus"> | number
    stamp?: IntFilter<"EmulatorStatus"> | number
    userpeak?: IntFilter<"EmulatorStatus"> | number
  }, "id">

  export type EmulatorStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
    _count?: EmulatorStatusCountOrderByAggregateInput
    _avg?: EmulatorStatusAvgOrderByAggregateInput
    _max?: EmulatorStatusMaxOrderByAggregateInput
    _min?: EmulatorStatusMinOrderByAggregateInput
    _sum?: EmulatorStatusSumOrderByAggregateInput
  }

  export type EmulatorStatusScalarWhereWithAggregatesInput = {
    AND?: EmulatorStatusScalarWhereWithAggregatesInput | EmulatorStatusScalarWhereWithAggregatesInput[]
    OR?: EmulatorStatusScalarWhereWithAggregatesInput[]
    NOT?: EmulatorStatusScalarWhereWithAggregatesInput | EmulatorStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorStatus"> | number
    status?: IntWithAggregatesFilter<"EmulatorStatus"> | number
    usersOnline?: IntWithAggregatesFilter<"EmulatorStatus"> | number
    roomsLoaded?: IntWithAggregatesFilter<"EmulatorStatus"> | number
    stamp?: IntWithAggregatesFilter<"EmulatorStatus"> | number
    userpeak?: IntWithAggregatesFilter<"EmulatorStatus"> | number
  }

  export type EmulatorTextWhereInput = {
    AND?: EmulatorTextWhereInput | EmulatorTextWhereInput[]
    OR?: EmulatorTextWhereInput[]
    NOT?: EmulatorTextWhereInput | EmulatorTextWhereInput[]
    id?: IntFilter<"EmulatorText"> | number
    identifiant?: StringFilter<"EmulatorText"> | string
    valueFr?: StringNullableFilter<"EmulatorText"> | string | null
    valueEn?: StringNullableFilter<"EmulatorText"> | string | null
    valueBr?: StringNullableFilter<"EmulatorText"> | string | null
  }

  export type EmulatorTextOrderByWithRelationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    valueFr?: SortOrderInput | SortOrder
    valueEn?: SortOrderInput | SortOrder
    valueBr?: SortOrderInput | SortOrder
  }

  export type EmulatorTextWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    identifiant?: string
    AND?: EmulatorTextWhereInput | EmulatorTextWhereInput[]
    OR?: EmulatorTextWhereInput[]
    NOT?: EmulatorTextWhereInput | EmulatorTextWhereInput[]
    valueFr?: StringNullableFilter<"EmulatorText"> | string | null
    valueEn?: StringNullableFilter<"EmulatorText"> | string | null
    valueBr?: StringNullableFilter<"EmulatorText"> | string | null
  }, "id" | "identifiant">

  export type EmulatorTextOrderByWithAggregationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    valueFr?: SortOrderInput | SortOrder
    valueEn?: SortOrderInput | SortOrder
    valueBr?: SortOrderInput | SortOrder
    _count?: EmulatorTextCountOrderByAggregateInput
    _avg?: EmulatorTextAvgOrderByAggregateInput
    _max?: EmulatorTextMaxOrderByAggregateInput
    _min?: EmulatorTextMinOrderByAggregateInput
    _sum?: EmulatorTextSumOrderByAggregateInput
  }

  export type EmulatorTextScalarWhereWithAggregatesInput = {
    AND?: EmulatorTextScalarWhereWithAggregatesInput | EmulatorTextScalarWhereWithAggregatesInput[]
    OR?: EmulatorTextScalarWhereWithAggregatesInput[]
    NOT?: EmulatorTextScalarWhereWithAggregatesInput | EmulatorTextScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmulatorText"> | number
    identifiant?: StringWithAggregatesFilter<"EmulatorText"> | string
    valueFr?: StringNullableWithAggregatesFilter<"EmulatorText"> | string | null
    valueEn?: StringNullableWithAggregatesFilter<"EmulatorText"> | string | null
    valueBr?: StringNullableWithAggregatesFilter<"EmulatorText"> | string | null
  }

  export type GuildWhereInput = {
    AND?: GuildWhereInput | GuildWhereInput[]
    OR?: GuildWhereInput[]
    NOT?: GuildWhereInput | GuildWhereInput[]
    id?: IntFilter<"Guild"> | number
    name?: StringFilter<"Guild"> | string
    desc?: StringFilter<"Guild"> | string
    badge?: StringFilter<"Guild"> | string
    ownerId?: IntFilter<"Guild"> | number
    created?: IntFilter<"Guild"> | number
    roomId?: IntFilter<"Guild"> | number
    state?: IntFilter<"Guild"> | number
    colour1?: IntFilter<"Guild"> | number
    colour2?: IntFilter<"Guild"> | number
    admindeco?: BoolFilter<"Guild"> | boolean
    hasForum?: BoolFilter<"Guild"> | boolean
  }

  export type GuildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    badge?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
    admindeco?: SortOrder
    hasForum?: SortOrder
  }

  export type GuildWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GuildWhereInput | GuildWhereInput[]
    OR?: GuildWhereInput[]
    NOT?: GuildWhereInput | GuildWhereInput[]
    name?: StringFilter<"Guild"> | string
    desc?: StringFilter<"Guild"> | string
    badge?: StringFilter<"Guild"> | string
    ownerId?: IntFilter<"Guild"> | number
    created?: IntFilter<"Guild"> | number
    roomId?: IntFilter<"Guild"> | number
    state?: IntFilter<"Guild"> | number
    colour1?: IntFilter<"Guild"> | number
    colour2?: IntFilter<"Guild"> | number
    admindeco?: BoolFilter<"Guild"> | boolean
    hasForum?: BoolFilter<"Guild"> | boolean
  }, "id">

  export type GuildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    badge?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
    admindeco?: SortOrder
    hasForum?: SortOrder
    _count?: GuildCountOrderByAggregateInput
    _avg?: GuildAvgOrderByAggregateInput
    _max?: GuildMaxOrderByAggregateInput
    _min?: GuildMinOrderByAggregateInput
    _sum?: GuildSumOrderByAggregateInput
  }

  export type GuildScalarWhereWithAggregatesInput = {
    AND?: GuildScalarWhereWithAggregatesInput | GuildScalarWhereWithAggregatesInput[]
    OR?: GuildScalarWhereWithAggregatesInput[]
    NOT?: GuildScalarWhereWithAggregatesInput | GuildScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Guild"> | number
    name?: StringWithAggregatesFilter<"Guild"> | string
    desc?: StringWithAggregatesFilter<"Guild"> | string
    badge?: StringWithAggregatesFilter<"Guild"> | string
    ownerId?: IntWithAggregatesFilter<"Guild"> | number
    created?: IntWithAggregatesFilter<"Guild"> | number
    roomId?: IntWithAggregatesFilter<"Guild"> | number
    state?: IntWithAggregatesFilter<"Guild"> | number
    colour1?: IntWithAggregatesFilter<"Guild"> | number
    colour2?: IntWithAggregatesFilter<"Guild"> | number
    admindeco?: BoolWithAggregatesFilter<"Guild"> | boolean
    hasForum?: BoolWithAggregatesFilter<"Guild"> | boolean
  }

  export type GuildItemWhereInput = {
    AND?: GuildItemWhereInput | GuildItemWhereInput[]
    OR?: GuildItemWhereInput[]
    NOT?: GuildItemWhereInput | GuildItemWhereInput[]
    id?: IntFilter<"GuildItem"> | number
    type?: EnumGuildItemTypeFilter<"GuildItem"> | $Enums.GuildItemType
    firstvalue?: StringFilter<"GuildItem"> | string
    secondvalue?: StringFilter<"GuildItem"> | string
    enabled?: BoolFilter<"GuildItem"> | boolean
  }

  export type GuildItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    firstvalue?: SortOrder
    secondvalue?: SortOrder
    enabled?: SortOrder
  }

  export type GuildItemWhereUniqueInput = Prisma.AtLeast<{
    id_type?: GuildItemIdTypeCompoundUniqueInput
    AND?: GuildItemWhereInput | GuildItemWhereInput[]
    OR?: GuildItemWhereInput[]
    NOT?: GuildItemWhereInput | GuildItemWhereInput[]
    id?: IntFilter<"GuildItem"> | number
    type?: EnumGuildItemTypeFilter<"GuildItem"> | $Enums.GuildItemType
    firstvalue?: StringFilter<"GuildItem"> | string
    secondvalue?: StringFilter<"GuildItem"> | string
    enabled?: BoolFilter<"GuildItem"> | boolean
  }, "id_type">

  export type GuildItemOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    firstvalue?: SortOrder
    secondvalue?: SortOrder
    enabled?: SortOrder
    _count?: GuildItemCountOrderByAggregateInput
    _avg?: GuildItemAvgOrderByAggregateInput
    _max?: GuildItemMaxOrderByAggregateInput
    _min?: GuildItemMinOrderByAggregateInput
    _sum?: GuildItemSumOrderByAggregateInput
  }

  export type GuildItemScalarWhereWithAggregatesInput = {
    AND?: GuildItemScalarWhereWithAggregatesInput | GuildItemScalarWhereWithAggregatesInput[]
    OR?: GuildItemScalarWhereWithAggregatesInput[]
    NOT?: GuildItemScalarWhereWithAggregatesInput | GuildItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GuildItem"> | number
    type?: EnumGuildItemTypeWithAggregatesFilter<"GuildItem"> | $Enums.GuildItemType
    firstvalue?: StringWithAggregatesFilter<"GuildItem"> | string
    secondvalue?: StringWithAggregatesFilter<"GuildItem"> | string
    enabled?: BoolWithAggregatesFilter<"GuildItem"> | boolean
  }

  export type GuildMembershipWhereInput = {
    AND?: GuildMembershipWhereInput | GuildMembershipWhereInput[]
    OR?: GuildMembershipWhereInput[]
    NOT?: GuildMembershipWhereInput | GuildMembershipWhereInput[]
    groupId?: IntFilter<"GuildMembership"> | number
    userId?: IntFilter<"GuildMembership"> | number
    rank?: IntFilter<"GuildMembership"> | number
  }

  export type GuildMembershipOrderByWithRelationInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
  }

  export type GuildMembershipWhereUniqueInput = Prisma.AtLeast<{
    groupId_userId?: GuildMembershipGroupIdUserIdCompoundUniqueInput
    AND?: GuildMembershipWhereInput | GuildMembershipWhereInput[]
    OR?: GuildMembershipWhereInput[]
    NOT?: GuildMembershipWhereInput | GuildMembershipWhereInput[]
    groupId?: IntFilter<"GuildMembership"> | number
    userId?: IntFilter<"GuildMembership"> | number
    rank?: IntFilter<"GuildMembership"> | number
  }, "groupId_userId">

  export type GuildMembershipOrderByWithAggregationInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
    _count?: GuildMembershipCountOrderByAggregateInput
    _avg?: GuildMembershipAvgOrderByAggregateInput
    _max?: GuildMembershipMaxOrderByAggregateInput
    _min?: GuildMembershipMinOrderByAggregateInput
    _sum?: GuildMembershipSumOrderByAggregateInput
  }

  export type GuildMembershipScalarWhereWithAggregatesInput = {
    AND?: GuildMembershipScalarWhereWithAggregatesInput | GuildMembershipScalarWhereWithAggregatesInput[]
    OR?: GuildMembershipScalarWhereWithAggregatesInput[]
    NOT?: GuildMembershipScalarWhereWithAggregatesInput | GuildMembershipScalarWhereWithAggregatesInput[]
    groupId?: IntWithAggregatesFilter<"GuildMembership"> | number
    userId?: IntWithAggregatesFilter<"GuildMembership"> | number
    rank?: IntWithAggregatesFilter<"GuildMembership"> | number
  }

  export type GuildRequestWhereInput = {
    AND?: GuildRequestWhereInput | GuildRequestWhereInput[]
    OR?: GuildRequestWhereInput[]
    NOT?: GuildRequestWhereInput | GuildRequestWhereInput[]
    groupId?: IntFilter<"GuildRequest"> | number
    userId?: IntFilter<"GuildRequest"> | number
  }

  export type GuildRequestOrderByWithRelationInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type GuildRequestWhereUniqueInput = Prisma.AtLeast<{
    groupId_userId?: GuildRequestGroupIdUserIdCompoundUniqueInput
    AND?: GuildRequestWhereInput | GuildRequestWhereInput[]
    OR?: GuildRequestWhereInput[]
    NOT?: GuildRequestWhereInput | GuildRequestWhereInput[]
    groupId?: IntFilter<"GuildRequest"> | number
    userId?: IntFilter<"GuildRequest"> | number
  }, "groupId_userId">

  export type GuildRequestOrderByWithAggregationInput = {
    groupId?: SortOrder
    userId?: SortOrder
    _count?: GuildRequestCountOrderByAggregateInput
    _avg?: GuildRequestAvgOrderByAggregateInput
    _max?: GuildRequestMaxOrderByAggregateInput
    _min?: GuildRequestMinOrderByAggregateInput
    _sum?: GuildRequestSumOrderByAggregateInput
  }

  export type GuildRequestScalarWhereWithAggregatesInput = {
    AND?: GuildRequestScalarWhereWithAggregatesInput | GuildRequestScalarWhereWithAggregatesInput[]
    OR?: GuildRequestScalarWhereWithAggregatesInput[]
    NOT?: GuildRequestScalarWhereWithAggregatesInput | GuildRequestScalarWhereWithAggregatesInput[]
    groupId?: IntWithAggregatesFilter<"GuildRequest"> | number
    userId?: IntWithAggregatesFilter<"GuildRequest"> | number
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    userId?: IntFilter<"Item"> | number
    roomId?: IntFilter<"Item"> | number
    baseItem?: IntFilter<"Item"> | number
    extraData?: StringNullableFilter<"Item"> | string | null
    x?: IntFilter<"Item"> | number
    y?: IntFilter<"Item"> | number
    z?: FloatFilter<"Item"> | number
    rot?: IntFilter<"Item"> | number
    wallPos?: StringNullableFilter<"Item"> | string | null
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    extraData?: SortOrderInput | SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
    wallPos?: SortOrderInput | SortOrder
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    userId?: IntFilter<"Item"> | number
    roomId?: IntFilter<"Item"> | number
    baseItem?: IntFilter<"Item"> | number
    extraData?: StringNullableFilter<"Item"> | string | null
    x?: IntFilter<"Item"> | number
    y?: IntFilter<"Item"> | number
    z?: FloatFilter<"Item"> | number
    rot?: IntFilter<"Item"> | number
    wallPos?: StringNullableFilter<"Item"> | string | null
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    extraData?: SortOrderInput | SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
    wallPos?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    userId?: IntWithAggregatesFilter<"Item"> | number
    roomId?: IntWithAggregatesFilter<"Item"> | number
    baseItem?: IntWithAggregatesFilter<"Item"> | number
    extraData?: StringNullableWithAggregatesFilter<"Item"> | string | null
    x?: IntWithAggregatesFilter<"Item"> | number
    y?: IntWithAggregatesFilter<"Item"> | number
    z?: FloatWithAggregatesFilter<"Item"> | number
    rot?: IntWithAggregatesFilter<"Item"> | number
    wallPos?: StringNullableWithAggregatesFilter<"Item"> | string | null
  }

  export type ItemBaseWhereInput = {
    AND?: ItemBaseWhereInput | ItemBaseWhereInput[]
    OR?: ItemBaseWhereInput[]
    NOT?: ItemBaseWhereInput | ItemBaseWhereInput[]
    id?: IntFilter<"ItemBase"> | number
    itemName?: StringFilter<"ItemBase"> | string
    type?: EnumItemBaseTypeFilter<"ItemBase"> | $Enums.ItemBaseType
    width?: IntFilter<"ItemBase"> | number
    length?: IntFilter<"ItemBase"> | number
    stackHeight?: FloatFilter<"ItemBase"> | number
    canStack?: BoolFilter<"ItemBase"> | boolean
    canSit?: BoolFilter<"ItemBase"> | boolean
    isWalkable?: BoolFilter<"ItemBase"> | boolean
    spriteId?: IntFilter<"ItemBase"> | number
    allowRecycle?: BoolFilter<"ItemBase"> | boolean
    allowTrade?: BoolFilter<"ItemBase"> | boolean
    allowMarketplaceSell?: BoolFilter<"ItemBase"> | boolean
    allowGift?: BoolFilter<"ItemBase"> | boolean
    allowInventoryStack?: BoolFilter<"ItemBase"> | boolean
    interactionType?: StringFilter<"ItemBase"> | string
    interactionModesCount?: IntFilter<"ItemBase"> | number
    vendingIds?: StringFilter<"ItemBase"> | string
    heightAdjustable?: StringFilter<"ItemBase"> | string
    effectId?: IntFilter<"ItemBase"> | number
    isRare?: BoolFilter<"ItemBase"> | boolean
    rarityLevel?: IntFilter<"ItemBase"> | number
    itemStat?: XOR<ItemStatNullableRelationFilter, ItemStatWhereInput> | null
    logLootbox?: LogLootboxListRelationFilter
    catalogItem?: CatalogItemListRelationFilter
  }

  export type ItemBaseOrderByWithRelationInput = {
    id?: SortOrder
    itemName?: SortOrder
    type?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    canStack?: SortOrder
    canSit?: SortOrder
    isWalkable?: SortOrder
    spriteId?: SortOrder
    allowRecycle?: SortOrder
    allowTrade?: SortOrder
    allowMarketplaceSell?: SortOrder
    allowGift?: SortOrder
    allowInventoryStack?: SortOrder
    interactionType?: SortOrder
    interactionModesCount?: SortOrder
    vendingIds?: SortOrder
    heightAdjustable?: SortOrder
    effectId?: SortOrder
    isRare?: SortOrder
    rarityLevel?: SortOrder
    itemStat?: ItemStatOrderByWithRelationInput
    logLootbox?: LogLootboxOrderByRelationAggregateInput
    catalogItem?: CatalogItemOrderByRelationAggregateInput
  }

  export type ItemBaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemBaseWhereInput | ItemBaseWhereInput[]
    OR?: ItemBaseWhereInput[]
    NOT?: ItemBaseWhereInput | ItemBaseWhereInput[]
    itemName?: StringFilter<"ItemBase"> | string
    type?: EnumItemBaseTypeFilter<"ItemBase"> | $Enums.ItemBaseType
    width?: IntFilter<"ItemBase"> | number
    length?: IntFilter<"ItemBase"> | number
    stackHeight?: FloatFilter<"ItemBase"> | number
    canStack?: BoolFilter<"ItemBase"> | boolean
    canSit?: BoolFilter<"ItemBase"> | boolean
    isWalkable?: BoolFilter<"ItemBase"> | boolean
    spriteId?: IntFilter<"ItemBase"> | number
    allowRecycle?: BoolFilter<"ItemBase"> | boolean
    allowTrade?: BoolFilter<"ItemBase"> | boolean
    allowMarketplaceSell?: BoolFilter<"ItemBase"> | boolean
    allowGift?: BoolFilter<"ItemBase"> | boolean
    allowInventoryStack?: BoolFilter<"ItemBase"> | boolean
    interactionType?: StringFilter<"ItemBase"> | string
    interactionModesCount?: IntFilter<"ItemBase"> | number
    vendingIds?: StringFilter<"ItemBase"> | string
    heightAdjustable?: StringFilter<"ItemBase"> | string
    effectId?: IntFilter<"ItemBase"> | number
    isRare?: BoolFilter<"ItemBase"> | boolean
    rarityLevel?: IntFilter<"ItemBase"> | number
    itemStat?: XOR<ItemStatNullableRelationFilter, ItemStatWhereInput> | null
    logLootbox?: LogLootboxListRelationFilter
    catalogItem?: CatalogItemListRelationFilter
  }, "id">

  export type ItemBaseOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrder
    type?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    canStack?: SortOrder
    canSit?: SortOrder
    isWalkable?: SortOrder
    spriteId?: SortOrder
    allowRecycle?: SortOrder
    allowTrade?: SortOrder
    allowMarketplaceSell?: SortOrder
    allowGift?: SortOrder
    allowInventoryStack?: SortOrder
    interactionType?: SortOrder
    interactionModesCount?: SortOrder
    vendingIds?: SortOrder
    heightAdjustable?: SortOrder
    effectId?: SortOrder
    isRare?: SortOrder
    rarityLevel?: SortOrder
    _count?: ItemBaseCountOrderByAggregateInput
    _avg?: ItemBaseAvgOrderByAggregateInput
    _max?: ItemBaseMaxOrderByAggregateInput
    _min?: ItemBaseMinOrderByAggregateInput
    _sum?: ItemBaseSumOrderByAggregateInput
  }

  export type ItemBaseScalarWhereWithAggregatesInput = {
    AND?: ItemBaseScalarWhereWithAggregatesInput | ItemBaseScalarWhereWithAggregatesInput[]
    OR?: ItemBaseScalarWhereWithAggregatesInput[]
    NOT?: ItemBaseScalarWhereWithAggregatesInput | ItemBaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemBase"> | number
    itemName?: StringWithAggregatesFilter<"ItemBase"> | string
    type?: EnumItemBaseTypeWithAggregatesFilter<"ItemBase"> | $Enums.ItemBaseType
    width?: IntWithAggregatesFilter<"ItemBase"> | number
    length?: IntWithAggregatesFilter<"ItemBase"> | number
    stackHeight?: FloatWithAggregatesFilter<"ItemBase"> | number
    canStack?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    canSit?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    isWalkable?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    spriteId?: IntWithAggregatesFilter<"ItemBase"> | number
    allowRecycle?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    allowTrade?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    allowMarketplaceSell?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    allowGift?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    allowInventoryStack?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    interactionType?: StringWithAggregatesFilter<"ItemBase"> | string
    interactionModesCount?: IntWithAggregatesFilter<"ItemBase"> | number
    vendingIds?: StringWithAggregatesFilter<"ItemBase"> | string
    heightAdjustable?: StringWithAggregatesFilter<"ItemBase"> | string
    effectId?: IntWithAggregatesFilter<"ItemBase"> | number
    isRare?: BoolWithAggregatesFilter<"ItemBase"> | boolean
    rarityLevel?: IntWithAggregatesFilter<"ItemBase"> | number
  }

  export type ItemLimitedWhereInput = {
    AND?: ItemLimitedWhereInput | ItemLimitedWhereInput[]
    OR?: ItemLimitedWhereInput[]
    NOT?: ItemLimitedWhereInput | ItemLimitedWhereInput[]
    itemId?: IntFilter<"ItemLimited"> | number
    limitedNumber?: IntFilter<"ItemLimited"> | number
    limitedStack?: IntFilter<"ItemLimited"> | number
  }

  export type ItemLimitedOrderByWithRelationInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type ItemLimitedWhereUniqueInput = Prisma.AtLeast<{
    itemId?: number
    AND?: ItemLimitedWhereInput | ItemLimitedWhereInput[]
    OR?: ItemLimitedWhereInput[]
    NOT?: ItemLimitedWhereInput | ItemLimitedWhereInput[]
    limitedNumber?: IntFilter<"ItemLimited"> | number
    limitedStack?: IntFilter<"ItemLimited"> | number
  }, "itemId" | "itemId">

  export type ItemLimitedOrderByWithAggregationInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
    _count?: ItemLimitedCountOrderByAggregateInput
    _avg?: ItemLimitedAvgOrderByAggregateInput
    _max?: ItemLimitedMaxOrderByAggregateInput
    _min?: ItemLimitedMinOrderByAggregateInput
    _sum?: ItemLimitedSumOrderByAggregateInput
  }

  export type ItemLimitedScalarWhereWithAggregatesInput = {
    AND?: ItemLimitedScalarWhereWithAggregatesInput | ItemLimitedScalarWhereWithAggregatesInput[]
    OR?: ItemLimitedScalarWhereWithAggregatesInput[]
    NOT?: ItemLimitedScalarWhereWithAggregatesInput | ItemLimitedScalarWhereWithAggregatesInput[]
    itemId?: IntWithAggregatesFilter<"ItemLimited"> | number
    limitedNumber?: IntWithAggregatesFilter<"ItemLimited"> | number
    limitedStack?: IntWithAggregatesFilter<"ItemLimited"> | number
  }

  export type ItemMoodlightWhereInput = {
    AND?: ItemMoodlightWhereInput | ItemMoodlightWhereInput[]
    OR?: ItemMoodlightWhereInput[]
    NOT?: ItemMoodlightWhereInput | ItemMoodlightWhereInput[]
    itemId?: IntFilter<"ItemMoodlight"> | number
    enabled?: BoolFilter<"ItemMoodlight"> | boolean
    currentPreset?: IntFilter<"ItemMoodlight"> | number
    presetOne?: StringFilter<"ItemMoodlight"> | string
    presetTwo?: StringFilter<"ItemMoodlight"> | string
    presetThree?: StringFilter<"ItemMoodlight"> | string
  }

  export type ItemMoodlightOrderByWithRelationInput = {
    itemId?: SortOrder
    enabled?: SortOrder
    currentPreset?: SortOrder
    presetOne?: SortOrder
    presetTwo?: SortOrder
    presetThree?: SortOrder
  }

  export type ItemMoodlightWhereUniqueInput = Prisma.AtLeast<{
    itemId?: number
    AND?: ItemMoodlightWhereInput | ItemMoodlightWhereInput[]
    OR?: ItemMoodlightWhereInput[]
    NOT?: ItemMoodlightWhereInput | ItemMoodlightWhereInput[]
    enabled?: BoolFilter<"ItemMoodlight"> | boolean
    currentPreset?: IntFilter<"ItemMoodlight"> | number
    presetOne?: StringFilter<"ItemMoodlight"> | string
    presetTwo?: StringFilter<"ItemMoodlight"> | string
    presetThree?: StringFilter<"ItemMoodlight"> | string
  }, "itemId" | "itemId">

  export type ItemMoodlightOrderByWithAggregationInput = {
    itemId?: SortOrder
    enabled?: SortOrder
    currentPreset?: SortOrder
    presetOne?: SortOrder
    presetTwo?: SortOrder
    presetThree?: SortOrder
    _count?: ItemMoodlightCountOrderByAggregateInput
    _avg?: ItemMoodlightAvgOrderByAggregateInput
    _max?: ItemMoodlightMaxOrderByAggregateInput
    _min?: ItemMoodlightMinOrderByAggregateInput
    _sum?: ItemMoodlightSumOrderByAggregateInput
  }

  export type ItemMoodlightScalarWhereWithAggregatesInput = {
    AND?: ItemMoodlightScalarWhereWithAggregatesInput | ItemMoodlightScalarWhereWithAggregatesInput[]
    OR?: ItemMoodlightScalarWhereWithAggregatesInput[]
    NOT?: ItemMoodlightScalarWhereWithAggregatesInput | ItemMoodlightScalarWhereWithAggregatesInput[]
    itemId?: IntWithAggregatesFilter<"ItemMoodlight"> | number
    enabled?: BoolWithAggregatesFilter<"ItemMoodlight"> | boolean
    currentPreset?: IntWithAggregatesFilter<"ItemMoodlight"> | number
    presetOne?: StringWithAggregatesFilter<"ItemMoodlight"> | string
    presetTwo?: StringWithAggregatesFilter<"ItemMoodlight"> | string
    presetThree?: StringWithAggregatesFilter<"ItemMoodlight"> | string
  }

  export type ItemPresentWhereInput = {
    AND?: ItemPresentWhereInput | ItemPresentWhereInput[]
    OR?: ItemPresentWhereInput[]
    NOT?: ItemPresentWhereInput | ItemPresentWhereInput[]
    itemId?: IntFilter<"ItemPresent"> | number
    baseId?: IntFilter<"ItemPresent"> | number
    extraData?: StringNullableFilter<"ItemPresent"> | string | null
  }

  export type ItemPresentOrderByWithRelationInput = {
    itemId?: SortOrder
    baseId?: SortOrder
    extraData?: SortOrderInput | SortOrder
  }

  export type ItemPresentWhereUniqueInput = Prisma.AtLeast<{
    itemId?: number
    AND?: ItemPresentWhereInput | ItemPresentWhereInput[]
    OR?: ItemPresentWhereInput[]
    NOT?: ItemPresentWhereInput | ItemPresentWhereInput[]
    baseId?: IntFilter<"ItemPresent"> | number
    extraData?: StringNullableFilter<"ItemPresent"> | string | null
  }, "itemId" | "itemId">

  export type ItemPresentOrderByWithAggregationInput = {
    itemId?: SortOrder
    baseId?: SortOrder
    extraData?: SortOrderInput | SortOrder
    _count?: ItemPresentCountOrderByAggregateInput
    _avg?: ItemPresentAvgOrderByAggregateInput
    _max?: ItemPresentMaxOrderByAggregateInput
    _min?: ItemPresentMinOrderByAggregateInput
    _sum?: ItemPresentSumOrderByAggregateInput
  }

  export type ItemPresentScalarWhereWithAggregatesInput = {
    AND?: ItemPresentScalarWhereWithAggregatesInput | ItemPresentScalarWhereWithAggregatesInput[]
    OR?: ItemPresentScalarWhereWithAggregatesInput[]
    NOT?: ItemPresentScalarWhereWithAggregatesInput | ItemPresentScalarWhereWithAggregatesInput[]
    itemId?: IntWithAggregatesFilter<"ItemPresent"> | number
    baseId?: IntWithAggregatesFilter<"ItemPresent"> | number
    extraData?: StringNullableWithAggregatesFilter<"ItemPresent"> | string | null
  }

  export type ItemStatWhereInput = {
    AND?: ItemStatWhereInput | ItemStatWhereInput[]
    OR?: ItemStatWhereInput[]
    NOT?: ItemStatWhereInput | ItemStatWhereInput[]
    baseId?: IntFilter<"ItemStat"> | number
    amount?: IntFilter<"ItemStat"> | number
    itemBase?: XOR<ItemBaseRelationFilter, ItemBaseWhereInput>
  }

  export type ItemStatOrderByWithRelationInput = {
    baseId?: SortOrder
    amount?: SortOrder
    itemBase?: ItemBaseOrderByWithRelationInput
  }

  export type ItemStatWhereUniqueInput = Prisma.AtLeast<{
    baseId?: number
    AND?: ItemStatWhereInput | ItemStatWhereInput[]
    OR?: ItemStatWhereInput[]
    NOT?: ItemStatWhereInput | ItemStatWhereInput[]
    amount?: IntFilter<"ItemStat"> | number
    itemBase?: XOR<ItemBaseRelationFilter, ItemBaseWhereInput>
  }, "baseId" | "baseId">

  export type ItemStatOrderByWithAggregationInput = {
    baseId?: SortOrder
    amount?: SortOrder
    _count?: ItemStatCountOrderByAggregateInput
    _avg?: ItemStatAvgOrderByAggregateInput
    _max?: ItemStatMaxOrderByAggregateInput
    _min?: ItemStatMinOrderByAggregateInput
    _sum?: ItemStatSumOrderByAggregateInput
  }

  export type ItemStatScalarWhereWithAggregatesInput = {
    AND?: ItemStatScalarWhereWithAggregatesInput | ItemStatScalarWhereWithAggregatesInput[]
    OR?: ItemStatScalarWhereWithAggregatesInput[]
    NOT?: ItemStatScalarWhereWithAggregatesInput | ItemStatScalarWhereWithAggregatesInput[]
    baseId?: IntWithAggregatesFilter<"ItemStat"> | number
    amount?: IntWithAggregatesFilter<"ItemStat"> | number
  }

  export type ItemTeleportWhereInput = {
    AND?: ItemTeleportWhereInput | ItemTeleportWhereInput[]
    OR?: ItemTeleportWhereInput[]
    NOT?: ItemTeleportWhereInput | ItemTeleportWhereInput[]
    teleOneId?: IntFilter<"ItemTeleport"> | number
    teleTwoId?: IntFilter<"ItemTeleport"> | number
  }

  export type ItemTeleportOrderByWithRelationInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
  }

  export type ItemTeleportWhereUniqueInput = Prisma.AtLeast<{
    teleOneId_teleTwoId?: ItemTeleportTeleOneIdTeleTwoIdCompoundUniqueInput
    AND?: ItemTeleportWhereInput | ItemTeleportWhereInput[]
    OR?: ItemTeleportWhereInput[]
    NOT?: ItemTeleportWhereInput | ItemTeleportWhereInput[]
    teleOneId?: IntFilter<"ItemTeleport"> | number
    teleTwoId?: IntFilter<"ItemTeleport"> | number
  }, "teleOneId_teleTwoId">

  export type ItemTeleportOrderByWithAggregationInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
    _count?: ItemTeleportCountOrderByAggregateInput
    _avg?: ItemTeleportAvgOrderByAggregateInput
    _max?: ItemTeleportMaxOrderByAggregateInput
    _min?: ItemTeleportMinOrderByAggregateInput
    _sum?: ItemTeleportSumOrderByAggregateInput
  }

  export type ItemTeleportScalarWhereWithAggregatesInput = {
    AND?: ItemTeleportScalarWhereWithAggregatesInput | ItemTeleportScalarWhereWithAggregatesInput[]
    OR?: ItemTeleportScalarWhereWithAggregatesInput[]
    NOT?: ItemTeleportScalarWhereWithAggregatesInput | ItemTeleportScalarWhereWithAggregatesInput[]
    teleOneId?: IntWithAggregatesFilter<"ItemTeleport"> | number
    teleTwoId?: IntWithAggregatesFilter<"ItemTeleport"> | number
  }

  export type ItemWiredWhereInput = {
    AND?: ItemWiredWhereInput | ItemWiredWhereInput[]
    OR?: ItemWiredWhereInput[]
    NOT?: ItemWiredWhereInput | ItemWiredWhereInput[]
    triggerId?: IntFilter<"ItemWired"> | number
    triggerData2?: StringNullableFilter<"ItemWired"> | string | null
    triggerData?: StringNullableFilter<"ItemWired"> | string | null
    allUserTriggerable?: BoolFilter<"ItemWired"> | boolean
    triggersItem?: StringNullableFilter<"ItemWired"> | string | null
    delay?: IntFilter<"ItemWired"> | number
  }

  export type ItemWiredOrderByWithRelationInput = {
    triggerId?: SortOrder
    triggerData2?: SortOrderInput | SortOrder
    triggerData?: SortOrderInput | SortOrder
    allUserTriggerable?: SortOrder
    triggersItem?: SortOrderInput | SortOrder
    delay?: SortOrder
  }

  export type ItemWiredWhereUniqueInput = Prisma.AtLeast<{
    triggerId?: number
    AND?: ItemWiredWhereInput | ItemWiredWhereInput[]
    OR?: ItemWiredWhereInput[]
    NOT?: ItemWiredWhereInput | ItemWiredWhereInput[]
    triggerData2?: StringNullableFilter<"ItemWired"> | string | null
    triggerData?: StringNullableFilter<"ItemWired"> | string | null
    allUserTriggerable?: BoolFilter<"ItemWired"> | boolean
    triggersItem?: StringNullableFilter<"ItemWired"> | string | null
    delay?: IntFilter<"ItemWired"> | number
  }, "triggerId">

  export type ItemWiredOrderByWithAggregationInput = {
    triggerId?: SortOrder
    triggerData2?: SortOrderInput | SortOrder
    triggerData?: SortOrderInput | SortOrder
    allUserTriggerable?: SortOrder
    triggersItem?: SortOrderInput | SortOrder
    delay?: SortOrder
    _count?: ItemWiredCountOrderByAggregateInput
    _avg?: ItemWiredAvgOrderByAggregateInput
    _max?: ItemWiredMaxOrderByAggregateInput
    _min?: ItemWiredMinOrderByAggregateInput
    _sum?: ItemWiredSumOrderByAggregateInput
  }

  export type ItemWiredScalarWhereWithAggregatesInput = {
    AND?: ItemWiredScalarWhereWithAggregatesInput | ItemWiredScalarWhereWithAggregatesInput[]
    OR?: ItemWiredScalarWhereWithAggregatesInput[]
    NOT?: ItemWiredScalarWhereWithAggregatesInput | ItemWiredScalarWhereWithAggregatesInput[]
    triggerId?: IntWithAggregatesFilter<"ItemWired"> | number
    triggerData2?: StringNullableWithAggregatesFilter<"ItemWired"> | string | null
    triggerData?: StringNullableWithAggregatesFilter<"ItemWired"> | string | null
    allUserTriggerable?: BoolWithAggregatesFilter<"ItemWired"> | boolean
    triggersItem?: StringNullableWithAggregatesFilter<"ItemWired"> | string | null
    delay?: IntWithAggregatesFilter<"ItemWired"> | number
  }

  export type LogChatWhereInput = {
    AND?: LogChatWhereInput | LogChatWhereInput[]
    OR?: LogChatWhereInput[]
    NOT?: LogChatWhereInput | LogChatWhereInput[]
    id?: IntFilter<"LogChat"> | number
    userId?: IntFilter<"LogChat"> | number
    roomId?: IntNullableFilter<"LogChat"> | number | null
    userName?: StringFilter<"LogChat"> | string
    timestamp?: IntFilter<"LogChat"> | number
    message?: StringFilter<"LogChat"> | string
    type?: StringFilter<"LogChat"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    room?: XOR<RoomNullableRelationFilter, RoomWhereInput> | null
  }

  export type LogChatOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
    type?: SortOrder
    user?: UserOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
  }

  export type LogChatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogChatWhereInput | LogChatWhereInput[]
    OR?: LogChatWhereInput[]
    NOT?: LogChatWhereInput | LogChatWhereInput[]
    userId?: IntFilter<"LogChat"> | number
    roomId?: IntNullableFilter<"LogChat"> | number | null
    userName?: StringFilter<"LogChat"> | string
    timestamp?: IntFilter<"LogChat"> | number
    message?: StringFilter<"LogChat"> | string
    type?: StringFilter<"LogChat"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    room?: XOR<RoomNullableRelationFilter, RoomWhereInput> | null
  }, "id">

  export type LogChatOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
    type?: SortOrder
    _count?: LogChatCountOrderByAggregateInput
    _avg?: LogChatAvgOrderByAggregateInput
    _max?: LogChatMaxOrderByAggregateInput
    _min?: LogChatMinOrderByAggregateInput
    _sum?: LogChatSumOrderByAggregateInput
  }

  export type LogChatScalarWhereWithAggregatesInput = {
    AND?: LogChatScalarWhereWithAggregatesInput | LogChatScalarWhereWithAggregatesInput[]
    OR?: LogChatScalarWhereWithAggregatesInput[]
    NOT?: LogChatScalarWhereWithAggregatesInput | LogChatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogChat"> | number
    userId?: IntWithAggregatesFilter<"LogChat"> | number
    roomId?: IntNullableWithAggregatesFilter<"LogChat"> | number | null
    userName?: StringWithAggregatesFilter<"LogChat"> | string
    timestamp?: IntWithAggregatesFilter<"LogChat"> | number
    message?: StringWithAggregatesFilter<"LogChat"> | string
    type?: StringWithAggregatesFilter<"LogChat"> | string
  }

  export type LogChatPubWhereInput = {
    AND?: LogChatPubWhereInput | LogChatPubWhereInput[]
    OR?: LogChatPubWhereInput[]
    NOT?: LogChatPubWhereInput | LogChatPubWhereInput[]
    id?: IntFilter<"LogChatPub"> | number
    userId?: IntFilter<"LogChatPub"> | number
    userName?: StringFilter<"LogChatPub"> | string
    timestamp?: IntFilter<"LogChatPub"> | number
    message?: StringFilter<"LogChatPub"> | string
  }

  export type LogChatPubOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
  }

  export type LogChatPubWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogChatPubWhereInput | LogChatPubWhereInput[]
    OR?: LogChatPubWhereInput[]
    NOT?: LogChatPubWhereInput | LogChatPubWhereInput[]
    userId?: IntFilter<"LogChatPub"> | number
    userName?: StringFilter<"LogChatPub"> | string
    timestamp?: IntFilter<"LogChatPub"> | number
    message?: StringFilter<"LogChatPub"> | string
  }, "id">

  export type LogChatPubOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
    _count?: LogChatPubCountOrderByAggregateInput
    _avg?: LogChatPubAvgOrderByAggregateInput
    _max?: LogChatPubMaxOrderByAggregateInput
    _min?: LogChatPubMinOrderByAggregateInput
    _sum?: LogChatPubSumOrderByAggregateInput
  }

  export type LogChatPubScalarWhereWithAggregatesInput = {
    AND?: LogChatPubScalarWhereWithAggregatesInput | LogChatPubScalarWhereWithAggregatesInput[]
    OR?: LogChatPubScalarWhereWithAggregatesInput[]
    NOT?: LogChatPubScalarWhereWithAggregatesInput | LogChatPubScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogChatPub"> | number
    userId?: IntWithAggregatesFilter<"LogChatPub"> | number
    userName?: StringWithAggregatesFilter<"LogChatPub"> | string
    timestamp?: IntWithAggregatesFilter<"LogChatPub"> | number
    message?: StringWithAggregatesFilter<"LogChatPub"> | string
  }

  export type LogCommandWhereInput = {
    AND?: LogCommandWhereInput | LogCommandWhereInput[]
    OR?: LogCommandWhereInput[]
    NOT?: LogCommandWhereInput | LogCommandWhereInput[]
    id?: IntFilter<"LogCommand"> | number
    userId?: IntFilter<"LogCommand"> | number
    userName?: StringFilter<"LogCommand"> | string
    roomid?: IntFilter<"LogCommand"> | number
    command?: StringFilter<"LogCommand"> | string
    extraData?: StringFilter<"LogCommand"> | string
    timestamp?: IntFilter<"LogCommand"> | number
  }

  export type LogCommandOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    roomid?: SortOrder
    command?: SortOrder
    extraData?: SortOrder
    timestamp?: SortOrder
  }

  export type LogCommandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogCommandWhereInput | LogCommandWhereInput[]
    OR?: LogCommandWhereInput[]
    NOT?: LogCommandWhereInput | LogCommandWhereInput[]
    userId?: IntFilter<"LogCommand"> | number
    userName?: StringFilter<"LogCommand"> | string
    roomid?: IntFilter<"LogCommand"> | number
    command?: StringFilter<"LogCommand"> | string
    extraData?: StringFilter<"LogCommand"> | string
    timestamp?: IntFilter<"LogCommand"> | number
  }, "id">

  export type LogCommandOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    roomid?: SortOrder
    command?: SortOrder
    extraData?: SortOrder
    timestamp?: SortOrder
    _count?: LogCommandCountOrderByAggregateInput
    _avg?: LogCommandAvgOrderByAggregateInput
    _max?: LogCommandMaxOrderByAggregateInput
    _min?: LogCommandMinOrderByAggregateInput
    _sum?: LogCommandSumOrderByAggregateInput
  }

  export type LogCommandScalarWhereWithAggregatesInput = {
    AND?: LogCommandScalarWhereWithAggregatesInput | LogCommandScalarWhereWithAggregatesInput[]
    OR?: LogCommandScalarWhereWithAggregatesInput[]
    NOT?: LogCommandScalarWhereWithAggregatesInput | LogCommandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogCommand"> | number
    userId?: IntWithAggregatesFilter<"LogCommand"> | number
    userName?: StringWithAggregatesFilter<"LogCommand"> | string
    roomid?: IntWithAggregatesFilter<"LogCommand"> | number
    command?: StringWithAggregatesFilter<"LogCommand"> | string
    extraData?: StringWithAggregatesFilter<"LogCommand"> | string
    timestamp?: IntWithAggregatesFilter<"LogCommand"> | number
  }

  export type LogFlagmeWhereInput = {
    AND?: LogFlagmeWhereInput | LogFlagmeWhereInput[]
    OR?: LogFlagmeWhereInput[]
    NOT?: LogFlagmeWhereInput | LogFlagmeWhereInput[]
    id?: IntFilter<"LogFlagme"> | number
    userId?: IntFilter<"LogFlagme"> | number
    oldusername?: StringFilter<"LogFlagme"> | string
    newusername?: StringFilter<"LogFlagme"> | string
    time?: IntFilter<"LogFlagme"> | number
  }

  export type LogFlagmeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    oldusername?: SortOrder
    newusername?: SortOrder
    time?: SortOrder
  }

  export type LogFlagmeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogFlagmeWhereInput | LogFlagmeWhereInput[]
    OR?: LogFlagmeWhereInput[]
    NOT?: LogFlagmeWhereInput | LogFlagmeWhereInput[]
    userId?: IntFilter<"LogFlagme"> | number
    oldusername?: StringFilter<"LogFlagme"> | string
    newusername?: StringFilter<"LogFlagme"> | string
    time?: IntFilter<"LogFlagme"> | number
  }, "id">

  export type LogFlagmeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    oldusername?: SortOrder
    newusername?: SortOrder
    time?: SortOrder
    _count?: LogFlagmeCountOrderByAggregateInput
    _avg?: LogFlagmeAvgOrderByAggregateInput
    _max?: LogFlagmeMaxOrderByAggregateInput
    _min?: LogFlagmeMinOrderByAggregateInput
    _sum?: LogFlagmeSumOrderByAggregateInput
  }

  export type LogFlagmeScalarWhereWithAggregatesInput = {
    AND?: LogFlagmeScalarWhereWithAggregatesInput | LogFlagmeScalarWhereWithAggregatesInput[]
    OR?: LogFlagmeScalarWhereWithAggregatesInput[]
    NOT?: LogFlagmeScalarWhereWithAggregatesInput | LogFlagmeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogFlagme"> | number
    userId?: IntWithAggregatesFilter<"LogFlagme"> | number
    oldusername?: StringWithAggregatesFilter<"LogFlagme"> | string
    newusername?: StringWithAggregatesFilter<"LogFlagme"> | string
    time?: IntWithAggregatesFilter<"LogFlagme"> | number
  }

  export type LogLoginWhereInput = {
    AND?: LogLoginWhereInput | LogLoginWhereInput[]
    OR?: LogLoginWhereInput[]
    NOT?: LogLoginWhereInput | LogLoginWhereInput[]
    id?: IntFilter<"LogLogin"> | number
    userId?: IntFilter<"LogLogin"> | number
    date?: IntFilter<"LogLogin"> | number
    ip?: StringFilter<"LogLogin"> | string
    userAgent?: StringFilter<"LogLogin"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogLoginOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogLoginWhereInput | LogLoginWhereInput[]
    OR?: LogLoginWhereInput[]
    NOT?: LogLoginWhereInput | LogLoginWhereInput[]
    userId?: IntFilter<"LogLogin"> | number
    date?: IntFilter<"LogLogin"> | number
    ip?: StringFilter<"LogLogin"> | string
    userAgent?: StringFilter<"LogLogin"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogLoginOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    _count?: LogLoginCountOrderByAggregateInput
    _avg?: LogLoginAvgOrderByAggregateInput
    _max?: LogLoginMaxOrderByAggregateInput
    _min?: LogLoginMinOrderByAggregateInput
    _sum?: LogLoginSumOrderByAggregateInput
  }

  export type LogLoginScalarWhereWithAggregatesInput = {
    AND?: LogLoginScalarWhereWithAggregatesInput | LogLoginScalarWhereWithAggregatesInput[]
    OR?: LogLoginScalarWhereWithAggregatesInput[]
    NOT?: LogLoginScalarWhereWithAggregatesInput | LogLoginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogLogin"> | number
    userId?: IntWithAggregatesFilter<"LogLogin"> | number
    date?: IntWithAggregatesFilter<"LogLogin"> | number
    ip?: StringWithAggregatesFilter<"LogLogin"> | string
    userAgent?: StringWithAggregatesFilter<"LogLogin"> | string
  }

  export type LogLootboxWhereInput = {
    AND?: LogLootboxWhereInput | LogLootboxWhereInput[]
    OR?: LogLootboxWhereInput[]
    NOT?: LogLootboxWhereInput | LogLootboxWhereInput[]
    id?: IntFilter<"LogLootbox"> | number
    interactionType?: StringFilter<"LogLootbox"> | string
    userId?: IntFilter<"LogLootbox"> | number
    itemId?: IntFilter<"LogLootbox"> | number
    baseId?: IntFilter<"LogLootbox"> | number
    timestamp?: IntFilter<"LogLootbox"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    itemBase?: XOR<ItemBaseRelationFilter, ItemBaseWhereInput>
  }

  export type LogLootboxOrderByWithRelationInput = {
    id?: SortOrder
    interactionType?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
    itemBase?: ItemBaseOrderByWithRelationInput
  }

  export type LogLootboxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogLootboxWhereInput | LogLootboxWhereInput[]
    OR?: LogLootboxWhereInput[]
    NOT?: LogLootboxWhereInput | LogLootboxWhereInput[]
    interactionType?: StringFilter<"LogLootbox"> | string
    userId?: IntFilter<"LogLootbox"> | number
    itemId?: IntFilter<"LogLootbox"> | number
    baseId?: IntFilter<"LogLootbox"> | number
    timestamp?: IntFilter<"LogLootbox"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    itemBase?: XOR<ItemBaseRelationFilter, ItemBaseWhereInput>
  }, "id">

  export type LogLootboxOrderByWithAggregationInput = {
    id?: SortOrder
    interactionType?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
    _count?: LogLootboxCountOrderByAggregateInput
    _avg?: LogLootboxAvgOrderByAggregateInput
    _max?: LogLootboxMaxOrderByAggregateInput
    _min?: LogLootboxMinOrderByAggregateInput
    _sum?: LogLootboxSumOrderByAggregateInput
  }

  export type LogLootboxScalarWhereWithAggregatesInput = {
    AND?: LogLootboxScalarWhereWithAggregatesInput | LogLootboxScalarWhereWithAggregatesInput[]
    OR?: LogLootboxScalarWhereWithAggregatesInput[]
    NOT?: LogLootboxScalarWhereWithAggregatesInput | LogLootboxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogLootbox"> | number
    interactionType?: StringWithAggregatesFilter<"LogLootbox"> | string
    userId?: IntWithAggregatesFilter<"LogLootbox"> | number
    itemId?: IntWithAggregatesFilter<"LogLootbox"> | number
    baseId?: IntWithAggregatesFilter<"LogLootbox"> | number
    timestamp?: IntWithAggregatesFilter<"LogLootbox"> | number
  }

  export type LogPaymentWhereInput = {
    AND?: LogPaymentWhereInput | LogPaymentWhereInput[]
    OR?: LogPaymentWhereInput[]
    NOT?: LogPaymentWhereInput | LogPaymentWhereInput[]
    historyPaymentId?: IntFilter<"LogPayment"> | number
    docId?: IntFilter<"LogPayment"> | number
    userId?: IntFilter<"LogPayment"> | number
    awards?: IntFilter<"LogPayment"> | number
    externalReference?: StringFilter<"LogPayment"> | string
    promoId?: IntFilter<"LogPayment"> | number
    date?: DateTimeFilter<"LogPayment"> | Date | string
  }

  export type LogPaymentOrderByWithRelationInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    externalReference?: SortOrder
    promoId?: SortOrder
    date?: SortOrder
  }

  export type LogPaymentWhereUniqueInput = Prisma.AtLeast<{
    historyPaymentId?: number
    AND?: LogPaymentWhereInput | LogPaymentWhereInput[]
    OR?: LogPaymentWhereInput[]
    NOT?: LogPaymentWhereInput | LogPaymentWhereInput[]
    docId?: IntFilter<"LogPayment"> | number
    userId?: IntFilter<"LogPayment"> | number
    awards?: IntFilter<"LogPayment"> | number
    externalReference?: StringFilter<"LogPayment"> | string
    promoId?: IntFilter<"LogPayment"> | number
    date?: DateTimeFilter<"LogPayment"> | Date | string
  }, "historyPaymentId">

  export type LogPaymentOrderByWithAggregationInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    externalReference?: SortOrder
    promoId?: SortOrder
    date?: SortOrder
    _count?: LogPaymentCountOrderByAggregateInput
    _avg?: LogPaymentAvgOrderByAggregateInput
    _max?: LogPaymentMaxOrderByAggregateInput
    _min?: LogPaymentMinOrderByAggregateInput
    _sum?: LogPaymentSumOrderByAggregateInput
  }

  export type LogPaymentScalarWhereWithAggregatesInput = {
    AND?: LogPaymentScalarWhereWithAggregatesInput | LogPaymentScalarWhereWithAggregatesInput[]
    OR?: LogPaymentScalarWhereWithAggregatesInput[]
    NOT?: LogPaymentScalarWhereWithAggregatesInput | LogPaymentScalarWhereWithAggregatesInput[]
    historyPaymentId?: IntWithAggregatesFilter<"LogPayment"> | number
    docId?: IntWithAggregatesFilter<"LogPayment"> | number
    userId?: IntWithAggregatesFilter<"LogPayment"> | number
    awards?: IntWithAggregatesFilter<"LogPayment"> | number
    externalReference?: StringWithAggregatesFilter<"LogPayment"> | string
    promoId?: IntWithAggregatesFilter<"LogPayment"> | number
    date?: DateTimeWithAggregatesFilter<"LogPayment"> | Date | string
  }

  export type LogShopWhereInput = {
    AND?: LogShopWhereInput | LogShopWhereInput[]
    OR?: LogShopWhereInput[]
    NOT?: LogShopWhereInput | LogShopWhereInput[]
    id?: IntFilter<"LogShop"> | number
    userId?: IntFilter<"LogShop"> | number
    date?: IntFilter<"LogShop"> | number
    price?: IntFilter<"LogShop"> | number
    content?: StringFilter<"LogShop"> | string
    type?: IntFilter<"LogShop"> | number
    catalogItemId?: IntFilter<"LogShop"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogShopOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    content?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogShopWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogShopWhereInput | LogShopWhereInput[]
    OR?: LogShopWhereInput[]
    NOT?: LogShopWhereInput | LogShopWhereInput[]
    userId?: IntFilter<"LogShop"> | number
    date?: IntFilter<"LogShop"> | number
    price?: IntFilter<"LogShop"> | number
    content?: StringFilter<"LogShop"> | string
    type?: IntFilter<"LogShop"> | number
    catalogItemId?: IntFilter<"LogShop"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogShopOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    content?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
    _count?: LogShopCountOrderByAggregateInput
    _avg?: LogShopAvgOrderByAggregateInput
    _max?: LogShopMaxOrderByAggregateInput
    _min?: LogShopMinOrderByAggregateInput
    _sum?: LogShopSumOrderByAggregateInput
  }

  export type LogShopScalarWhereWithAggregatesInput = {
    AND?: LogShopScalarWhereWithAggregatesInput | LogShopScalarWhereWithAggregatesInput[]
    OR?: LogShopScalarWhereWithAggregatesInput[]
    NOT?: LogShopScalarWhereWithAggregatesInput | LogShopScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogShop"> | number
    userId?: IntWithAggregatesFilter<"LogShop"> | number
    date?: IntWithAggregatesFilter<"LogShop"> | number
    price?: IntWithAggregatesFilter<"LogShop"> | number
    content?: StringWithAggregatesFilter<"LogShop"> | string
    type?: IntWithAggregatesFilter<"LogShop"> | number
    catalogItemId?: IntWithAggregatesFilter<"LogShop"> | number
  }

  export type LogSlotmachineWhereInput = {
    AND?: LogSlotmachineWhereInput | LogSlotmachineWhereInput[]
    OR?: LogSlotmachineWhereInput[]
    NOT?: LogSlotmachineWhereInput | LogSlotmachineWhereInput[]
    id?: IntFilter<"LogSlotmachine"> | number
    userId?: IntFilter<"LogSlotmachine"> | number
    amount?: IntFilter<"LogSlotmachine"> | number
    isWin?: BoolFilter<"LogSlotmachine"> | boolean
    date?: IntFilter<"LogSlotmachine"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogSlotmachineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isWin?: SortOrder
    date?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogSlotmachineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogSlotmachineWhereInput | LogSlotmachineWhereInput[]
    OR?: LogSlotmachineWhereInput[]
    NOT?: LogSlotmachineWhereInput | LogSlotmachineWhereInput[]
    userId?: IntFilter<"LogSlotmachine"> | number
    amount?: IntFilter<"LogSlotmachine"> | number
    isWin?: BoolFilter<"LogSlotmachine"> | boolean
    date?: IntFilter<"LogSlotmachine"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogSlotmachineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isWin?: SortOrder
    date?: SortOrder
    _count?: LogSlotmachineCountOrderByAggregateInput
    _avg?: LogSlotmachineAvgOrderByAggregateInput
    _max?: LogSlotmachineMaxOrderByAggregateInput
    _min?: LogSlotmachineMinOrderByAggregateInput
    _sum?: LogSlotmachineSumOrderByAggregateInput
  }

  export type LogSlotmachineScalarWhereWithAggregatesInput = {
    AND?: LogSlotmachineScalarWhereWithAggregatesInput | LogSlotmachineScalarWhereWithAggregatesInput[]
    OR?: LogSlotmachineScalarWhereWithAggregatesInput[]
    NOT?: LogSlotmachineScalarWhereWithAggregatesInput | LogSlotmachineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogSlotmachine"> | number
    userId?: IntWithAggregatesFilter<"LogSlotmachine"> | number
    amount?: IntWithAggregatesFilter<"LogSlotmachine"> | number
    isWin?: BoolWithAggregatesFilter<"LogSlotmachine"> | boolean
    date?: IntWithAggregatesFilter<"LogSlotmachine"> | number
  }

  export type LogStaffWhereInput = {
    AND?: LogStaffWhereInput | LogStaffWhereInput[]
    OR?: LogStaffWhereInput[]
    NOT?: LogStaffWhereInput | LogStaffWhereInput[]
    id?: IntFilter<"LogStaff"> | number
    pseudo?: StringFilter<"LogStaff"> | string
    action?: StringFilter<"LogStaff"> | string
    date?: IntFilter<"LogStaff"> | number
  }

  export type LogStaffOrderByWithRelationInput = {
    id?: SortOrder
    pseudo?: SortOrder
    action?: SortOrder
    date?: SortOrder
  }

  export type LogStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogStaffWhereInput | LogStaffWhereInput[]
    OR?: LogStaffWhereInput[]
    NOT?: LogStaffWhereInput | LogStaffWhereInput[]
    pseudo?: StringFilter<"LogStaff"> | string
    action?: StringFilter<"LogStaff"> | string
    date?: IntFilter<"LogStaff"> | number
  }, "id" | "id">

  export type LogStaffOrderByWithAggregationInput = {
    id?: SortOrder
    pseudo?: SortOrder
    action?: SortOrder
    date?: SortOrder
    _count?: LogStaffCountOrderByAggregateInput
    _avg?: LogStaffAvgOrderByAggregateInput
    _max?: LogStaffMaxOrderByAggregateInput
    _min?: LogStaffMinOrderByAggregateInput
    _sum?: LogStaffSumOrderByAggregateInput
  }

  export type LogStaffScalarWhereWithAggregatesInput = {
    AND?: LogStaffScalarWhereWithAggregatesInput | LogStaffScalarWhereWithAggregatesInput[]
    OR?: LogStaffScalarWhereWithAggregatesInput[]
    NOT?: LogStaffScalarWhereWithAggregatesInput | LogStaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogStaff"> | number
    pseudo?: StringWithAggregatesFilter<"LogStaff"> | string
    action?: StringWithAggregatesFilter<"LogStaff"> | string
    date?: IntWithAggregatesFilter<"LogStaff"> | number
  }

  export type LogTradeWhereInput = {
    AND?: LogTradeWhereInput | LogTradeWhereInput[]
    OR?: LogTradeWhereInput[]
    NOT?: LogTradeWhereInput | LogTradeWhereInput[]
    id?: IntFilter<"LogTrade"> | number
    userOneId?: IntFilter<"LogTrade"> | number
    userTwoId?: IntFilter<"LogTrade"> | number
    userOneItems?: StringFilter<"LogTrade"> | string
    userTwoItems?: StringFilter<"LogTrade"> | string
    roomId?: IntFilter<"LogTrade"> | number
    time?: IntFilter<"LogTrade"> | number
    userOneTrade?: XOR<UserRelationFilter, UserWhereInput>
    userTwoTrade?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogTradeOrderByWithRelationInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    userOneItems?: SortOrder
    userTwoItems?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
    userOneTrade?: UserOrderByWithRelationInput
    userTwoTrade?: UserOrderByWithRelationInput
  }

  export type LogTradeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogTradeWhereInput | LogTradeWhereInput[]
    OR?: LogTradeWhereInput[]
    NOT?: LogTradeWhereInput | LogTradeWhereInput[]
    userOneId?: IntFilter<"LogTrade"> | number
    userTwoId?: IntFilter<"LogTrade"> | number
    userOneItems?: StringFilter<"LogTrade"> | string
    userTwoItems?: StringFilter<"LogTrade"> | string
    roomId?: IntFilter<"LogTrade"> | number
    time?: IntFilter<"LogTrade"> | number
    userOneTrade?: XOR<UserRelationFilter, UserWhereInput>
    userTwoTrade?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogTradeOrderByWithAggregationInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    userOneItems?: SortOrder
    userTwoItems?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
    _count?: LogTradeCountOrderByAggregateInput
    _avg?: LogTradeAvgOrderByAggregateInput
    _max?: LogTradeMaxOrderByAggregateInput
    _min?: LogTradeMinOrderByAggregateInput
    _sum?: LogTradeSumOrderByAggregateInput
  }

  export type LogTradeScalarWhereWithAggregatesInput = {
    AND?: LogTradeScalarWhereWithAggregatesInput | LogTradeScalarWhereWithAggregatesInput[]
    OR?: LogTradeScalarWhereWithAggregatesInput[]
    NOT?: LogTradeScalarWhereWithAggregatesInput | LogTradeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogTrade"> | number
    userOneId?: IntWithAggregatesFilter<"LogTrade"> | number
    userTwoId?: IntWithAggregatesFilter<"LogTrade"> | number
    userOneItems?: StringWithAggregatesFilter<"LogTrade"> | string
    userTwoItems?: StringWithAggregatesFilter<"LogTrade"> | string
    roomId?: IntWithAggregatesFilter<"LogTrade"> | number
    time?: IntWithAggregatesFilter<"LogTrade"> | number
  }

  export type LogVpnWhereInput = {
    AND?: LogVpnWhereInput | LogVpnWhereInput[]
    OR?: LogVpnWhereInput[]
    NOT?: LogVpnWhereInput | LogVpnWhereInput[]
    id?: IntFilter<"LogVpn"> | number
    ip?: StringFilter<"LogVpn"> | string
    ipCountry?: StringNullableFilter<"LogVpn"> | string | null
    host?: StringNullableFilter<"LogVpn"> | string | null
    timestampCreated?: IntFilter<"LogVpn"> | number
    isVpn?: BoolFilter<"LogVpn"> | boolean
  }

  export type LogVpnOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    ipCountry?: SortOrderInput | SortOrder
    host?: SortOrderInput | SortOrder
    timestampCreated?: SortOrder
    isVpn?: SortOrder
  }

  export type LogVpnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogVpnWhereInput | LogVpnWhereInput[]
    OR?: LogVpnWhereInput[]
    NOT?: LogVpnWhereInput | LogVpnWhereInput[]
    ip?: StringFilter<"LogVpn"> | string
    ipCountry?: StringNullableFilter<"LogVpn"> | string | null
    host?: StringNullableFilter<"LogVpn"> | string | null
    timestampCreated?: IntFilter<"LogVpn"> | number
    isVpn?: BoolFilter<"LogVpn"> | boolean
  }, "id">

  export type LogVpnOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    ipCountry?: SortOrderInput | SortOrder
    host?: SortOrderInput | SortOrder
    timestampCreated?: SortOrder
    isVpn?: SortOrder
    _count?: LogVpnCountOrderByAggregateInput
    _avg?: LogVpnAvgOrderByAggregateInput
    _max?: LogVpnMaxOrderByAggregateInput
    _min?: LogVpnMinOrderByAggregateInput
    _sum?: LogVpnSumOrderByAggregateInput
  }

  export type LogVpnScalarWhereWithAggregatesInput = {
    AND?: LogVpnScalarWhereWithAggregatesInput | LogVpnScalarWhereWithAggregatesInput[]
    OR?: LogVpnScalarWhereWithAggregatesInput[]
    NOT?: LogVpnScalarWhereWithAggregatesInput | LogVpnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogVpn"> | number
    ip?: StringWithAggregatesFilter<"LogVpn"> | string
    ipCountry?: StringNullableWithAggregatesFilter<"LogVpn"> | string | null
    host?: StringNullableWithAggregatesFilter<"LogVpn"> | string | null
    timestampCreated?: IntWithAggregatesFilter<"LogVpn"> | number
    isVpn?: BoolWithAggregatesFilter<"LogVpn"> | boolean
  }

  export type LogSandboxWhereInput = {
    AND?: LogSandboxWhereInput | LogSandboxWhereInput[]
    OR?: LogSandboxWhereInput[]
    NOT?: LogSandboxWhereInput | LogSandboxWhereInput[]
    id?: IntFilter<"LogSandbox"> | number
    userId?: IntFilter<"LogSandbox"> | number
    method?: StringFilter<"LogSandbox"> | string
    editName?: StringFilter<"LogSandbox"> | string
    editKey?: StringFilter<"LogSandbox"> | string
    createdAt?: DateTimeFilter<"LogSandbox"> | Date | string
    updatedAt?: DateTimeFilter<"LogSandbox"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LogSandboxOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    editName?: SortOrder
    editKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogSandboxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogSandboxWhereInput | LogSandboxWhereInput[]
    OR?: LogSandboxWhereInput[]
    NOT?: LogSandboxWhereInput | LogSandboxWhereInput[]
    userId?: IntFilter<"LogSandbox"> | number
    method?: StringFilter<"LogSandbox"> | string
    editName?: StringFilter<"LogSandbox"> | string
    editKey?: StringFilter<"LogSandbox"> | string
    createdAt?: DateTimeFilter<"LogSandbox"> | Date | string
    updatedAt?: DateTimeFilter<"LogSandbox"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type LogSandboxOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    editName?: SortOrder
    editKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LogSandboxCountOrderByAggregateInput
    _avg?: LogSandboxAvgOrderByAggregateInput
    _max?: LogSandboxMaxOrderByAggregateInput
    _min?: LogSandboxMinOrderByAggregateInput
    _sum?: LogSandboxSumOrderByAggregateInput
  }

  export type LogSandboxScalarWhereWithAggregatesInput = {
    AND?: LogSandboxScalarWhereWithAggregatesInput | LogSandboxScalarWhereWithAggregatesInput[]
    OR?: LogSandboxScalarWhereWithAggregatesInput[]
    NOT?: LogSandboxScalarWhereWithAggregatesInput | LogSandboxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogSandbox"> | number
    userId?: IntWithAggregatesFilter<"LogSandbox"> | number
    method?: StringWithAggregatesFilter<"LogSandbox"> | string
    editName?: StringWithAggregatesFilter<"LogSandbox"> | string
    editKey?: StringWithAggregatesFilter<"LogSandbox"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LogSandbox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LogSandbox"> | Date | string
  }

  export type MessengerFriendshipWhereInput = {
    AND?: MessengerFriendshipWhereInput | MessengerFriendshipWhereInput[]
    OR?: MessengerFriendshipWhereInput[]
    NOT?: MessengerFriendshipWhereInput | MessengerFriendshipWhereInput[]
    userOneId?: IntFilter<"MessengerFriendship"> | number
    userTwoId?: IntFilter<"MessengerFriendship"> | number
    relation?: IntFilter<"MessengerFriendship"> | number
  }

  export type MessengerFriendshipOrderByWithRelationInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
  }

  export type MessengerFriendshipWhereUniqueInput = Prisma.AtLeast<{
    userOneId_userTwoId?: MessengerFriendshipUserOneIdUserTwoIdCompoundUniqueInput
    AND?: MessengerFriendshipWhereInput | MessengerFriendshipWhereInput[]
    OR?: MessengerFriendshipWhereInput[]
    NOT?: MessengerFriendshipWhereInput | MessengerFriendshipWhereInput[]
    userOneId?: IntFilter<"MessengerFriendship"> | number
    userTwoId?: IntFilter<"MessengerFriendship"> | number
    relation?: IntFilter<"MessengerFriendship"> | number
  }, "userOneId_userTwoId">

  export type MessengerFriendshipOrderByWithAggregationInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
    _count?: MessengerFriendshipCountOrderByAggregateInput
    _avg?: MessengerFriendshipAvgOrderByAggregateInput
    _max?: MessengerFriendshipMaxOrderByAggregateInput
    _min?: MessengerFriendshipMinOrderByAggregateInput
    _sum?: MessengerFriendshipSumOrderByAggregateInput
  }

  export type MessengerFriendshipScalarWhereWithAggregatesInput = {
    AND?: MessengerFriendshipScalarWhereWithAggregatesInput | MessengerFriendshipScalarWhereWithAggregatesInput[]
    OR?: MessengerFriendshipScalarWhereWithAggregatesInput[]
    NOT?: MessengerFriendshipScalarWhereWithAggregatesInput | MessengerFriendshipScalarWhereWithAggregatesInput[]
    userOneId?: IntWithAggregatesFilter<"MessengerFriendship"> | number
    userTwoId?: IntWithAggregatesFilter<"MessengerFriendship"> | number
    relation?: IntWithAggregatesFilter<"MessengerFriendship"> | number
  }

  export type MessengerOfflineMessageWhereInput = {
    AND?: MessengerOfflineMessageWhereInput | MessengerOfflineMessageWhereInput[]
    OR?: MessengerOfflineMessageWhereInput[]
    NOT?: MessengerOfflineMessageWhereInput | MessengerOfflineMessageWhereInput[]
    id?: IntFilter<"MessengerOfflineMessage"> | number
    toId?: IntFilter<"MessengerOfflineMessage"> | number
    fromId?: IntFilter<"MessengerOfflineMessage"> | number
    message?: StringFilter<"MessengerOfflineMessage"> | string
    timestamp?: IntFilter<"MessengerOfflineMessage"> | number
  }

  export type MessengerOfflineMessageOrderByWithRelationInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type MessengerOfflineMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessengerOfflineMessageWhereInput | MessengerOfflineMessageWhereInput[]
    OR?: MessengerOfflineMessageWhereInput[]
    NOT?: MessengerOfflineMessageWhereInput | MessengerOfflineMessageWhereInput[]
    toId?: IntFilter<"MessengerOfflineMessage"> | number
    fromId?: IntFilter<"MessengerOfflineMessage"> | number
    message?: StringFilter<"MessengerOfflineMessage"> | string
    timestamp?: IntFilter<"MessengerOfflineMessage"> | number
  }, "id">

  export type MessengerOfflineMessageOrderByWithAggregationInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    _count?: MessengerOfflineMessageCountOrderByAggregateInput
    _avg?: MessengerOfflineMessageAvgOrderByAggregateInput
    _max?: MessengerOfflineMessageMaxOrderByAggregateInput
    _min?: MessengerOfflineMessageMinOrderByAggregateInput
    _sum?: MessengerOfflineMessageSumOrderByAggregateInput
  }

  export type MessengerOfflineMessageScalarWhereWithAggregatesInput = {
    AND?: MessengerOfflineMessageScalarWhereWithAggregatesInput | MessengerOfflineMessageScalarWhereWithAggregatesInput[]
    OR?: MessengerOfflineMessageScalarWhereWithAggregatesInput[]
    NOT?: MessengerOfflineMessageScalarWhereWithAggregatesInput | MessengerOfflineMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MessengerOfflineMessage"> | number
    toId?: IntWithAggregatesFilter<"MessengerOfflineMessage"> | number
    fromId?: IntWithAggregatesFilter<"MessengerOfflineMessage"> | number
    message?: StringWithAggregatesFilter<"MessengerOfflineMessage"> | string
    timestamp?: IntWithAggregatesFilter<"MessengerOfflineMessage"> | number
  }

  export type MessengerRequestWhereInput = {
    AND?: MessengerRequestWhereInput | MessengerRequestWhereInput[]
    OR?: MessengerRequestWhereInput[]
    NOT?: MessengerRequestWhereInput | MessengerRequestWhereInput[]
    fromId?: IntFilter<"MessengerRequest"> | number
    toId?: IntFilter<"MessengerRequest"> | number
  }

  export type MessengerRequestOrderByWithRelationInput = {
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type MessengerRequestWhereUniqueInput = Prisma.AtLeast<{
    fromId_toId?: MessengerRequestFromIdToIdCompoundUniqueInput
    AND?: MessengerRequestWhereInput | MessengerRequestWhereInput[]
    OR?: MessengerRequestWhereInput[]
    NOT?: MessengerRequestWhereInput | MessengerRequestWhereInput[]
    fromId?: IntFilter<"MessengerRequest"> | number
    toId?: IntFilter<"MessengerRequest"> | number
  }, "fromId_toId">

  export type MessengerRequestOrderByWithAggregationInput = {
    fromId?: SortOrder
    toId?: SortOrder
    _count?: MessengerRequestCountOrderByAggregateInput
    _avg?: MessengerRequestAvgOrderByAggregateInput
    _max?: MessengerRequestMaxOrderByAggregateInput
    _min?: MessengerRequestMinOrderByAggregateInput
    _sum?: MessengerRequestSumOrderByAggregateInput
  }

  export type MessengerRequestScalarWhereWithAggregatesInput = {
    AND?: MessengerRequestScalarWhereWithAggregatesInput | MessengerRequestScalarWhereWithAggregatesInput[]
    OR?: MessengerRequestScalarWhereWithAggregatesInput[]
    NOT?: MessengerRequestScalarWhereWithAggregatesInput | MessengerRequestScalarWhereWithAggregatesInput[]
    fromId?: IntWithAggregatesFilter<"MessengerRequest"> | number
    toId?: IntWithAggregatesFilter<"MessengerRequest"> | number
  }

  export type ModerationPresetWhereInput = {
    AND?: ModerationPresetWhereInput | ModerationPresetWhereInput[]
    OR?: ModerationPresetWhereInput[]
    NOT?: ModerationPresetWhereInput | ModerationPresetWhereInput[]
    id?: IntFilter<"ModerationPreset"> | number
    enabled?: BoolFilter<"ModerationPreset"> | boolean
    type?: EnumModerationPresetTypeFilter<"ModerationPreset"> | $Enums.ModerationPresetType
    message?: StringFilter<"ModerationPreset"> | string
  }

  export type ModerationPresetOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    message?: SortOrder
  }

  export type ModerationPresetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModerationPresetWhereInput | ModerationPresetWhereInput[]
    OR?: ModerationPresetWhereInput[]
    NOT?: ModerationPresetWhereInput | ModerationPresetWhereInput[]
    enabled?: BoolFilter<"ModerationPreset"> | boolean
    type?: EnumModerationPresetTypeFilter<"ModerationPreset"> | $Enums.ModerationPresetType
    message?: StringFilter<"ModerationPreset"> | string
  }, "id">

  export type ModerationPresetOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    message?: SortOrder
    _count?: ModerationPresetCountOrderByAggregateInput
    _avg?: ModerationPresetAvgOrderByAggregateInput
    _max?: ModerationPresetMaxOrderByAggregateInput
    _min?: ModerationPresetMinOrderByAggregateInput
    _sum?: ModerationPresetSumOrderByAggregateInput
  }

  export type ModerationPresetScalarWhereWithAggregatesInput = {
    AND?: ModerationPresetScalarWhereWithAggregatesInput | ModerationPresetScalarWhereWithAggregatesInput[]
    OR?: ModerationPresetScalarWhereWithAggregatesInput[]
    NOT?: ModerationPresetScalarWhereWithAggregatesInput | ModerationPresetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModerationPreset"> | number
    enabled?: BoolWithAggregatesFilter<"ModerationPreset"> | boolean
    type?: EnumModerationPresetTypeWithAggregatesFilter<"ModerationPreset"> | $Enums.ModerationPresetType
    message?: StringWithAggregatesFilter<"ModerationPreset"> | string
  }

  export type ModerationResolutionWhereInput = {
    AND?: ModerationResolutionWhereInput | ModerationResolutionWhereInput[]
    OR?: ModerationResolutionWhereInput[]
    NOT?: ModerationResolutionWhereInput | ModerationResolutionWhereInput[]
    id?: IntFilter<"ModerationResolution"> | number
    type?: EnumModerationResolutionTypeFilter<"ModerationResolution"> | $Enums.ModerationResolutionType
    title?: StringFilter<"ModerationResolution"> | string
    subtitle?: StringFilter<"ModerationResolution"> | string
    banHours?: IntFilter<"ModerationResolution"> | number
    enableMute?: IntFilter<"ModerationResolution"> | number
    muteHours?: IntFilter<"ModerationResolution"> | number
    reminder?: IntFilter<"ModerationResolution"> | number
    message?: StringFilter<"ModerationResolution"> | string
  }

  export type ModerationResolutionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
    message?: SortOrder
  }

  export type ModerationResolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModerationResolutionWhereInput | ModerationResolutionWhereInput[]
    OR?: ModerationResolutionWhereInput[]
    NOT?: ModerationResolutionWhereInput | ModerationResolutionWhereInput[]
    type?: EnumModerationResolutionTypeFilter<"ModerationResolution"> | $Enums.ModerationResolutionType
    title?: StringFilter<"ModerationResolution"> | string
    subtitle?: StringFilter<"ModerationResolution"> | string
    banHours?: IntFilter<"ModerationResolution"> | number
    enableMute?: IntFilter<"ModerationResolution"> | number
    muteHours?: IntFilter<"ModerationResolution"> | number
    reminder?: IntFilter<"ModerationResolution"> | number
    message?: StringFilter<"ModerationResolution"> | string
  }, "id">

  export type ModerationResolutionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
    message?: SortOrder
    _count?: ModerationResolutionCountOrderByAggregateInput
    _avg?: ModerationResolutionAvgOrderByAggregateInput
    _max?: ModerationResolutionMaxOrderByAggregateInput
    _min?: ModerationResolutionMinOrderByAggregateInput
    _sum?: ModerationResolutionSumOrderByAggregateInput
  }

  export type ModerationResolutionScalarWhereWithAggregatesInput = {
    AND?: ModerationResolutionScalarWhereWithAggregatesInput | ModerationResolutionScalarWhereWithAggregatesInput[]
    OR?: ModerationResolutionScalarWhereWithAggregatesInput[]
    NOT?: ModerationResolutionScalarWhereWithAggregatesInput | ModerationResolutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModerationResolution"> | number
    type?: EnumModerationResolutionTypeWithAggregatesFilter<"ModerationResolution"> | $Enums.ModerationResolutionType
    title?: StringWithAggregatesFilter<"ModerationResolution"> | string
    subtitle?: StringWithAggregatesFilter<"ModerationResolution"> | string
    banHours?: IntWithAggregatesFilter<"ModerationResolution"> | number
    enableMute?: IntWithAggregatesFilter<"ModerationResolution"> | number
    muteHours?: IntWithAggregatesFilter<"ModerationResolution"> | number
    reminder?: IntWithAggregatesFilter<"ModerationResolution"> | number
    message?: StringWithAggregatesFilter<"ModerationResolution"> | string
  }

  export type ModerationTicketWhereInput = {
    AND?: ModerationTicketWhereInput | ModerationTicketWhereInput[]
    OR?: ModerationTicketWhereInput[]
    NOT?: ModerationTicketWhereInput | ModerationTicketWhereInput[]
    id?: IntFilter<"ModerationTicket"> | number
    score?: IntFilter<"ModerationTicket"> | number
    type?: IntFilter<"ModerationTicket"> | number
    status?: EnumModerationTicketStatusFilter<"ModerationTicket"> | $Enums.ModerationTicketStatus
    senderId?: IntFilter<"ModerationTicket"> | number
    reportedId?: IntFilter<"ModerationTicket"> | number
    moderatorId?: IntFilter<"ModerationTicket"> | number
    message?: StringFilter<"ModerationTicket"> | string
    roomId?: IntFilter<"ModerationTicket"> | number
    roomName?: StringFilter<"ModerationTicket"> | string
    timestamp?: IntFilter<"ModerationTicket"> | number
  }

  export type ModerationTicketOrderByWithRelationInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    message?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    timestamp?: SortOrder
  }

  export type ModerationTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModerationTicketWhereInput | ModerationTicketWhereInput[]
    OR?: ModerationTicketWhereInput[]
    NOT?: ModerationTicketWhereInput | ModerationTicketWhereInput[]
    score?: IntFilter<"ModerationTicket"> | number
    type?: IntFilter<"ModerationTicket"> | number
    status?: EnumModerationTicketStatusFilter<"ModerationTicket"> | $Enums.ModerationTicketStatus
    senderId?: IntFilter<"ModerationTicket"> | number
    reportedId?: IntFilter<"ModerationTicket"> | number
    moderatorId?: IntFilter<"ModerationTicket"> | number
    message?: StringFilter<"ModerationTicket"> | string
    roomId?: IntFilter<"ModerationTicket"> | number
    roomName?: StringFilter<"ModerationTicket"> | string
    timestamp?: IntFilter<"ModerationTicket"> | number
  }, "id" | "id">

  export type ModerationTicketOrderByWithAggregationInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    message?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    timestamp?: SortOrder
    _count?: ModerationTicketCountOrderByAggregateInput
    _avg?: ModerationTicketAvgOrderByAggregateInput
    _max?: ModerationTicketMaxOrderByAggregateInput
    _min?: ModerationTicketMinOrderByAggregateInput
    _sum?: ModerationTicketSumOrderByAggregateInput
  }

  export type ModerationTicketScalarWhereWithAggregatesInput = {
    AND?: ModerationTicketScalarWhereWithAggregatesInput | ModerationTicketScalarWhereWithAggregatesInput[]
    OR?: ModerationTicketScalarWhereWithAggregatesInput[]
    NOT?: ModerationTicketScalarWhereWithAggregatesInput | ModerationTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModerationTicket"> | number
    score?: IntWithAggregatesFilter<"ModerationTicket"> | number
    type?: IntWithAggregatesFilter<"ModerationTicket"> | number
    status?: EnumModerationTicketStatusWithAggregatesFilter<"ModerationTicket"> | $Enums.ModerationTicketStatus
    senderId?: IntWithAggregatesFilter<"ModerationTicket"> | number
    reportedId?: IntWithAggregatesFilter<"ModerationTicket"> | number
    moderatorId?: IntWithAggregatesFilter<"ModerationTicket"> | number
    message?: StringWithAggregatesFilter<"ModerationTicket"> | string
    roomId?: IntWithAggregatesFilter<"ModerationTicket"> | number
    roomName?: StringWithAggregatesFilter<"ModerationTicket"> | string
    timestamp?: IntWithAggregatesFilter<"ModerationTicket"> | number
  }

  export type ModerationTopicWhereInput = {
    AND?: ModerationTopicWhereInput | ModerationTopicWhereInput[]
    OR?: ModerationTopicWhereInput[]
    NOT?: ModerationTopicWhereInput | ModerationTopicWhereInput[]
    id?: IntFilter<"ModerationTopic"> | number
    caption?: StringFilter<"ModerationTopic"> | string
  }

  export type ModerationTopicOrderByWithRelationInput = {
    id?: SortOrder
    caption?: SortOrder
  }

  export type ModerationTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModerationTopicWhereInput | ModerationTopicWhereInput[]
    OR?: ModerationTopicWhereInput[]
    NOT?: ModerationTopicWhereInput | ModerationTopicWhereInput[]
    caption?: StringFilter<"ModerationTopic"> | string
  }, "id">

  export type ModerationTopicOrderByWithAggregationInput = {
    id?: SortOrder
    caption?: SortOrder
    _count?: ModerationTopicCountOrderByAggregateInput
    _avg?: ModerationTopicAvgOrderByAggregateInput
    _max?: ModerationTopicMaxOrderByAggregateInput
    _min?: ModerationTopicMinOrderByAggregateInput
    _sum?: ModerationTopicSumOrderByAggregateInput
  }

  export type ModerationTopicScalarWhereWithAggregatesInput = {
    AND?: ModerationTopicScalarWhereWithAggregatesInput | ModerationTopicScalarWhereWithAggregatesInput[]
    OR?: ModerationTopicScalarWhereWithAggregatesInput[]
    NOT?: ModerationTopicScalarWhereWithAggregatesInput | ModerationTopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModerationTopic"> | number
    caption?: StringWithAggregatesFilter<"ModerationTopic"> | string
  }

  export type ModerationTopicActionWhereInput = {
    AND?: ModerationTopicActionWhereInput | ModerationTopicActionWhereInput[]
    OR?: ModerationTopicActionWhereInput[]
    NOT?: ModerationTopicActionWhereInput | ModerationTopicActionWhereInput[]
    id?: IntFilter<"ModerationTopicAction"> | number
    parentId?: IntFilter<"ModerationTopicAction"> | number
    type?: StringFilter<"ModerationTopicAction"> | string
    caption?: StringFilter<"ModerationTopicAction"> | string
    messageText?: StringFilter<"ModerationTopicAction"> | string
    defaultSanction?: StringFilter<"ModerationTopicAction"> | string
    muteTime?: IntFilter<"ModerationTopicAction"> | number
    banTime?: IntFilter<"ModerationTopicAction"> | number
    ipTime?: IntFilter<"ModerationTopicAction"> | number
    tradeLockTime?: IntFilter<"ModerationTopicAction"> | number
  }

  export type ModerationTopicActionOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    messageText?: SortOrder
    defaultSanction?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
  }

  export type ModerationTopicActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModerationTopicActionWhereInput | ModerationTopicActionWhereInput[]
    OR?: ModerationTopicActionWhereInput[]
    NOT?: ModerationTopicActionWhereInput | ModerationTopicActionWhereInput[]
    parentId?: IntFilter<"ModerationTopicAction"> | number
    type?: StringFilter<"ModerationTopicAction"> | string
    caption?: StringFilter<"ModerationTopicAction"> | string
    messageText?: StringFilter<"ModerationTopicAction"> | string
    defaultSanction?: StringFilter<"ModerationTopicAction"> | string
    muteTime?: IntFilter<"ModerationTopicAction"> | number
    banTime?: IntFilter<"ModerationTopicAction"> | number
    ipTime?: IntFilter<"ModerationTopicAction"> | number
    tradeLockTime?: IntFilter<"ModerationTopicAction"> | number
  }, "id">

  export type ModerationTopicActionOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    messageText?: SortOrder
    defaultSanction?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
    _count?: ModerationTopicActionCountOrderByAggregateInput
    _avg?: ModerationTopicActionAvgOrderByAggregateInput
    _max?: ModerationTopicActionMaxOrderByAggregateInput
    _min?: ModerationTopicActionMinOrderByAggregateInput
    _sum?: ModerationTopicActionSumOrderByAggregateInput
  }

  export type ModerationTopicActionScalarWhereWithAggregatesInput = {
    AND?: ModerationTopicActionScalarWhereWithAggregatesInput | ModerationTopicActionScalarWhereWithAggregatesInput[]
    OR?: ModerationTopicActionScalarWhereWithAggregatesInput[]
    NOT?: ModerationTopicActionScalarWhereWithAggregatesInput | ModerationTopicActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModerationTopicAction"> | number
    parentId?: IntWithAggregatesFilter<"ModerationTopicAction"> | number
    type?: StringWithAggregatesFilter<"ModerationTopicAction"> | string
    caption?: StringWithAggregatesFilter<"ModerationTopicAction"> | string
    messageText?: StringWithAggregatesFilter<"ModerationTopicAction"> | string
    defaultSanction?: StringWithAggregatesFilter<"ModerationTopicAction"> | string
    muteTime?: IntWithAggregatesFilter<"ModerationTopicAction"> | number
    banTime?: IntWithAggregatesFilter<"ModerationTopicAction"> | number
    ipTime?: IntWithAggregatesFilter<"ModerationTopicAction"> | number
    tradeLockTime?: IntWithAggregatesFilter<"ModerationTopicAction"> | number
  }

  export type NavigatorCategoryWhereInput = {
    AND?: NavigatorCategoryWhereInput | NavigatorCategoryWhereInput[]
    OR?: NavigatorCategoryWhereInput[]
    NOT?: NavigatorCategoryWhereInput | NavigatorCategoryWhereInput[]
    id?: IntFilter<"NavigatorCategory"> | number
    category?: EnumNavigatorCategoryCategoryFilter<"NavigatorCategory"> | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringFilter<"NavigatorCategory"> | string
    publicName?: StringFilter<"NavigatorCategory"> | string
    viewMode?: EnumNavigatorCategoryViewModeFilter<"NavigatorCategory"> | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntFilter<"NavigatorCategory"> | number
    categoryType?: StringFilter<"NavigatorCategory"> | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceFilter<"NavigatorCategory"> | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolFilter<"NavigatorCategory"> | boolean
    enabled?: BoolFilter<"NavigatorCategory"> | boolean
    orderId?: IntFilter<"NavigatorCategory"> | number
  }

  export type NavigatorCategoryOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    categoryIdentifier?: SortOrder
    publicName?: SortOrder
    viewMode?: SortOrder
    requiredRank?: SortOrder
    categoryType?: SortOrder
    searchAllowance?: SortOrder
    minimized?: SortOrder
    enabled?: SortOrder
    orderId?: SortOrder
  }

  export type NavigatorCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NavigatorCategoryWhereInput | NavigatorCategoryWhereInput[]
    OR?: NavigatorCategoryWhereInput[]
    NOT?: NavigatorCategoryWhereInput | NavigatorCategoryWhereInput[]
    category?: EnumNavigatorCategoryCategoryFilter<"NavigatorCategory"> | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringFilter<"NavigatorCategory"> | string
    publicName?: StringFilter<"NavigatorCategory"> | string
    viewMode?: EnumNavigatorCategoryViewModeFilter<"NavigatorCategory"> | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntFilter<"NavigatorCategory"> | number
    categoryType?: StringFilter<"NavigatorCategory"> | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceFilter<"NavigatorCategory"> | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolFilter<"NavigatorCategory"> | boolean
    enabled?: BoolFilter<"NavigatorCategory"> | boolean
    orderId?: IntFilter<"NavigatorCategory"> | number
  }, "id">

  export type NavigatorCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    categoryIdentifier?: SortOrder
    publicName?: SortOrder
    viewMode?: SortOrder
    requiredRank?: SortOrder
    categoryType?: SortOrder
    searchAllowance?: SortOrder
    minimized?: SortOrder
    enabled?: SortOrder
    orderId?: SortOrder
    _count?: NavigatorCategoryCountOrderByAggregateInput
    _avg?: NavigatorCategoryAvgOrderByAggregateInput
    _max?: NavigatorCategoryMaxOrderByAggregateInput
    _min?: NavigatorCategoryMinOrderByAggregateInput
    _sum?: NavigatorCategorySumOrderByAggregateInput
  }

  export type NavigatorCategoryScalarWhereWithAggregatesInput = {
    AND?: NavigatorCategoryScalarWhereWithAggregatesInput | NavigatorCategoryScalarWhereWithAggregatesInput[]
    OR?: NavigatorCategoryScalarWhereWithAggregatesInput[]
    NOT?: NavigatorCategoryScalarWhereWithAggregatesInput | NavigatorCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NavigatorCategory"> | number
    category?: EnumNavigatorCategoryCategoryWithAggregatesFilter<"NavigatorCategory"> | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringWithAggregatesFilter<"NavigatorCategory"> | string
    publicName?: StringWithAggregatesFilter<"NavigatorCategory"> | string
    viewMode?: EnumNavigatorCategoryViewModeWithAggregatesFilter<"NavigatorCategory"> | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntWithAggregatesFilter<"NavigatorCategory"> | number
    categoryType?: StringWithAggregatesFilter<"NavigatorCategory"> | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceWithAggregatesFilter<"NavigatorCategory"> | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolWithAggregatesFilter<"NavigatorCategory"> | boolean
    enabled?: BoolWithAggregatesFilter<"NavigatorCategory"> | boolean
    orderId?: IntWithAggregatesFilter<"NavigatorCategory"> | number
  }

  export type NavigatorPublicWhereInput = {
    AND?: NavigatorPublicWhereInput | NavigatorPublicWhereInput[]
    OR?: NavigatorPublicWhereInput[]
    NOT?: NavigatorPublicWhereInput | NavigatorPublicWhereInput[]
    roomId?: IntFilter<"NavigatorPublic"> | number
    imageUrl?: StringNullableFilter<"NavigatorPublic"> | string | null
    orderNum?: IntFilter<"NavigatorPublic"> | number
    enabled?: BoolFilter<"NavigatorPublic"> | boolean
    langue?: EnumNavigatorPublicLangueFilter<"NavigatorPublic"> | $Enums.NavigatorPublicLangue
    categoryType?: StringFilter<"NavigatorPublic"> | string
  }

  export type NavigatorPublicOrderByWithRelationInput = {
    roomId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    orderNum?: SortOrder
    enabled?: SortOrder
    langue?: SortOrder
    categoryType?: SortOrder
  }

  export type NavigatorPublicWhereUniqueInput = Prisma.AtLeast<{
    roomId?: number
    AND?: NavigatorPublicWhereInput | NavigatorPublicWhereInput[]
    OR?: NavigatorPublicWhereInput[]
    NOT?: NavigatorPublicWhereInput | NavigatorPublicWhereInput[]
    imageUrl?: StringNullableFilter<"NavigatorPublic"> | string | null
    orderNum?: IntFilter<"NavigatorPublic"> | number
    enabled?: BoolFilter<"NavigatorPublic"> | boolean
    langue?: EnumNavigatorPublicLangueFilter<"NavigatorPublic"> | $Enums.NavigatorPublicLangue
    categoryType?: StringFilter<"NavigatorPublic"> | string
  }, "roomId">

  export type NavigatorPublicOrderByWithAggregationInput = {
    roomId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    orderNum?: SortOrder
    enabled?: SortOrder
    langue?: SortOrder
    categoryType?: SortOrder
    _count?: NavigatorPublicCountOrderByAggregateInput
    _avg?: NavigatorPublicAvgOrderByAggregateInput
    _max?: NavigatorPublicMaxOrderByAggregateInput
    _min?: NavigatorPublicMinOrderByAggregateInput
    _sum?: NavigatorPublicSumOrderByAggregateInput
  }

  export type NavigatorPublicScalarWhereWithAggregatesInput = {
    AND?: NavigatorPublicScalarWhereWithAggregatesInput | NavigatorPublicScalarWhereWithAggregatesInput[]
    OR?: NavigatorPublicScalarWhereWithAggregatesInput[]
    NOT?: NavigatorPublicScalarWhereWithAggregatesInput | NavigatorPublicScalarWhereWithAggregatesInput[]
    roomId?: IntWithAggregatesFilter<"NavigatorPublic"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"NavigatorPublic"> | string | null
    orderNum?: IntWithAggregatesFilter<"NavigatorPublic"> | number
    enabled?: BoolWithAggregatesFilter<"NavigatorPublic"> | boolean
    langue?: EnumNavigatorPublicLangueWithAggregatesFilter<"NavigatorPublic"> | $Enums.NavigatorPublicLangue
    categoryType?: StringWithAggregatesFilter<"NavigatorPublic"> | string
  }

  export type RoleplayWhereInput = {
    AND?: RoleplayWhereInput | RoleplayWhereInput[]
    OR?: RoleplayWhereInput[]
    NOT?: RoleplayWhereInput | RoleplayWhereInput[]
    id?: IntFilter<"Roleplay"> | number
    ownerId?: IntFilter<"Roleplay"> | number
    hopitalId?: IntFilter<"Roleplay"> | number
    prisonId?: IntFilter<"Roleplay"> | number
  }

  export type RoleplayOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
  }

  export type RoleplayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleplayWhereInput | RoleplayWhereInput[]
    OR?: RoleplayWhereInput[]
    NOT?: RoleplayWhereInput | RoleplayWhereInput[]
    ownerId?: IntFilter<"Roleplay"> | number
    hopitalId?: IntFilter<"Roleplay"> | number
    prisonId?: IntFilter<"Roleplay"> | number
  }, "id">

  export type RoleplayOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
    _count?: RoleplayCountOrderByAggregateInput
    _avg?: RoleplayAvgOrderByAggregateInput
    _max?: RoleplayMaxOrderByAggregateInput
    _min?: RoleplayMinOrderByAggregateInput
    _sum?: RoleplaySumOrderByAggregateInput
  }

  export type RoleplayScalarWhereWithAggregatesInput = {
    AND?: RoleplayScalarWhereWithAggregatesInput | RoleplayScalarWhereWithAggregatesInput[]
    OR?: RoleplayScalarWhereWithAggregatesInput[]
    NOT?: RoleplayScalarWhereWithAggregatesInput | RoleplayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roleplay"> | number
    ownerId?: IntWithAggregatesFilter<"Roleplay"> | number
    hopitalId?: IntWithAggregatesFilter<"Roleplay"> | number
    prisonId?: IntWithAggregatesFilter<"Roleplay"> | number
  }

  export type RoleplayEnemyWhereInput = {
    AND?: RoleplayEnemyWhereInput | RoleplayEnemyWhereInput[]
    OR?: RoleplayEnemyWhereInput[]
    NOT?: RoleplayEnemyWhereInput | RoleplayEnemyWhereInput[]
    id?: IntFilter<"RoleplayEnemy"> | number
    type?: EnumRoleplayEnemyTypeFilter<"RoleplayEnemy"> | $Enums.RoleplayEnemyType
    health?: IntFilter<"RoleplayEnemy"> | number
    weaponFarId?: IntFilter<"RoleplayEnemy"> | number
    weaponCacId?: IntFilter<"RoleplayEnemy"> | number
    deadTimer?: IntFilter<"RoleplayEnemy"> | number
    lootItemId?: IntFilter<"RoleplayEnemy"> | number
    moneyDrop?: IntFilter<"RoleplayEnemy"> | number
    dropScriptId?: IntFilter<"RoleplayEnemy"> | number
    teamId?: IntFilter<"RoleplayEnemy"> | number
    aggroDistance?: IntFilter<"RoleplayEnemy"> | number
    zoneDistance?: IntFilter<"RoleplayEnemy"> | number
    resetPosition?: BoolFilter<"RoleplayEnemy"> | boolean
    lostAggroDistance?: IntFilter<"RoleplayEnemy"> | number
    zombieMode?: BoolFilter<"RoleplayEnemy"> | boolean
  }

  export type RoleplayEnemyOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    resetPosition?: SortOrder
    lostAggroDistance?: SortOrder
    zombieMode?: SortOrder
  }

  export type RoleplayEnemyWhereUniqueInput = Prisma.AtLeast<{
    id_type?: RoleplayEnemyIdTypeCompoundUniqueInput
    AND?: RoleplayEnemyWhereInput | RoleplayEnemyWhereInput[]
    OR?: RoleplayEnemyWhereInput[]
    NOT?: RoleplayEnemyWhereInput | RoleplayEnemyWhereInput[]
    id?: IntFilter<"RoleplayEnemy"> | number
    type?: EnumRoleplayEnemyTypeFilter<"RoleplayEnemy"> | $Enums.RoleplayEnemyType
    health?: IntFilter<"RoleplayEnemy"> | number
    weaponFarId?: IntFilter<"RoleplayEnemy"> | number
    weaponCacId?: IntFilter<"RoleplayEnemy"> | number
    deadTimer?: IntFilter<"RoleplayEnemy"> | number
    lootItemId?: IntFilter<"RoleplayEnemy"> | number
    moneyDrop?: IntFilter<"RoleplayEnemy"> | number
    dropScriptId?: IntFilter<"RoleplayEnemy"> | number
    teamId?: IntFilter<"RoleplayEnemy"> | number
    aggroDistance?: IntFilter<"RoleplayEnemy"> | number
    zoneDistance?: IntFilter<"RoleplayEnemy"> | number
    resetPosition?: BoolFilter<"RoleplayEnemy"> | boolean
    lostAggroDistance?: IntFilter<"RoleplayEnemy"> | number
    zombieMode?: BoolFilter<"RoleplayEnemy"> | boolean
  }, "id_type">

  export type RoleplayEnemyOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    resetPosition?: SortOrder
    lostAggroDistance?: SortOrder
    zombieMode?: SortOrder
    _count?: RoleplayEnemyCountOrderByAggregateInput
    _avg?: RoleplayEnemyAvgOrderByAggregateInput
    _max?: RoleplayEnemyMaxOrderByAggregateInput
    _min?: RoleplayEnemyMinOrderByAggregateInput
    _sum?: RoleplayEnemySumOrderByAggregateInput
  }

  export type RoleplayEnemyScalarWhereWithAggregatesInput = {
    AND?: RoleplayEnemyScalarWhereWithAggregatesInput | RoleplayEnemyScalarWhereWithAggregatesInput[]
    OR?: RoleplayEnemyScalarWhereWithAggregatesInput[]
    NOT?: RoleplayEnemyScalarWhereWithAggregatesInput | RoleplayEnemyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    type?: EnumRoleplayEnemyTypeWithAggregatesFilter<"RoleplayEnemy"> | $Enums.RoleplayEnemyType
    health?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    weaponFarId?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    weaponCacId?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    deadTimer?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    lootItemId?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    moneyDrop?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    dropScriptId?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    teamId?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    aggroDistance?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    zoneDistance?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    resetPosition?: BoolWithAggregatesFilter<"RoleplayEnemy"> | boolean
    lostAggroDistance?: IntWithAggregatesFilter<"RoleplayEnemy"> | number
    zombieMode?: BoolWithAggregatesFilter<"RoleplayEnemy"> | boolean
  }

  export type RoleplayItemWhereInput = {
    AND?: RoleplayItemWhereInput | RoleplayItemWhereInput[]
    OR?: RoleplayItemWhereInput[]
    NOT?: RoleplayItemWhereInput | RoleplayItemWhereInput[]
    id?: IntFilter<"RoleplayItem"> | number
    name?: StringFilter<"RoleplayItem"> | string
    desc?: StringNullableFilter<"RoleplayItem"> | string | null
    price?: IntFilter<"RoleplayItem"> | number
    type?: EnumRoleplayItemTypeFilter<"RoleplayItem"> | $Enums.RoleplayItemType
    value?: IntFilter<"RoleplayItem"> | number
    allowstack?: BoolFilter<"RoleplayItem"> | boolean
    category?: EnumRoleplayItemCategoryFilter<"RoleplayItem"> | $Enums.RoleplayItemCategory
  }

  export type RoleplayItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    price?: SortOrder
    type?: SortOrder
    value?: SortOrder
    allowstack?: SortOrder
    category?: SortOrder
  }

  export type RoleplayItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleplayItemWhereInput | RoleplayItemWhereInput[]
    OR?: RoleplayItemWhereInput[]
    NOT?: RoleplayItemWhereInput | RoleplayItemWhereInput[]
    name?: StringFilter<"RoleplayItem"> | string
    desc?: StringNullableFilter<"RoleplayItem"> | string | null
    price?: IntFilter<"RoleplayItem"> | number
    type?: EnumRoleplayItemTypeFilter<"RoleplayItem"> | $Enums.RoleplayItemType
    value?: IntFilter<"RoleplayItem"> | number
    allowstack?: BoolFilter<"RoleplayItem"> | boolean
    category?: EnumRoleplayItemCategoryFilter<"RoleplayItem"> | $Enums.RoleplayItemCategory
  }, "id">

  export type RoleplayItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    price?: SortOrder
    type?: SortOrder
    value?: SortOrder
    allowstack?: SortOrder
    category?: SortOrder
    _count?: RoleplayItemCountOrderByAggregateInput
    _avg?: RoleplayItemAvgOrderByAggregateInput
    _max?: RoleplayItemMaxOrderByAggregateInput
    _min?: RoleplayItemMinOrderByAggregateInput
    _sum?: RoleplayItemSumOrderByAggregateInput
  }

  export type RoleplayItemScalarWhereWithAggregatesInput = {
    AND?: RoleplayItemScalarWhereWithAggregatesInput | RoleplayItemScalarWhereWithAggregatesInput[]
    OR?: RoleplayItemScalarWhereWithAggregatesInput[]
    NOT?: RoleplayItemScalarWhereWithAggregatesInput | RoleplayItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleplayItem"> | number
    name?: StringWithAggregatesFilter<"RoleplayItem"> | string
    desc?: StringNullableWithAggregatesFilter<"RoleplayItem"> | string | null
    price?: IntWithAggregatesFilter<"RoleplayItem"> | number
    type?: EnumRoleplayItemTypeWithAggregatesFilter<"RoleplayItem"> | $Enums.RoleplayItemType
    value?: IntWithAggregatesFilter<"RoleplayItem"> | number
    allowstack?: BoolWithAggregatesFilter<"RoleplayItem"> | boolean
    category?: EnumRoleplayItemCategoryWithAggregatesFilter<"RoleplayItem"> | $Enums.RoleplayItemCategory
  }

  export type RoleplayWeaponWhereInput = {
    AND?: RoleplayWeaponWhereInput | RoleplayWeaponWhereInput[]
    OR?: RoleplayWeaponWhereInput[]
    NOT?: RoleplayWeaponWhereInput | RoleplayWeaponWhereInput[]
    id?: IntFilter<"RoleplayWeapon"> | number
    type?: EnumRoleplayWeaponTypeFilter<"RoleplayWeapon"> | $Enums.RoleplayWeaponType
    domageMin?: IntFilter<"RoleplayWeapon"> | number
    domageMax?: IntFilter<"RoleplayWeapon"> | number
    interaction?: EnumRoleplayWeaponInteractionFilter<"RoleplayWeapon"> | $Enums.RoleplayWeaponInteraction
    enable?: IntFilter<"RoleplayWeapon"> | number
    freezeTime?: IntFilter<"RoleplayWeapon"> | number
    distance?: IntFilter<"RoleplayWeapon"> | number
  }

  export type RoleplayWeaponOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    interaction?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
  }

  export type RoleplayWeaponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleplayWeaponWhereInput | RoleplayWeaponWhereInput[]
    OR?: RoleplayWeaponWhereInput[]
    NOT?: RoleplayWeaponWhereInput | RoleplayWeaponWhereInput[]
    type?: EnumRoleplayWeaponTypeFilter<"RoleplayWeapon"> | $Enums.RoleplayWeaponType
    domageMin?: IntFilter<"RoleplayWeapon"> | number
    domageMax?: IntFilter<"RoleplayWeapon"> | number
    interaction?: EnumRoleplayWeaponInteractionFilter<"RoleplayWeapon"> | $Enums.RoleplayWeaponInteraction
    enable?: IntFilter<"RoleplayWeapon"> | number
    freezeTime?: IntFilter<"RoleplayWeapon"> | number
    distance?: IntFilter<"RoleplayWeapon"> | number
  }, "id">

  export type RoleplayWeaponOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    interaction?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
    _count?: RoleplayWeaponCountOrderByAggregateInput
    _avg?: RoleplayWeaponAvgOrderByAggregateInput
    _max?: RoleplayWeaponMaxOrderByAggregateInput
    _min?: RoleplayWeaponMinOrderByAggregateInput
    _sum?: RoleplayWeaponSumOrderByAggregateInput
  }

  export type RoleplayWeaponScalarWhereWithAggregatesInput = {
    AND?: RoleplayWeaponScalarWhereWithAggregatesInput | RoleplayWeaponScalarWhereWithAggregatesInput[]
    OR?: RoleplayWeaponScalarWhereWithAggregatesInput[]
    NOT?: RoleplayWeaponScalarWhereWithAggregatesInput | RoleplayWeaponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoleplayWeapon"> | number
    type?: EnumRoleplayWeaponTypeWithAggregatesFilter<"RoleplayWeapon"> | $Enums.RoleplayWeaponType
    domageMin?: IntWithAggregatesFilter<"RoleplayWeapon"> | number
    domageMax?: IntWithAggregatesFilter<"RoleplayWeapon"> | number
    interaction?: EnumRoleplayWeaponInteractionWithAggregatesFilter<"RoleplayWeapon"> | $Enums.RoleplayWeaponInteraction
    enable?: IntWithAggregatesFilter<"RoleplayWeapon"> | number
    freezeTime?: IntWithAggregatesFilter<"RoleplayWeapon"> | number
    distance?: IntWithAggregatesFilter<"RoleplayWeapon"> | number
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    caption?: StringFilter<"Room"> | string
    owner?: StringFilter<"Room"> | string
    description?: StringNullableFilter<"Room"> | string | null
    category?: IntFilter<"Room"> | number
    state?: EnumRoomStateFilter<"Room"> | $Enums.RoomState
    usersMax?: IntFilter<"Room"> | number
    modelName?: StringFilter<"Room"> | string
    score?: IntFilter<"Room"> | number
    tags?: StringNullableFilter<"Room"> | string | null
    password?: StringNullableFilter<"Room"> | string | null
    wallpaper?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    landscape?: StringFilter<"Room"> | string
    allowPets?: BoolFilter<"Room"> | boolean
    allowPetsEat?: BoolFilter<"Room"> | boolean
    allowWalkthrough?: BoolFilter<"Room"> | boolean
    allowHidewall?: BoolFilter<"Room"> | boolean
    wallthick?: IntFilter<"Room"> | number
    floorthick?: IntFilter<"Room"> | number
    moderationMuteFuse?: BoolFilter<"Room"> | boolean
    allowRightsoverride?: BoolFilter<"Room"> | boolean
    moderationKickFuse?: IntFilter<"Room"> | number
    moderationBanFuse?: BoolFilter<"Room"> | boolean
    groupId?: IntFilter<"Room"> | number
    chatType?: IntFilter<"Room"> | number
    chatBalloon?: IntFilter<"Room"> | number
    chatSpeed?: IntFilter<"Room"> | number
    chatMaxDistance?: IntFilter<"Room"> | number
    chatFloodProtection?: IntFilter<"Room"> | number
    trocStatus?: IntFilter<"Room"> | number
    usersNow?: IntFilter<"Room"> | number
    allowHidewireds?: BoolFilter<"Room"> | boolean
    price?: IntFilter<"Room"> | number
    wiredSecurity?: BoolFilter<"Room"> | boolean
    LogChat?: LogChatListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    caption?: SortOrder
    owner?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    state?: SortOrder
    usersMax?: SortOrder
    modelName?: SortOrder
    score?: SortOrder
    tags?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    wallpaper?: SortOrder
    floor?: SortOrder
    landscape?: SortOrder
    allowPets?: SortOrder
    allowPetsEat?: SortOrder
    allowWalkthrough?: SortOrder
    allowHidewall?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationMuteFuse?: SortOrder
    allowRightsoverride?: SortOrder
    moderationKickFuse?: SortOrder
    moderationBanFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    allowHidewireds?: SortOrder
    price?: SortOrder
    wiredSecurity?: SortOrder
    LogChat?: LogChatOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    caption?: StringFilter<"Room"> | string
    owner?: StringFilter<"Room"> | string
    description?: StringNullableFilter<"Room"> | string | null
    category?: IntFilter<"Room"> | number
    state?: EnumRoomStateFilter<"Room"> | $Enums.RoomState
    usersMax?: IntFilter<"Room"> | number
    modelName?: StringFilter<"Room"> | string
    score?: IntFilter<"Room"> | number
    tags?: StringNullableFilter<"Room"> | string | null
    password?: StringNullableFilter<"Room"> | string | null
    wallpaper?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    landscape?: StringFilter<"Room"> | string
    allowPets?: BoolFilter<"Room"> | boolean
    allowPetsEat?: BoolFilter<"Room"> | boolean
    allowWalkthrough?: BoolFilter<"Room"> | boolean
    allowHidewall?: BoolFilter<"Room"> | boolean
    wallthick?: IntFilter<"Room"> | number
    floorthick?: IntFilter<"Room"> | number
    moderationMuteFuse?: BoolFilter<"Room"> | boolean
    allowRightsoverride?: BoolFilter<"Room"> | boolean
    moderationKickFuse?: IntFilter<"Room"> | number
    moderationBanFuse?: BoolFilter<"Room"> | boolean
    groupId?: IntFilter<"Room"> | number
    chatType?: IntFilter<"Room"> | number
    chatBalloon?: IntFilter<"Room"> | number
    chatSpeed?: IntFilter<"Room"> | number
    chatMaxDistance?: IntFilter<"Room"> | number
    chatFloodProtection?: IntFilter<"Room"> | number
    trocStatus?: IntFilter<"Room"> | number
    usersNow?: IntFilter<"Room"> | number
    allowHidewireds?: BoolFilter<"Room"> | boolean
    price?: IntFilter<"Room"> | number
    wiredSecurity?: BoolFilter<"Room"> | boolean
    LogChat?: LogChatListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    caption?: SortOrder
    owner?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    state?: SortOrder
    usersMax?: SortOrder
    modelName?: SortOrder
    score?: SortOrder
    tags?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    wallpaper?: SortOrder
    floor?: SortOrder
    landscape?: SortOrder
    allowPets?: SortOrder
    allowPetsEat?: SortOrder
    allowWalkthrough?: SortOrder
    allowHidewall?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationMuteFuse?: SortOrder
    allowRightsoverride?: SortOrder
    moderationKickFuse?: SortOrder
    moderationBanFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    allowHidewireds?: SortOrder
    price?: SortOrder
    wiredSecurity?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    caption?: StringWithAggregatesFilter<"Room"> | string
    owner?: StringWithAggregatesFilter<"Room"> | string
    description?: StringNullableWithAggregatesFilter<"Room"> | string | null
    category?: IntWithAggregatesFilter<"Room"> | number
    state?: EnumRoomStateWithAggregatesFilter<"Room"> | $Enums.RoomState
    usersMax?: IntWithAggregatesFilter<"Room"> | number
    modelName?: StringWithAggregatesFilter<"Room"> | string
    score?: IntWithAggregatesFilter<"Room"> | number
    tags?: StringNullableWithAggregatesFilter<"Room"> | string | null
    password?: StringNullableWithAggregatesFilter<"Room"> | string | null
    wallpaper?: StringWithAggregatesFilter<"Room"> | string
    floor?: StringWithAggregatesFilter<"Room"> | string
    landscape?: StringWithAggregatesFilter<"Room"> | string
    allowPets?: BoolWithAggregatesFilter<"Room"> | boolean
    allowPetsEat?: BoolWithAggregatesFilter<"Room"> | boolean
    allowWalkthrough?: BoolWithAggregatesFilter<"Room"> | boolean
    allowHidewall?: BoolWithAggregatesFilter<"Room"> | boolean
    wallthick?: IntWithAggregatesFilter<"Room"> | number
    floorthick?: IntWithAggregatesFilter<"Room"> | number
    moderationMuteFuse?: BoolWithAggregatesFilter<"Room"> | boolean
    allowRightsoverride?: BoolWithAggregatesFilter<"Room"> | boolean
    moderationKickFuse?: IntWithAggregatesFilter<"Room"> | number
    moderationBanFuse?: BoolWithAggregatesFilter<"Room"> | boolean
    groupId?: IntWithAggregatesFilter<"Room"> | number
    chatType?: IntWithAggregatesFilter<"Room"> | number
    chatBalloon?: IntWithAggregatesFilter<"Room"> | number
    chatSpeed?: IntWithAggregatesFilter<"Room"> | number
    chatMaxDistance?: IntWithAggregatesFilter<"Room"> | number
    chatFloodProtection?: IntWithAggregatesFilter<"Room"> | number
    trocStatus?: IntWithAggregatesFilter<"Room"> | number
    usersNow?: IntWithAggregatesFilter<"Room"> | number
    allowHidewireds?: BoolWithAggregatesFilter<"Room"> | boolean
    price?: IntWithAggregatesFilter<"Room"> | number
    wiredSecurity?: BoolWithAggregatesFilter<"Room"> | boolean
  }

  export type RoomModelWhereInput = {
    AND?: RoomModelWhereInput | RoomModelWhereInput[]
    OR?: RoomModelWhereInput[]
    NOT?: RoomModelWhereInput | RoomModelWhereInput[]
    id?: StringFilter<"RoomModel"> | string
    doorX?: IntFilter<"RoomModel"> | number
    doorY?: IntFilter<"RoomModel"> | number
    doorZ?: FloatFilter<"RoomModel"> | number
    doorDir?: IntFilter<"RoomModel"> | number
    heightmap?: StringFilter<"RoomModel"> | string
  }

  export type RoomModelOrderByWithRelationInput = {
    id?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
  }

  export type RoomModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomModelWhereInput | RoomModelWhereInput[]
    OR?: RoomModelWhereInput[]
    NOT?: RoomModelWhereInput | RoomModelWhereInput[]
    doorX?: IntFilter<"RoomModel"> | number
    doorY?: IntFilter<"RoomModel"> | number
    doorZ?: FloatFilter<"RoomModel"> | number
    doorDir?: IntFilter<"RoomModel"> | number
    heightmap?: StringFilter<"RoomModel"> | string
  }, "id">

  export type RoomModelOrderByWithAggregationInput = {
    id?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
    _count?: RoomModelCountOrderByAggregateInput
    _avg?: RoomModelAvgOrderByAggregateInput
    _max?: RoomModelMaxOrderByAggregateInput
    _min?: RoomModelMinOrderByAggregateInput
    _sum?: RoomModelSumOrderByAggregateInput
  }

  export type RoomModelScalarWhereWithAggregatesInput = {
    AND?: RoomModelScalarWhereWithAggregatesInput | RoomModelScalarWhereWithAggregatesInput[]
    OR?: RoomModelScalarWhereWithAggregatesInput[]
    NOT?: RoomModelScalarWhereWithAggregatesInput | RoomModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomModel"> | string
    doorX?: IntWithAggregatesFilter<"RoomModel"> | number
    doorY?: IntWithAggregatesFilter<"RoomModel"> | number
    doorZ?: FloatWithAggregatesFilter<"RoomModel"> | number
    doorDir?: IntWithAggregatesFilter<"RoomModel"> | number
    heightmap?: StringWithAggregatesFilter<"RoomModel"> | string
  }

  export type RoomModelCustomWhereInput = {
    AND?: RoomModelCustomWhereInput | RoomModelCustomWhereInput[]
    OR?: RoomModelCustomWhereInput[]
    NOT?: RoomModelCustomWhereInput | RoomModelCustomWhereInput[]
    roomId?: IntFilter<"RoomModelCustom"> | number
    doorX?: IntFilter<"RoomModelCustom"> | number
    doorY?: IntFilter<"RoomModelCustom"> | number
    doorZ?: FloatFilter<"RoomModelCustom"> | number
    doorDir?: IntFilter<"RoomModelCustom"> | number
    heightmap?: StringFilter<"RoomModelCustom"> | string
    wallHeight?: IntFilter<"RoomModelCustom"> | number
  }

  export type RoomModelCustomOrderByWithRelationInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
    wallHeight?: SortOrder
  }

  export type RoomModelCustomWhereUniqueInput = Prisma.AtLeast<{
    roomId?: number
    AND?: RoomModelCustomWhereInput | RoomModelCustomWhereInput[]
    OR?: RoomModelCustomWhereInput[]
    NOT?: RoomModelCustomWhereInput | RoomModelCustomWhereInput[]
    doorX?: IntFilter<"RoomModelCustom"> | number
    doorY?: IntFilter<"RoomModelCustom"> | number
    doorZ?: FloatFilter<"RoomModelCustom"> | number
    doorDir?: IntFilter<"RoomModelCustom"> | number
    heightmap?: StringFilter<"RoomModelCustom"> | string
    wallHeight?: IntFilter<"RoomModelCustom"> | number
  }, "roomId">

  export type RoomModelCustomOrderByWithAggregationInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
    wallHeight?: SortOrder
    _count?: RoomModelCustomCountOrderByAggregateInput
    _avg?: RoomModelCustomAvgOrderByAggregateInput
    _max?: RoomModelCustomMaxOrderByAggregateInput
    _min?: RoomModelCustomMinOrderByAggregateInput
    _sum?: RoomModelCustomSumOrderByAggregateInput
  }

  export type RoomModelCustomScalarWhereWithAggregatesInput = {
    AND?: RoomModelCustomScalarWhereWithAggregatesInput | RoomModelCustomScalarWhereWithAggregatesInput[]
    OR?: RoomModelCustomScalarWhereWithAggregatesInput[]
    NOT?: RoomModelCustomScalarWhereWithAggregatesInput | RoomModelCustomScalarWhereWithAggregatesInput[]
    roomId?: IntWithAggregatesFilter<"RoomModelCustom"> | number
    doorX?: IntWithAggregatesFilter<"RoomModelCustom"> | number
    doorY?: IntWithAggregatesFilter<"RoomModelCustom"> | number
    doorZ?: FloatWithAggregatesFilter<"RoomModelCustom"> | number
    doorDir?: IntWithAggregatesFilter<"RoomModelCustom"> | number
    heightmap?: StringWithAggregatesFilter<"RoomModelCustom"> | string
    wallHeight?: IntWithAggregatesFilter<"RoomModelCustom"> | number
  }

  export type RoomRightWhereInput = {
    AND?: RoomRightWhereInput | RoomRightWhereInput[]
    OR?: RoomRightWhereInput[]
    NOT?: RoomRightWhereInput | RoomRightWhereInput[]
    roomId?: IntFilter<"RoomRight"> | number
    userId?: IntFilter<"RoomRight"> | number
  }

  export type RoomRightOrderByWithRelationInput = {
    roomId?: SortOrder
    userId?: SortOrder
  }

  export type RoomRightWhereUniqueInput = Prisma.AtLeast<{
    roomId_userId?: RoomRightRoomIdUserIdCompoundUniqueInput
    AND?: RoomRightWhereInput | RoomRightWhereInput[]
    OR?: RoomRightWhereInput[]
    NOT?: RoomRightWhereInput | RoomRightWhereInput[]
    roomId?: IntFilter<"RoomRight"> | number
    userId?: IntFilter<"RoomRight"> | number
  }, "roomId_userId">

  export type RoomRightOrderByWithAggregationInput = {
    roomId?: SortOrder
    userId?: SortOrder
    _count?: RoomRightCountOrderByAggregateInput
    _avg?: RoomRightAvgOrderByAggregateInput
    _max?: RoomRightMaxOrderByAggregateInput
    _min?: RoomRightMinOrderByAggregateInput
    _sum?: RoomRightSumOrderByAggregateInput
  }

  export type RoomRightScalarWhereWithAggregatesInput = {
    AND?: RoomRightScalarWhereWithAggregatesInput | RoomRightScalarWhereWithAggregatesInput[]
    OR?: RoomRightScalarWhereWithAggregatesInput[]
    NOT?: RoomRightScalarWhereWithAggregatesInput | RoomRightScalarWhereWithAggregatesInput[]
    roomId?: IntWithAggregatesFilter<"RoomRight"> | number
    userId?: IntWithAggregatesFilter<"RoomRight"> | number
  }

  export type RoomSwearwordFilterWhereInput = {
    AND?: RoomSwearwordFilterWhereInput | RoomSwearwordFilterWhereInput[]
    OR?: RoomSwearwordFilterWhereInput[]
    NOT?: RoomSwearwordFilterWhereInput | RoomSwearwordFilterWhereInput[]
    word?: StringFilter<"RoomSwearwordFilter"> | string
  }

  export type RoomSwearwordFilterOrderByWithRelationInput = {
    word?: SortOrder
  }

  export type RoomSwearwordFilterWhereUniqueInput = Prisma.AtLeast<{
    word?: string
    AND?: RoomSwearwordFilterWhereInput | RoomSwearwordFilterWhereInput[]
    OR?: RoomSwearwordFilterWhereInput[]
    NOT?: RoomSwearwordFilterWhereInput | RoomSwearwordFilterWhereInput[]
  }, "word">

  export type RoomSwearwordFilterOrderByWithAggregationInput = {
    word?: SortOrder
    _count?: RoomSwearwordFilterCountOrderByAggregateInput
    _max?: RoomSwearwordFilterMaxOrderByAggregateInput
    _min?: RoomSwearwordFilterMinOrderByAggregateInput
  }

  export type RoomSwearwordFilterScalarWhereWithAggregatesInput = {
    AND?: RoomSwearwordFilterScalarWhereWithAggregatesInput | RoomSwearwordFilterScalarWhereWithAggregatesInput[]
    OR?: RoomSwearwordFilterScalarWhereWithAggregatesInput[]
    NOT?: RoomSwearwordFilterScalarWhereWithAggregatesInput | RoomSwearwordFilterScalarWhereWithAggregatesInput[]
    word?: StringWithAggregatesFilter<"RoomSwearwordFilter"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    mail?: StringNullableFilter<"User"> | string | null
    authTicket?: StringNullableFilter<"User"> | string | null
    rank?: IntFilter<"User"> | number
    credits?: IntFilter<"User"> | number
    activityPoints?: IntFilter<"User"> | number
    look?: StringFilter<"User"> | string
    gender?: EnumUserGenderFilter<"User"> | $Enums.UserGender
    motto?: StringNullableFilter<"User"> | string | null
    accountCreated?: IntFilter<"User"> | number
    lastOnline?: IntFilter<"User"> | number
    online?: BoolFilter<"User"> | boolean
    ipLast?: StringNullableFilter<"User"> | string | null
    machineId?: StringNullableFilter<"User"> | string | null
    homeRoom?: IntFilter<"User"> | number
    blockNewfriends?: BoolFilter<"User"> | boolean
    hideOnline?: BoolFilter<"User"> | boolean
    hideInroom?: BoolFilter<"User"> | boolean
    lastOffline?: IntFilter<"User"> | number
    moisVip?: IntFilter<"User"> | number
    volume?: StringFilter<"User"> | string
    vipPoints?: IntFilter<"User"> | number
    limitCoins?: IntFilter<"User"> | number
    acceptTrading?: BoolFilter<"User"> | boolean
    cameraFollowDisabled?: BoolFilter<"User"> | boolean
    ignoreRoomInvite?: BoolFilter<"User"> | boolean
    lastdailycredits?: StringFilter<"User"> | string
    hideGamealert?: BoolFilter<"User"> | boolean
    ipcountry?: StringNullableFilter<"User"> | string | null
    gamePoints?: IntFilter<"User"> | number
    gamePointsMonth?: IntFilter<"User"> | number
    mazoscore?: IntFilter<"User"> | number
    mazo?: IntFilter<"User"> | number
    nuxEnable?: BoolFilter<"User"> | boolean
    langue?: EnumUserLangueFilter<"User"> | $Enums.UserLangue
    runPoints?: IntFilter<"User"> | number
    runPointsMonth?: IntFilter<"User"> | number
    isBanned?: BoolFilter<"User"> | boolean
    bannerId?: IntFilter<"User"> | number
    logLogin?: LogLoginListRelationFilter
    logChat?: LogChatListRelationFilter
    logSlotmachine?: LogSlotmachineListRelationFilter
    logShop?: LogShopListRelationFilter
    logLootbox?: LogLootboxListRelationFilter
    logSandbox?: LogSandboxListRelationFilter
    userOneTrade?: LogTradeListRelationFilter
    userTwoTrade?: LogTradeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mail?: SortOrderInput | SortOrder
    authTicket?: SortOrderInput | SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    look?: SortOrder
    gender?: SortOrder
    motto?: SortOrderInput | SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    online?: SortOrder
    ipLast?: SortOrderInput | SortOrder
    machineId?: SortOrderInput | SortOrder
    homeRoom?: SortOrder
    blockNewfriends?: SortOrder
    hideOnline?: SortOrder
    hideInroom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    volume?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    acceptTrading?: SortOrder
    cameraFollowDisabled?: SortOrder
    ignoreRoomInvite?: SortOrder
    lastdailycredits?: SortOrder
    hideGamealert?: SortOrder
    ipcountry?: SortOrderInput | SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    nuxEnable?: SortOrder
    langue?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    isBanned?: SortOrder
    bannerId?: SortOrder
    logLogin?: LogLoginOrderByRelationAggregateInput
    logChat?: LogChatOrderByRelationAggregateInput
    logSlotmachine?: LogSlotmachineOrderByRelationAggregateInput
    logShop?: LogShopOrderByRelationAggregateInput
    logLootbox?: LogLootboxOrderByRelationAggregateInput
    logSandbox?: LogSandboxOrderByRelationAggregateInput
    userOneTrade?: LogTradeOrderByRelationAggregateInput
    userTwoTrade?: LogTradeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    mail?: StringNullableFilter<"User"> | string | null
    authTicket?: StringNullableFilter<"User"> | string | null
    rank?: IntFilter<"User"> | number
    credits?: IntFilter<"User"> | number
    activityPoints?: IntFilter<"User"> | number
    look?: StringFilter<"User"> | string
    gender?: EnumUserGenderFilter<"User"> | $Enums.UserGender
    motto?: StringNullableFilter<"User"> | string | null
    accountCreated?: IntFilter<"User"> | number
    lastOnline?: IntFilter<"User"> | number
    online?: BoolFilter<"User"> | boolean
    ipLast?: StringNullableFilter<"User"> | string | null
    machineId?: StringNullableFilter<"User"> | string | null
    homeRoom?: IntFilter<"User"> | number
    blockNewfriends?: BoolFilter<"User"> | boolean
    hideOnline?: BoolFilter<"User"> | boolean
    hideInroom?: BoolFilter<"User"> | boolean
    lastOffline?: IntFilter<"User"> | number
    moisVip?: IntFilter<"User"> | number
    volume?: StringFilter<"User"> | string
    vipPoints?: IntFilter<"User"> | number
    limitCoins?: IntFilter<"User"> | number
    acceptTrading?: BoolFilter<"User"> | boolean
    cameraFollowDisabled?: BoolFilter<"User"> | boolean
    ignoreRoomInvite?: BoolFilter<"User"> | boolean
    lastdailycredits?: StringFilter<"User"> | string
    hideGamealert?: BoolFilter<"User"> | boolean
    ipcountry?: StringNullableFilter<"User"> | string | null
    gamePoints?: IntFilter<"User"> | number
    gamePointsMonth?: IntFilter<"User"> | number
    mazoscore?: IntFilter<"User"> | number
    mazo?: IntFilter<"User"> | number
    nuxEnable?: BoolFilter<"User"> | boolean
    langue?: EnumUserLangueFilter<"User"> | $Enums.UserLangue
    runPoints?: IntFilter<"User"> | number
    runPointsMonth?: IntFilter<"User"> | number
    isBanned?: BoolFilter<"User"> | boolean
    bannerId?: IntFilter<"User"> | number
    logLogin?: LogLoginListRelationFilter
    logChat?: LogChatListRelationFilter
    logSlotmachine?: LogSlotmachineListRelationFilter
    logShop?: LogShopListRelationFilter
    logLootbox?: LogLootboxListRelationFilter
    logSandbox?: LogSandboxListRelationFilter
    userOneTrade?: LogTradeListRelationFilter
    userTwoTrade?: LogTradeListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mail?: SortOrderInput | SortOrder
    authTicket?: SortOrderInput | SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    look?: SortOrder
    gender?: SortOrder
    motto?: SortOrderInput | SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    online?: SortOrder
    ipLast?: SortOrderInput | SortOrder
    machineId?: SortOrderInput | SortOrder
    homeRoom?: SortOrder
    blockNewfriends?: SortOrder
    hideOnline?: SortOrder
    hideInroom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    volume?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    acceptTrading?: SortOrder
    cameraFollowDisabled?: SortOrder
    ignoreRoomInvite?: SortOrder
    lastdailycredits?: SortOrder
    hideGamealert?: SortOrder
    ipcountry?: SortOrderInput | SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    nuxEnable?: SortOrder
    langue?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    isBanned?: SortOrder
    bannerId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    mail?: StringNullableWithAggregatesFilter<"User"> | string | null
    authTicket?: StringNullableWithAggregatesFilter<"User"> | string | null
    rank?: IntWithAggregatesFilter<"User"> | number
    credits?: IntWithAggregatesFilter<"User"> | number
    activityPoints?: IntWithAggregatesFilter<"User"> | number
    look?: StringWithAggregatesFilter<"User"> | string
    gender?: EnumUserGenderWithAggregatesFilter<"User"> | $Enums.UserGender
    motto?: StringNullableWithAggregatesFilter<"User"> | string | null
    accountCreated?: IntWithAggregatesFilter<"User"> | number
    lastOnline?: IntWithAggregatesFilter<"User"> | number
    online?: BoolWithAggregatesFilter<"User"> | boolean
    ipLast?: StringNullableWithAggregatesFilter<"User"> | string | null
    machineId?: StringNullableWithAggregatesFilter<"User"> | string | null
    homeRoom?: IntWithAggregatesFilter<"User"> | number
    blockNewfriends?: BoolWithAggregatesFilter<"User"> | boolean
    hideOnline?: BoolWithAggregatesFilter<"User"> | boolean
    hideInroom?: BoolWithAggregatesFilter<"User"> | boolean
    lastOffline?: IntWithAggregatesFilter<"User"> | number
    moisVip?: IntWithAggregatesFilter<"User"> | number
    volume?: StringWithAggregatesFilter<"User"> | string
    vipPoints?: IntWithAggregatesFilter<"User"> | number
    limitCoins?: IntWithAggregatesFilter<"User"> | number
    acceptTrading?: BoolWithAggregatesFilter<"User"> | boolean
    cameraFollowDisabled?: BoolWithAggregatesFilter<"User"> | boolean
    ignoreRoomInvite?: BoolWithAggregatesFilter<"User"> | boolean
    lastdailycredits?: StringWithAggregatesFilter<"User"> | string
    hideGamealert?: BoolWithAggregatesFilter<"User"> | boolean
    ipcountry?: StringNullableWithAggregatesFilter<"User"> | string | null
    gamePoints?: IntWithAggregatesFilter<"User"> | number
    gamePointsMonth?: IntWithAggregatesFilter<"User"> | number
    mazoscore?: IntWithAggregatesFilter<"User"> | number
    mazo?: IntWithAggregatesFilter<"User"> | number
    nuxEnable?: BoolWithAggregatesFilter<"User"> | boolean
    langue?: EnumUserLangueWithAggregatesFilter<"User"> | $Enums.UserLangue
    runPoints?: IntWithAggregatesFilter<"User"> | number
    runPointsMonth?: IntWithAggregatesFilter<"User"> | number
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    bannerId?: IntWithAggregatesFilter<"User"> | number
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: IntFilter<"UserAchievement"> | number
    group?: StringFilter<"UserAchievement"> | string
    level?: IntFilter<"UserAchievement"> | number
    progress?: IntFilter<"UserAchievement"> | number
  }

  export type UserAchievementOrderByWithRelationInput = {
    userId?: SortOrder
    group?: SortOrder
    level?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    userId_group?: UserAchievementUserIdGroupCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: IntFilter<"UserAchievement"> | number
    group?: StringFilter<"UserAchievement"> | string
    level?: IntFilter<"UserAchievement"> | number
    progress?: IntFilter<"UserAchievement"> | number
  }, "userId_group">

  export type UserAchievementOrderByWithAggregationInput = {
    userId?: SortOrder
    group?: SortOrder
    level?: SortOrder
    progress?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserAchievement"> | number
    group?: StringWithAggregatesFilter<"UserAchievement"> | string
    level?: IntWithAggregatesFilter<"UserAchievement"> | number
    progress?: IntWithAggregatesFilter<"UserAchievement"> | number
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: IntFilter<"UserBadge"> | number
    badgeId?: StringFilter<"UserBadge"> | string
    badgeSlot?: IntFilter<"UserBadge"> | number
  }

  export type UserBadgeOrderByWithRelationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    badgeSlot?: SortOrder
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: IntFilter<"UserBadge"> | number
    badgeId?: StringFilter<"UserBadge"> | string
    badgeSlot?: IntFilter<"UserBadge"> | number
  }, "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    badgeSlot?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _avg?: UserBadgeAvgOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
    _sum?: UserBadgeSumOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserBadge"> | number
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeSlot?: IntWithAggregatesFilter<"UserBadge"> | number
  }

  export type UserBannerWhereInput = {
    AND?: UserBannerWhereInput | UserBannerWhereInput[]
    OR?: UserBannerWhereInput[]
    NOT?: UserBannerWhereInput | UserBannerWhereInput[]
    id?: IntFilter<"UserBanner"> | number
    user_id?: IntFilter<"UserBanner"> | number
    banner_id?: IntFilter<"UserBanner"> | number
  }

  export type UserBannerOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
  }

  export type UserBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserBannerWhereInput | UserBannerWhereInput[]
    OR?: UserBannerWhereInput[]
    NOT?: UserBannerWhereInput | UserBannerWhereInput[]
    user_id?: IntFilter<"UserBanner"> | number
    banner_id?: IntFilter<"UserBanner"> | number
  }, "id">

  export type UserBannerOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
    _count?: UserBannerCountOrderByAggregateInput
    _avg?: UserBannerAvgOrderByAggregateInput
    _max?: UserBannerMaxOrderByAggregateInput
    _min?: UserBannerMinOrderByAggregateInput
    _sum?: UserBannerSumOrderByAggregateInput
  }

  export type UserBannerScalarWhereWithAggregatesInput = {
    AND?: UserBannerScalarWhereWithAggregatesInput | UserBannerScalarWhereWithAggregatesInput[]
    OR?: UserBannerScalarWhereWithAggregatesInput[]
    NOT?: UserBannerScalarWhereWithAggregatesInput | UserBannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserBanner"> | number
    user_id?: IntWithAggregatesFilter<"UserBanner"> | number
    banner_id?: IntWithAggregatesFilter<"UserBanner"> | number
  }

  export type UserPhotoWhereInput = {
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    id?: IntFilter<"UserPhoto"> | number
    userId?: IntFilter<"UserPhoto"> | number
    photo?: StringFilter<"UserPhoto"> | string
    time?: IntFilter<"UserPhoto"> | number
  }

  export type UserPhotoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    time?: SortOrder
  }

  export type UserPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    userId?: IntFilter<"UserPhoto"> | number
    photo?: StringFilter<"UserPhoto"> | string
    time?: IntFilter<"UserPhoto"> | number
  }, "id">

  export type UserPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    time?: SortOrder
    _count?: UserPhotoCountOrderByAggregateInput
    _avg?: UserPhotoAvgOrderByAggregateInput
    _max?: UserPhotoMaxOrderByAggregateInput
    _min?: UserPhotoMinOrderByAggregateInput
    _sum?: UserPhotoSumOrderByAggregateInput
  }

  export type UserPhotoScalarWhereWithAggregatesInput = {
    AND?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    OR?: UserPhotoScalarWhereWithAggregatesInput[]
    NOT?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPhoto"> | number
    userId?: IntWithAggregatesFilter<"UserPhoto"> | number
    photo?: StringWithAggregatesFilter<"UserPhoto"> | string
    time?: IntWithAggregatesFilter<"UserPhoto"> | number
  }

  export type UserPremiumWhereInput = {
    AND?: UserPremiumWhereInput | UserPremiumWhereInput[]
    OR?: UserPremiumWhereInput[]
    NOT?: UserPremiumWhereInput | UserPremiumWhereInput[]
    userId?: IntFilter<"UserPremium"> | number
    timestampActivated?: IntFilter<"UserPremium"> | number
    timestampExpireClassic?: IntFilter<"UserPremium"> | number
    timestampExpireEpic?: IntFilter<"UserPremium"> | number
    timestampExpireLegend?: IntFilter<"UserPremium"> | number
  }

  export type UserPremiumOrderByWithRelationInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
  }

  export type UserPremiumWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: UserPremiumWhereInput | UserPremiumWhereInput[]
    OR?: UserPremiumWhereInput[]
    NOT?: UserPremiumWhereInput | UserPremiumWhereInput[]
    timestampActivated?: IntFilter<"UserPremium"> | number
    timestampExpireClassic?: IntFilter<"UserPremium"> | number
    timestampExpireEpic?: IntFilter<"UserPremium"> | number
    timestampExpireLegend?: IntFilter<"UserPremium"> | number
  }, "userId">

  export type UserPremiumOrderByWithAggregationInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
    _count?: UserPremiumCountOrderByAggregateInput
    _avg?: UserPremiumAvgOrderByAggregateInput
    _max?: UserPremiumMaxOrderByAggregateInput
    _min?: UserPremiumMinOrderByAggregateInput
    _sum?: UserPremiumSumOrderByAggregateInput
  }

  export type UserPremiumScalarWhereWithAggregatesInput = {
    AND?: UserPremiumScalarWhereWithAggregatesInput | UserPremiumScalarWhereWithAggregatesInput[]
    OR?: UserPremiumScalarWhereWithAggregatesInput[]
    NOT?: UserPremiumScalarWhereWithAggregatesInput | UserPremiumScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserPremium"> | number
    timestampActivated?: IntWithAggregatesFilter<"UserPremium"> | number
    timestampExpireClassic?: IntWithAggregatesFilter<"UserPremium"> | number
    timestampExpireEpic?: IntWithAggregatesFilter<"UserPremium"> | number
    timestampExpireLegend?: IntWithAggregatesFilter<"UserPremium"> | number
  }

  export type UserQuestWhereInput = {
    AND?: UserQuestWhereInput | UserQuestWhereInput[]
    OR?: UserQuestWhereInput[]
    NOT?: UserQuestWhereInput | UserQuestWhereInput[]
    userId?: IntFilter<"UserQuest"> | number
    questId?: IntFilter<"UserQuest"> | number
    progress?: IntFilter<"UserQuest"> | number
  }

  export type UserQuestOrderByWithRelationInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
  }

  export type UserQuestWhereUniqueInput = Prisma.AtLeast<{
    userId_questId?: UserQuestUserIdQuestIdCompoundUniqueInput
    AND?: UserQuestWhereInput | UserQuestWhereInput[]
    OR?: UserQuestWhereInput[]
    NOT?: UserQuestWhereInput | UserQuestWhereInput[]
    userId?: IntFilter<"UserQuest"> | number
    questId?: IntFilter<"UserQuest"> | number
    progress?: IntFilter<"UserQuest"> | number
  }, "userId_questId">

  export type UserQuestOrderByWithAggregationInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
    _count?: UserQuestCountOrderByAggregateInput
    _avg?: UserQuestAvgOrderByAggregateInput
    _max?: UserQuestMaxOrderByAggregateInput
    _min?: UserQuestMinOrderByAggregateInput
    _sum?: UserQuestSumOrderByAggregateInput
  }

  export type UserQuestScalarWhereWithAggregatesInput = {
    AND?: UserQuestScalarWhereWithAggregatesInput | UserQuestScalarWhereWithAggregatesInput[]
    OR?: UserQuestScalarWhereWithAggregatesInput[]
    NOT?: UserQuestScalarWhereWithAggregatesInput | UserQuestScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserQuest"> | number
    questId?: IntWithAggregatesFilter<"UserQuest"> | number
    progress?: IntWithAggregatesFilter<"UserQuest"> | number
  }

  export type UserRoleplayWhereInput = {
    AND?: UserRoleplayWhereInput | UserRoleplayWhereInput[]
    OR?: UserRoleplayWhereInput[]
    NOT?: UserRoleplayWhereInput | UserRoleplayWhereInput[]
    userId?: IntFilter<"UserRoleplay"> | number
    roleplayId?: IntFilter<"UserRoleplay"> | number
    health?: IntFilter<"UserRoleplay"> | number
    energy?: IntFilter<"UserRoleplay"> | number
    money?: IntFilter<"UserRoleplay"> | number
    munition?: IntFilter<"UserRoleplay"> | number
    exp?: IntFilter<"UserRoleplay"> | number
    weaponFar?: IntFilter<"UserRoleplay"> | number
    weaponCac?: IntFilter<"UserRoleplay"> | number
    hygiene?: IntFilter<"UserRoleplay"> | number
    money1?: IntFilter<"UserRoleplay"> | number
    money2?: IntFilter<"UserRoleplay"> | number
    money3?: IntFilter<"UserRoleplay"> | number
    money4?: IntFilter<"UserRoleplay"> | number
  }

  export type UserRoleplayOrderByWithRelationInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
  }

  export type UserRoleplayWhereUniqueInput = Prisma.AtLeast<{
    userId_roleplayId?: UserRoleplayUserIdRoleplayIdCompoundUniqueInput
    AND?: UserRoleplayWhereInput | UserRoleplayWhereInput[]
    OR?: UserRoleplayWhereInput[]
    NOT?: UserRoleplayWhereInput | UserRoleplayWhereInput[]
    userId?: IntFilter<"UserRoleplay"> | number
    roleplayId?: IntFilter<"UserRoleplay"> | number
    health?: IntFilter<"UserRoleplay"> | number
    energy?: IntFilter<"UserRoleplay"> | number
    money?: IntFilter<"UserRoleplay"> | number
    munition?: IntFilter<"UserRoleplay"> | number
    exp?: IntFilter<"UserRoleplay"> | number
    weaponFar?: IntFilter<"UserRoleplay"> | number
    weaponCac?: IntFilter<"UserRoleplay"> | number
    hygiene?: IntFilter<"UserRoleplay"> | number
    money1?: IntFilter<"UserRoleplay"> | number
    money2?: IntFilter<"UserRoleplay"> | number
    money3?: IntFilter<"UserRoleplay"> | number
    money4?: IntFilter<"UserRoleplay"> | number
  }, "userId_roleplayId">

  export type UserRoleplayOrderByWithAggregationInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
    _count?: UserRoleplayCountOrderByAggregateInput
    _avg?: UserRoleplayAvgOrderByAggregateInput
    _max?: UserRoleplayMaxOrderByAggregateInput
    _min?: UserRoleplayMinOrderByAggregateInput
    _sum?: UserRoleplaySumOrderByAggregateInput
  }

  export type UserRoleplayScalarWhereWithAggregatesInput = {
    AND?: UserRoleplayScalarWhereWithAggregatesInput | UserRoleplayScalarWhereWithAggregatesInput[]
    OR?: UserRoleplayScalarWhereWithAggregatesInput[]
    NOT?: UserRoleplayScalarWhereWithAggregatesInput | UserRoleplayScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserRoleplay"> | number
    roleplayId?: IntWithAggregatesFilter<"UserRoleplay"> | number
    health?: IntWithAggregatesFilter<"UserRoleplay"> | number
    energy?: IntWithAggregatesFilter<"UserRoleplay"> | number
    money?: IntWithAggregatesFilter<"UserRoleplay"> | number
    munition?: IntWithAggregatesFilter<"UserRoleplay"> | number
    exp?: IntWithAggregatesFilter<"UserRoleplay"> | number
    weaponFar?: IntWithAggregatesFilter<"UserRoleplay"> | number
    weaponCac?: IntWithAggregatesFilter<"UserRoleplay"> | number
    hygiene?: IntWithAggregatesFilter<"UserRoleplay"> | number
    money1?: IntWithAggregatesFilter<"UserRoleplay"> | number
    money2?: IntWithAggregatesFilter<"UserRoleplay"> | number
    money3?: IntWithAggregatesFilter<"UserRoleplay"> | number
    money4?: IntWithAggregatesFilter<"UserRoleplay"> | number
  }

  export type UserRoleplayItemWhereInput = {
    AND?: UserRoleplayItemWhereInput | UserRoleplayItemWhereInput[]
    OR?: UserRoleplayItemWhereInput[]
    NOT?: UserRoleplayItemWhereInput | UserRoleplayItemWhereInput[]
    id?: IntFilter<"UserRoleplayItem"> | number
    userId?: IntFilter<"UserRoleplayItem"> | number
    rpId?: IntFilter<"UserRoleplayItem"> | number
    itemId?: IntFilter<"UserRoleplayItem"> | number
    count?: IntFilter<"UserRoleplayItem"> | number
  }

  export type UserRoleplayItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
  }

  export type UserRoleplayItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserRoleplayItemWhereInput | UserRoleplayItemWhereInput[]
    OR?: UserRoleplayItemWhereInput[]
    NOT?: UserRoleplayItemWhereInput | UserRoleplayItemWhereInput[]
    userId?: IntFilter<"UserRoleplayItem"> | number
    rpId?: IntFilter<"UserRoleplayItem"> | number
    itemId?: IntFilter<"UserRoleplayItem"> | number
    count?: IntFilter<"UserRoleplayItem"> | number
  }, "id">

  export type UserRoleplayItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    _count?: UserRoleplayItemCountOrderByAggregateInput
    _avg?: UserRoleplayItemAvgOrderByAggregateInput
    _max?: UserRoleplayItemMaxOrderByAggregateInput
    _min?: UserRoleplayItemMinOrderByAggregateInput
    _sum?: UserRoleplayItemSumOrderByAggregateInput
  }

  export type UserRoleplayItemScalarWhereWithAggregatesInput = {
    AND?: UserRoleplayItemScalarWhereWithAggregatesInput | UserRoleplayItemScalarWhereWithAggregatesInput[]
    OR?: UserRoleplayItemScalarWhereWithAggregatesInput[]
    NOT?: UserRoleplayItemScalarWhereWithAggregatesInput | UserRoleplayItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRoleplayItem"> | number
    userId?: IntWithAggregatesFilter<"UserRoleplayItem"> | number
    rpId?: IntWithAggregatesFilter<"UserRoleplayItem"> | number
    itemId?: IntWithAggregatesFilter<"UserRoleplayItem"> | number
    count?: IntWithAggregatesFilter<"UserRoleplayItem"> | number
  }

  export type UserStatsWhereInput = {
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    id?: IntFilter<"UserStats"> | number
    onlineTime?: IntFilter<"UserStats"> | number
    respect?: IntFilter<"UserStats"> | number
    respectGiven?: IntFilter<"UserStats"> | number
    giftsGiven?: IntFilter<"UserStats"> | number
    giftsReceived?: IntFilter<"UserStats"> | number
    dailyRespectPoints?: IntFilter<"UserStats"> | number
    dailyPetRespectPoints?: IntFilter<"UserStats"> | number
    achievementScore?: IntFilter<"UserStats"> | number
    questId?: IntFilter<"UserStats"> | number
    questProgress?: IntFilter<"UserStats"> | number
    levBuilder?: IntFilter<"UserStats"> | number
    levSocial?: IntFilter<"UserStats"> | number
    levIdentity?: IntFilter<"UserStats"> | number
    levExplore?: IntFilter<"UserStats"> | number
    groupId?: IntFilter<"UserStats"> | number
  }

  export type UserStatsOrderByWithRelationInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
  }

  export type UserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    onlineTime?: IntFilter<"UserStats"> | number
    respect?: IntFilter<"UserStats"> | number
    respectGiven?: IntFilter<"UserStats"> | number
    giftsGiven?: IntFilter<"UserStats"> | number
    giftsReceived?: IntFilter<"UserStats"> | number
    dailyRespectPoints?: IntFilter<"UserStats"> | number
    dailyPetRespectPoints?: IntFilter<"UserStats"> | number
    achievementScore?: IntFilter<"UserStats"> | number
    questId?: IntFilter<"UserStats"> | number
    questProgress?: IntFilter<"UserStats"> | number
    levBuilder?: IntFilter<"UserStats"> | number
    levSocial?: IntFilter<"UserStats"> | number
    levIdentity?: IntFilter<"UserStats"> | number
    levExplore?: IntFilter<"UserStats"> | number
    groupId?: IntFilter<"UserStats"> | number
  }, "id">

  export type UserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
    _count?: UserStatsCountOrderByAggregateInput
    _avg?: UserStatsAvgOrderByAggregateInput
    _max?: UserStatsMaxOrderByAggregateInput
    _min?: UserStatsMinOrderByAggregateInput
    _sum?: UserStatsSumOrderByAggregateInput
  }

  export type UserStatsScalarWhereWithAggregatesInput = {
    AND?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    OR?: UserStatsScalarWhereWithAggregatesInput[]
    NOT?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserStats"> | number
    onlineTime?: IntWithAggregatesFilter<"UserStats"> | number
    respect?: IntWithAggregatesFilter<"UserStats"> | number
    respectGiven?: IntWithAggregatesFilter<"UserStats"> | number
    giftsGiven?: IntWithAggregatesFilter<"UserStats"> | number
    giftsReceived?: IntWithAggregatesFilter<"UserStats"> | number
    dailyRespectPoints?: IntWithAggregatesFilter<"UserStats"> | number
    dailyPetRespectPoints?: IntWithAggregatesFilter<"UserStats"> | number
    achievementScore?: IntWithAggregatesFilter<"UserStats"> | number
    questId?: IntWithAggregatesFilter<"UserStats"> | number
    questProgress?: IntWithAggregatesFilter<"UserStats"> | number
    levBuilder?: IntWithAggregatesFilter<"UserStats"> | number
    levSocial?: IntWithAggregatesFilter<"UserStats"> | number
    levIdentity?: IntWithAggregatesFilter<"UserStats"> | number
    levExplore?: IntWithAggregatesFilter<"UserStats"> | number
    groupId?: IntWithAggregatesFilter<"UserStats"> | number
  }

  export type UserWardrobeWhereInput = {
    AND?: UserWardrobeWhereInput | UserWardrobeWhereInput[]
    OR?: UserWardrobeWhereInput[]
    NOT?: UserWardrobeWhereInput | UserWardrobeWhereInput[]
    userId?: IntFilter<"UserWardrobe"> | number
    slotId?: IntFilter<"UserWardrobe"> | number
    look?: StringFilter<"UserWardrobe"> | string
    gender?: EnumUserWardrobeGenderFilter<"UserWardrobe"> | $Enums.UserWardrobeGender
  }

  export type UserWardrobeOrderByWithRelationInput = {
    userId?: SortOrder
    slotId?: SortOrder
    look?: SortOrder
    gender?: SortOrder
  }

  export type UserWardrobeWhereUniqueInput = Prisma.AtLeast<{
    userId_slotId?: UserWardrobeUserIdSlotIdCompoundUniqueInput
    AND?: UserWardrobeWhereInput | UserWardrobeWhereInput[]
    OR?: UserWardrobeWhereInput[]
    NOT?: UserWardrobeWhereInput | UserWardrobeWhereInput[]
    userId?: IntFilter<"UserWardrobe"> | number
    slotId?: IntFilter<"UserWardrobe"> | number
    look?: StringFilter<"UserWardrobe"> | string
    gender?: EnumUserWardrobeGenderFilter<"UserWardrobe"> | $Enums.UserWardrobeGender
  }, "userId_slotId">

  export type UserWardrobeOrderByWithAggregationInput = {
    userId?: SortOrder
    slotId?: SortOrder
    look?: SortOrder
    gender?: SortOrder
    _count?: UserWardrobeCountOrderByAggregateInput
    _avg?: UserWardrobeAvgOrderByAggregateInput
    _max?: UserWardrobeMaxOrderByAggregateInput
    _min?: UserWardrobeMinOrderByAggregateInput
    _sum?: UserWardrobeSumOrderByAggregateInput
  }

  export type UserWardrobeScalarWhereWithAggregatesInput = {
    AND?: UserWardrobeScalarWhereWithAggregatesInput | UserWardrobeScalarWhereWithAggregatesInput[]
    OR?: UserWardrobeScalarWhereWithAggregatesInput[]
    NOT?: UserWardrobeScalarWhereWithAggregatesInput | UserWardrobeScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserWardrobe"> | number
    slotId?: IntWithAggregatesFilter<"UserWardrobe"> | number
    look?: StringWithAggregatesFilter<"UserWardrobe"> | string
    gender?: EnumUserWardrobeGenderWithAggregatesFilter<"UserWardrobe"> | $Enums.UserWardrobeGender
  }

  export type WordFilterRetroWhereInput = {
    AND?: WordFilterRetroWhereInput | WordFilterRetroWhereInput[]
    OR?: WordFilterRetroWhereInput[]
    NOT?: WordFilterRetroWhereInput | WordFilterRetroWhereInput[]
    word?: StringFilter<"WordFilterRetro"> | string
  }

  export type WordFilterRetroOrderByWithRelationInput = {
    word?: SortOrder
  }

  export type WordFilterRetroWhereUniqueInput = Prisma.AtLeast<{
    word?: string
    AND?: WordFilterRetroWhereInput | WordFilterRetroWhereInput[]
    OR?: WordFilterRetroWhereInput[]
    NOT?: WordFilterRetroWhereInput | WordFilterRetroWhereInput[]
  }, "word">

  export type WordFilterRetroOrderByWithAggregationInput = {
    word?: SortOrder
    _count?: WordFilterRetroCountOrderByAggregateInput
    _max?: WordFilterRetroMaxOrderByAggregateInput
    _min?: WordFilterRetroMinOrderByAggregateInput
  }

  export type WordFilterRetroScalarWhereWithAggregatesInput = {
    AND?: WordFilterRetroScalarWhereWithAggregatesInput | WordFilterRetroScalarWhereWithAggregatesInput[]
    OR?: WordFilterRetroScalarWhereWithAggregatesInput[]
    NOT?: WordFilterRetroScalarWhereWithAggregatesInput | WordFilterRetroScalarWhereWithAggregatesInput[]
    word?: StringWithAggregatesFilter<"WordFilterRetro"> | string
  }

  export type BanCreateInput = {
    bantype?: $Enums.BanBantype
    value: string
    reason: string
    expire?: number
    addedBy: string
    addedDate: number
  }

  export type BanUncheckedCreateInput = {
    id?: number
    bantype?: $Enums.BanBantype
    value: string
    reason: string
    expire?: number
    addedBy: string
    addedDate: number
  }

  export type BanUpdateInput = {
    bantype?: EnumBanBantypeFieldUpdateOperationsInput | $Enums.BanBantype
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    addedBy?: StringFieldUpdateOperationsInput | string
    addedDate?: IntFieldUpdateOperationsInput | number
  }

  export type BanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bantype?: EnumBanBantypeFieldUpdateOperationsInput | $Enums.BanBantype
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    addedBy?: StringFieldUpdateOperationsInput | string
    addedDate?: IntFieldUpdateOperationsInput | number
  }

  export type BanCreateManyInput = {
    id?: number
    bantype?: $Enums.BanBantype
    value: string
    reason: string
    expire?: number
    addedBy: string
    addedDate: number
  }

  export type BanUpdateManyMutationInput = {
    bantype?: EnumBanBantypeFieldUpdateOperationsInput | $Enums.BanBantype
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    addedBy?: StringFieldUpdateOperationsInput | string
    addedDate?: IntFieldUpdateOperationsInput | number
  }

  export type BanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bantype?: EnumBanBantypeFieldUpdateOperationsInput | $Enums.BanBantype
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    addedBy?: StringFieldUpdateOperationsInput | string
    addedDate?: IntFieldUpdateOperationsInput | number
  }

  export type BotPetCreateInput = {
    userId: number
    roomId?: number
    name?: string
    race?: string
    color?: string
    type: number
    experience: number
    energy: number
    nutrition?: number
    respect?: number
    createstamp?: number
    x?: number
    y?: number
    z?: number
    haveSaddle?: number
    hairdye?: number
    pethair?: number
    anyoneRide?: boolean
  }

  export type BotPetUncheckedCreateInput = {
    id?: number
    userId: number
    roomId?: number
    name?: string
    race?: string
    color?: string
    type: number
    experience: number
    energy: number
    nutrition?: number
    respect?: number
    createstamp?: number
    x?: number
    y?: number
    z?: number
    haveSaddle?: number
    hairdye?: number
    pethair?: number
    anyoneRide?: boolean
  }

  export type BotPetUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    race?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    nutrition?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    createstamp?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    haveSaddle?: IntFieldUpdateOperationsInput | number
    hairdye?: IntFieldUpdateOperationsInput | number
    pethair?: IntFieldUpdateOperationsInput | number
    anyoneRide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BotPetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    race?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    nutrition?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    createstamp?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    haveSaddle?: IntFieldUpdateOperationsInput | number
    hairdye?: IntFieldUpdateOperationsInput | number
    pethair?: IntFieldUpdateOperationsInput | number
    anyoneRide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BotPetCreateManyInput = {
    id?: number
    userId: number
    roomId?: number
    name?: string
    race?: string
    color?: string
    type: number
    experience: number
    energy: number
    nutrition?: number
    respect?: number
    createstamp?: number
    x?: number
    y?: number
    z?: number
    haveSaddle?: number
    hairdye?: number
    pethair?: number
    anyoneRide?: boolean
  }

  export type BotPetUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    race?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    nutrition?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    createstamp?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    haveSaddle?: IntFieldUpdateOperationsInput | number
    hairdye?: IntFieldUpdateOperationsInput | number
    pethair?: IntFieldUpdateOperationsInput | number
    anyoneRide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BotPetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    race?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    nutrition?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    createstamp?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    haveSaddle?: IntFieldUpdateOperationsInput | number
    hairdye?: IntFieldUpdateOperationsInput | number
    pethair?: IntFieldUpdateOperationsInput | number
    anyoneRide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BotUserCreateInput = {
    userId?: number
    name?: string
    motto?: string
    gender?: string
    look?: string
    roomId?: number
    walkEnabled?: boolean
    x?: number
    y?: number
    z?: number
    rotation?: number
    chatEnabled?: boolean
    chatText: string
    chatSeconds?: number
    isDancing?: boolean
    isMixchat?: boolean
    status?: number
    enable?: number
    handitem?: number
    aiType?: $Enums.BotUserAiType
  }

  export type BotUserUncheckedCreateInput = {
    id?: number
    userId?: number
    name?: string
    motto?: string
    gender?: string
    look?: string
    roomId?: number
    walkEnabled?: boolean
    x?: number
    y?: number
    z?: number
    rotation?: number
    chatEnabled?: boolean
    chatText: string
    chatSeconds?: number
    isDancing?: boolean
    isMixchat?: boolean
    status?: number
    enable?: number
    handitem?: number
    aiType?: $Enums.BotUserAiType
  }

  export type BotUserUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    walkEnabled?: BoolFieldUpdateOperationsInput | boolean
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: IntFieldUpdateOperationsInput | number
    rotation?: IntFieldUpdateOperationsInput | number
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    chatText?: StringFieldUpdateOperationsInput | string
    chatSeconds?: IntFieldUpdateOperationsInput | number
    isDancing?: BoolFieldUpdateOperationsInput | boolean
    isMixchat?: BoolFieldUpdateOperationsInput | boolean
    status?: IntFieldUpdateOperationsInput | number
    enable?: IntFieldUpdateOperationsInput | number
    handitem?: IntFieldUpdateOperationsInput | number
    aiType?: EnumBotUserAiTypeFieldUpdateOperationsInput | $Enums.BotUserAiType
  }

  export type BotUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    walkEnabled?: BoolFieldUpdateOperationsInput | boolean
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: IntFieldUpdateOperationsInput | number
    rotation?: IntFieldUpdateOperationsInput | number
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    chatText?: StringFieldUpdateOperationsInput | string
    chatSeconds?: IntFieldUpdateOperationsInput | number
    isDancing?: BoolFieldUpdateOperationsInput | boolean
    isMixchat?: BoolFieldUpdateOperationsInput | boolean
    status?: IntFieldUpdateOperationsInput | number
    enable?: IntFieldUpdateOperationsInput | number
    handitem?: IntFieldUpdateOperationsInput | number
    aiType?: EnumBotUserAiTypeFieldUpdateOperationsInput | $Enums.BotUserAiType
  }

  export type BotUserCreateManyInput = {
    id?: number
    userId?: number
    name?: string
    motto?: string
    gender?: string
    look?: string
    roomId?: number
    walkEnabled?: boolean
    x?: number
    y?: number
    z?: number
    rotation?: number
    chatEnabled?: boolean
    chatText: string
    chatSeconds?: number
    isDancing?: boolean
    isMixchat?: boolean
    status?: number
    enable?: number
    handitem?: number
    aiType?: $Enums.BotUserAiType
  }

  export type BotUserUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    walkEnabled?: BoolFieldUpdateOperationsInput | boolean
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: IntFieldUpdateOperationsInput | number
    rotation?: IntFieldUpdateOperationsInput | number
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    chatText?: StringFieldUpdateOperationsInput | string
    chatSeconds?: IntFieldUpdateOperationsInput | number
    isDancing?: BoolFieldUpdateOperationsInput | boolean
    isMixchat?: BoolFieldUpdateOperationsInput | boolean
    status?: IntFieldUpdateOperationsInput | number
    enable?: IntFieldUpdateOperationsInput | number
    handitem?: IntFieldUpdateOperationsInput | number
    aiType?: EnumBotUserAiTypeFieldUpdateOperationsInput | $Enums.BotUserAiType
  }

  export type BotUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    walkEnabled?: BoolFieldUpdateOperationsInput | boolean
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: IntFieldUpdateOperationsInput | number
    rotation?: IntFieldUpdateOperationsInput | number
    chatEnabled?: BoolFieldUpdateOperationsInput | boolean
    chatText?: StringFieldUpdateOperationsInput | string
    chatSeconds?: IntFieldUpdateOperationsInput | number
    isDancing?: BoolFieldUpdateOperationsInput | boolean
    isMixchat?: BoolFieldUpdateOperationsInput | boolean
    status?: IntFieldUpdateOperationsInput | number
    enable?: IntFieldUpdateOperationsInput | number
    handitem?: IntFieldUpdateOperationsInput | number
    aiType?: EnumBotUserAiTypeFieldUpdateOperationsInput | $Enums.BotUserAiType
  }

  export type CatalogBotPresetCreateInput = {
    name: string
    figure: string
    gender: string
    motto: string
    aiType?: $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetUncheckedCreateInput = {
    id?: number
    name: string
    figure: string
    gender: string
    motto: string
    aiType?: $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    figure?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    aiType?: EnumCatalogBotPresetAiTypeFieldUpdateOperationsInput | $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    figure?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    aiType?: EnumCatalogBotPresetAiTypeFieldUpdateOperationsInput | $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetCreateManyInput = {
    id?: number
    name: string
    figure: string
    gender: string
    motto: string
    aiType?: $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    figure?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    aiType?: EnumCatalogBotPresetAiTypeFieldUpdateOperationsInput | $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    figure?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    aiType?: EnumCatalogBotPresetAiTypeFieldUpdateOperationsInput | $Enums.CatalogBotPresetAiType
  }

  export type CatalogItemCreateInput = {
    pageId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
    catalogItemLimited?: CatalogItemLimitedCreateNestedOneWithoutCatalogItemInput
    itemBase: ItemBaseCreateNestedOneWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateInput = {
    id?: number
    pageId: number
    itemId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
    catalogItemLimited?: CatalogItemLimitedUncheckedCreateNestedOneWithoutCatalogItemInput
  }

  export type CatalogItemUpdateInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
    catalogItemLimited?: CatalogItemLimitedUpdateOneWithoutCatalogItemNestedInput
    itemBase?: ItemBaseUpdateOneRequiredWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
    catalogItemLimited?: CatalogItemLimitedUncheckedUpdateOneWithoutCatalogItemNestedInput
  }

  export type CatalogItemCreateManyInput = {
    id?: number
    pageId: number
    itemId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
  }

  export type CatalogItemUpdateManyMutationInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
  }

  export type CatalogItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
  }

  export type CatalogItemLimitedCreateInput = {
    limitedSells?: number
    limitedStack?: number
    catalogItem: CatalogItemCreateNestedOneWithoutCatalogItemLimitedInput
  }

  export type CatalogItemLimitedUncheckedCreateInput = {
    catalogItemId: number
    limitedSells?: number
    limitedStack?: number
  }

  export type CatalogItemLimitedUpdateInput = {
    limitedSells?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
    catalogItem?: CatalogItemUpdateOneRequiredWithoutCatalogItemLimitedNestedInput
  }

  export type CatalogItemLimitedUncheckedUpdateInput = {
    catalogItemId?: IntFieldUpdateOperationsInput | number
    limitedSells?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogItemLimitedCreateManyInput = {
    catalogItemId: number
    limitedSells?: number
    limitedStack?: number
  }

  export type CatalogItemLimitedUpdateManyMutationInput = {
    limitedSells?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogItemLimitedUncheckedUpdateManyInput = {
    catalogItemId?: IntFieldUpdateOperationsInput | number
    limitedSells?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceDataCreateInput = {
    sprite: number
    sold?: number
    avgprice?: number
  }

  export type CatalogMarketplaceDataUncheckedCreateInput = {
    id?: number
    sprite: number
    sold?: number
    avgprice?: number
  }

  export type CatalogMarketplaceDataUpdateInput = {
    sprite?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    avgprice?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sprite?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    avgprice?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceDataCreateManyInput = {
    id?: number
    sprite: number
    sold?: number
    avgprice?: number
  }

  export type CatalogMarketplaceDataUpdateManyMutationInput = {
    sprite?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    avgprice?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sprite?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    avgprice?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceOfferCreateInput = {
    userId: number
    itemId: number
    askingPrice: number
    totalPrice?: number
    publicName: string
    spriteId: number
    itemType?: number
    timestamp?: number
    state?: number
    extraData: string
    furniId: number
    limitedNumber?: number
    limitedStack?: number
  }

  export type CatalogMarketplaceOfferUncheckedCreateInput = {
    offerId?: number
    userId: number
    itemId: number
    askingPrice: number
    totalPrice?: number
    publicName: string
    spriteId: number
    itemType?: number
    timestamp?: number
    state?: number
    extraData: string
    furniId: number
    limitedNumber?: number
    limitedStack?: number
  }

  export type CatalogMarketplaceOfferUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    askingPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    publicName?: StringFieldUpdateOperationsInput | string
    spriteId?: IntFieldUpdateOperationsInput | number
    itemType?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    extraData?: StringFieldUpdateOperationsInput | string
    furniId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceOfferUncheckedUpdateInput = {
    offerId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    askingPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    publicName?: StringFieldUpdateOperationsInput | string
    spriteId?: IntFieldUpdateOperationsInput | number
    itemType?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    extraData?: StringFieldUpdateOperationsInput | string
    furniId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceOfferCreateManyInput = {
    offerId?: number
    userId: number
    itemId: number
    askingPrice: number
    totalPrice?: number
    publicName: string
    spriteId: number
    itemType?: number
    timestamp?: number
    state?: number
    extraData: string
    furniId: number
    limitedNumber?: number
    limitedStack?: number
  }

  export type CatalogMarketplaceOfferUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    askingPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    publicName?: StringFieldUpdateOperationsInput | string
    spriteId?: IntFieldUpdateOperationsInput | number
    itemType?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    extraData?: StringFieldUpdateOperationsInput | string
    furniId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogMarketplaceOfferUncheckedUpdateManyInput = {
    offerId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    askingPrice?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    publicName?: StringFieldUpdateOperationsInput | string
    spriteId?: IntFieldUpdateOperationsInput | number
    itemType?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    extraData?: StringFieldUpdateOperationsInput | string
    furniId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogPageCreateInput = {
    parentId?: number
    caption: string
    iconImage?: number
    enabled?: boolean
    requiredRight?: string
    orderNum?: number
    pageLayout?: string
    pageLink?: string
    pageStrings1?: string
    pageStrings2: string
    isPremium?: boolean
  }

  export type CatalogPageUncheckedCreateInput = {
    id?: number
    parentId?: number
    caption: string
    iconImage?: number
    enabled?: boolean
    requiredRight?: string
    orderNum?: number
    pageLayout?: string
    pageLink?: string
    pageStrings1?: string
    pageStrings2: string
    isPremium?: boolean
  }

  export type CatalogPageUpdateInput = {
    parentId?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    iconImage?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    requiredRight?: StringFieldUpdateOperationsInput | string
    orderNum?: IntFieldUpdateOperationsInput | number
    pageLayout?: StringFieldUpdateOperationsInput | string
    pageLink?: StringFieldUpdateOperationsInput | string
    pageStrings1?: StringFieldUpdateOperationsInput | string
    pageStrings2?: StringFieldUpdateOperationsInput | string
    isPremium?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    iconImage?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    requiredRight?: StringFieldUpdateOperationsInput | string
    orderNum?: IntFieldUpdateOperationsInput | number
    pageLayout?: StringFieldUpdateOperationsInput | string
    pageLink?: StringFieldUpdateOperationsInput | string
    pageStrings1?: StringFieldUpdateOperationsInput | string
    pageStrings2?: StringFieldUpdateOperationsInput | string
    isPremium?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPageCreateManyInput = {
    id?: number
    parentId?: number
    caption: string
    iconImage?: number
    enabled?: boolean
    requiredRight?: string
    orderNum?: number
    pageLayout?: string
    pageLink?: string
    pageStrings1?: string
    pageStrings2: string
    isPremium?: boolean
  }

  export type CatalogPageUpdateManyMutationInput = {
    parentId?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    iconImage?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    requiredRight?: StringFieldUpdateOperationsInput | string
    orderNum?: IntFieldUpdateOperationsInput | number
    pageLayout?: StringFieldUpdateOperationsInput | string
    pageLink?: StringFieldUpdateOperationsInput | string
    pageStrings1?: StringFieldUpdateOperationsInput | string
    pageStrings2?: StringFieldUpdateOperationsInput | string
    isPremium?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    iconImage?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    requiredRight?: StringFieldUpdateOperationsInput | string
    orderNum?: IntFieldUpdateOperationsInput | number
    pageLayout?: StringFieldUpdateOperationsInput | string
    pageLink?: StringFieldUpdateOperationsInput | string
    pageStrings1?: StringFieldUpdateOperationsInput | string
    pageStrings2?: StringFieldUpdateOperationsInput | string
    isPremium?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPageLangueCreateInput = {
    pageId: number
    captionFr?: string | null
    captionEn?: string | null
    captionBr?: string | null
    pageStrings2Fr?: string | null
    pageStrings2En?: string | null
    pageStrings2Br?: string | null
  }

  export type CatalogPageLangueUncheckedCreateInput = {
    pageId: number
    captionFr?: string | null
    captionEn?: string | null
    captionBr?: string | null
    pageStrings2Fr?: string | null
    pageStrings2En?: string | null
    pageStrings2Br?: string | null
  }

  export type CatalogPageLangueUpdateInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    captionFr?: NullableStringFieldUpdateOperationsInput | string | null
    captionEn?: NullableStringFieldUpdateOperationsInput | string | null
    captionBr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Fr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2En?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Br?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogPageLangueUncheckedUpdateInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    captionFr?: NullableStringFieldUpdateOperationsInput | string | null
    captionEn?: NullableStringFieldUpdateOperationsInput | string | null
    captionBr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Fr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2En?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Br?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogPageLangueCreateManyInput = {
    pageId: number
    captionFr?: string | null
    captionEn?: string | null
    captionBr?: string | null
    pageStrings2Fr?: string | null
    pageStrings2En?: string | null
    pageStrings2Br?: string | null
  }

  export type CatalogPageLangueUpdateManyMutationInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    captionFr?: NullableStringFieldUpdateOperationsInput | string | null
    captionEn?: NullableStringFieldUpdateOperationsInput | string | null
    captionBr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Fr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2En?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Br?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogPageLangueUncheckedUpdateManyInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    captionFr?: NullableStringFieldUpdateOperationsInput | string | null
    captionEn?: NullableStringFieldUpdateOperationsInput | string | null
    captionBr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Fr?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2En?: NullableStringFieldUpdateOperationsInput | string | null
    pageStrings2Br?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogPetRaceCreateInput = {
    raceid: number
    color1?: number | null
    color2?: number | null
    has1color?: boolean
    has2color?: boolean
  }

  export type CatalogPetRaceUncheckedCreateInput = {
    id?: number
    raceid: number
    color1?: number | null
    color2?: number | null
    has1color?: boolean
    has2color?: boolean
  }

  export type CatalogPetRaceUpdateInput = {
    raceid?: IntFieldUpdateOperationsInput | number
    color1?: NullableIntFieldUpdateOperationsInput | number | null
    color2?: NullableIntFieldUpdateOperationsInput | number | null
    has1color?: BoolFieldUpdateOperationsInput | boolean
    has2color?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPetRaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceid?: IntFieldUpdateOperationsInput | number
    color1?: NullableIntFieldUpdateOperationsInput | number | null
    color2?: NullableIntFieldUpdateOperationsInput | number | null
    has1color?: BoolFieldUpdateOperationsInput | boolean
    has2color?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPetRaceCreateManyInput = {
    id?: number
    raceid: number
    color1?: number | null
    color2?: number | null
    has1color?: boolean
    has2color?: boolean
  }

  export type CatalogPetRaceUpdateManyMutationInput = {
    raceid?: IntFieldUpdateOperationsInput | number
    color1?: NullableIntFieldUpdateOperationsInput | number | null
    color2?: NullableIntFieldUpdateOperationsInput | number | null
    has1color?: BoolFieldUpdateOperationsInput | boolean
    has2color?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPetRaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceid?: IntFieldUpdateOperationsInput | number
    color1?: NullableIntFieldUpdateOperationsInput | number | null
    color2?: NullableIntFieldUpdateOperationsInput | number | null
    has1color?: BoolFieldUpdateOperationsInput | boolean
    has2color?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogPromotionCreateInput = {
    title?: string | null
    titleEn?: string | null
    titleBr?: string | null
    image?: string | null
    unknown?: number | null
    pageLink?: string | null
    parentId?: number | null
  }

  export type CatalogPromotionUncheckedCreateInput = {
    id?: number
    title?: string | null
    titleEn?: string | null
    titleBr?: string | null
    image?: string | null
    unknown?: number | null
    pageLink?: string | null
    parentId?: number | null
  }

  export type CatalogPromotionUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    titleBr?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    unknown?: NullableIntFieldUpdateOperationsInput | number | null
    pageLink?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CatalogPromotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    titleBr?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    unknown?: NullableIntFieldUpdateOperationsInput | number | null
    pageLink?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CatalogPromotionCreateManyInput = {
    id?: number
    title?: string | null
    titleEn?: string | null
    titleBr?: string | null
    image?: string | null
    unknown?: number | null
    pageLink?: string | null
    parentId?: number | null
  }

  export type CatalogPromotionUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    titleBr?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    unknown?: NullableIntFieldUpdateOperationsInput | number | null
    pageLink?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CatalogPromotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    titleBr?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    unknown?: NullableIntFieldUpdateOperationsInput | number | null
    pageLink?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CatalogVoucherCreateInput = {
    voucher: string
    type?: $Enums.CatalogVoucherType
    value?: number
    currentUses?: number
    maxUses?: number
    enabled?: boolean
  }

  export type CatalogVoucherUncheckedCreateInput = {
    voucher: string
    type?: $Enums.CatalogVoucherType
    value?: number
    currentUses?: number
    maxUses?: number
    enabled?: boolean
  }

  export type CatalogVoucherUpdateInput = {
    voucher?: StringFieldUpdateOperationsInput | string
    type?: EnumCatalogVoucherTypeFieldUpdateOperationsInput | $Enums.CatalogVoucherType
    value?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogVoucherUncheckedUpdateInput = {
    voucher?: StringFieldUpdateOperationsInput | string
    type?: EnumCatalogVoucherTypeFieldUpdateOperationsInput | $Enums.CatalogVoucherType
    value?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogVoucherCreateManyInput = {
    voucher: string
    type?: $Enums.CatalogVoucherType
    value?: number
    currentUses?: number
    maxUses?: number
    enabled?: boolean
  }

  export type CatalogVoucherUpdateManyMutationInput = {
    voucher?: StringFieldUpdateOperationsInput | string
    type?: EnumCatalogVoucherTypeFieldUpdateOperationsInput | $Enums.CatalogVoucherType
    value?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogVoucherUncheckedUpdateManyInput = {
    voucher?: StringFieldUpdateOperationsInput | string
    type?: EnumCatalogVoucherTypeFieldUpdateOperationsInput | $Enums.CatalogVoucherType
    value?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsForumPostCreateInput = {
    threadid?: number
    message: string
    author: string
    date: string
    motto: string
    look: string
    idAuteur: number
    rank: boolean
  }

  export type CmsForumPostUncheckedCreateInput = {
    id?: number
    threadid?: number
    message: string
    author: string
    date: string
    motto: string
    look: string
    idAuteur: number
    rank: boolean
  }

  export type CmsForumPostUpdateInput = {
    threadid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    idAuteur?: IntFieldUpdateOperationsInput | number
    rank?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsForumPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    threadid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    idAuteur?: IntFieldUpdateOperationsInput | number
    rank?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsForumPostCreateManyInput = {
    id?: number
    threadid?: number
    message: string
    author: string
    date: string
    motto: string
    look: string
    idAuteur: number
    rank: boolean
  }

  export type CmsForumPostUpdateManyMutationInput = {
    threadid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    idAuteur?: IntFieldUpdateOperationsInput | number
    rank?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsForumPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    threadid?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    motto?: StringFieldUpdateOperationsInput | string
    look?: StringFieldUpdateOperationsInput | string
    idAuteur?: IntFieldUpdateOperationsInput | number
    rank?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsForumThreadCreateInput = {
    type: number
    title: string
    author: string
    date: string
    lastpostAuthor: string
    lastpostDate: string
    posts: number
    mainPost: number
    statut: number
    categorie: boolean
    views?: number
  }

  export type CmsForumThreadUncheckedCreateInput = {
    id?: number
    type: number
    title: string
    author: string
    date: string
    lastpostAuthor: string
    lastpostDate: string
    posts: number
    mainPost: number
    statut: number
    categorie: boolean
    views?: number
  }

  export type CmsForumThreadUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    lastpostAuthor?: StringFieldUpdateOperationsInput | string
    lastpostDate?: StringFieldUpdateOperationsInput | string
    posts?: IntFieldUpdateOperationsInput | number
    mainPost?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    categorie?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
  }

  export type CmsForumThreadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    lastpostAuthor?: StringFieldUpdateOperationsInput | string
    lastpostDate?: StringFieldUpdateOperationsInput | string
    posts?: IntFieldUpdateOperationsInput | number
    mainPost?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    categorie?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
  }

  export type CmsForumThreadCreateManyInput = {
    id?: number
    type: number
    title: string
    author: string
    date: string
    lastpostAuthor: string
    lastpostDate: string
    posts: number
    mainPost: number
    statut: number
    categorie: boolean
    views?: number
  }

  export type CmsForumThreadUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    lastpostAuthor?: StringFieldUpdateOperationsInput | string
    lastpostDate?: StringFieldUpdateOperationsInput | string
    posts?: IntFieldUpdateOperationsInput | number
    mainPost?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    categorie?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
  }

  export type CmsForumThreadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    lastpostAuthor?: StringFieldUpdateOperationsInput | string
    lastpostDate?: StringFieldUpdateOperationsInput | string
    posts?: IntFieldUpdateOperationsInput | number
    mainPost?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    categorie?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
  }

  export type CmsFourmCategoryCreateInput = {
    name?: string | null
    order?: number
  }

  export type CmsFourmCategoryUncheckedCreateInput = {
    id?: number
    name?: string | null
    order?: number
  }

  export type CmsFourmCategoryUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CmsFourmCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CmsFourmCategoryCreateManyInput = {
    id?: number
    name?: string | null
    order?: number
  }

  export type CmsFourmCategoryUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CmsFourmCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CmsMailConfirmCreateInput = {
    userId: number
    codedevalidation: string
    email: string
    temps: number
    type?: number
  }

  export type CmsMailConfirmUncheckedCreateInput = {
    userId: number
    codedevalidation: string
    email: string
    temps: number
    type?: number
  }

  export type CmsMailConfirmUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    codedevalidation?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    temps?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type CmsMailConfirmUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    codedevalidation?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    temps?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type CmsMailConfirmCreateManyInput = {
    userId: number
    codedevalidation: string
    email: string
    temps: number
    type?: number
  }

  export type CmsMailConfirmUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    codedevalidation?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    temps?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type CmsMailConfirmUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    codedevalidation?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    temps?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
  }

  export type CmsMailForgotCreateInput = {
    pass: string
    email: string
    expire: number
    users: string
  }

  export type CmsMailForgotUncheckedCreateInput = {
    id?: number
    pass: string
    email: string
    expire: number
    users: string
  }

  export type CmsMailForgotUpdateInput = {
    pass?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    users?: StringFieldUpdateOperationsInput | string
  }

  export type CmsMailForgotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pass?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    users?: StringFieldUpdateOperationsInput | string
  }

  export type CmsMailForgotCreateManyInput = {
    id?: number
    pass: string
    email: string
    expire: number
    users: string
  }

  export type CmsMailForgotUpdateManyMutationInput = {
    pass?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    users?: StringFieldUpdateOperationsInput | string
  }

  export type CmsMailForgotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pass?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expire?: IntFieldUpdateOperationsInput | number
    users?: StringFieldUpdateOperationsInput | string
  }

  export type CmsNewsCreateInput = {
    title: string
    categoryId?: number
    topstoryImage: string
    body: string
    snippet: string
    timestamp: number
    author: string
    authorId: number
    link_keyword: string
  }

  export type CmsNewsUncheckedCreateInput = {
    id?: number
    title: string
    categoryId?: number
    topstoryImage: string
    body: string
    snippet: string
    timestamp: number
    author: string
    authorId: number
    link_keyword: string
  }

  export type CmsNewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    topstoryImage?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    authorId?: IntFieldUpdateOperationsInput | number
    link_keyword?: StringFieldUpdateOperationsInput | string
  }

  export type CmsNewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    topstoryImage?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    authorId?: IntFieldUpdateOperationsInput | number
    link_keyword?: StringFieldUpdateOperationsInput | string
  }

  export type CmsNewsCreateManyInput = {
    id?: number
    title: string
    categoryId?: number
    topstoryImage: string
    body: string
    snippet: string
    timestamp: number
    author: string
    authorId: number
    link_keyword: string
  }

  export type CmsNewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    topstoryImage?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    authorId?: IntFieldUpdateOperationsInput | number
    link_keyword?: StringFieldUpdateOperationsInput | string
  }

  export type CmsNewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    topstoryImage?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    snippet?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    authorId?: IntFieldUpdateOperationsInput | number
    link_keyword?: StringFieldUpdateOperationsInput | string
  }

  export type CmsStaffCreateInput = {
    userid: number
    rank: number
    function?: string | null
    socialInsta?: string | null
    socialDiscord?: string | null
  }

  export type CmsStaffUncheckedCreateInput = {
    id?: number
    userid: number
    rank: number
    function?: string | null
    socialInsta?: string | null
    socialDiscord?: string | null
  }

  export type CmsStaffUpdateInput = {
    userid?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    function?: NullableStringFieldUpdateOperationsInput | string | null
    socialInsta?: NullableStringFieldUpdateOperationsInput | string | null
    socialDiscord?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CmsStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    function?: NullableStringFieldUpdateOperationsInput | string | null
    socialInsta?: NullableStringFieldUpdateOperationsInput | string | null
    socialDiscord?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CmsStaffCreateManyInput = {
    id?: number
    userid: number
    rank: number
    function?: string | null
    socialInsta?: string | null
    socialDiscord?: string | null
  }

  export type CmsStaffUpdateManyMutationInput = {
    userid?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    function?: NullableStringFieldUpdateOperationsInput | string | null
    socialInsta?: NullableStringFieldUpdateOperationsInput | string | null
    socialDiscord?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CmsStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    function?: NullableStringFieldUpdateOperationsInput | string | null
    socialInsta?: NullableStringFieldUpdateOperationsInput | string | null
    socialDiscord?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CmsStaffProtectCreateInput = {
    ip?: string | null
    username: string
    hide?: boolean
  }

  export type CmsStaffProtectUncheckedCreateInput = {
    id?: number
    ip?: string | null
    username: string
    hide?: boolean
  }

  export type CmsStaffProtectUpdateInput = {
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    hide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsStaffProtectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    hide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsStaffProtectCreateManyInput = {
    id?: number
    ip?: string | null
    username: string
    hide?: boolean
  }

  export type CmsStaffProtectUpdateManyMutationInput = {
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    hide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CmsStaffProtectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    hide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorAchievementCreateInput = {
    groupName?: string
    category?: string
    level?: number
    rewardPixels?: number
    rewardPoints?: number
    progressNeeded?: number
  }

  export type EmulatorAchievementUncheckedCreateInput = {
    id?: number
    groupName?: string
    category?: string
    level?: number
    rewardPixels?: number
    rewardPoints?: number
    progressNeeded?: number
  }

  export type EmulatorAchievementUpdateInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    rewardPixels?: IntFieldUpdateOperationsInput | number
    rewardPoints?: IntFieldUpdateOperationsInput | number
    progressNeeded?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorAchievementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    rewardPixels?: IntFieldUpdateOperationsInput | number
    rewardPoints?: IntFieldUpdateOperationsInput | number
    progressNeeded?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorAchievementCreateManyInput = {
    id?: number
    groupName?: string
    category?: string
    level?: number
    rewardPixels?: number
    rewardPoints?: number
    progressNeeded?: number
  }

  export type EmulatorAchievementUpdateManyMutationInput = {
    groupName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    rewardPixels?: IntFieldUpdateOperationsInput | number
    rewardPoints?: IntFieldUpdateOperationsInput | number
    progressNeeded?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorAchievementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    rewardPixels?: IntFieldUpdateOperationsInput | number
    rewardPoints?: IntFieldUpdateOperationsInput | number
    progressNeeded?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorBannerCreateInput = {
    haveLayer?: boolean
    canTrade?: boolean
  }

  export type EmulatorBannerUncheckedCreateInput = {
    id?: number
    haveLayer?: boolean
    canTrade?: boolean
  }

  export type EmulatorBannerUpdateInput = {
    haveLayer?: BoolFieldUpdateOperationsInput | boolean
    canTrade?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorBannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    haveLayer?: BoolFieldUpdateOperationsInput | boolean
    canTrade?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorBannerCreateManyInput = {
    id?: number
    haveLayer?: boolean
    canTrade?: boolean
  }

  export type EmulatorBannerUpdateManyMutationInput = {
    haveLayer?: BoolFieldUpdateOperationsInput | boolean
    canTrade?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorBannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    haveLayer?: BoolFieldUpdateOperationsInput | boolean
    canTrade?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorChatStyleCreateInput = {
    id: number
    name?: string
    requiredRight?: string
  }

  export type EmulatorChatStyleUncheckedCreateInput = {
    id: number
    name?: string
    requiredRight?: string
  }

  export type EmulatorChatStyleUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    requiredRight?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorChatStyleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    requiredRight?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorChatStyleCreateManyInput = {
    id: number
    name?: string
    requiredRight?: string
  }

  export type EmulatorChatStyleUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    requiredRight?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorChatStyleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    requiredRight?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorCommandCreateInput = {
    input: string
    minrank: number
    descriptionFr?: string | null
    descriptionEn?: string | null
    descriptionBr?: string | null
  }

  export type EmulatorCommandUncheckedCreateInput = {
    id?: number
    input: string
    minrank: number
    descriptionFr?: string | null
    descriptionEn?: string | null
    descriptionBr?: string | null
  }

  export type EmulatorCommandUpdateInput = {
    input?: StringFieldUpdateOperationsInput | string
    minrank?: IntFieldUpdateOperationsInput | number
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorCommandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    input?: StringFieldUpdateOperationsInput | string
    minrank?: IntFieldUpdateOperationsInput | number
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorCommandCreateManyInput = {
    id?: number
    input: string
    minrank: number
    descriptionFr?: string | null
    descriptionEn?: string | null
    descriptionBr?: string | null
  }

  export type EmulatorCommandUpdateManyMutationInput = {
    input?: StringFieldUpdateOperationsInput | string
    minrank?: IntFieldUpdateOperationsInput | number
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorCommandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    input?: StringFieldUpdateOperationsInput | string
    minrank?: IntFieldUpdateOperationsInput | number
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorCommandPetCreateInput = {
    id: number
    command: string
  }

  export type EmulatorCommandPetUncheckedCreateInput = {
    id: number
    command: string
  }

  export type EmulatorCommandPetUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorCommandPetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorCommandPetCreateManyInput = {
    id: number
    command: string
  }

  export type EmulatorCommandPetUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorCommandPetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorEffectCreateInput = {
    id: number
    onlyStaff?: boolean
  }

  export type EmulatorEffectUncheckedCreateInput = {
    id: number
    onlyStaff?: boolean
  }

  export type EmulatorEffectUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlyStaff?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorEffectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlyStaff?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorEffectCreateManyInput = {
    id: number
    onlyStaff?: boolean
  }

  export type EmulatorEffectUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlyStaff?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorEffectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlyStaff?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorLandingviewCreateInput = {
    header?: string
    body?: string
    button?: string
    inGamePromo?: boolean
    specialAction?: string
    image?: string
    enabled?: boolean
  }

  export type EmulatorLandingviewUncheckedCreateInput = {
    index?: number
    header?: string
    body?: string
    button?: string
    inGamePromo?: boolean
    specialAction?: string
    image?: string
    enabled?: boolean
  }

  export type EmulatorLandingviewUpdateInput = {
    header?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    button?: StringFieldUpdateOperationsInput | string
    inGamePromo?: BoolFieldUpdateOperationsInput | boolean
    specialAction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorLandingviewUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    button?: StringFieldUpdateOperationsInput | string
    inGamePromo?: BoolFieldUpdateOperationsInput | boolean
    specialAction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorLandingviewCreateManyInput = {
    index?: number
    header?: string
    body?: string
    button?: string
    inGamePromo?: boolean
    specialAction?: string
    image?: string
    enabled?: boolean
  }

  export type EmulatorLandingviewUpdateManyMutationInput = {
    header?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    button?: StringFieldUpdateOperationsInput | string
    inGamePromo?: BoolFieldUpdateOperationsInput | boolean
    specialAction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorLandingviewUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    header?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    button?: StringFieldUpdateOperationsInput | string
    inGamePromo?: BoolFieldUpdateOperationsInput | boolean
    specialAction?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmulatorLootboxCreateInput = {
    interactionType: string
    probability?: number
    pageId: number
    itemId?: number
    category?: $Enums.EmulatorLootboxCategory
    amount?: number
  }

  export type EmulatorLootboxUncheckedCreateInput = {
    id?: number
    interactionType: string
    probability?: number
    pageId: number
    itemId?: number
    category?: $Enums.EmulatorLootboxCategory
    amount?: number
  }

  export type EmulatorLootboxUpdateInput = {
    interactionType?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    category?: EnumEmulatorLootboxCategoryFieldUpdateOperationsInput | $Enums.EmulatorLootboxCategory
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorLootboxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    category?: EnumEmulatorLootboxCategoryFieldUpdateOperationsInput | $Enums.EmulatorLootboxCategory
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorLootboxCreateManyInput = {
    id?: number
    interactionType: string
    probability?: number
    pageId: number
    itemId?: number
    category?: $Enums.EmulatorLootboxCategory
    amount?: number
  }

  export type EmulatorLootboxUpdateManyMutationInput = {
    interactionType?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    category?: EnumEmulatorLootboxCategoryFieldUpdateOperationsInput | $Enums.EmulatorLootboxCategory
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorLootboxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    probability?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    category?: EnumEmulatorLootboxCategoryFieldUpdateOperationsInput | $Enums.EmulatorLootboxCategory
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorPermissionCreateInput = {
    rank: number
    permission: string
  }

  export type EmulatorPermissionUncheckedCreateInput = {
    id?: number
    rank: number
    permission: string
  }

  export type EmulatorPermissionUpdateInput = {
    rank?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorPermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorPermissionCreateManyInput = {
    id?: number
    rank: number
    permission: string
  }

  export type EmulatorPermissionUpdateManyMutationInput = {
    rank?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorPermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    permission?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorQuestCreateInput = {
    category?: string
    seriesNumber?: number
    goalType?: number
    goalData?: number
    name?: string
    reward?: number
    dataBit?: string
  }

  export type EmulatorQuestUncheckedCreateInput = {
    id?: number
    category?: string
    seriesNumber?: number
    goalType?: number
    goalData?: number
    name?: string
    reward?: number
    dataBit?: string
  }

  export type EmulatorQuestUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    seriesNumber?: IntFieldUpdateOperationsInput | number
    goalType?: IntFieldUpdateOperationsInput | number
    goalData?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reward?: IntFieldUpdateOperationsInput | number
    dataBit?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorQuestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    seriesNumber?: IntFieldUpdateOperationsInput | number
    goalType?: IntFieldUpdateOperationsInput | number
    goalData?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reward?: IntFieldUpdateOperationsInput | number
    dataBit?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorQuestCreateManyInput = {
    id?: number
    category?: string
    seriesNumber?: number
    goalType?: number
    goalData?: number
    name?: string
    reward?: number
    dataBit?: string
  }

  export type EmulatorQuestUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    seriesNumber?: IntFieldUpdateOperationsInput | number
    goalType?: IntFieldUpdateOperationsInput | number
    goalData?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reward?: IntFieldUpdateOperationsInput | number
    dataBit?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorQuestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    seriesNumber?: IntFieldUpdateOperationsInput | number
    goalType?: IntFieldUpdateOperationsInput | number
    goalData?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reward?: IntFieldUpdateOperationsInput | number
    dataBit?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorSettingCreateInput = {
    key: string
    value: string
  }

  export type EmulatorSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
  }

  export type EmulatorSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorSettingCreateManyInput = {
    id?: number
    key: string
    value: string
  }

  export type EmulatorSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type EmulatorStatsCreateInput = {
    online: number
    time: number
    room: number
  }

  export type EmulatorStatsUncheckedCreateInput = {
    id?: number
    online: number
    time: number
    room: number
  }

  export type EmulatorStatsUpdateInput = {
    online?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    online?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatsCreateManyInput = {
    id?: number
    online: number
    time: number
    room: number
  }

  export type EmulatorStatsUpdateManyMutationInput = {
    online?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    online?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    room?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatusCreateInput = {
    status?: number
    usersOnline?: number
    roomsLoaded?: number
    stamp: number
    userpeak: number
  }

  export type EmulatorStatusUncheckedCreateInput = {
    id?: number
    status?: number
    usersOnline?: number
    roomsLoaded?: number
    stamp: number
    userpeak: number
  }

  export type EmulatorStatusUpdateInput = {
    status?: IntFieldUpdateOperationsInput | number
    usersOnline?: IntFieldUpdateOperationsInput | number
    roomsLoaded?: IntFieldUpdateOperationsInput | number
    stamp?: IntFieldUpdateOperationsInput | number
    userpeak?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    usersOnline?: IntFieldUpdateOperationsInput | number
    roomsLoaded?: IntFieldUpdateOperationsInput | number
    stamp?: IntFieldUpdateOperationsInput | number
    userpeak?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatusCreateManyInput = {
    id?: number
    status?: number
    usersOnline?: number
    roomsLoaded?: number
    stamp: number
    userpeak: number
  }

  export type EmulatorStatusUpdateManyMutationInput = {
    status?: IntFieldUpdateOperationsInput | number
    usersOnline?: IntFieldUpdateOperationsInput | number
    roomsLoaded?: IntFieldUpdateOperationsInput | number
    stamp?: IntFieldUpdateOperationsInput | number
    userpeak?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    usersOnline?: IntFieldUpdateOperationsInput | number
    roomsLoaded?: IntFieldUpdateOperationsInput | number
    stamp?: IntFieldUpdateOperationsInput | number
    userpeak?: IntFieldUpdateOperationsInput | number
  }

  export type EmulatorTextCreateInput = {
    identifiant: string
    valueFr?: string | null
    valueEn?: string | null
    valueBr?: string | null
  }

  export type EmulatorTextUncheckedCreateInput = {
    id?: number
    identifiant: string
    valueFr?: string | null
    valueEn?: string | null
    valueBr?: string | null
  }

  export type EmulatorTextUpdateInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    valueFr?: NullableStringFieldUpdateOperationsInput | string | null
    valueEn?: NullableStringFieldUpdateOperationsInput | string | null
    valueBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorTextUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    valueFr?: NullableStringFieldUpdateOperationsInput | string | null
    valueEn?: NullableStringFieldUpdateOperationsInput | string | null
    valueBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorTextCreateManyInput = {
    id?: number
    identifiant: string
    valueFr?: string | null
    valueEn?: string | null
    valueBr?: string | null
  }

  export type EmulatorTextUpdateManyMutationInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    valueFr?: NullableStringFieldUpdateOperationsInput | string | null
    valueEn?: NullableStringFieldUpdateOperationsInput | string | null
    valueBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmulatorTextUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    valueFr?: NullableStringFieldUpdateOperationsInput | string | null
    valueEn?: NullableStringFieldUpdateOperationsInput | string | null
    valueBr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildCreateInput = {
    name: string
    desc: string
    badge: string
    ownerId: number
    created: number
    roomId: number
    state?: number
    colour1: number
    colour2: number
    admindeco?: boolean
    hasForum?: boolean
  }

  export type GuildUncheckedCreateInput = {
    id?: number
    name: string
    desc: string
    badge: string
    ownerId: number
    created: number
    roomId: number
    state?: number
    colour1: number
    colour2: number
    admindeco?: boolean
    hasForum?: boolean
  }

  export type GuildUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    colour1?: IntFieldUpdateOperationsInput | number
    colour2?: IntFieldUpdateOperationsInput | number
    admindeco?: BoolFieldUpdateOperationsInput | boolean
    hasForum?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    colour1?: IntFieldUpdateOperationsInput | number
    colour2?: IntFieldUpdateOperationsInput | number
    admindeco?: BoolFieldUpdateOperationsInput | boolean
    hasForum?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildCreateManyInput = {
    id?: number
    name: string
    desc: string
    badge: string
    ownerId: number
    created: number
    roomId: number
    state?: number
    colour1: number
    colour2: number
    admindeco?: boolean
    hasForum?: boolean
  }

  export type GuildUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    colour1?: IntFieldUpdateOperationsInput | number
    colour2?: IntFieldUpdateOperationsInput | number
    admindeco?: BoolFieldUpdateOperationsInput | boolean
    hasForum?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    badge?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    state?: IntFieldUpdateOperationsInput | number
    colour1?: IntFieldUpdateOperationsInput | number
    colour2?: IntFieldUpdateOperationsInput | number
    admindeco?: BoolFieldUpdateOperationsInput | boolean
    hasForum?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildItemCreateInput = {
    id: number
    type: $Enums.GuildItemType
    firstvalue: string
    secondvalue: string
    enabled?: boolean
  }

  export type GuildItemUncheckedCreateInput = {
    id: number
    type: $Enums.GuildItemType
    firstvalue: string
    secondvalue: string
    enabled?: boolean
  }

  export type GuildItemUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGuildItemTypeFieldUpdateOperationsInput | $Enums.GuildItemType
    firstvalue?: StringFieldUpdateOperationsInput | string
    secondvalue?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGuildItemTypeFieldUpdateOperationsInput | $Enums.GuildItemType
    firstvalue?: StringFieldUpdateOperationsInput | string
    secondvalue?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildItemCreateManyInput = {
    id: number
    type: $Enums.GuildItemType
    firstvalue: string
    secondvalue: string
    enabled?: boolean
  }

  export type GuildItemUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGuildItemTypeFieldUpdateOperationsInput | $Enums.GuildItemType
    firstvalue?: StringFieldUpdateOperationsInput | string
    secondvalue?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumGuildItemTypeFieldUpdateOperationsInput | $Enums.GuildItemType
    firstvalue?: StringFieldUpdateOperationsInput | string
    secondvalue?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuildMembershipCreateInput = {
    groupId: number
    userId: number
    rank?: number
  }

  export type GuildMembershipUncheckedCreateInput = {
    groupId: number
    userId: number
    rank?: number
  }

  export type GuildMembershipUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
  }

  export type GuildMembershipUncheckedUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
  }

  export type GuildMembershipCreateManyInput = {
    groupId: number
    userId: number
    rank?: number
  }

  export type GuildMembershipUpdateManyMutationInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
  }

  export type GuildMembershipUncheckedUpdateManyInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
  }

  export type GuildRequestCreateInput = {
    groupId: number
    userId: number
  }

  export type GuildRequestUncheckedCreateInput = {
    groupId: number
    userId: number
  }

  export type GuildRequestUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GuildRequestUncheckedUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GuildRequestCreateManyInput = {
    groupId: number
    userId: number
  }

  export type GuildRequestUpdateManyMutationInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GuildRequestUncheckedUpdateManyInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCreateInput = {
    userId: number
    roomId?: number
    baseItem: number
    extraData?: string | null
    x?: number
    y?: number
    z?: number
    rot?: number
    wallPos?: string | null
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    userId: number
    roomId?: number
    baseItem: number
    extraData?: string | null
    x?: number
    y?: number
    z?: number
    rot?: number
    wallPos?: string | null
  }

  export type ItemUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    baseItem?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    rot?: IntFieldUpdateOperationsInput | number
    wallPos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    baseItem?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    rot?: IntFieldUpdateOperationsInput | number
    wallPos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateManyInput = {
    id?: number
    userId: number
    roomId?: number
    baseItem: number
    extraData?: string | null
    x?: number
    y?: number
    z?: number
    rot?: number
    wallPos?: string | null
  }

  export type ItemUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    baseItem?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    rot?: IntFieldUpdateOperationsInput | number
    wallPos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    baseItem?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    z?: FloatFieldUpdateOperationsInput | number
    rot?: IntFieldUpdateOperationsInput | number
    wallPos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemBaseCreateInput = {
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    itemStat?: ItemStatCreateNestedOneWithoutItemBaseInput
    logLootbox?: LogLootboxCreateNestedManyWithoutItemBaseInput
    catalogItem?: CatalogItemCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseUncheckedCreateInput = {
    id?: number
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    itemStat?: ItemStatUncheckedCreateNestedOneWithoutItemBaseInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutItemBaseInput
    catalogItem?: CatalogItemUncheckedCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseUpdateInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    itemStat?: ItemStatUpdateOneWithoutItemBaseNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutItemBaseNestedInput
    catalogItem?: CatalogItemUpdateManyWithoutItemBaseNestedInput
  }

  export type ItemBaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    itemStat?: ItemStatUncheckedUpdateOneWithoutItemBaseNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutItemBaseNestedInput
    catalogItem?: CatalogItemUncheckedUpdateManyWithoutItemBaseNestedInput
  }

  export type ItemBaseCreateManyInput = {
    id?: number
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
  }

  export type ItemBaseUpdateManyMutationInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ItemBaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
  }

  export type ItemLimitedCreateInput = {
    itemId: number
    limitedNumber: number
    limitedStack?: number
  }

  export type ItemLimitedUncheckedCreateInput = {
    itemId: number
    limitedNumber: number
    limitedStack?: number
  }

  export type ItemLimitedUpdateInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type ItemLimitedUncheckedUpdateInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type ItemLimitedCreateManyInput = {
    itemId: number
    limitedNumber: number
    limitedStack?: number
  }

  export type ItemLimitedUpdateManyMutationInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type ItemLimitedUncheckedUpdateManyInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    limitedNumber?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type ItemMoodlightCreateInput = {
    itemId: number
    enabled?: boolean
    currentPreset: number
    presetOne: string
    presetTwo: string
    presetThree: string
  }

  export type ItemMoodlightUncheckedCreateInput = {
    itemId: number
    enabled?: boolean
    currentPreset: number
    presetOne: string
    presetTwo: string
    presetThree: string
  }

  export type ItemMoodlightUpdateInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    currentPreset?: IntFieldUpdateOperationsInput | number
    presetOne?: StringFieldUpdateOperationsInput | string
    presetTwo?: StringFieldUpdateOperationsInput | string
    presetThree?: StringFieldUpdateOperationsInput | string
  }

  export type ItemMoodlightUncheckedUpdateInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    currentPreset?: IntFieldUpdateOperationsInput | number
    presetOne?: StringFieldUpdateOperationsInput | string
    presetTwo?: StringFieldUpdateOperationsInput | string
    presetThree?: StringFieldUpdateOperationsInput | string
  }

  export type ItemMoodlightCreateManyInput = {
    itemId: number
    enabled?: boolean
    currentPreset: number
    presetOne: string
    presetTwo: string
    presetThree: string
  }

  export type ItemMoodlightUpdateManyMutationInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    currentPreset?: IntFieldUpdateOperationsInput | number
    presetOne?: StringFieldUpdateOperationsInput | string
    presetTwo?: StringFieldUpdateOperationsInput | string
    presetThree?: StringFieldUpdateOperationsInput | string
  }

  export type ItemMoodlightUncheckedUpdateManyInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    currentPreset?: IntFieldUpdateOperationsInput | number
    presetOne?: StringFieldUpdateOperationsInput | string
    presetTwo?: StringFieldUpdateOperationsInput | string
    presetThree?: StringFieldUpdateOperationsInput | string
  }

  export type ItemPresentCreateInput = {
    itemId: number
    baseId: number
    extraData?: string | null
  }

  export type ItemPresentUncheckedCreateInput = {
    itemId: number
    baseId: number
    extraData?: string | null
  }

  export type ItemPresentUpdateInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemPresentUncheckedUpdateInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemPresentCreateManyInput = {
    itemId: number
    baseId: number
    extraData?: string | null
  }

  export type ItemPresentUpdateManyMutationInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemPresentUncheckedUpdateManyInput = {
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    extraData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemStatCreateInput = {
    amount?: number
    itemBase: ItemBaseCreateNestedOneWithoutItemStatInput
  }

  export type ItemStatUncheckedCreateInput = {
    baseId: number
    amount?: number
  }

  export type ItemStatUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    itemBase?: ItemBaseUpdateOneRequiredWithoutItemStatNestedInput
  }

  export type ItemStatUncheckedUpdateInput = {
    baseId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type ItemStatCreateManyInput = {
    baseId: number
    amount?: number
  }

  export type ItemStatUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type ItemStatUncheckedUpdateManyInput = {
    baseId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type ItemTeleportCreateInput = {
    teleOneId: number
    teleTwoId: number
  }

  export type ItemTeleportUncheckedCreateInput = {
    teleOneId: number
    teleTwoId: number
  }

  export type ItemTeleportUpdateInput = {
    teleOneId?: IntFieldUpdateOperationsInput | number
    teleTwoId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemTeleportUncheckedUpdateInput = {
    teleOneId?: IntFieldUpdateOperationsInput | number
    teleTwoId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemTeleportCreateManyInput = {
    teleOneId: number
    teleTwoId: number
  }

  export type ItemTeleportUpdateManyMutationInput = {
    teleOneId?: IntFieldUpdateOperationsInput | number
    teleTwoId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemTeleportUncheckedUpdateManyInput = {
    teleOneId?: IntFieldUpdateOperationsInput | number
    teleTwoId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemWiredCreateInput = {
    triggerId: number
    triggerData2?: string | null
    triggerData?: string | null
    allUserTriggerable?: boolean
    triggersItem?: string | null
    delay?: number
  }

  export type ItemWiredUncheckedCreateInput = {
    triggerId: number
    triggerData2?: string | null
    triggerData?: string | null
    allUserTriggerable?: boolean
    triggersItem?: string | null
    delay?: number
  }

  export type ItemWiredUpdateInput = {
    triggerId?: IntFieldUpdateOperationsInput | number
    triggerData2?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableStringFieldUpdateOperationsInput | string | null
    allUserTriggerable?: BoolFieldUpdateOperationsInput | boolean
    triggersItem?: NullableStringFieldUpdateOperationsInput | string | null
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type ItemWiredUncheckedUpdateInput = {
    triggerId?: IntFieldUpdateOperationsInput | number
    triggerData2?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableStringFieldUpdateOperationsInput | string | null
    allUserTriggerable?: BoolFieldUpdateOperationsInput | boolean
    triggersItem?: NullableStringFieldUpdateOperationsInput | string | null
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type ItemWiredCreateManyInput = {
    triggerId: number
    triggerData2?: string | null
    triggerData?: string | null
    allUserTriggerable?: boolean
    triggersItem?: string | null
    delay?: number
  }

  export type ItemWiredUpdateManyMutationInput = {
    triggerId?: IntFieldUpdateOperationsInput | number
    triggerData2?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableStringFieldUpdateOperationsInput | string | null
    allUserTriggerable?: BoolFieldUpdateOperationsInput | boolean
    triggersItem?: NullableStringFieldUpdateOperationsInput | string | null
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type ItemWiredUncheckedUpdateManyInput = {
    triggerId?: IntFieldUpdateOperationsInput | number
    triggerData2?: NullableStringFieldUpdateOperationsInput | string | null
    triggerData?: NullableStringFieldUpdateOperationsInput | string | null
    allUserTriggerable?: BoolFieldUpdateOperationsInput | boolean
    triggersItem?: NullableStringFieldUpdateOperationsInput | string | null
    delay?: IntFieldUpdateOperationsInput | number
  }

  export type LogChatCreateInput = {
    userName: string
    timestamp?: number
    message: string
    type: string
    user: UserCreateNestedOneWithoutLogChatInput
    room?: RoomCreateNestedOneWithoutLogChatInput
  }

  export type LogChatUncheckedCreateInput = {
    id?: number
    userId: number
    roomId?: number | null
    userName: string
    timestamp?: number
    message: string
    type: string
  }

  export type LogChatUpdateInput = {
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLogChatNestedInput
    room?: RoomUpdateOneWithoutLogChatNestedInput
  }

  export type LogChatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatCreateManyInput = {
    id?: number
    userId: number
    roomId?: number | null
    userName: string
    timestamp?: number
    message: string
    type: string
  }

  export type LogChatUpdateManyMutationInput = {
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatPubCreateInput = {
    userId: number
    userName: string
    timestamp?: number
    message: string
  }

  export type LogChatPubUncheckedCreateInput = {
    id?: number
    userId: number
    userName: string
    timestamp?: number
    message: string
  }

  export type LogChatPubUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatPubUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatPubCreateManyInput = {
    id?: number
    userId: number
    userName: string
    timestamp?: number
    message: string
  }

  export type LogChatPubUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatPubUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type LogCommandCreateInput = {
    userId: number
    userName: string
    roomid: number
    command: string
    extraData: string
    timestamp: number
  }

  export type LogCommandUncheckedCreateInput = {
    id?: number
    userId: number
    userName: string
    roomid: number
    command: string
    extraData: string
    timestamp: number
  }

  export type LogCommandUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    roomid?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    extraData?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogCommandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    roomid?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    extraData?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogCommandCreateManyInput = {
    id?: number
    userId: number
    userName: string
    roomid: number
    command: string
    extraData: string
    timestamp: number
  }

  export type LogCommandUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    roomid?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    extraData?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogCommandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    roomid?: IntFieldUpdateOperationsInput | number
    command?: StringFieldUpdateOperationsInput | string
    extraData?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogFlagmeCreateInput = {
    userId: number
    oldusername: string
    newusername: string
    time: number
  }

  export type LogFlagmeUncheckedCreateInput = {
    id?: number
    userId: number
    oldusername: string
    newusername: string
    time: number
  }

  export type LogFlagmeUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    oldusername?: StringFieldUpdateOperationsInput | string
    newusername?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogFlagmeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    oldusername?: StringFieldUpdateOperationsInput | string
    newusername?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogFlagmeCreateManyInput = {
    id?: number
    userId: number
    oldusername: string
    newusername: string
    time: number
  }

  export type LogFlagmeUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    oldusername?: StringFieldUpdateOperationsInput | string
    newusername?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogFlagmeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    oldusername?: StringFieldUpdateOperationsInput | string
    newusername?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogLoginCreateInput = {
    date?: number
    ip: string
    userAgent: string
    user: UserCreateNestedOneWithoutLogLoginInput
  }

  export type LogLoginUncheckedCreateInput = {
    id?: number
    userId: number
    date?: number
    ip: string
    userAgent: string
  }

  export type LogLoginUpdateInput = {
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLogLoginNestedInput
  }

  export type LogLoginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
  }

  export type LogLoginCreateManyInput = {
    id?: number
    userId: number
    date?: number
    ip: string
    userAgent: string
  }

  export type LogLoginUpdateManyMutationInput = {
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
  }

  export type LogLoginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
  }

  export type LogLootboxCreateInput = {
    interactionType: string
    itemId: number
    timestamp: number
    user: UserCreateNestedOneWithoutLogLootboxInput
    itemBase: ItemBaseCreateNestedOneWithoutLogLootboxInput
  }

  export type LogLootboxUncheckedCreateInput = {
    id?: number
    interactionType: string
    userId: number
    itemId: number
    baseId: number
    timestamp: number
  }

  export type LogLootboxUpdateInput = {
    interactionType?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLogLootboxNestedInput
    itemBase?: ItemBaseUpdateOneRequiredWithoutLogLootboxNestedInput
  }

  export type LogLootboxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogLootboxCreateManyInput = {
    id?: number
    interactionType: string
    userId: number
    itemId: number
    baseId: number
    timestamp: number
  }

  export type LogLootboxUpdateManyMutationInput = {
    interactionType?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogLootboxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogPaymentCreateInput = {
    docId: number
    userId: number
    awards: number
    externalReference: string
    promoId: number
    date: Date | string
  }

  export type LogPaymentUncheckedCreateInput = {
    historyPaymentId?: number
    docId: number
    userId: number
    awards: number
    externalReference: string
    promoId: number
    date: Date | string
  }

  export type LogPaymentUpdateInput = {
    docId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    awards?: IntFieldUpdateOperationsInput | number
    externalReference?: StringFieldUpdateOperationsInput | string
    promoId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogPaymentUncheckedUpdateInput = {
    historyPaymentId?: IntFieldUpdateOperationsInput | number
    docId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    awards?: IntFieldUpdateOperationsInput | number
    externalReference?: StringFieldUpdateOperationsInput | string
    promoId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogPaymentCreateManyInput = {
    historyPaymentId?: number
    docId: number
    userId: number
    awards: number
    externalReference: string
    promoId: number
    date: Date | string
  }

  export type LogPaymentUpdateManyMutationInput = {
    docId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    awards?: IntFieldUpdateOperationsInput | number
    externalReference?: StringFieldUpdateOperationsInput | string
    promoId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogPaymentUncheckedUpdateManyInput = {
    historyPaymentId?: IntFieldUpdateOperationsInput | number
    docId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    awards?: IntFieldUpdateOperationsInput | number
    externalReference?: StringFieldUpdateOperationsInput | string
    promoId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogShopCreateInput = {
    date: number
    price: number
    content: string
    type: number
    catalogItemId?: number
    user: UserCreateNestedOneWithoutLogShopInput
  }

  export type LogShopUncheckedCreateInput = {
    id?: number
    userId: number
    date: number
    price: number
    content: string
    type: number
    catalogItemId?: number
  }

  export type LogShopUpdateInput = {
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLogShopNestedInput
  }

  export type LogShopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
  }

  export type LogShopCreateManyInput = {
    id?: number
    userId: number
    date: number
    price: number
    content: string
    type: number
    catalogItemId?: number
  }

  export type LogShopUpdateManyMutationInput = {
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
  }

  export type LogShopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
  }

  export type LogSlotmachineCreateInput = {
    amount: number
    isWin: boolean
    date: number
    user: UserCreateNestedOneWithoutLogSlotmachineInput
  }

  export type LogSlotmachineUncheckedCreateInput = {
    id?: number
    userId: number
    amount: number
    isWin: boolean
    date: number
  }

  export type LogSlotmachineUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLogSlotmachineNestedInput
  }

  export type LogSlotmachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogSlotmachineCreateManyInput = {
    id?: number
    userId: number
    amount: number
    isWin: boolean
    date: number
  }

  export type LogSlotmachineUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogSlotmachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogStaffCreateInput = {
    pseudo: string
    action: string
    date: number
  }

  export type LogStaffUncheckedCreateInput = {
    id?: number
    pseudo: string
    action: string
    date: number
  }

  export type LogStaffUpdateInput = {
    pseudo?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogStaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pseudo?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogStaffCreateManyInput = {
    id?: number
    pseudo: string
    action: string
    date: number
  }

  export type LogStaffUpdateManyMutationInput = {
    pseudo?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogStaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pseudo?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogTradeCreateInput = {
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
    userOneTrade: UserCreateNestedOneWithoutUserOneTradeInput
    userTwoTrade: UserCreateNestedOneWithoutUserTwoTradeInput
  }

  export type LogTradeUncheckedCreateInput = {
    id?: number
    userOneId: number
    userTwoId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
  }

  export type LogTradeUpdateInput = {
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    userOneTrade?: UserUpdateOneRequiredWithoutUserOneTradeNestedInput
    userTwoTrade?: UserUpdateOneRequiredWithoutUserTwoTradeNestedInput
  }

  export type LogTradeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOneId?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogTradeCreateManyInput = {
    id?: number
    userOneId: number
    userTwoId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
  }

  export type LogTradeUpdateManyMutationInput = {
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogTradeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOneId?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogVpnCreateInput = {
    ip: string
    ipCountry?: string | null
    host?: string | null
    timestampCreated: number
    isVpn?: boolean
  }

  export type LogVpnUncheckedCreateInput = {
    id?: number
    ip: string
    ipCountry?: string | null
    host?: string | null
    timestampCreated: number
    isVpn?: boolean
  }

  export type LogVpnUpdateInput = {
    ip?: StringFieldUpdateOperationsInput | string
    ipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestampCreated?: IntFieldUpdateOperationsInput | number
    isVpn?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogVpnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    ipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestampCreated?: IntFieldUpdateOperationsInput | number
    isVpn?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogVpnCreateManyInput = {
    id?: number
    ip: string
    ipCountry?: string | null
    host?: string | null
    timestampCreated: number
    isVpn?: boolean
  }

  export type LogVpnUpdateManyMutationInput = {
    ip?: StringFieldUpdateOperationsInput | string
    ipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestampCreated?: IntFieldUpdateOperationsInput | number
    isVpn?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogVpnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    ipCountry?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    timestampCreated?: IntFieldUpdateOperationsInput | number
    isVpn?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LogSandboxCreateInput = {
    method: string
    editName: string
    editKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLogSandboxInput
  }

  export type LogSandboxUncheckedCreateInput = {
    id?: number
    userId: number
    method: string
    editName: string
    editKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogSandboxUpdateInput = {
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLogSandboxNestedInput
  }

  export type LogSandboxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSandboxCreateManyInput = {
    id?: number
    userId: number
    method: string
    editName: string
    editKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogSandboxUpdateManyMutationInput = {
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSandboxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessengerFriendshipCreateInput = {
    userOneId: number
    userTwoId: number
    relation?: number
  }

  export type MessengerFriendshipUncheckedCreateInput = {
    userOneId: number
    userTwoId: number
    relation?: number
  }

  export type MessengerFriendshipUpdateInput = {
    userOneId?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    relation?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerFriendshipUncheckedUpdateInput = {
    userOneId?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    relation?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerFriendshipCreateManyInput = {
    userOneId: number
    userTwoId: number
    relation?: number
  }

  export type MessengerFriendshipUpdateManyMutationInput = {
    userOneId?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    relation?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerFriendshipUncheckedUpdateManyInput = {
    userOneId?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    relation?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerOfflineMessageCreateInput = {
    toId?: number
    fromId?: number
    message: string
    timestamp?: number
  }

  export type MessengerOfflineMessageUncheckedCreateInput = {
    id?: number
    toId?: number
    fromId?: number
    message: string
    timestamp?: number
  }

  export type MessengerOfflineMessageUpdateInput = {
    toId?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerOfflineMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerOfflineMessageCreateManyInput = {
    id?: number
    toId?: number
    fromId?: number
    message: string
    timestamp?: number
  }

  export type MessengerOfflineMessageUpdateManyMutationInput = {
    toId?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerOfflineMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerRequestCreateInput = {
    fromId: number
    toId: number
  }

  export type MessengerRequestUncheckedCreateInput = {
    fromId: number
    toId: number
  }

  export type MessengerRequestUpdateInput = {
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerRequestUncheckedUpdateInput = {
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerRequestCreateManyInput = {
    fromId: number
    toId: number
  }

  export type MessengerRequestUpdateManyMutationInput = {
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type MessengerRequestUncheckedUpdateManyInput = {
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationPresetCreateInput = {
    enabled?: boolean
    type?: $Enums.ModerationPresetType
    message: string
  }

  export type ModerationPresetUncheckedCreateInput = {
    id?: number
    enabled?: boolean
    type?: $Enums.ModerationPresetType
    message: string
  }

  export type ModerationPresetUpdateInput = {
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumModerationPresetTypeFieldUpdateOperationsInput | $Enums.ModerationPresetType
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationPresetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumModerationPresetTypeFieldUpdateOperationsInput | $Enums.ModerationPresetType
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationPresetCreateManyInput = {
    id?: number
    enabled?: boolean
    type?: $Enums.ModerationPresetType
    message: string
  }

  export type ModerationPresetUpdateManyMutationInput = {
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumModerationPresetTypeFieldUpdateOperationsInput | $Enums.ModerationPresetType
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationPresetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumModerationPresetTypeFieldUpdateOperationsInput | $Enums.ModerationPresetType
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationResolutionCreateInput = {
    type?: $Enums.ModerationResolutionType
    title: string
    subtitle: string
    banHours?: number
    enableMute?: number
    muteHours?: number
    reminder?: number
    message: string
  }

  export type ModerationResolutionUncheckedCreateInput = {
    id?: number
    type?: $Enums.ModerationResolutionType
    title: string
    subtitle: string
    banHours?: number
    enableMute?: number
    muteHours?: number
    reminder?: number
    message: string
  }

  export type ModerationResolutionUpdateInput = {
    type?: EnumModerationResolutionTypeFieldUpdateOperationsInput | $Enums.ModerationResolutionType
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    banHours?: IntFieldUpdateOperationsInput | number
    enableMute?: IntFieldUpdateOperationsInput | number
    muteHours?: IntFieldUpdateOperationsInput | number
    reminder?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationResolutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumModerationResolutionTypeFieldUpdateOperationsInput | $Enums.ModerationResolutionType
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    banHours?: IntFieldUpdateOperationsInput | number
    enableMute?: IntFieldUpdateOperationsInput | number
    muteHours?: IntFieldUpdateOperationsInput | number
    reminder?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationResolutionCreateManyInput = {
    id?: number
    type?: $Enums.ModerationResolutionType
    title: string
    subtitle: string
    banHours?: number
    enableMute?: number
    muteHours?: number
    reminder?: number
    message: string
  }

  export type ModerationResolutionUpdateManyMutationInput = {
    type?: EnumModerationResolutionTypeFieldUpdateOperationsInput | $Enums.ModerationResolutionType
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    banHours?: IntFieldUpdateOperationsInput | number
    enableMute?: IntFieldUpdateOperationsInput | number
    muteHours?: IntFieldUpdateOperationsInput | number
    reminder?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationResolutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumModerationResolutionTypeFieldUpdateOperationsInput | $Enums.ModerationResolutionType
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    banHours?: IntFieldUpdateOperationsInput | number
    enableMute?: IntFieldUpdateOperationsInput | number
    muteHours?: IntFieldUpdateOperationsInput | number
    reminder?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationTicketCreateInput = {
    score: number
    type: number
    status?: $Enums.ModerationTicketStatus
    senderId: number
    reportedId: number
    moderatorId: number
    message: string
    roomId: number
    roomName: string
    timestamp: number
  }

  export type ModerationTicketUncheckedCreateInput = {
    id?: number
    score: number
    type: number
    status?: $Enums.ModerationTicketStatus
    senderId: number
    reportedId: number
    moderatorId: number
    message: string
    roomId: number
    roomName: string
    timestamp: number
  }

  export type ModerationTicketUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumModerationTicketStatusFieldUpdateOperationsInput | $Enums.ModerationTicketStatus
    senderId?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    moderatorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumModerationTicketStatusFieldUpdateOperationsInput | $Enums.ModerationTicketStatus
    senderId?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    moderatorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTicketCreateManyInput = {
    id?: number
    score: number
    type: number
    status?: $Enums.ModerationTicketStatus
    senderId: number
    reportedId: number
    moderatorId: number
    message: string
    roomId: number
    roomName: string
    timestamp: number
  }

  export type ModerationTicketUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumModerationTicketStatusFieldUpdateOperationsInput | $Enums.ModerationTicketStatus
    senderId?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    moderatorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumModerationTicketStatusFieldUpdateOperationsInput | $Enums.ModerationTicketStatus
    senderId?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    moderatorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTopicCreateInput = {
    caption?: string
  }

  export type ModerationTopicUncheckedCreateInput = {
    id?: number
    caption?: string
  }

  export type ModerationTopicUpdateInput = {
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationTopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationTopicCreateManyInput = {
    id?: number
    caption?: string
  }

  export type ModerationTopicUpdateManyMutationInput = {
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationTopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
  }

  export type ModerationTopicActionCreateInput = {
    parentId: number
    type: string
    caption?: string
    messageText: string
    defaultSanction: string
    muteTime?: number
    banTime?: number
    ipTime?: number
    tradeLockTime?: number
  }

  export type ModerationTopicActionUncheckedCreateInput = {
    id?: number
    parentId: number
    type: string
    caption?: string
    messageText: string
    defaultSanction: string
    muteTime?: number
    banTime?: number
    ipTime?: number
    tradeLockTime?: number
  }

  export type ModerationTopicActionUpdateInput = {
    parentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    defaultSanction?: StringFieldUpdateOperationsInput | string
    muteTime?: IntFieldUpdateOperationsInput | number
    banTime?: IntFieldUpdateOperationsInput | number
    ipTime?: IntFieldUpdateOperationsInput | number
    tradeLockTime?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTopicActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    defaultSanction?: StringFieldUpdateOperationsInput | string
    muteTime?: IntFieldUpdateOperationsInput | number
    banTime?: IntFieldUpdateOperationsInput | number
    ipTime?: IntFieldUpdateOperationsInput | number
    tradeLockTime?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTopicActionCreateManyInput = {
    id?: number
    parentId: number
    type: string
    caption?: string
    messageText: string
    defaultSanction: string
    muteTime?: number
    banTime?: number
    ipTime?: number
    tradeLockTime?: number
  }

  export type ModerationTopicActionUpdateManyMutationInput = {
    parentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    defaultSanction?: StringFieldUpdateOperationsInput | string
    muteTime?: IntFieldUpdateOperationsInput | number
    banTime?: IntFieldUpdateOperationsInput | number
    ipTime?: IntFieldUpdateOperationsInput | number
    tradeLockTime?: IntFieldUpdateOperationsInput | number
  }

  export type ModerationTopicActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    caption?: StringFieldUpdateOperationsInput | string
    messageText?: StringFieldUpdateOperationsInput | string
    defaultSanction?: StringFieldUpdateOperationsInput | string
    muteTime?: IntFieldUpdateOperationsInput | number
    banTime?: IntFieldUpdateOperationsInput | number
    ipTime?: IntFieldUpdateOperationsInput | number
    tradeLockTime?: IntFieldUpdateOperationsInput | number
  }

  export type NavigatorCategoryCreateInput = {
    id: number
    category?: $Enums.NavigatorCategoryCategory
    categoryIdentifier?: string
    publicName?: string
    viewMode?: $Enums.NavigatorCategoryViewMode
    requiredRank?: number
    categoryType?: string
    searchAllowance?: $Enums.NavigatorCategorySearchAllowance
    minimized?: boolean
    enabled?: boolean
    orderId?: number
  }

  export type NavigatorCategoryUncheckedCreateInput = {
    id: number
    category?: $Enums.NavigatorCategoryCategory
    categoryIdentifier?: string
    publicName?: string
    viewMode?: $Enums.NavigatorCategoryViewMode
    requiredRank?: number
    categoryType?: string
    searchAllowance?: $Enums.NavigatorCategorySearchAllowance
    minimized?: boolean
    enabled?: boolean
    orderId?: number
  }

  export type NavigatorCategoryUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumNavigatorCategoryCategoryFieldUpdateOperationsInput | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    viewMode?: EnumNavigatorCategoryViewModeFieldUpdateOperationsInput | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntFieldUpdateOperationsInput | number
    categoryType?: StringFieldUpdateOperationsInput | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceFieldUpdateOperationsInput | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type NavigatorCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumNavigatorCategoryCategoryFieldUpdateOperationsInput | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    viewMode?: EnumNavigatorCategoryViewModeFieldUpdateOperationsInput | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntFieldUpdateOperationsInput | number
    categoryType?: StringFieldUpdateOperationsInput | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceFieldUpdateOperationsInput | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type NavigatorCategoryCreateManyInput = {
    id: number
    category?: $Enums.NavigatorCategoryCategory
    categoryIdentifier?: string
    publicName?: string
    viewMode?: $Enums.NavigatorCategoryViewMode
    requiredRank?: number
    categoryType?: string
    searchAllowance?: $Enums.NavigatorCategorySearchAllowance
    minimized?: boolean
    enabled?: boolean
    orderId?: number
  }

  export type NavigatorCategoryUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumNavigatorCategoryCategoryFieldUpdateOperationsInput | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    viewMode?: EnumNavigatorCategoryViewModeFieldUpdateOperationsInput | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntFieldUpdateOperationsInput | number
    categoryType?: StringFieldUpdateOperationsInput | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceFieldUpdateOperationsInput | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type NavigatorCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumNavigatorCategoryCategoryFieldUpdateOperationsInput | $Enums.NavigatorCategoryCategory
    categoryIdentifier?: StringFieldUpdateOperationsInput | string
    publicName?: StringFieldUpdateOperationsInput | string
    viewMode?: EnumNavigatorCategoryViewModeFieldUpdateOperationsInput | $Enums.NavigatorCategoryViewMode
    requiredRank?: IntFieldUpdateOperationsInput | number
    categoryType?: StringFieldUpdateOperationsInput | string
    searchAllowance?: EnumNavigatorCategorySearchAllowanceFieldUpdateOperationsInput | $Enums.NavigatorCategorySearchAllowance
    minimized?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    orderId?: IntFieldUpdateOperationsInput | number
  }

  export type NavigatorPublicCreateInput = {
    roomId: number
    imageUrl?: string | null
    orderNum?: number
    enabled?: boolean
    langue?: $Enums.NavigatorPublicLangue
    categoryType?: string
  }

  export type NavigatorPublicUncheckedCreateInput = {
    roomId: number
    imageUrl?: string | null
    orderNum?: number
    enabled?: boolean
    langue?: $Enums.NavigatorPublicLangue
    categoryType?: string
  }

  export type NavigatorPublicUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumNavigatorPublicLangueFieldUpdateOperationsInput | $Enums.NavigatorPublicLangue
    categoryType?: StringFieldUpdateOperationsInput | string
  }

  export type NavigatorPublicUncheckedUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumNavigatorPublicLangueFieldUpdateOperationsInput | $Enums.NavigatorPublicLangue
    categoryType?: StringFieldUpdateOperationsInput | string
  }

  export type NavigatorPublicCreateManyInput = {
    roomId: number
    imageUrl?: string | null
    orderNum?: number
    enabled?: boolean
    langue?: $Enums.NavigatorPublicLangue
    categoryType?: string
  }

  export type NavigatorPublicUpdateManyMutationInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumNavigatorPublicLangueFieldUpdateOperationsInput | $Enums.NavigatorPublicLangue
    categoryType?: StringFieldUpdateOperationsInput | string
  }

  export type NavigatorPublicUncheckedUpdateManyInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderNum?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumNavigatorPublicLangueFieldUpdateOperationsInput | $Enums.NavigatorPublicLangue
    categoryType?: StringFieldUpdateOperationsInput | string
  }

  export type RoleplayCreateInput = {
    ownerId: number
    hopitalId?: number
    prisonId: number
  }

  export type RoleplayUncheckedCreateInput = {
    id?: number
    ownerId: number
    hopitalId?: number
    prisonId: number
  }

  export type RoleplayUpdateInput = {
    ownerId?: IntFieldUpdateOperationsInput | number
    hopitalId?: IntFieldUpdateOperationsInput | number
    prisonId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    hopitalId?: IntFieldUpdateOperationsInput | number
    prisonId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayCreateManyInput = {
    id?: number
    ownerId: number
    hopitalId?: number
    prisonId: number
  }

  export type RoleplayUpdateManyMutationInput = {
    ownerId?: IntFieldUpdateOperationsInput | number
    hopitalId?: IntFieldUpdateOperationsInput | number
    prisonId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    hopitalId?: IntFieldUpdateOperationsInput | number
    prisonId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayEnemyCreateInput = {
    id?: number
    type?: $Enums.RoleplayEnemyType
    health?: number
    weaponFarId?: number
    weaponCacId?: number
    deadTimer?: number
    lootItemId?: number
    moneyDrop?: number
    dropScriptId?: number
    teamId?: number
    aggroDistance?: number
    zoneDistance: number
    resetPosition?: boolean
    lostAggroDistance?: number
    zombieMode?: boolean
  }

  export type RoleplayEnemyUncheckedCreateInput = {
    id?: number
    type?: $Enums.RoleplayEnemyType
    health?: number
    weaponFarId?: number
    weaponCacId?: number
    deadTimer?: number
    lootItemId?: number
    moneyDrop?: number
    dropScriptId?: number
    teamId?: number
    aggroDistance?: number
    zoneDistance: number
    resetPosition?: boolean
    lostAggroDistance?: number
    zombieMode?: boolean
  }

  export type RoleplayEnemyUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayEnemyTypeFieldUpdateOperationsInput | $Enums.RoleplayEnemyType
    health?: IntFieldUpdateOperationsInput | number
    weaponFarId?: IntFieldUpdateOperationsInput | number
    weaponCacId?: IntFieldUpdateOperationsInput | number
    deadTimer?: IntFieldUpdateOperationsInput | number
    lootItemId?: IntFieldUpdateOperationsInput | number
    moneyDrop?: IntFieldUpdateOperationsInput | number
    dropScriptId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    aggroDistance?: IntFieldUpdateOperationsInput | number
    zoneDistance?: IntFieldUpdateOperationsInput | number
    resetPosition?: BoolFieldUpdateOperationsInput | boolean
    lostAggroDistance?: IntFieldUpdateOperationsInput | number
    zombieMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleplayEnemyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayEnemyTypeFieldUpdateOperationsInput | $Enums.RoleplayEnemyType
    health?: IntFieldUpdateOperationsInput | number
    weaponFarId?: IntFieldUpdateOperationsInput | number
    weaponCacId?: IntFieldUpdateOperationsInput | number
    deadTimer?: IntFieldUpdateOperationsInput | number
    lootItemId?: IntFieldUpdateOperationsInput | number
    moneyDrop?: IntFieldUpdateOperationsInput | number
    dropScriptId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    aggroDistance?: IntFieldUpdateOperationsInput | number
    zoneDistance?: IntFieldUpdateOperationsInput | number
    resetPosition?: BoolFieldUpdateOperationsInput | boolean
    lostAggroDistance?: IntFieldUpdateOperationsInput | number
    zombieMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleplayEnemyCreateManyInput = {
    id?: number
    type?: $Enums.RoleplayEnemyType
    health?: number
    weaponFarId?: number
    weaponCacId?: number
    deadTimer?: number
    lootItemId?: number
    moneyDrop?: number
    dropScriptId?: number
    teamId?: number
    aggroDistance?: number
    zoneDistance: number
    resetPosition?: boolean
    lostAggroDistance?: number
    zombieMode?: boolean
  }

  export type RoleplayEnemyUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayEnemyTypeFieldUpdateOperationsInput | $Enums.RoleplayEnemyType
    health?: IntFieldUpdateOperationsInput | number
    weaponFarId?: IntFieldUpdateOperationsInput | number
    weaponCacId?: IntFieldUpdateOperationsInput | number
    deadTimer?: IntFieldUpdateOperationsInput | number
    lootItemId?: IntFieldUpdateOperationsInput | number
    moneyDrop?: IntFieldUpdateOperationsInput | number
    dropScriptId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    aggroDistance?: IntFieldUpdateOperationsInput | number
    zoneDistance?: IntFieldUpdateOperationsInput | number
    resetPosition?: BoolFieldUpdateOperationsInput | boolean
    lostAggroDistance?: IntFieldUpdateOperationsInput | number
    zombieMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleplayEnemyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayEnemyTypeFieldUpdateOperationsInput | $Enums.RoleplayEnemyType
    health?: IntFieldUpdateOperationsInput | number
    weaponFarId?: IntFieldUpdateOperationsInput | number
    weaponCacId?: IntFieldUpdateOperationsInput | number
    deadTimer?: IntFieldUpdateOperationsInput | number
    lootItemId?: IntFieldUpdateOperationsInput | number
    moneyDrop?: IntFieldUpdateOperationsInput | number
    dropScriptId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    aggroDistance?: IntFieldUpdateOperationsInput | number
    zoneDistance?: IntFieldUpdateOperationsInput | number
    resetPosition?: BoolFieldUpdateOperationsInput | boolean
    lostAggroDistance?: IntFieldUpdateOperationsInput | number
    zombieMode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleplayItemCreateInput = {
    name: string
    desc?: string | null
    price?: number
    type: $Enums.RoleplayItemType
    value?: number
    allowstack?: boolean
    category: $Enums.RoleplayItemCategory
  }

  export type RoleplayItemUncheckedCreateInput = {
    id?: number
    name: string
    desc?: string | null
    price?: number
    type: $Enums.RoleplayItemType
    value?: number
    allowstack?: boolean
    category: $Enums.RoleplayItemCategory
  }

  export type RoleplayItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayItemTypeFieldUpdateOperationsInput | $Enums.RoleplayItemType
    value?: IntFieldUpdateOperationsInput | number
    allowstack?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumRoleplayItemCategoryFieldUpdateOperationsInput | $Enums.RoleplayItemCategory
  }

  export type RoleplayItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayItemTypeFieldUpdateOperationsInput | $Enums.RoleplayItemType
    value?: IntFieldUpdateOperationsInput | number
    allowstack?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumRoleplayItemCategoryFieldUpdateOperationsInput | $Enums.RoleplayItemCategory
  }

  export type RoleplayItemCreateManyInput = {
    id?: number
    name: string
    desc?: string | null
    price?: number
    type: $Enums.RoleplayItemType
    value?: number
    allowstack?: boolean
    category: $Enums.RoleplayItemCategory
  }

  export type RoleplayItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayItemTypeFieldUpdateOperationsInput | $Enums.RoleplayItemType
    value?: IntFieldUpdateOperationsInput | number
    allowstack?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumRoleplayItemCategoryFieldUpdateOperationsInput | $Enums.RoleplayItemCategory
  }

  export type RoleplayItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayItemTypeFieldUpdateOperationsInput | $Enums.RoleplayItemType
    value?: IntFieldUpdateOperationsInput | number
    allowstack?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumRoleplayItemCategoryFieldUpdateOperationsInput | $Enums.RoleplayItemCategory
  }

  export type RoleplayWeaponCreateInput = {
    type?: $Enums.RoleplayWeaponType
    domageMin?: number
    domageMax?: number
    interaction?: $Enums.RoleplayWeaponInteraction
    enable?: number
    freezeTime?: number
    distance?: number
  }

  export type RoleplayWeaponUncheckedCreateInput = {
    id?: number
    type?: $Enums.RoleplayWeaponType
    domageMin?: number
    domageMax?: number
    interaction?: $Enums.RoleplayWeaponInteraction
    enable?: number
    freezeTime?: number
    distance?: number
  }

  export type RoleplayWeaponUpdateInput = {
    type?: EnumRoleplayWeaponTypeFieldUpdateOperationsInput | $Enums.RoleplayWeaponType
    domageMin?: IntFieldUpdateOperationsInput | number
    domageMax?: IntFieldUpdateOperationsInput | number
    interaction?: EnumRoleplayWeaponInteractionFieldUpdateOperationsInput | $Enums.RoleplayWeaponInteraction
    enable?: IntFieldUpdateOperationsInput | number
    freezeTime?: IntFieldUpdateOperationsInput | number
    distance?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayWeaponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayWeaponTypeFieldUpdateOperationsInput | $Enums.RoleplayWeaponType
    domageMin?: IntFieldUpdateOperationsInput | number
    domageMax?: IntFieldUpdateOperationsInput | number
    interaction?: EnumRoleplayWeaponInteractionFieldUpdateOperationsInput | $Enums.RoleplayWeaponInteraction
    enable?: IntFieldUpdateOperationsInput | number
    freezeTime?: IntFieldUpdateOperationsInput | number
    distance?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayWeaponCreateManyInput = {
    id?: number
    type?: $Enums.RoleplayWeaponType
    domageMin?: number
    domageMax?: number
    interaction?: $Enums.RoleplayWeaponInteraction
    enable?: number
    freezeTime?: number
    distance?: number
  }

  export type RoleplayWeaponUpdateManyMutationInput = {
    type?: EnumRoleplayWeaponTypeFieldUpdateOperationsInput | $Enums.RoleplayWeaponType
    domageMin?: IntFieldUpdateOperationsInput | number
    domageMax?: IntFieldUpdateOperationsInput | number
    interaction?: EnumRoleplayWeaponInteractionFieldUpdateOperationsInput | $Enums.RoleplayWeaponInteraction
    enable?: IntFieldUpdateOperationsInput | number
    freezeTime?: IntFieldUpdateOperationsInput | number
    distance?: IntFieldUpdateOperationsInput | number
  }

  export type RoleplayWeaponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRoleplayWeaponTypeFieldUpdateOperationsInput | $Enums.RoleplayWeaponType
    domageMin?: IntFieldUpdateOperationsInput | number
    domageMax?: IntFieldUpdateOperationsInput | number
    interaction?: EnumRoleplayWeaponInteractionFieldUpdateOperationsInput | $Enums.RoleplayWeaponInteraction
    enable?: IntFieldUpdateOperationsInput | number
    freezeTime?: IntFieldUpdateOperationsInput | number
    distance?: IntFieldUpdateOperationsInput | number
  }

  export type RoomCreateInput = {
    caption?: string
    owner: string
    description?: string | null
    category?: number
    state?: $Enums.RoomState
    usersMax?: number
    modelName: string
    score?: number
    tags?: string | null
    password?: string | null
    wallpaper?: string
    floor?: string
    landscape?: string
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: number
    floorthick?: number
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: number
    moderationBanFuse?: boolean
    groupId?: number
    chatType?: number
    chatBalloon?: number
    chatSpeed?: number
    chatMaxDistance?: number
    chatFloodProtection?: number
    trocStatus?: number
    usersNow?: number
    allowHidewireds?: boolean
    price?: number
    wiredSecurity?: boolean
    LogChat?: LogChatCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    caption?: string
    owner: string
    description?: string | null
    category?: number
    state?: $Enums.RoomState
    usersMax?: number
    modelName: string
    score?: number
    tags?: string | null
    password?: string | null
    wallpaper?: string
    floor?: string
    landscape?: string
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: number
    floorthick?: number
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: number
    moderationBanFuse?: boolean
    groupId?: number
    chatType?: number
    chatBalloon?: number
    chatSpeed?: number
    chatMaxDistance?: number
    chatFloodProtection?: number
    trocStatus?: number
    usersNow?: number
    allowHidewireds?: boolean
    price?: number
    wiredSecurity?: boolean
    LogChat?: LogChatUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    caption?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    state?: EnumRoomStateFieldUpdateOperationsInput | $Enums.RoomState
    usersMax?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wallpaper?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    landscape?: StringFieldUpdateOperationsInput | string
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    allowPetsEat?: BoolFieldUpdateOperationsInput | boolean
    allowWalkthrough?: BoolFieldUpdateOperationsInput | boolean
    allowHidewall?: BoolFieldUpdateOperationsInput | boolean
    wallthick?: IntFieldUpdateOperationsInput | number
    floorthick?: IntFieldUpdateOperationsInput | number
    moderationMuteFuse?: BoolFieldUpdateOperationsInput | boolean
    allowRightsoverride?: BoolFieldUpdateOperationsInput | boolean
    moderationKickFuse?: IntFieldUpdateOperationsInput | number
    moderationBanFuse?: BoolFieldUpdateOperationsInput | boolean
    groupId?: IntFieldUpdateOperationsInput | number
    chatType?: IntFieldUpdateOperationsInput | number
    chatBalloon?: IntFieldUpdateOperationsInput | number
    chatSpeed?: IntFieldUpdateOperationsInput | number
    chatMaxDistance?: IntFieldUpdateOperationsInput | number
    chatFloodProtection?: IntFieldUpdateOperationsInput | number
    trocStatus?: IntFieldUpdateOperationsInput | number
    usersNow?: IntFieldUpdateOperationsInput | number
    allowHidewireds?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    wiredSecurity?: BoolFieldUpdateOperationsInput | boolean
    LogChat?: LogChatUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    state?: EnumRoomStateFieldUpdateOperationsInput | $Enums.RoomState
    usersMax?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wallpaper?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    landscape?: StringFieldUpdateOperationsInput | string
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    allowPetsEat?: BoolFieldUpdateOperationsInput | boolean
    allowWalkthrough?: BoolFieldUpdateOperationsInput | boolean
    allowHidewall?: BoolFieldUpdateOperationsInput | boolean
    wallthick?: IntFieldUpdateOperationsInput | number
    floorthick?: IntFieldUpdateOperationsInput | number
    moderationMuteFuse?: BoolFieldUpdateOperationsInput | boolean
    allowRightsoverride?: BoolFieldUpdateOperationsInput | boolean
    moderationKickFuse?: IntFieldUpdateOperationsInput | number
    moderationBanFuse?: BoolFieldUpdateOperationsInput | boolean
    groupId?: IntFieldUpdateOperationsInput | number
    chatType?: IntFieldUpdateOperationsInput | number
    chatBalloon?: IntFieldUpdateOperationsInput | number
    chatSpeed?: IntFieldUpdateOperationsInput | number
    chatMaxDistance?: IntFieldUpdateOperationsInput | number
    chatFloodProtection?: IntFieldUpdateOperationsInput | number
    trocStatus?: IntFieldUpdateOperationsInput | number
    usersNow?: IntFieldUpdateOperationsInput | number
    allowHidewireds?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    wiredSecurity?: BoolFieldUpdateOperationsInput | boolean
    LogChat?: LogChatUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: number
    caption?: string
    owner: string
    description?: string | null
    category?: number
    state?: $Enums.RoomState
    usersMax?: number
    modelName: string
    score?: number
    tags?: string | null
    password?: string | null
    wallpaper?: string
    floor?: string
    landscape?: string
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: number
    floorthick?: number
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: number
    moderationBanFuse?: boolean
    groupId?: number
    chatType?: number
    chatBalloon?: number
    chatSpeed?: number
    chatMaxDistance?: number
    chatFloodProtection?: number
    trocStatus?: number
    usersNow?: number
    allowHidewireds?: boolean
    price?: number
    wiredSecurity?: boolean
  }

  export type RoomUpdateManyMutationInput = {
    caption?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    state?: EnumRoomStateFieldUpdateOperationsInput | $Enums.RoomState
    usersMax?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wallpaper?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    landscape?: StringFieldUpdateOperationsInput | string
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    allowPetsEat?: BoolFieldUpdateOperationsInput | boolean
    allowWalkthrough?: BoolFieldUpdateOperationsInput | boolean
    allowHidewall?: BoolFieldUpdateOperationsInput | boolean
    wallthick?: IntFieldUpdateOperationsInput | number
    floorthick?: IntFieldUpdateOperationsInput | number
    moderationMuteFuse?: BoolFieldUpdateOperationsInput | boolean
    allowRightsoverride?: BoolFieldUpdateOperationsInput | boolean
    moderationKickFuse?: IntFieldUpdateOperationsInput | number
    moderationBanFuse?: BoolFieldUpdateOperationsInput | boolean
    groupId?: IntFieldUpdateOperationsInput | number
    chatType?: IntFieldUpdateOperationsInput | number
    chatBalloon?: IntFieldUpdateOperationsInput | number
    chatSpeed?: IntFieldUpdateOperationsInput | number
    chatMaxDistance?: IntFieldUpdateOperationsInput | number
    chatFloodProtection?: IntFieldUpdateOperationsInput | number
    trocStatus?: IntFieldUpdateOperationsInput | number
    usersNow?: IntFieldUpdateOperationsInput | number
    allowHidewireds?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    wiredSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    state?: EnumRoomStateFieldUpdateOperationsInput | $Enums.RoomState
    usersMax?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wallpaper?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    landscape?: StringFieldUpdateOperationsInput | string
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    allowPetsEat?: BoolFieldUpdateOperationsInput | boolean
    allowWalkthrough?: BoolFieldUpdateOperationsInput | boolean
    allowHidewall?: BoolFieldUpdateOperationsInput | boolean
    wallthick?: IntFieldUpdateOperationsInput | number
    floorthick?: IntFieldUpdateOperationsInput | number
    moderationMuteFuse?: BoolFieldUpdateOperationsInput | boolean
    allowRightsoverride?: BoolFieldUpdateOperationsInput | boolean
    moderationKickFuse?: IntFieldUpdateOperationsInput | number
    moderationBanFuse?: BoolFieldUpdateOperationsInput | boolean
    groupId?: IntFieldUpdateOperationsInput | number
    chatType?: IntFieldUpdateOperationsInput | number
    chatBalloon?: IntFieldUpdateOperationsInput | number
    chatSpeed?: IntFieldUpdateOperationsInput | number
    chatMaxDistance?: IntFieldUpdateOperationsInput | number
    chatFloodProtection?: IntFieldUpdateOperationsInput | number
    trocStatus?: IntFieldUpdateOperationsInput | number
    usersNow?: IntFieldUpdateOperationsInput | number
    allowHidewireds?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    wiredSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomModelCreateInput = {
    id: string
    doorX?: number
    doorY?: number
    doorZ?: number
    doorDir?: number
    heightmap: string
  }

  export type RoomModelUncheckedCreateInput = {
    id: string
    doorX?: number
    doorY?: number
    doorZ?: number
    doorDir?: number
    heightmap: string
  }

  export type RoomModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
  }

  export type RoomModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
  }

  export type RoomModelCreateManyInput = {
    id: string
    doorX?: number
    doorY?: number
    doorZ?: number
    doorDir?: number
    heightmap: string
  }

  export type RoomModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
  }

  export type RoomModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
  }

  export type RoomModelCustomCreateInput = {
    roomId: number
    doorX?: number
    doorY?: number
    doorZ?: number
    doorDir?: number
    heightmap: string
    wallHeight?: number
  }

  export type RoomModelCustomUncheckedCreateInput = {
    roomId: number
    doorX?: number
    doorY?: number
    doorZ?: number
    doorDir?: number
    heightmap: string
    wallHeight?: number
  }

  export type RoomModelCustomUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
    wallHeight?: IntFieldUpdateOperationsInput | number
  }

  export type RoomModelCustomUncheckedUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
    wallHeight?: IntFieldUpdateOperationsInput | number
  }

  export type RoomModelCustomCreateManyInput = {
    roomId: number
    doorX?: number
    doorY?: number
    doorZ?: number
    doorDir?: number
    heightmap: string
    wallHeight?: number
  }

  export type RoomModelCustomUpdateManyMutationInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
    wallHeight?: IntFieldUpdateOperationsInput | number
  }

  export type RoomModelCustomUncheckedUpdateManyInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    doorX?: IntFieldUpdateOperationsInput | number
    doorY?: IntFieldUpdateOperationsInput | number
    doorZ?: FloatFieldUpdateOperationsInput | number
    doorDir?: IntFieldUpdateOperationsInput | number
    heightmap?: StringFieldUpdateOperationsInput | string
    wallHeight?: IntFieldUpdateOperationsInput | number
  }

  export type RoomRightCreateInput = {
    roomId: number
    userId: number
  }

  export type RoomRightUncheckedCreateInput = {
    roomId: number
    userId: number
  }

  export type RoomRightUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomRightUncheckedUpdateInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomRightCreateManyInput = {
    roomId: number
    userId: number
  }

  export type RoomRightUpdateManyMutationInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomRightUncheckedUpdateManyInput = {
    roomId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomSwearwordFilterCreateInput = {
    word: string
  }

  export type RoomSwearwordFilterUncheckedCreateInput = {
    word: string
  }

  export type RoomSwearwordFilterUpdateInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type RoomSwearwordFilterUncheckedUpdateInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type RoomSwearwordFilterCreateManyInput = {
    word: string
  }

  export type RoomSwearwordFilterUpdateManyMutationInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type RoomSwearwordFilterUncheckedUpdateManyInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementCreateInput = {
    userId: number
    group: string
    level: number
    progress: number
  }

  export type UserAchievementUncheckedCreateInput = {
    userId: number
    group: string
    level: number
    progress: number
  }

  export type UserAchievementUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    group?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    group?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementCreateManyInput = {
    userId: number
    group: string
    level: number
    progress: number
  }

  export type UserAchievementUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    group?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    group?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeCreateInput = {
    userId: number
    badgeId: string
    badgeSlot?: number
  }

  export type UserBadgeUncheckedCreateInput = {
    userId: number
    badgeId: string
    badgeSlot?: number
  }

  export type UserBadgeUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    badgeId?: StringFieldUpdateOperationsInput | string
    badgeSlot?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    badgeId?: StringFieldUpdateOperationsInput | string
    badgeSlot?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeCreateManyInput = {
    userId: number
    badgeId: string
    badgeSlot?: number
  }

  export type UserBadgeUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    badgeId?: StringFieldUpdateOperationsInput | string
    badgeSlot?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    badgeId?: StringFieldUpdateOperationsInput | string
    badgeSlot?: IntFieldUpdateOperationsInput | number
  }

  export type UserBannerCreateInput = {
    user_id: number
    banner_id: number
  }

  export type UserBannerUncheckedCreateInput = {
    id?: number
    user_id: number
    banner_id: number
  }

  export type UserBannerUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    banner_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserBannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    banner_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserBannerCreateManyInput = {
    id?: number
    user_id: number
    banner_id: number
  }

  export type UserBannerUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    banner_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserBannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    banner_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserPhotoCreateInput = {
    userId: number
    photo: string
    time: number
  }

  export type UserPhotoUncheckedCreateInput = {
    id?: number
    userId: number
    photo: string
    time: number
  }

  export type UserPhotoUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type UserPhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type UserPhotoCreateManyInput = {
    id?: number
    userId: number
    photo: string
    time: number
  }

  export type UserPhotoUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type UserPhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type UserPremiumCreateInput = {
    userId: number
    timestampActivated?: number
    timestampExpireClassic?: number
    timestampExpireEpic?: number
    timestampExpireLegend?: number
  }

  export type UserPremiumUncheckedCreateInput = {
    userId: number
    timestampActivated?: number
    timestampExpireClassic?: number
    timestampExpireEpic?: number
    timestampExpireLegend?: number
  }

  export type UserPremiumUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    timestampActivated?: IntFieldUpdateOperationsInput | number
    timestampExpireClassic?: IntFieldUpdateOperationsInput | number
    timestampExpireEpic?: IntFieldUpdateOperationsInput | number
    timestampExpireLegend?: IntFieldUpdateOperationsInput | number
  }

  export type UserPremiumUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    timestampActivated?: IntFieldUpdateOperationsInput | number
    timestampExpireClassic?: IntFieldUpdateOperationsInput | number
    timestampExpireEpic?: IntFieldUpdateOperationsInput | number
    timestampExpireLegend?: IntFieldUpdateOperationsInput | number
  }

  export type UserPremiumCreateManyInput = {
    userId: number
    timestampActivated?: number
    timestampExpireClassic?: number
    timestampExpireEpic?: number
    timestampExpireLegend?: number
  }

  export type UserPremiumUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    timestampActivated?: IntFieldUpdateOperationsInput | number
    timestampExpireClassic?: IntFieldUpdateOperationsInput | number
    timestampExpireEpic?: IntFieldUpdateOperationsInput | number
    timestampExpireLegend?: IntFieldUpdateOperationsInput | number
  }

  export type UserPremiumUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    timestampActivated?: IntFieldUpdateOperationsInput | number
    timestampExpireClassic?: IntFieldUpdateOperationsInput | number
    timestampExpireEpic?: IntFieldUpdateOperationsInput | number
    timestampExpireLegend?: IntFieldUpdateOperationsInput | number
  }

  export type UserQuestCreateInput = {
    userId: number
    questId: number
    progress: number
  }

  export type UserQuestUncheckedCreateInput = {
    userId: number
    questId: number
    progress: number
  }

  export type UserQuestUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserQuestUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserQuestCreateManyInput = {
    userId: number
    questId: number
    progress: number
  }

  export type UserQuestUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserQuestUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayCreateInput = {
    userId: number
    roleplayId: number
    health?: number
    energy?: number
    money?: number
    munition?: number
    exp?: number
    weaponFar?: number
    weaponCac?: number
    hygiene?: number
    money1?: number
    money2?: number
    money3?: number
    money4?: number
  }

  export type UserRoleplayUncheckedCreateInput = {
    userId: number
    roleplayId: number
    health?: number
    energy?: number
    money?: number
    munition?: number
    exp?: number
    weaponFar?: number
    weaponCac?: number
    hygiene?: number
    money1?: number
    money2?: number
    money3?: number
    money4?: number
  }

  export type UserRoleplayUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleplayId?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    money?: IntFieldUpdateOperationsInput | number
    munition?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    weaponFar?: IntFieldUpdateOperationsInput | number
    weaponCac?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    money1?: IntFieldUpdateOperationsInput | number
    money2?: IntFieldUpdateOperationsInput | number
    money3?: IntFieldUpdateOperationsInput | number
    money4?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleplayId?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    money?: IntFieldUpdateOperationsInput | number
    munition?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    weaponFar?: IntFieldUpdateOperationsInput | number
    weaponCac?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    money1?: IntFieldUpdateOperationsInput | number
    money2?: IntFieldUpdateOperationsInput | number
    money3?: IntFieldUpdateOperationsInput | number
    money4?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayCreateManyInput = {
    userId: number
    roleplayId: number
    health?: number
    energy?: number
    money?: number
    munition?: number
    exp?: number
    weaponFar?: number
    weaponCac?: number
    hygiene?: number
    money1?: number
    money2?: number
    money3?: number
    money4?: number
  }

  export type UserRoleplayUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleplayId?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    money?: IntFieldUpdateOperationsInput | number
    munition?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    weaponFar?: IntFieldUpdateOperationsInput | number
    weaponCac?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    money1?: IntFieldUpdateOperationsInput | number
    money2?: IntFieldUpdateOperationsInput | number
    money3?: IntFieldUpdateOperationsInput | number
    money4?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleplayId?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    energy?: IntFieldUpdateOperationsInput | number
    money?: IntFieldUpdateOperationsInput | number
    munition?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    weaponFar?: IntFieldUpdateOperationsInput | number
    weaponCac?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    money1?: IntFieldUpdateOperationsInput | number
    money2?: IntFieldUpdateOperationsInput | number
    money3?: IntFieldUpdateOperationsInput | number
    money4?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayItemCreateInput = {
    userId: number
    rpId: number
    itemId: number
    count?: number
  }

  export type UserRoleplayItemUncheckedCreateInput = {
    id?: number
    userId: number
    rpId: number
    itemId: number
    count?: number
  }

  export type UserRoleplayItemUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    rpId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rpId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayItemCreateManyInput = {
    id?: number
    userId: number
    rpId: number
    itemId: number
    count?: number
  }

  export type UserRoleplayItemUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    rpId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleplayItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rpId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsCreateInput = {
    id: number
    onlineTime?: number
    respect?: number
    respectGiven?: number
    giftsGiven?: number
    giftsReceived?: number
    dailyRespectPoints?: number
    dailyPetRespectPoints?: number
    achievementScore?: number
    questId?: number
    questProgress?: number
    levBuilder?: number
    levSocial?: number
    levIdentity?: number
    levExplore?: number
    groupId?: number
  }

  export type UserStatsUncheckedCreateInput = {
    id: number
    onlineTime?: number
    respect?: number
    respectGiven?: number
    giftsGiven?: number
    giftsReceived?: number
    dailyRespectPoints?: number
    dailyPetRespectPoints?: number
    achievementScore?: number
    questId?: number
    questProgress?: number
    levBuilder?: number
    levSocial?: number
    levIdentity?: number
    levExplore?: number
    groupId?: number
  }

  export type UserStatsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlineTime?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    respectGiven?: IntFieldUpdateOperationsInput | number
    giftsGiven?: IntFieldUpdateOperationsInput | number
    giftsReceived?: IntFieldUpdateOperationsInput | number
    dailyRespectPoints?: IntFieldUpdateOperationsInput | number
    dailyPetRespectPoints?: IntFieldUpdateOperationsInput | number
    achievementScore?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    questProgress?: IntFieldUpdateOperationsInput | number
    levBuilder?: IntFieldUpdateOperationsInput | number
    levSocial?: IntFieldUpdateOperationsInput | number
    levIdentity?: IntFieldUpdateOperationsInput | number
    levExplore?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlineTime?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    respectGiven?: IntFieldUpdateOperationsInput | number
    giftsGiven?: IntFieldUpdateOperationsInput | number
    giftsReceived?: IntFieldUpdateOperationsInput | number
    dailyRespectPoints?: IntFieldUpdateOperationsInput | number
    dailyPetRespectPoints?: IntFieldUpdateOperationsInput | number
    achievementScore?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    questProgress?: IntFieldUpdateOperationsInput | number
    levBuilder?: IntFieldUpdateOperationsInput | number
    levSocial?: IntFieldUpdateOperationsInput | number
    levIdentity?: IntFieldUpdateOperationsInput | number
    levExplore?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsCreateManyInput = {
    id: number
    onlineTime?: number
    respect?: number
    respectGiven?: number
    giftsGiven?: number
    giftsReceived?: number
    dailyRespectPoints?: number
    dailyPetRespectPoints?: number
    achievementScore?: number
    questId?: number
    questProgress?: number
    levBuilder?: number
    levSocial?: number
    levIdentity?: number
    levExplore?: number
    groupId?: number
  }

  export type UserStatsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlineTime?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    respectGiven?: IntFieldUpdateOperationsInput | number
    giftsGiven?: IntFieldUpdateOperationsInput | number
    giftsReceived?: IntFieldUpdateOperationsInput | number
    dailyRespectPoints?: IntFieldUpdateOperationsInput | number
    dailyPetRespectPoints?: IntFieldUpdateOperationsInput | number
    achievementScore?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    questProgress?: IntFieldUpdateOperationsInput | number
    levBuilder?: IntFieldUpdateOperationsInput | number
    levSocial?: IntFieldUpdateOperationsInput | number
    levIdentity?: IntFieldUpdateOperationsInput | number
    levExplore?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    onlineTime?: IntFieldUpdateOperationsInput | number
    respect?: IntFieldUpdateOperationsInput | number
    respectGiven?: IntFieldUpdateOperationsInput | number
    giftsGiven?: IntFieldUpdateOperationsInput | number
    giftsReceived?: IntFieldUpdateOperationsInput | number
    dailyRespectPoints?: IntFieldUpdateOperationsInput | number
    dailyPetRespectPoints?: IntFieldUpdateOperationsInput | number
    achievementScore?: IntFieldUpdateOperationsInput | number
    questId?: IntFieldUpdateOperationsInput | number
    questProgress?: IntFieldUpdateOperationsInput | number
    levBuilder?: IntFieldUpdateOperationsInput | number
    levSocial?: IntFieldUpdateOperationsInput | number
    levIdentity?: IntFieldUpdateOperationsInput | number
    levExplore?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserWardrobeCreateInput = {
    userId: number
    slotId: number
    look: string
    gender?: $Enums.UserWardrobeGender
  }

  export type UserWardrobeUncheckedCreateInput = {
    userId: number
    slotId: number
    look: string
    gender?: $Enums.UserWardrobeGender
  }

  export type UserWardrobeUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserWardrobeGenderFieldUpdateOperationsInput | $Enums.UserWardrobeGender
  }

  export type UserWardrobeUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserWardrobeGenderFieldUpdateOperationsInput | $Enums.UserWardrobeGender
  }

  export type UserWardrobeCreateManyInput = {
    userId: number
    slotId: number
    look: string
    gender?: $Enums.UserWardrobeGender
  }

  export type UserWardrobeUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserWardrobeGenderFieldUpdateOperationsInput | $Enums.UserWardrobeGender
  }

  export type UserWardrobeUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    slotId?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserWardrobeGenderFieldUpdateOperationsInput | $Enums.UserWardrobeGender
  }

  export type WordFilterRetroCreateInput = {
    word: string
  }

  export type WordFilterRetroUncheckedCreateInput = {
    word: string
  }

  export type WordFilterRetroUpdateInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type WordFilterRetroUncheckedUpdateInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type WordFilterRetroCreateManyInput = {
    word: string
  }

  export type WordFilterRetroUpdateManyMutationInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type WordFilterRetroUncheckedUpdateManyInput = {
    word?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumBanBantypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BanBantype | EnumBanBantypeFieldRefInput<$PrismaModel>
    in?: $Enums.BanBantype[]
    notIn?: $Enums.BanBantype[]
    not?: NestedEnumBanBantypeFilter<$PrismaModel> | $Enums.BanBantype
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BanCountOrderByAggregateInput = {
    id?: SortOrder
    bantype?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    expire?: SortOrder
    addedBy?: SortOrder
    addedDate?: SortOrder
  }

  export type BanAvgOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    addedDate?: SortOrder
  }

  export type BanMaxOrderByAggregateInput = {
    id?: SortOrder
    bantype?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    expire?: SortOrder
    addedBy?: SortOrder
    addedDate?: SortOrder
  }

  export type BanMinOrderByAggregateInput = {
    id?: SortOrder
    bantype?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    expire?: SortOrder
    addedBy?: SortOrder
    addedDate?: SortOrder
  }

  export type BanSumOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    addedDate?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumBanBantypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BanBantype | EnumBanBantypeFieldRefInput<$PrismaModel>
    in?: $Enums.BanBantype[]
    notIn?: $Enums.BanBantype[]
    not?: NestedEnumBanBantypeWithAggregatesFilter<$PrismaModel> | $Enums.BanBantype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBanBantypeFilter<$PrismaModel>
    _max?: NestedEnumBanBantypeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BotPetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    race?: SortOrder
    color?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
    anyoneRide?: SortOrder
  }

  export type BotPetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
  }

  export type BotPetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    race?: SortOrder
    color?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
    anyoneRide?: SortOrder
  }

  export type BotPetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    name?: SortOrder
    race?: SortOrder
    color?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
    anyoneRide?: SortOrder
  }

  export type BotPetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    energy?: SortOrder
    nutrition?: SortOrder
    respect?: SortOrder
    createstamp?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    haveSaddle?: SortOrder
    hairdye?: SortOrder
    pethair?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumBotUserAiTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BotUserAiType | EnumBotUserAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BotUserAiType[]
    notIn?: $Enums.BotUserAiType[]
    not?: NestedEnumBotUserAiTypeFilter<$PrismaModel> | $Enums.BotUserAiType
  }

  export type BotUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    motto?: SortOrder
    gender?: SortOrder
    look?: SortOrder
    roomId?: SortOrder
    walkEnabled?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatEnabled?: SortOrder
    chatText?: SortOrder
    chatSeconds?: SortOrder
    isDancing?: SortOrder
    isMixchat?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
    aiType?: SortOrder
  }

  export type BotUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatSeconds?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
  }

  export type BotUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    motto?: SortOrder
    gender?: SortOrder
    look?: SortOrder
    roomId?: SortOrder
    walkEnabled?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatEnabled?: SortOrder
    chatText?: SortOrder
    chatSeconds?: SortOrder
    isDancing?: SortOrder
    isMixchat?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
    aiType?: SortOrder
  }

  export type BotUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    motto?: SortOrder
    gender?: SortOrder
    look?: SortOrder
    roomId?: SortOrder
    walkEnabled?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatEnabled?: SortOrder
    chatText?: SortOrder
    chatSeconds?: SortOrder
    isDancing?: SortOrder
    isMixchat?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
    aiType?: SortOrder
  }

  export type BotUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rotation?: SortOrder
    chatSeconds?: SortOrder
    status?: SortOrder
    enable?: SortOrder
    handitem?: SortOrder
  }

  export type EnumBotUserAiTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BotUserAiType | EnumBotUserAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BotUserAiType[]
    notIn?: $Enums.BotUserAiType[]
    not?: NestedEnumBotUserAiTypeWithAggregatesFilter<$PrismaModel> | $Enums.BotUserAiType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBotUserAiTypeFilter<$PrismaModel>
    _max?: NestedEnumBotUserAiTypeFilter<$PrismaModel>
  }

  export type EnumCatalogBotPresetAiTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogBotPresetAiType | EnumCatalogBotPresetAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogBotPresetAiType[]
    notIn?: $Enums.CatalogBotPresetAiType[]
    not?: NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel> | $Enums.CatalogBotPresetAiType
  }

  export type CatalogBotPresetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    figure?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    aiType?: SortOrder
  }

  export type CatalogBotPresetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CatalogBotPresetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    figure?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    aiType?: SortOrder
  }

  export type CatalogBotPresetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    figure?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    aiType?: SortOrder
  }

  export type CatalogBotPresetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCatalogBotPresetAiTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogBotPresetAiType | EnumCatalogBotPresetAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogBotPresetAiType[]
    notIn?: $Enums.CatalogBotPresetAiType[]
    not?: NestedEnumCatalogBotPresetAiTypeWithAggregatesFilter<$PrismaModel> | $Enums.CatalogBotPresetAiType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel>
    _max?: NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel>
  }

  export type CatalogItemLimitedNullableRelationFilter = {
    is?: CatalogItemLimitedWhereInput | null
    isNot?: CatalogItemLimitedWhereInput | null
  }

  export type ItemBaseRelationFilter = {
    is?: ItemBaseWhereInput
    isNot?: ItemBaseWhereInput
  }

  export type CatalogItemCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    catalogName?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
    offerActive?: SortOrder
    badge?: SortOrder
  }

  export type CatalogItemAvgOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
  }

  export type CatalogItemMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    catalogName?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
    offerActive?: SortOrder
    badge?: SortOrder
  }

  export type CatalogItemMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    catalogName?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
    offerActive?: SortOrder
    badge?: SortOrder
  }

  export type CatalogItemSumOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    costCredits?: SortOrder
    costPixels?: SortOrder
    costDiamonds?: SortOrder
    costLimitcoins?: SortOrder
    amount?: SortOrder
  }

  export type CatalogItemRelationFilter = {
    is?: CatalogItemWhereInput
    isNot?: CatalogItemWhereInput
  }

  export type CatalogItemLimitedCountOrderByAggregateInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogItemLimitedAvgOrderByAggregateInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogItemLimitedMaxOrderByAggregateInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogItemLimitedMinOrderByAggregateInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogItemLimitedSumOrderByAggregateInput = {
    catalogItemId?: SortOrder
    limitedSells?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogMarketplaceDataCountOrderByAggregateInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
  }

  export type CatalogMarketplaceDataAvgOrderByAggregateInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
  }

  export type CatalogMarketplaceDataMaxOrderByAggregateInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
  }

  export type CatalogMarketplaceDataMinOrderByAggregateInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
  }

  export type CatalogMarketplaceDataSumOrderByAggregateInput = {
    id?: SortOrder
    sprite?: SortOrder
    sold?: SortOrder
    avgprice?: SortOrder
  }

  export type CatalogMarketplaceOfferCountOrderByAggregateInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    publicName?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    extraData?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogMarketplaceOfferAvgOrderByAggregateInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogMarketplaceOfferMaxOrderByAggregateInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    publicName?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    extraData?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogMarketplaceOfferMinOrderByAggregateInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    publicName?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    extraData?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogMarketplaceOfferSumOrderByAggregateInput = {
    offerId?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    askingPrice?: SortOrder
    totalPrice?: SortOrder
    spriteId?: SortOrder
    itemType?: SortOrder
    timestamp?: SortOrder
    state?: SortOrder
    furniId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type CatalogPageCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    caption?: SortOrder
    iconImage?: SortOrder
    enabled?: SortOrder
    requiredRight?: SortOrder
    orderNum?: SortOrder
    pageLayout?: SortOrder
    pageLink?: SortOrder
    pageStrings1?: SortOrder
    pageStrings2?: SortOrder
    isPremium?: SortOrder
  }

  export type CatalogPageAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    iconImage?: SortOrder
    orderNum?: SortOrder
  }

  export type CatalogPageMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    caption?: SortOrder
    iconImage?: SortOrder
    enabled?: SortOrder
    requiredRight?: SortOrder
    orderNum?: SortOrder
    pageLayout?: SortOrder
    pageLink?: SortOrder
    pageStrings1?: SortOrder
    pageStrings2?: SortOrder
    isPremium?: SortOrder
  }

  export type CatalogPageMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    caption?: SortOrder
    iconImage?: SortOrder
    enabled?: SortOrder
    requiredRight?: SortOrder
    orderNum?: SortOrder
    pageLayout?: SortOrder
    pageLink?: SortOrder
    pageStrings1?: SortOrder
    pageStrings2?: SortOrder
    isPremium?: SortOrder
  }

  export type CatalogPageSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    iconImage?: SortOrder
    orderNum?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CatalogPageLangueCountOrderByAggregateInput = {
    pageId?: SortOrder
    captionFr?: SortOrder
    captionEn?: SortOrder
    captionBr?: SortOrder
    pageStrings2Fr?: SortOrder
    pageStrings2En?: SortOrder
    pageStrings2Br?: SortOrder
  }

  export type CatalogPageLangueAvgOrderByAggregateInput = {
    pageId?: SortOrder
  }

  export type CatalogPageLangueMaxOrderByAggregateInput = {
    pageId?: SortOrder
    captionFr?: SortOrder
    captionEn?: SortOrder
    captionBr?: SortOrder
    pageStrings2Fr?: SortOrder
    pageStrings2En?: SortOrder
    pageStrings2Br?: SortOrder
  }

  export type CatalogPageLangueMinOrderByAggregateInput = {
    pageId?: SortOrder
    captionFr?: SortOrder
    captionEn?: SortOrder
    captionBr?: SortOrder
    pageStrings2Fr?: SortOrder
    pageStrings2En?: SortOrder
    pageStrings2Br?: SortOrder
  }

  export type CatalogPageLangueSumOrderByAggregateInput = {
    pageId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CatalogPetRaceCountOrderByAggregateInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    has1color?: SortOrder
    has2color?: SortOrder
  }

  export type CatalogPetRaceAvgOrderByAggregateInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
  }

  export type CatalogPetRaceMaxOrderByAggregateInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    has1color?: SortOrder
    has2color?: SortOrder
  }

  export type CatalogPetRaceMinOrderByAggregateInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    has1color?: SortOrder
    has2color?: SortOrder
  }

  export type CatalogPetRaceSumOrderByAggregateInput = {
    id?: SortOrder
    raceid?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CatalogPromotionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    titleBr?: SortOrder
    image?: SortOrder
    unknown?: SortOrder
    pageLink?: SortOrder
    parentId?: SortOrder
  }

  export type CatalogPromotionAvgOrderByAggregateInput = {
    id?: SortOrder
    unknown?: SortOrder
    parentId?: SortOrder
  }

  export type CatalogPromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    titleBr?: SortOrder
    image?: SortOrder
    unknown?: SortOrder
    pageLink?: SortOrder
    parentId?: SortOrder
  }

  export type CatalogPromotionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    titleBr?: SortOrder
    image?: SortOrder
    unknown?: SortOrder
    pageLink?: SortOrder
    parentId?: SortOrder
  }

  export type CatalogPromotionSumOrderByAggregateInput = {
    id?: SortOrder
    unknown?: SortOrder
    parentId?: SortOrder
  }

  export type EnumCatalogVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogVoucherType | EnumCatalogVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogVoucherType[]
    notIn?: $Enums.CatalogVoucherType[]
    not?: NestedEnumCatalogVoucherTypeFilter<$PrismaModel> | $Enums.CatalogVoucherType
  }

  export type CatalogVoucherCountOrderByAggregateInput = {
    voucher?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
    enabled?: SortOrder
  }

  export type CatalogVoucherAvgOrderByAggregateInput = {
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
  }

  export type CatalogVoucherMaxOrderByAggregateInput = {
    voucher?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
    enabled?: SortOrder
  }

  export type CatalogVoucherMinOrderByAggregateInput = {
    voucher?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
    enabled?: SortOrder
  }

  export type CatalogVoucherSumOrderByAggregateInput = {
    value?: SortOrder
    currentUses?: SortOrder
    maxUses?: SortOrder
  }

  export type EnumCatalogVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogVoucherType | EnumCatalogVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogVoucherType[]
    notIn?: $Enums.CatalogVoucherType[]
    not?: NestedEnumCatalogVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.CatalogVoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCatalogVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumCatalogVoucherTypeFilter<$PrismaModel>
  }

  export type CmsForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    threadid?: SortOrder
    message?: SortOrder
    author?: SortOrder
    date?: SortOrder
    motto?: SortOrder
    look?: SortOrder
    idAuteur?: SortOrder
    rank?: SortOrder
  }

  export type CmsForumPostAvgOrderByAggregateInput = {
    id?: SortOrder
    threadid?: SortOrder
    idAuteur?: SortOrder
  }

  export type CmsForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    threadid?: SortOrder
    message?: SortOrder
    author?: SortOrder
    date?: SortOrder
    motto?: SortOrder
    look?: SortOrder
    idAuteur?: SortOrder
    rank?: SortOrder
  }

  export type CmsForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    threadid?: SortOrder
    message?: SortOrder
    author?: SortOrder
    date?: SortOrder
    motto?: SortOrder
    look?: SortOrder
    idAuteur?: SortOrder
    rank?: SortOrder
  }

  export type CmsForumPostSumOrderByAggregateInput = {
    id?: SortOrder
    threadid?: SortOrder
    idAuteur?: SortOrder
  }

  export type CmsForumThreadCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    author?: SortOrder
    date?: SortOrder
    lastpostAuthor?: SortOrder
    lastpostDate?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    categorie?: SortOrder
    views?: SortOrder
  }

  export type CmsForumThreadAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    views?: SortOrder
  }

  export type CmsForumThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    author?: SortOrder
    date?: SortOrder
    lastpostAuthor?: SortOrder
    lastpostDate?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    categorie?: SortOrder
    views?: SortOrder
  }

  export type CmsForumThreadMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    author?: SortOrder
    date?: SortOrder
    lastpostAuthor?: SortOrder
    lastpostDate?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    categorie?: SortOrder
    views?: SortOrder
  }

  export type CmsForumThreadSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    posts?: SortOrder
    mainPost?: SortOrder
    statut?: SortOrder
    views?: SortOrder
  }

  export type CmsFourmCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type CmsFourmCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CmsFourmCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type CmsFourmCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type CmsFourmCategorySumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CmsMailConfirmCountOrderByAggregateInput = {
    userId?: SortOrder
    codedevalidation?: SortOrder
    email?: SortOrder
    temps?: SortOrder
    type?: SortOrder
  }

  export type CmsMailConfirmAvgOrderByAggregateInput = {
    userId?: SortOrder
    temps?: SortOrder
    type?: SortOrder
  }

  export type CmsMailConfirmMaxOrderByAggregateInput = {
    userId?: SortOrder
    codedevalidation?: SortOrder
    email?: SortOrder
    temps?: SortOrder
    type?: SortOrder
  }

  export type CmsMailConfirmMinOrderByAggregateInput = {
    userId?: SortOrder
    codedevalidation?: SortOrder
    email?: SortOrder
    temps?: SortOrder
    type?: SortOrder
  }

  export type CmsMailConfirmSumOrderByAggregateInput = {
    userId?: SortOrder
    temps?: SortOrder
    type?: SortOrder
  }

  export type CmsMailForgotCountOrderByAggregateInput = {
    id?: SortOrder
    pass?: SortOrder
    email?: SortOrder
    expire?: SortOrder
    users?: SortOrder
  }

  export type CmsMailForgotAvgOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
  }

  export type CmsMailForgotMaxOrderByAggregateInput = {
    id?: SortOrder
    pass?: SortOrder
    email?: SortOrder
    expire?: SortOrder
    users?: SortOrder
  }

  export type CmsMailForgotMinOrderByAggregateInput = {
    id?: SortOrder
    pass?: SortOrder
    email?: SortOrder
    expire?: SortOrder
    users?: SortOrder
  }

  export type CmsMailForgotSumOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
  }

  export type CmsNewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    topstoryImage?: SortOrder
    body?: SortOrder
    snippet?: SortOrder
    timestamp?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    link_keyword?: SortOrder
  }

  export type CmsNewsAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
  }

  export type CmsNewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    topstoryImage?: SortOrder
    body?: SortOrder
    snippet?: SortOrder
    timestamp?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    link_keyword?: SortOrder
  }

  export type CmsNewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    topstoryImage?: SortOrder
    body?: SortOrder
    snippet?: SortOrder
    timestamp?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    link_keyword?: SortOrder
  }

  export type CmsNewsSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
  }

  export type CmsStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
    function?: SortOrder
    socialInsta?: SortOrder
    socialDiscord?: SortOrder
  }

  export type CmsStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
  }

  export type CmsStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
    function?: SortOrder
    socialInsta?: SortOrder
    socialDiscord?: SortOrder
  }

  export type CmsStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
    function?: SortOrder
    socialInsta?: SortOrder
    socialDiscord?: SortOrder
  }

  export type CmsStaffSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    rank?: SortOrder
  }

  export type CmsStaffProtectCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    hide?: SortOrder
  }

  export type CmsStaffProtectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CmsStaffProtectMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    hide?: SortOrder
  }

  export type CmsStaffProtectMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    username?: SortOrder
    hide?: SortOrder
  }

  export type CmsStaffProtectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    groupName?: SortOrder
    category?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
  }

  export type EmulatorAchievementAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
  }

  export type EmulatorAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    groupName?: SortOrder
    category?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
  }

  export type EmulatorAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    groupName?: SortOrder
    category?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
  }

  export type EmulatorAchievementSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    rewardPixels?: SortOrder
    rewardPoints?: SortOrder
    progressNeeded?: SortOrder
  }

  export type EmulatorBannerCountOrderByAggregateInput = {
    id?: SortOrder
    haveLayer?: SortOrder
    canTrade?: SortOrder
  }

  export type EmulatorBannerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    haveLayer?: SortOrder
    canTrade?: SortOrder
  }

  export type EmulatorBannerMinOrderByAggregateInput = {
    id?: SortOrder
    haveLayer?: SortOrder
    canTrade?: SortOrder
  }

  export type EmulatorBannerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorChatStyleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredRight?: SortOrder
  }

  export type EmulatorChatStyleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorChatStyleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredRight?: SortOrder
  }

  export type EmulatorChatStyleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredRight?: SortOrder
  }

  export type EmulatorChatStyleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorCommandCountOrderByAggregateInput = {
    id?: SortOrder
    input?: SortOrder
    minrank?: SortOrder
    descriptionFr?: SortOrder
    descriptionEn?: SortOrder
    descriptionBr?: SortOrder
  }

  export type EmulatorCommandAvgOrderByAggregateInput = {
    id?: SortOrder
    minrank?: SortOrder
  }

  export type EmulatorCommandMaxOrderByAggregateInput = {
    id?: SortOrder
    input?: SortOrder
    minrank?: SortOrder
    descriptionFr?: SortOrder
    descriptionEn?: SortOrder
    descriptionBr?: SortOrder
  }

  export type EmulatorCommandMinOrderByAggregateInput = {
    id?: SortOrder
    input?: SortOrder
    minrank?: SortOrder
    descriptionFr?: SortOrder
    descriptionEn?: SortOrder
    descriptionBr?: SortOrder
  }

  export type EmulatorCommandSumOrderByAggregateInput = {
    id?: SortOrder
    minrank?: SortOrder
  }

  export type EmulatorCommandPetCountOrderByAggregateInput = {
    id?: SortOrder
    command?: SortOrder
  }

  export type EmulatorCommandPetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorCommandPetMaxOrderByAggregateInput = {
    id?: SortOrder
    command?: SortOrder
  }

  export type EmulatorCommandPetMinOrderByAggregateInput = {
    id?: SortOrder
    command?: SortOrder
  }

  export type EmulatorCommandPetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorEffectCountOrderByAggregateInput = {
    id?: SortOrder
    onlyStaff?: SortOrder
  }

  export type EmulatorEffectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorEffectMaxOrderByAggregateInput = {
    id?: SortOrder
    onlyStaff?: SortOrder
  }

  export type EmulatorEffectMinOrderByAggregateInput = {
    id?: SortOrder
    onlyStaff?: SortOrder
  }

  export type EmulatorEffectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorLandingviewCountOrderByAggregateInput = {
    index?: SortOrder
    header?: SortOrder
    body?: SortOrder
    button?: SortOrder
    inGamePromo?: SortOrder
    specialAction?: SortOrder
    image?: SortOrder
    enabled?: SortOrder
  }

  export type EmulatorLandingviewAvgOrderByAggregateInput = {
    index?: SortOrder
  }

  export type EmulatorLandingviewMaxOrderByAggregateInput = {
    index?: SortOrder
    header?: SortOrder
    body?: SortOrder
    button?: SortOrder
    inGamePromo?: SortOrder
    specialAction?: SortOrder
    image?: SortOrder
    enabled?: SortOrder
  }

  export type EmulatorLandingviewMinOrderByAggregateInput = {
    index?: SortOrder
    header?: SortOrder
    body?: SortOrder
    button?: SortOrder
    inGamePromo?: SortOrder
    specialAction?: SortOrder
    image?: SortOrder
    enabled?: SortOrder
  }

  export type EmulatorLandingviewSumOrderByAggregateInput = {
    index?: SortOrder
  }

  export type EnumEmulatorLootboxCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EmulatorLootboxCategory | EnumEmulatorLootboxCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmulatorLootboxCategory[]
    notIn?: $Enums.EmulatorLootboxCategory[]
    not?: NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel> | $Enums.EmulatorLootboxCategory
  }

  export type EmulatorLootboxCountOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
  }

  export type EmulatorLootboxAvgOrderByAggregateInput = {
    id?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    amount?: SortOrder
  }

  export type EmulatorLootboxMaxOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
  }

  export type EmulatorLootboxMinOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
  }

  export type EmulatorLootboxSumOrderByAggregateInput = {
    id?: SortOrder
    probability?: SortOrder
    pageId?: SortOrder
    itemId?: SortOrder
    amount?: SortOrder
  }

  export type EnumEmulatorLootboxCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmulatorLootboxCategory | EnumEmulatorLootboxCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmulatorLootboxCategory[]
    notIn?: $Enums.EmulatorLootboxCategory[]
    not?: NestedEnumEmulatorLootboxCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EmulatorLootboxCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel>
    _max?: NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel>
  }

  export type EmulatorPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    permission?: SortOrder
  }

  export type EmulatorPermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type EmulatorPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    permission?: SortOrder
  }

  export type EmulatorPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    permission?: SortOrder
  }

  export type EmulatorPermissionSumOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type EmulatorQuestCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    name?: SortOrder
    reward?: SortOrder
    dataBit?: SortOrder
  }

  export type EmulatorQuestAvgOrderByAggregateInput = {
    id?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    reward?: SortOrder
  }

  export type EmulatorQuestMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    name?: SortOrder
    reward?: SortOrder
    dataBit?: SortOrder
  }

  export type EmulatorQuestMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    name?: SortOrder
    reward?: SortOrder
    dataBit?: SortOrder
  }

  export type EmulatorQuestSumOrderByAggregateInput = {
    id?: SortOrder
    seriesNumber?: SortOrder
    goalType?: SortOrder
    goalData?: SortOrder
    reward?: SortOrder
  }

  export type EmulatorSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type EmulatorSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type EmulatorSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type EmulatorSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorStatsCountOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
  }

  export type EmulatorStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
  }

  export type EmulatorStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
  }

  export type EmulatorStatsMinOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
  }

  export type EmulatorStatsSumOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    time?: SortOrder
    room?: SortOrder
  }

  export type EmulatorStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
  }

  export type EmulatorStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
  }

  export type EmulatorStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
  }

  export type EmulatorStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
  }

  export type EmulatorStatusSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    usersOnline?: SortOrder
    roomsLoaded?: SortOrder
    stamp?: SortOrder
    userpeak?: SortOrder
  }

  export type EmulatorTextCountOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    valueFr?: SortOrder
    valueEn?: SortOrder
    valueBr?: SortOrder
  }

  export type EmulatorTextAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmulatorTextMaxOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    valueFr?: SortOrder
    valueEn?: SortOrder
    valueBr?: SortOrder
  }

  export type EmulatorTextMinOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    valueFr?: SortOrder
    valueEn?: SortOrder
    valueBr?: SortOrder
  }

  export type EmulatorTextSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    badge?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
    admindeco?: SortOrder
    hasForum?: SortOrder
  }

  export type GuildAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
  }

  export type GuildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    badge?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
    admindeco?: SortOrder
    hasForum?: SortOrder
  }

  export type GuildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    badge?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
    admindeco?: SortOrder
    hasForum?: SortOrder
  }

  export type GuildSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    created?: SortOrder
    roomId?: SortOrder
    state?: SortOrder
    colour1?: SortOrder
    colour2?: SortOrder
  }

  export type EnumGuildItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildItemType | EnumGuildItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuildItemType[]
    notIn?: $Enums.GuildItemType[]
    not?: NestedEnumGuildItemTypeFilter<$PrismaModel> | $Enums.GuildItemType
  }

  export type GuildItemIdTypeCompoundUniqueInput = {
    id: number
    type: $Enums.GuildItemType
  }

  export type GuildItemCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstvalue?: SortOrder
    secondvalue?: SortOrder
    enabled?: SortOrder
  }

  export type GuildItemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuildItemMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstvalue?: SortOrder
    secondvalue?: SortOrder
    enabled?: SortOrder
  }

  export type GuildItemMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    firstvalue?: SortOrder
    secondvalue?: SortOrder
    enabled?: SortOrder
  }

  export type GuildItemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGuildItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildItemType | EnumGuildItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuildItemType[]
    notIn?: $Enums.GuildItemType[]
    not?: NestedEnumGuildItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.GuildItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuildItemTypeFilter<$PrismaModel>
    _max?: NestedEnumGuildItemTypeFilter<$PrismaModel>
  }

  export type GuildMembershipGroupIdUserIdCompoundUniqueInput = {
    groupId: number
    userId: number
  }

  export type GuildMembershipCountOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
  }

  export type GuildMembershipAvgOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
  }

  export type GuildMembershipMaxOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
  }

  export type GuildMembershipMinOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
  }

  export type GuildMembershipSumOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
  }

  export type GuildRequestGroupIdUserIdCompoundUniqueInput = {
    groupId: number
    userId: number
  }

  export type GuildRequestCountOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type GuildRequestAvgOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type GuildRequestMaxOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type GuildRequestMinOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type GuildRequestSumOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    extraData?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
    wallPos?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    extraData?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
    wallPos?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    extraData?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
    wallPos?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    baseItem?: SortOrder
    x?: SortOrder
    y?: SortOrder
    z?: SortOrder
    rot?: SortOrder
  }

  export type EnumItemBaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemBaseType | EnumItemBaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemBaseType[]
    notIn?: $Enums.ItemBaseType[]
    not?: NestedEnumItemBaseTypeFilter<$PrismaModel> | $Enums.ItemBaseType
  }

  export type ItemStatNullableRelationFilter = {
    is?: ItemStatWhereInput | null
    isNot?: ItemStatWhereInput | null
  }

  export type LogLootboxListRelationFilter = {
    every?: LogLootboxWhereInput
    some?: LogLootboxWhereInput
    none?: LogLootboxWhereInput
  }

  export type CatalogItemListRelationFilter = {
    every?: CatalogItemWhereInput
    some?: CatalogItemWhereInput
    none?: CatalogItemWhereInput
  }

  export type LogLootboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatalogItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemBaseCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    type?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    canStack?: SortOrder
    canSit?: SortOrder
    isWalkable?: SortOrder
    spriteId?: SortOrder
    allowRecycle?: SortOrder
    allowTrade?: SortOrder
    allowMarketplaceSell?: SortOrder
    allowGift?: SortOrder
    allowInventoryStack?: SortOrder
    interactionType?: SortOrder
    interactionModesCount?: SortOrder
    vendingIds?: SortOrder
    heightAdjustable?: SortOrder
    effectId?: SortOrder
    isRare?: SortOrder
    rarityLevel?: SortOrder
  }

  export type ItemBaseAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    spriteId?: SortOrder
    interactionModesCount?: SortOrder
    effectId?: SortOrder
    rarityLevel?: SortOrder
  }

  export type ItemBaseMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    type?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    canStack?: SortOrder
    canSit?: SortOrder
    isWalkable?: SortOrder
    spriteId?: SortOrder
    allowRecycle?: SortOrder
    allowTrade?: SortOrder
    allowMarketplaceSell?: SortOrder
    allowGift?: SortOrder
    allowInventoryStack?: SortOrder
    interactionType?: SortOrder
    interactionModesCount?: SortOrder
    vendingIds?: SortOrder
    heightAdjustable?: SortOrder
    effectId?: SortOrder
    isRare?: SortOrder
    rarityLevel?: SortOrder
  }

  export type ItemBaseMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    type?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    canStack?: SortOrder
    canSit?: SortOrder
    isWalkable?: SortOrder
    spriteId?: SortOrder
    allowRecycle?: SortOrder
    allowTrade?: SortOrder
    allowMarketplaceSell?: SortOrder
    allowGift?: SortOrder
    allowInventoryStack?: SortOrder
    interactionType?: SortOrder
    interactionModesCount?: SortOrder
    vendingIds?: SortOrder
    heightAdjustable?: SortOrder
    effectId?: SortOrder
    isRare?: SortOrder
    rarityLevel?: SortOrder
  }

  export type ItemBaseSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    length?: SortOrder
    stackHeight?: SortOrder
    spriteId?: SortOrder
    interactionModesCount?: SortOrder
    effectId?: SortOrder
    rarityLevel?: SortOrder
  }

  export type EnumItemBaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemBaseType | EnumItemBaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemBaseType[]
    notIn?: $Enums.ItemBaseType[]
    not?: NestedEnumItemBaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemBaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemBaseTypeFilter<$PrismaModel>
    _max?: NestedEnumItemBaseTypeFilter<$PrismaModel>
  }

  export type ItemLimitedCountOrderByAggregateInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type ItemLimitedAvgOrderByAggregateInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type ItemLimitedMaxOrderByAggregateInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type ItemLimitedMinOrderByAggregateInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type ItemLimitedSumOrderByAggregateInput = {
    itemId?: SortOrder
    limitedNumber?: SortOrder
    limitedStack?: SortOrder
  }

  export type ItemMoodlightCountOrderByAggregateInput = {
    itemId?: SortOrder
    enabled?: SortOrder
    currentPreset?: SortOrder
    presetOne?: SortOrder
    presetTwo?: SortOrder
    presetThree?: SortOrder
  }

  export type ItemMoodlightAvgOrderByAggregateInput = {
    itemId?: SortOrder
    currentPreset?: SortOrder
  }

  export type ItemMoodlightMaxOrderByAggregateInput = {
    itemId?: SortOrder
    enabled?: SortOrder
    currentPreset?: SortOrder
    presetOne?: SortOrder
    presetTwo?: SortOrder
    presetThree?: SortOrder
  }

  export type ItemMoodlightMinOrderByAggregateInput = {
    itemId?: SortOrder
    enabled?: SortOrder
    currentPreset?: SortOrder
    presetOne?: SortOrder
    presetTwo?: SortOrder
    presetThree?: SortOrder
  }

  export type ItemMoodlightSumOrderByAggregateInput = {
    itemId?: SortOrder
    currentPreset?: SortOrder
  }

  export type ItemPresentCountOrderByAggregateInput = {
    itemId?: SortOrder
    baseId?: SortOrder
    extraData?: SortOrder
  }

  export type ItemPresentAvgOrderByAggregateInput = {
    itemId?: SortOrder
    baseId?: SortOrder
  }

  export type ItemPresentMaxOrderByAggregateInput = {
    itemId?: SortOrder
    baseId?: SortOrder
    extraData?: SortOrder
  }

  export type ItemPresentMinOrderByAggregateInput = {
    itemId?: SortOrder
    baseId?: SortOrder
    extraData?: SortOrder
  }

  export type ItemPresentSumOrderByAggregateInput = {
    itemId?: SortOrder
    baseId?: SortOrder
  }

  export type ItemStatCountOrderByAggregateInput = {
    baseId?: SortOrder
    amount?: SortOrder
  }

  export type ItemStatAvgOrderByAggregateInput = {
    baseId?: SortOrder
    amount?: SortOrder
  }

  export type ItemStatMaxOrderByAggregateInput = {
    baseId?: SortOrder
    amount?: SortOrder
  }

  export type ItemStatMinOrderByAggregateInput = {
    baseId?: SortOrder
    amount?: SortOrder
  }

  export type ItemStatSumOrderByAggregateInput = {
    baseId?: SortOrder
    amount?: SortOrder
  }

  export type ItemTeleportTeleOneIdTeleTwoIdCompoundUniqueInput = {
    teleOneId: number
    teleTwoId: number
  }

  export type ItemTeleportCountOrderByAggregateInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
  }

  export type ItemTeleportAvgOrderByAggregateInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
  }

  export type ItemTeleportMaxOrderByAggregateInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
  }

  export type ItemTeleportMinOrderByAggregateInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
  }

  export type ItemTeleportSumOrderByAggregateInput = {
    teleOneId?: SortOrder
    teleTwoId?: SortOrder
  }

  export type ItemWiredCountOrderByAggregateInput = {
    triggerId?: SortOrder
    triggerData2?: SortOrder
    triggerData?: SortOrder
    allUserTriggerable?: SortOrder
    triggersItem?: SortOrder
    delay?: SortOrder
  }

  export type ItemWiredAvgOrderByAggregateInput = {
    triggerId?: SortOrder
    delay?: SortOrder
  }

  export type ItemWiredMaxOrderByAggregateInput = {
    triggerId?: SortOrder
    triggerData2?: SortOrder
    triggerData?: SortOrder
    allUserTriggerable?: SortOrder
    triggersItem?: SortOrder
    delay?: SortOrder
  }

  export type ItemWiredMinOrderByAggregateInput = {
    triggerId?: SortOrder
    triggerData2?: SortOrder
    triggerData?: SortOrder
    allUserTriggerable?: SortOrder
    triggersItem?: SortOrder
    delay?: SortOrder
  }

  export type ItemWiredSumOrderByAggregateInput = {
    triggerId?: SortOrder
    delay?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoomNullableRelationFilter = {
    is?: RoomWhereInput | null
    isNot?: RoomWhereInput | null
  }

  export type LogChatCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
    type?: SortOrder
  }

  export type LogChatAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogChatMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
    type?: SortOrder
  }

  export type LogChatMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
    type?: SortOrder
  }

  export type LogChatSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogChatPubCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
  }

  export type LogChatPubAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogChatPubMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
  }

  export type LogChatPubMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    message?: SortOrder
  }

  export type LogChatPubSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogCommandCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    roomid?: SortOrder
    command?: SortOrder
    extraData?: SortOrder
    timestamp?: SortOrder
  }

  export type LogCommandAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomid?: SortOrder
    timestamp?: SortOrder
  }

  export type LogCommandMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    roomid?: SortOrder
    command?: SortOrder
    extraData?: SortOrder
    timestamp?: SortOrder
  }

  export type LogCommandMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    roomid?: SortOrder
    command?: SortOrder
    extraData?: SortOrder
    timestamp?: SortOrder
  }

  export type LogCommandSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomid?: SortOrder
    timestamp?: SortOrder
  }

  export type LogFlagmeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    oldusername?: SortOrder
    newusername?: SortOrder
    time?: SortOrder
  }

  export type LogFlagmeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type LogFlagmeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    oldusername?: SortOrder
    newusername?: SortOrder
    time?: SortOrder
  }

  export type LogFlagmeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    oldusername?: SortOrder
    newusername?: SortOrder
    time?: SortOrder
  }

  export type LogFlagmeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type LogLoginCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
  }

  export type LogLoginAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
  }

  export type LogLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
  }

  export type LogLoginMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
  }

  export type LogLoginSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
  }

  export type LogLootboxCountOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogLootboxAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogLootboxMaxOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogLootboxMinOrderByAggregateInput = {
    id?: SortOrder
    interactionType?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
  }

  export type LogLootboxSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    baseId?: SortOrder
    timestamp?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LogPaymentCountOrderByAggregateInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    externalReference?: SortOrder
    promoId?: SortOrder
    date?: SortOrder
  }

  export type LogPaymentAvgOrderByAggregateInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    promoId?: SortOrder
  }

  export type LogPaymentMaxOrderByAggregateInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    externalReference?: SortOrder
    promoId?: SortOrder
    date?: SortOrder
  }

  export type LogPaymentMinOrderByAggregateInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    externalReference?: SortOrder
    promoId?: SortOrder
    date?: SortOrder
  }

  export type LogPaymentSumOrderByAggregateInput = {
    historyPaymentId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    awards?: SortOrder
    promoId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LogShopCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    content?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
  }

  export type LogShopAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
  }

  export type LogShopMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    content?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
  }

  export type LogShopMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    content?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
  }

  export type LogShopSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    type?: SortOrder
    catalogItemId?: SortOrder
  }

  export type LogSlotmachineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isWin?: SortOrder
    date?: SortOrder
  }

  export type LogSlotmachineAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
  }

  export type LogSlotmachineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isWin?: SortOrder
    date?: SortOrder
  }

  export type LogSlotmachineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isWin?: SortOrder
    date?: SortOrder
  }

  export type LogSlotmachineSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
  }

  export type LogStaffCountOrderByAggregateInput = {
    id?: SortOrder
    pseudo?: SortOrder
    action?: SortOrder
    date?: SortOrder
  }

  export type LogStaffAvgOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
  }

  export type LogStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    pseudo?: SortOrder
    action?: SortOrder
    date?: SortOrder
  }

  export type LogStaffMinOrderByAggregateInput = {
    id?: SortOrder
    pseudo?: SortOrder
    action?: SortOrder
    date?: SortOrder
  }

  export type LogStaffSumOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
  }

  export type LogTradeCountOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    userOneItems?: SortOrder
    userTwoItems?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
  }

  export type LogTradeAvgOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
  }

  export type LogTradeMaxOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    userOneItems?: SortOrder
    userTwoItems?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
  }

  export type LogTradeMinOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    userOneItems?: SortOrder
    userTwoItems?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
  }

  export type LogTradeSumOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
    roomId?: SortOrder
    time?: SortOrder
  }

  export type LogVpnCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    ipCountry?: SortOrder
    host?: SortOrder
    timestampCreated?: SortOrder
    isVpn?: SortOrder
  }

  export type LogVpnAvgOrderByAggregateInput = {
    id?: SortOrder
    timestampCreated?: SortOrder
  }

  export type LogVpnMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    ipCountry?: SortOrder
    host?: SortOrder
    timestampCreated?: SortOrder
    isVpn?: SortOrder
  }

  export type LogVpnMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    ipCountry?: SortOrder
    host?: SortOrder
    timestampCreated?: SortOrder
    isVpn?: SortOrder
  }

  export type LogVpnSumOrderByAggregateInput = {
    id?: SortOrder
    timestampCreated?: SortOrder
  }

  export type LogSandboxCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    editName?: SortOrder
    editKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogSandboxAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogSandboxMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    editName?: SortOrder
    editKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogSandboxMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    editName?: SortOrder
    editKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogSandboxSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MessengerFriendshipUserOneIdUserTwoIdCompoundUniqueInput = {
    userOneId: number
    userTwoId: number
  }

  export type MessengerFriendshipCountOrderByAggregateInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
  }

  export type MessengerFriendshipAvgOrderByAggregateInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
  }

  export type MessengerFriendshipMaxOrderByAggregateInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
  }

  export type MessengerFriendshipMinOrderByAggregateInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
  }

  export type MessengerFriendshipSumOrderByAggregateInput = {
    userOneId?: SortOrder
    userTwoId?: SortOrder
    relation?: SortOrder
  }

  export type MessengerOfflineMessageCountOrderByAggregateInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type MessengerOfflineMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    timestamp?: SortOrder
  }

  export type MessengerOfflineMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type MessengerOfflineMessageMinOrderByAggregateInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
  }

  export type MessengerOfflineMessageSumOrderByAggregateInput = {
    id?: SortOrder
    toId?: SortOrder
    fromId?: SortOrder
    timestamp?: SortOrder
  }

  export type MessengerRequestFromIdToIdCompoundUniqueInput = {
    fromId: number
    toId: number
  }

  export type MessengerRequestCountOrderByAggregateInput = {
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type MessengerRequestAvgOrderByAggregateInput = {
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type MessengerRequestMaxOrderByAggregateInput = {
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type MessengerRequestMinOrderByAggregateInput = {
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type MessengerRequestSumOrderByAggregateInput = {
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type EnumModerationPresetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationPresetType | EnumModerationPresetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationPresetType[]
    notIn?: $Enums.ModerationPresetType[]
    not?: NestedEnumModerationPresetTypeFilter<$PrismaModel> | $Enums.ModerationPresetType
  }

  export type ModerationPresetCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    message?: SortOrder
  }

  export type ModerationPresetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModerationPresetMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    message?: SortOrder
  }

  export type ModerationPresetMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    message?: SortOrder
  }

  export type ModerationPresetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumModerationPresetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationPresetType | EnumModerationPresetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationPresetType[]
    notIn?: $Enums.ModerationPresetType[]
    not?: NestedEnumModerationPresetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModerationPresetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationPresetTypeFilter<$PrismaModel>
    _max?: NestedEnumModerationPresetTypeFilter<$PrismaModel>
  }

  export type EnumModerationResolutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationResolutionType | EnumModerationResolutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationResolutionType[]
    notIn?: $Enums.ModerationResolutionType[]
    not?: NestedEnumModerationResolutionTypeFilter<$PrismaModel> | $Enums.ModerationResolutionType
  }

  export type ModerationResolutionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
    message?: SortOrder
  }

  export type ModerationResolutionAvgOrderByAggregateInput = {
    id?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
  }

  export type ModerationResolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
    message?: SortOrder
  }

  export type ModerationResolutionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
    message?: SortOrder
  }

  export type ModerationResolutionSumOrderByAggregateInput = {
    id?: SortOrder
    banHours?: SortOrder
    enableMute?: SortOrder
    muteHours?: SortOrder
    reminder?: SortOrder
  }

  export type EnumModerationResolutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationResolutionType | EnumModerationResolutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationResolutionType[]
    notIn?: $Enums.ModerationResolutionType[]
    not?: NestedEnumModerationResolutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModerationResolutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationResolutionTypeFilter<$PrismaModel>
    _max?: NestedEnumModerationResolutionTypeFilter<$PrismaModel>
  }

  export type EnumModerationTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationTicketStatus | EnumModerationTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationTicketStatus[]
    notIn?: $Enums.ModerationTicketStatus[]
    not?: NestedEnumModerationTicketStatusFilter<$PrismaModel> | $Enums.ModerationTicketStatus
  }

  export type ModerationTicketCountOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    message?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    timestamp?: SortOrder
  }

  export type ModerationTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    roomId?: SortOrder
    timestamp?: SortOrder
  }

  export type ModerationTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    message?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    timestamp?: SortOrder
  }

  export type ModerationTicketMinOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    message?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    timestamp?: SortOrder
  }

  export type ModerationTicketSumOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    type?: SortOrder
    senderId?: SortOrder
    reportedId?: SortOrder
    moderatorId?: SortOrder
    roomId?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumModerationTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationTicketStatus | EnumModerationTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationTicketStatus[]
    notIn?: $Enums.ModerationTicketStatus[]
    not?: NestedEnumModerationTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModerationTicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumModerationTicketStatusFilter<$PrismaModel>
  }

  export type ModerationTopicCountOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
  }

  export type ModerationTopicAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModerationTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
  }

  export type ModerationTopicMinOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
  }

  export type ModerationTopicSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModerationTopicActionCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    messageText?: SortOrder
    defaultSanction?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
  }

  export type ModerationTopicActionAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
  }

  export type ModerationTopicActionMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    messageText?: SortOrder
    defaultSanction?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
  }

  export type ModerationTopicActionMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    type?: SortOrder
    caption?: SortOrder
    messageText?: SortOrder
    defaultSanction?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
  }

  export type ModerationTopicActionSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    muteTime?: SortOrder
    banTime?: SortOrder
    ipTime?: SortOrder
    tradeLockTime?: SortOrder
  }

  export type EnumNavigatorCategoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryCategory | EnumNavigatorCategoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryCategory[]
    notIn?: $Enums.NavigatorCategoryCategory[]
    not?: NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel> | $Enums.NavigatorCategoryCategory
  }

  export type EnumNavigatorCategoryViewModeFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryViewMode | EnumNavigatorCategoryViewModeFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryViewMode[]
    notIn?: $Enums.NavigatorCategoryViewMode[]
    not?: NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel> | $Enums.NavigatorCategoryViewMode
  }

  export type EnumNavigatorCategorySearchAllowanceFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategorySearchAllowance | EnumNavigatorCategorySearchAllowanceFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategorySearchAllowance[]
    notIn?: $Enums.NavigatorCategorySearchAllowance[]
    not?: NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel> | $Enums.NavigatorCategorySearchAllowance
  }

  export type NavigatorCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    categoryIdentifier?: SortOrder
    publicName?: SortOrder
    viewMode?: SortOrder
    requiredRank?: SortOrder
    categoryType?: SortOrder
    searchAllowance?: SortOrder
    minimized?: SortOrder
    enabled?: SortOrder
    orderId?: SortOrder
  }

  export type NavigatorCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    requiredRank?: SortOrder
    orderId?: SortOrder
  }

  export type NavigatorCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    categoryIdentifier?: SortOrder
    publicName?: SortOrder
    viewMode?: SortOrder
    requiredRank?: SortOrder
    categoryType?: SortOrder
    searchAllowance?: SortOrder
    minimized?: SortOrder
    enabled?: SortOrder
    orderId?: SortOrder
  }

  export type NavigatorCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    categoryIdentifier?: SortOrder
    publicName?: SortOrder
    viewMode?: SortOrder
    requiredRank?: SortOrder
    categoryType?: SortOrder
    searchAllowance?: SortOrder
    minimized?: SortOrder
    enabled?: SortOrder
    orderId?: SortOrder
  }

  export type NavigatorCategorySumOrderByAggregateInput = {
    id?: SortOrder
    requiredRank?: SortOrder
    orderId?: SortOrder
  }

  export type EnumNavigatorCategoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryCategory | EnumNavigatorCategoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryCategory[]
    notIn?: $Enums.NavigatorCategoryCategory[]
    not?: NestedEnumNavigatorCategoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorCategoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel>
  }

  export type EnumNavigatorCategoryViewModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryViewMode | EnumNavigatorCategoryViewModeFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryViewMode[]
    notIn?: $Enums.NavigatorCategoryViewMode[]
    not?: NestedEnumNavigatorCategoryViewModeWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorCategoryViewMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel>
    _max?: NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel>
  }

  export type EnumNavigatorCategorySearchAllowanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategorySearchAllowance | EnumNavigatorCategorySearchAllowanceFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategorySearchAllowance[]
    notIn?: $Enums.NavigatorCategorySearchAllowance[]
    not?: NestedEnumNavigatorCategorySearchAllowanceWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorCategorySearchAllowance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel>
    _max?: NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel>
  }

  export type EnumNavigatorPublicLangueFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorPublicLangue | EnumNavigatorPublicLangueFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorPublicLangue[]
    notIn?: $Enums.NavigatorPublicLangue[]
    not?: NestedEnumNavigatorPublicLangueFilter<$PrismaModel> | $Enums.NavigatorPublicLangue
  }

  export type NavigatorPublicCountOrderByAggregateInput = {
    roomId?: SortOrder
    imageUrl?: SortOrder
    orderNum?: SortOrder
    enabled?: SortOrder
    langue?: SortOrder
    categoryType?: SortOrder
  }

  export type NavigatorPublicAvgOrderByAggregateInput = {
    roomId?: SortOrder
    orderNum?: SortOrder
  }

  export type NavigatorPublicMaxOrderByAggregateInput = {
    roomId?: SortOrder
    imageUrl?: SortOrder
    orderNum?: SortOrder
    enabled?: SortOrder
    langue?: SortOrder
    categoryType?: SortOrder
  }

  export type NavigatorPublicMinOrderByAggregateInput = {
    roomId?: SortOrder
    imageUrl?: SortOrder
    orderNum?: SortOrder
    enabled?: SortOrder
    langue?: SortOrder
    categoryType?: SortOrder
  }

  export type NavigatorPublicSumOrderByAggregateInput = {
    roomId?: SortOrder
    orderNum?: SortOrder
  }

  export type EnumNavigatorPublicLangueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorPublicLangue | EnumNavigatorPublicLangueFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorPublicLangue[]
    notIn?: $Enums.NavigatorPublicLangue[]
    not?: NestedEnumNavigatorPublicLangueWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorPublicLangue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorPublicLangueFilter<$PrismaModel>
    _max?: NestedEnumNavigatorPublicLangueFilter<$PrismaModel>
  }

  export type RoleplayCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
  }

  export type RoleplayAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
  }

  export type RoleplayMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
  }

  export type RoleplayMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
  }

  export type RoleplaySumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    hopitalId?: SortOrder
    prisonId?: SortOrder
  }

  export type EnumRoleplayEnemyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayEnemyType | EnumRoleplayEnemyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayEnemyType[]
    notIn?: $Enums.RoleplayEnemyType[]
    not?: NestedEnumRoleplayEnemyTypeFilter<$PrismaModel> | $Enums.RoleplayEnemyType
  }

  export type RoleplayEnemyIdTypeCompoundUniqueInput = {
    id: number
    type: $Enums.RoleplayEnemyType
  }

  export type RoleplayEnemyCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    resetPosition?: SortOrder
    lostAggroDistance?: SortOrder
    zombieMode?: SortOrder
  }

  export type RoleplayEnemyAvgOrderByAggregateInput = {
    id?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    lostAggroDistance?: SortOrder
  }

  export type RoleplayEnemyMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    resetPosition?: SortOrder
    lostAggroDistance?: SortOrder
    zombieMode?: SortOrder
  }

  export type RoleplayEnemyMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    resetPosition?: SortOrder
    lostAggroDistance?: SortOrder
    zombieMode?: SortOrder
  }

  export type RoleplayEnemySumOrderByAggregateInput = {
    id?: SortOrder
    health?: SortOrder
    weaponFarId?: SortOrder
    weaponCacId?: SortOrder
    deadTimer?: SortOrder
    lootItemId?: SortOrder
    moneyDrop?: SortOrder
    dropScriptId?: SortOrder
    teamId?: SortOrder
    aggroDistance?: SortOrder
    zoneDistance?: SortOrder
    lostAggroDistance?: SortOrder
  }

  export type EnumRoleplayEnemyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayEnemyType | EnumRoleplayEnemyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayEnemyType[]
    notIn?: $Enums.RoleplayEnemyType[]
    not?: NestedEnumRoleplayEnemyTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayEnemyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayEnemyTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleplayEnemyTypeFilter<$PrismaModel>
  }

  export type EnumRoleplayItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemType | EnumRoleplayItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemType[]
    notIn?: $Enums.RoleplayItemType[]
    not?: NestedEnumRoleplayItemTypeFilter<$PrismaModel> | $Enums.RoleplayItemType
  }

  export type EnumRoleplayItemCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemCategory | EnumRoleplayItemCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemCategory[]
    notIn?: $Enums.RoleplayItemCategory[]
    not?: NestedEnumRoleplayItemCategoryFilter<$PrismaModel> | $Enums.RoleplayItemCategory
  }

  export type RoleplayItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    price?: SortOrder
    type?: SortOrder
    value?: SortOrder
    allowstack?: SortOrder
    category?: SortOrder
  }

  export type RoleplayItemAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    value?: SortOrder
  }

  export type RoleplayItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    price?: SortOrder
    type?: SortOrder
    value?: SortOrder
    allowstack?: SortOrder
    category?: SortOrder
  }

  export type RoleplayItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    price?: SortOrder
    type?: SortOrder
    value?: SortOrder
    allowstack?: SortOrder
    category?: SortOrder
  }

  export type RoleplayItemSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    value?: SortOrder
  }

  export type EnumRoleplayItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemType | EnumRoleplayItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemType[]
    notIn?: $Enums.RoleplayItemType[]
    not?: NestedEnumRoleplayItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayItemTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleplayItemTypeFilter<$PrismaModel>
  }

  export type EnumRoleplayItemCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemCategory | EnumRoleplayItemCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemCategory[]
    notIn?: $Enums.RoleplayItemCategory[]
    not?: NestedEnumRoleplayItemCategoryWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayItemCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayItemCategoryFilter<$PrismaModel>
    _max?: NestedEnumRoleplayItemCategoryFilter<$PrismaModel>
  }

  export type EnumRoleplayWeaponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponType | EnumRoleplayWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponType[]
    notIn?: $Enums.RoleplayWeaponType[]
    not?: NestedEnumRoleplayWeaponTypeFilter<$PrismaModel> | $Enums.RoleplayWeaponType
  }

  export type EnumRoleplayWeaponInteractionFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponInteraction | EnumRoleplayWeaponInteractionFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponInteraction[]
    notIn?: $Enums.RoleplayWeaponInteraction[]
    not?: NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel> | $Enums.RoleplayWeaponInteraction
  }

  export type RoleplayWeaponCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    interaction?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
  }

  export type RoleplayWeaponAvgOrderByAggregateInput = {
    id?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
  }

  export type RoleplayWeaponMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    interaction?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
  }

  export type RoleplayWeaponMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    interaction?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
  }

  export type RoleplayWeaponSumOrderByAggregateInput = {
    id?: SortOrder
    domageMin?: SortOrder
    domageMax?: SortOrder
    enable?: SortOrder
    freezeTime?: SortOrder
    distance?: SortOrder
  }

  export type EnumRoleplayWeaponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponType | EnumRoleplayWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponType[]
    notIn?: $Enums.RoleplayWeaponType[]
    not?: NestedEnumRoleplayWeaponTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayWeaponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayWeaponTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleplayWeaponTypeFilter<$PrismaModel>
  }

  export type EnumRoleplayWeaponInteractionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponInteraction | EnumRoleplayWeaponInteractionFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponInteraction[]
    notIn?: $Enums.RoleplayWeaponInteraction[]
    not?: NestedEnumRoleplayWeaponInteractionWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayWeaponInteraction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel>
    _max?: NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel>
  }

  export type EnumRoomStateFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomState | EnumRoomStateFieldRefInput<$PrismaModel>
    in?: $Enums.RoomState[]
    notIn?: $Enums.RoomState[]
    not?: NestedEnumRoomStateFilter<$PrismaModel> | $Enums.RoomState
  }

  export type LogChatListRelationFilter = {
    every?: LogChatWhereInput
    some?: LogChatWhereInput
    none?: LogChatWhereInput
  }

  export type LogChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    owner?: SortOrder
    description?: SortOrder
    category?: SortOrder
    state?: SortOrder
    usersMax?: SortOrder
    modelName?: SortOrder
    score?: SortOrder
    tags?: SortOrder
    password?: SortOrder
    wallpaper?: SortOrder
    floor?: SortOrder
    landscape?: SortOrder
    allowPets?: SortOrder
    allowPetsEat?: SortOrder
    allowWalkthrough?: SortOrder
    allowHidewall?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationMuteFuse?: SortOrder
    allowRightsoverride?: SortOrder
    moderationKickFuse?: SortOrder
    moderationBanFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    allowHidewireds?: SortOrder
    price?: SortOrder
    wiredSecurity?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    usersMax?: SortOrder
    score?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationKickFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    price?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    owner?: SortOrder
    description?: SortOrder
    category?: SortOrder
    state?: SortOrder
    usersMax?: SortOrder
    modelName?: SortOrder
    score?: SortOrder
    tags?: SortOrder
    password?: SortOrder
    wallpaper?: SortOrder
    floor?: SortOrder
    landscape?: SortOrder
    allowPets?: SortOrder
    allowPetsEat?: SortOrder
    allowWalkthrough?: SortOrder
    allowHidewall?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationMuteFuse?: SortOrder
    allowRightsoverride?: SortOrder
    moderationKickFuse?: SortOrder
    moderationBanFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    allowHidewireds?: SortOrder
    price?: SortOrder
    wiredSecurity?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    caption?: SortOrder
    owner?: SortOrder
    description?: SortOrder
    category?: SortOrder
    state?: SortOrder
    usersMax?: SortOrder
    modelName?: SortOrder
    score?: SortOrder
    tags?: SortOrder
    password?: SortOrder
    wallpaper?: SortOrder
    floor?: SortOrder
    landscape?: SortOrder
    allowPets?: SortOrder
    allowPetsEat?: SortOrder
    allowWalkthrough?: SortOrder
    allowHidewall?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationMuteFuse?: SortOrder
    allowRightsoverride?: SortOrder
    moderationKickFuse?: SortOrder
    moderationBanFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    allowHidewireds?: SortOrder
    price?: SortOrder
    wiredSecurity?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    usersMax?: SortOrder
    score?: SortOrder
    wallthick?: SortOrder
    floorthick?: SortOrder
    moderationKickFuse?: SortOrder
    groupId?: SortOrder
    chatType?: SortOrder
    chatBalloon?: SortOrder
    chatSpeed?: SortOrder
    chatMaxDistance?: SortOrder
    chatFloodProtection?: SortOrder
    trocStatus?: SortOrder
    usersNow?: SortOrder
    price?: SortOrder
  }

  export type EnumRoomStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomState | EnumRoomStateFieldRefInput<$PrismaModel>
    in?: $Enums.RoomState[]
    notIn?: $Enums.RoomState[]
    not?: NestedEnumRoomStateWithAggregatesFilter<$PrismaModel> | $Enums.RoomState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStateFilter<$PrismaModel>
    _max?: NestedEnumRoomStateFilter<$PrismaModel>
  }

  export type RoomModelCountOrderByAggregateInput = {
    id?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
  }

  export type RoomModelAvgOrderByAggregateInput = {
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
  }

  export type RoomModelMaxOrderByAggregateInput = {
    id?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
  }

  export type RoomModelMinOrderByAggregateInput = {
    id?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
  }

  export type RoomModelSumOrderByAggregateInput = {
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
  }

  export type RoomModelCustomCountOrderByAggregateInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
    wallHeight?: SortOrder
  }

  export type RoomModelCustomAvgOrderByAggregateInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    wallHeight?: SortOrder
  }

  export type RoomModelCustomMaxOrderByAggregateInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
    wallHeight?: SortOrder
  }

  export type RoomModelCustomMinOrderByAggregateInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    heightmap?: SortOrder
    wallHeight?: SortOrder
  }

  export type RoomModelCustomSumOrderByAggregateInput = {
    roomId?: SortOrder
    doorX?: SortOrder
    doorY?: SortOrder
    doorZ?: SortOrder
    doorDir?: SortOrder
    wallHeight?: SortOrder
  }

  export type RoomRightRoomIdUserIdCompoundUniqueInput = {
    roomId: number
    userId: number
  }

  export type RoomRightCountOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
  }

  export type RoomRightAvgOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
  }

  export type RoomRightMaxOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
  }

  export type RoomRightMinOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
  }

  export type RoomRightSumOrderByAggregateInput = {
    roomId?: SortOrder
    userId?: SortOrder
  }

  export type RoomSwearwordFilterCountOrderByAggregateInput = {
    word?: SortOrder
  }

  export type RoomSwearwordFilterMaxOrderByAggregateInput = {
    word?: SortOrder
  }

  export type RoomSwearwordFilterMinOrderByAggregateInput = {
    word?: SortOrder
  }

  export type EnumUserGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserGender[]
    notIn?: $Enums.UserGender[]
    not?: NestedEnumUserGenderFilter<$PrismaModel> | $Enums.UserGender
  }

  export type EnumUserLangueFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLangue | EnumUserLangueFieldRefInput<$PrismaModel>
    in?: $Enums.UserLangue[]
    notIn?: $Enums.UserLangue[]
    not?: NestedEnumUserLangueFilter<$PrismaModel> | $Enums.UserLangue
  }

  export type LogLoginListRelationFilter = {
    every?: LogLoginWhereInput
    some?: LogLoginWhereInput
    none?: LogLoginWhereInput
  }

  export type LogSlotmachineListRelationFilter = {
    every?: LogSlotmachineWhereInput
    some?: LogSlotmachineWhereInput
    none?: LogSlotmachineWhereInput
  }

  export type LogShopListRelationFilter = {
    every?: LogShopWhereInput
    some?: LogShopWhereInput
    none?: LogShopWhereInput
  }

  export type LogSandboxListRelationFilter = {
    every?: LogSandboxWhereInput
    some?: LogSandboxWhereInput
    none?: LogSandboxWhereInput
  }

  export type LogTradeListRelationFilter = {
    every?: LogTradeWhereInput
    some?: LogTradeWhereInput
    none?: LogTradeWhereInput
  }

  export type LogLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogSlotmachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogSandboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogTradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mail?: SortOrder
    authTicket?: SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    look?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    online?: SortOrder
    ipLast?: SortOrder
    machineId?: SortOrder
    homeRoom?: SortOrder
    blockNewfriends?: SortOrder
    hideOnline?: SortOrder
    hideInroom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    volume?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    acceptTrading?: SortOrder
    cameraFollowDisabled?: SortOrder
    ignoreRoomInvite?: SortOrder
    lastdailycredits?: SortOrder
    hideGamealert?: SortOrder
    ipcountry?: SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    nuxEnable?: SortOrder
    langue?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    isBanned?: SortOrder
    bannerId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    homeRoom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    bannerId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mail?: SortOrder
    authTicket?: SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    look?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    online?: SortOrder
    ipLast?: SortOrder
    machineId?: SortOrder
    homeRoom?: SortOrder
    blockNewfriends?: SortOrder
    hideOnline?: SortOrder
    hideInroom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    volume?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    acceptTrading?: SortOrder
    cameraFollowDisabled?: SortOrder
    ignoreRoomInvite?: SortOrder
    lastdailycredits?: SortOrder
    hideGamealert?: SortOrder
    ipcountry?: SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    nuxEnable?: SortOrder
    langue?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    isBanned?: SortOrder
    bannerId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    mail?: SortOrder
    authTicket?: SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    look?: SortOrder
    gender?: SortOrder
    motto?: SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    online?: SortOrder
    ipLast?: SortOrder
    machineId?: SortOrder
    homeRoom?: SortOrder
    blockNewfriends?: SortOrder
    hideOnline?: SortOrder
    hideInroom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    volume?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    acceptTrading?: SortOrder
    cameraFollowDisabled?: SortOrder
    ignoreRoomInvite?: SortOrder
    lastdailycredits?: SortOrder
    hideGamealert?: SortOrder
    ipcountry?: SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    nuxEnable?: SortOrder
    langue?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    isBanned?: SortOrder
    bannerId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    credits?: SortOrder
    activityPoints?: SortOrder
    accountCreated?: SortOrder
    lastOnline?: SortOrder
    homeRoom?: SortOrder
    lastOffline?: SortOrder
    moisVip?: SortOrder
    vipPoints?: SortOrder
    limitCoins?: SortOrder
    gamePoints?: SortOrder
    gamePointsMonth?: SortOrder
    mazoscore?: SortOrder
    mazo?: SortOrder
    runPoints?: SortOrder
    runPointsMonth?: SortOrder
    bannerId?: SortOrder
  }

  export type EnumUserGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserGender[]
    notIn?: $Enums.UserGender[]
    not?: NestedEnumUserGenderWithAggregatesFilter<$PrismaModel> | $Enums.UserGender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserGenderFilter<$PrismaModel>
    _max?: NestedEnumUserGenderFilter<$PrismaModel>
  }

  export type EnumUserLangueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLangue | EnumUserLangueFieldRefInput<$PrismaModel>
    in?: $Enums.UserLangue[]
    notIn?: $Enums.UserLangue[]
    not?: NestedEnumUserLangueWithAggregatesFilter<$PrismaModel> | $Enums.UserLangue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserLangueFilter<$PrismaModel>
    _max?: NestedEnumUserLangueFilter<$PrismaModel>
  }

  export type UserAchievementUserIdGroupCompoundUniqueInput = {
    userId: number
    group: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    userId?: SortOrder
    group?: SortOrder
    level?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    userId?: SortOrder
    level?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    userId?: SortOrder
    group?: SortOrder
    level?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    userId?: SortOrder
    group?: SortOrder
    level?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    userId?: SortOrder
    level?: SortOrder
    progress?: SortOrder
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: number
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    badgeSlot?: SortOrder
  }

  export type UserBadgeAvgOrderByAggregateInput = {
    userId?: SortOrder
    badgeSlot?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    badgeSlot?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    badgeSlot?: SortOrder
  }

  export type UserBadgeSumOrderByAggregateInput = {
    userId?: SortOrder
    badgeSlot?: SortOrder
  }

  export type UserBannerCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
  }

  export type UserBannerAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
  }

  export type UserBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
  }

  export type UserBannerMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
  }

  export type UserBannerSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    banner_id?: SortOrder
  }

  export type UserPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    time?: SortOrder
  }

  export type UserPhotoAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type UserPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    time?: SortOrder
  }

  export type UserPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    photo?: SortOrder
    time?: SortOrder
  }

  export type UserPhotoSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type UserPremiumCountOrderByAggregateInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
  }

  export type UserPremiumAvgOrderByAggregateInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
  }

  export type UserPremiumMaxOrderByAggregateInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
  }

  export type UserPremiumMinOrderByAggregateInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
  }

  export type UserPremiumSumOrderByAggregateInput = {
    userId?: SortOrder
    timestampActivated?: SortOrder
    timestampExpireClassic?: SortOrder
    timestampExpireEpic?: SortOrder
    timestampExpireLegend?: SortOrder
  }

  export type UserQuestUserIdQuestIdCompoundUniqueInput = {
    userId: number
    questId: number
  }

  export type UserQuestCountOrderByAggregateInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
  }

  export type UserQuestAvgOrderByAggregateInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
  }

  export type UserQuestMaxOrderByAggregateInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
  }

  export type UserQuestMinOrderByAggregateInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
  }

  export type UserQuestSumOrderByAggregateInput = {
    userId?: SortOrder
    questId?: SortOrder
    progress?: SortOrder
  }

  export type UserRoleplayUserIdRoleplayIdCompoundUniqueInput = {
    userId: number
    roleplayId: number
  }

  export type UserRoleplayCountOrderByAggregateInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
  }

  export type UserRoleplayAvgOrderByAggregateInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
  }

  export type UserRoleplayMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
  }

  export type UserRoleplayMinOrderByAggregateInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
  }

  export type UserRoleplaySumOrderByAggregateInput = {
    userId?: SortOrder
    roleplayId?: SortOrder
    health?: SortOrder
    energy?: SortOrder
    money?: SortOrder
    munition?: SortOrder
    exp?: SortOrder
    weaponFar?: SortOrder
    weaponCac?: SortOrder
    hygiene?: SortOrder
    money1?: SortOrder
    money2?: SortOrder
    money3?: SortOrder
    money4?: SortOrder
  }

  export type UserRoleplayItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
  }

  export type UserRoleplayItemAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
  }

  export type UserRoleplayItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
  }

  export type UserRoleplayItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
  }

  export type UserRoleplayItemSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rpId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
  }

  export type UserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
  }

  export type UserStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
  }

  export type UserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
  }

  export type UserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
  }

  export type UserStatsSumOrderByAggregateInput = {
    id?: SortOrder
    onlineTime?: SortOrder
    respect?: SortOrder
    respectGiven?: SortOrder
    giftsGiven?: SortOrder
    giftsReceived?: SortOrder
    dailyRespectPoints?: SortOrder
    dailyPetRespectPoints?: SortOrder
    achievementScore?: SortOrder
    questId?: SortOrder
    questProgress?: SortOrder
    levBuilder?: SortOrder
    levSocial?: SortOrder
    levIdentity?: SortOrder
    levExplore?: SortOrder
    groupId?: SortOrder
  }

  export type EnumUserWardrobeGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.UserWardrobeGender | EnumUserWardrobeGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserWardrobeGender[]
    notIn?: $Enums.UserWardrobeGender[]
    not?: NestedEnumUserWardrobeGenderFilter<$PrismaModel> | $Enums.UserWardrobeGender
  }

  export type UserWardrobeUserIdSlotIdCompoundUniqueInput = {
    userId: number
    slotId: number
  }

  export type UserWardrobeCountOrderByAggregateInput = {
    userId?: SortOrder
    slotId?: SortOrder
    look?: SortOrder
    gender?: SortOrder
  }

  export type UserWardrobeAvgOrderByAggregateInput = {
    userId?: SortOrder
    slotId?: SortOrder
  }

  export type UserWardrobeMaxOrderByAggregateInput = {
    userId?: SortOrder
    slotId?: SortOrder
    look?: SortOrder
    gender?: SortOrder
  }

  export type UserWardrobeMinOrderByAggregateInput = {
    userId?: SortOrder
    slotId?: SortOrder
    look?: SortOrder
    gender?: SortOrder
  }

  export type UserWardrobeSumOrderByAggregateInput = {
    userId?: SortOrder
    slotId?: SortOrder
  }

  export type EnumUserWardrobeGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserWardrobeGender | EnumUserWardrobeGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserWardrobeGender[]
    notIn?: $Enums.UserWardrobeGender[]
    not?: NestedEnumUserWardrobeGenderWithAggregatesFilter<$PrismaModel> | $Enums.UserWardrobeGender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserWardrobeGenderFilter<$PrismaModel>
    _max?: NestedEnumUserWardrobeGenderFilter<$PrismaModel>
  }

  export type WordFilterRetroCountOrderByAggregateInput = {
    word?: SortOrder
  }

  export type WordFilterRetroMaxOrderByAggregateInput = {
    word?: SortOrder
  }

  export type WordFilterRetroMinOrderByAggregateInput = {
    word?: SortOrder
  }

  export type EnumBanBantypeFieldUpdateOperationsInput = {
    set?: $Enums.BanBantype
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumBotUserAiTypeFieldUpdateOperationsInput = {
    set?: $Enums.BotUserAiType
  }

  export type EnumCatalogBotPresetAiTypeFieldUpdateOperationsInput = {
    set?: $Enums.CatalogBotPresetAiType
  }

  export type CatalogItemLimitedCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<CatalogItemLimitedCreateWithoutCatalogItemInput, CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: CatalogItemLimitedCreateOrConnectWithoutCatalogItemInput
    connect?: CatalogItemLimitedWhereUniqueInput
  }

  export type ItemBaseCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<ItemBaseCreateWithoutCatalogItemInput, ItemBaseUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: ItemBaseCreateOrConnectWithoutCatalogItemInput
    connect?: ItemBaseWhereUniqueInput
  }

  export type CatalogItemLimitedUncheckedCreateNestedOneWithoutCatalogItemInput = {
    create?: XOR<CatalogItemLimitedCreateWithoutCatalogItemInput, CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: CatalogItemLimitedCreateOrConnectWithoutCatalogItemInput
    connect?: CatalogItemLimitedWhereUniqueInput
  }

  export type CatalogItemLimitedUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<CatalogItemLimitedCreateWithoutCatalogItemInput, CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: CatalogItemLimitedCreateOrConnectWithoutCatalogItemInput
    upsert?: CatalogItemLimitedUpsertWithoutCatalogItemInput
    disconnect?: CatalogItemLimitedWhereInput | boolean
    delete?: CatalogItemLimitedWhereInput | boolean
    connect?: CatalogItemLimitedWhereUniqueInput
    update?: XOR<XOR<CatalogItemLimitedUpdateToOneWithWhereWithoutCatalogItemInput, CatalogItemLimitedUpdateWithoutCatalogItemInput>, CatalogItemLimitedUncheckedUpdateWithoutCatalogItemInput>
  }

  export type ItemBaseUpdateOneRequiredWithoutCatalogItemNestedInput = {
    create?: XOR<ItemBaseCreateWithoutCatalogItemInput, ItemBaseUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: ItemBaseCreateOrConnectWithoutCatalogItemInput
    upsert?: ItemBaseUpsertWithoutCatalogItemInput
    connect?: ItemBaseWhereUniqueInput
    update?: XOR<XOR<ItemBaseUpdateToOneWithWhereWithoutCatalogItemInput, ItemBaseUpdateWithoutCatalogItemInput>, ItemBaseUncheckedUpdateWithoutCatalogItemInput>
  }

  export type CatalogItemLimitedUncheckedUpdateOneWithoutCatalogItemNestedInput = {
    create?: XOR<CatalogItemLimitedCreateWithoutCatalogItemInput, CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput>
    connectOrCreate?: CatalogItemLimitedCreateOrConnectWithoutCatalogItemInput
    upsert?: CatalogItemLimitedUpsertWithoutCatalogItemInput
    disconnect?: CatalogItemLimitedWhereInput | boolean
    delete?: CatalogItemLimitedWhereInput | boolean
    connect?: CatalogItemLimitedWhereUniqueInput
    update?: XOR<XOR<CatalogItemLimitedUpdateToOneWithWhereWithoutCatalogItemInput, CatalogItemLimitedUpdateWithoutCatalogItemInput>, CatalogItemLimitedUncheckedUpdateWithoutCatalogItemInput>
  }

  export type CatalogItemCreateNestedOneWithoutCatalogItemLimitedInput = {
    create?: XOR<CatalogItemCreateWithoutCatalogItemLimitedInput, CatalogItemUncheckedCreateWithoutCatalogItemLimitedInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutCatalogItemLimitedInput
    connect?: CatalogItemWhereUniqueInput
  }

  export type CatalogItemUpdateOneRequiredWithoutCatalogItemLimitedNestedInput = {
    create?: XOR<CatalogItemCreateWithoutCatalogItemLimitedInput, CatalogItemUncheckedCreateWithoutCatalogItemLimitedInput>
    connectOrCreate?: CatalogItemCreateOrConnectWithoutCatalogItemLimitedInput
    upsert?: CatalogItemUpsertWithoutCatalogItemLimitedInput
    connect?: CatalogItemWhereUniqueInput
    update?: XOR<XOR<CatalogItemUpdateToOneWithWhereWithoutCatalogItemLimitedInput, CatalogItemUpdateWithoutCatalogItemLimitedInput>, CatalogItemUncheckedUpdateWithoutCatalogItemLimitedInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCatalogVoucherTypeFieldUpdateOperationsInput = {
    set?: $Enums.CatalogVoucherType
  }

  export type EnumEmulatorLootboxCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EmulatorLootboxCategory
  }

  export type EnumGuildItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.GuildItemType
  }

  export type ItemStatCreateNestedOneWithoutItemBaseInput = {
    create?: XOR<ItemStatCreateWithoutItemBaseInput, ItemStatUncheckedCreateWithoutItemBaseInput>
    connectOrCreate?: ItemStatCreateOrConnectWithoutItemBaseInput
    connect?: ItemStatWhereUniqueInput
  }

  export type LogLootboxCreateNestedManyWithoutItemBaseInput = {
    create?: XOR<LogLootboxCreateWithoutItemBaseInput, LogLootboxUncheckedCreateWithoutItemBaseInput> | LogLootboxCreateWithoutItemBaseInput[] | LogLootboxUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutItemBaseInput | LogLootboxCreateOrConnectWithoutItemBaseInput[]
    createMany?: LogLootboxCreateManyItemBaseInputEnvelope
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
  }

  export type CatalogItemCreateNestedManyWithoutItemBaseInput = {
    create?: XOR<CatalogItemCreateWithoutItemBaseInput, CatalogItemUncheckedCreateWithoutItemBaseInput> | CatalogItemCreateWithoutItemBaseInput[] | CatalogItemUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutItemBaseInput | CatalogItemCreateOrConnectWithoutItemBaseInput[]
    createMany?: CatalogItemCreateManyItemBaseInputEnvelope
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
  }

  export type ItemStatUncheckedCreateNestedOneWithoutItemBaseInput = {
    create?: XOR<ItemStatCreateWithoutItemBaseInput, ItemStatUncheckedCreateWithoutItemBaseInput>
    connectOrCreate?: ItemStatCreateOrConnectWithoutItemBaseInput
    connect?: ItemStatWhereUniqueInput
  }

  export type LogLootboxUncheckedCreateNestedManyWithoutItemBaseInput = {
    create?: XOR<LogLootboxCreateWithoutItemBaseInput, LogLootboxUncheckedCreateWithoutItemBaseInput> | LogLootboxCreateWithoutItemBaseInput[] | LogLootboxUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutItemBaseInput | LogLootboxCreateOrConnectWithoutItemBaseInput[]
    createMany?: LogLootboxCreateManyItemBaseInputEnvelope
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
  }

  export type CatalogItemUncheckedCreateNestedManyWithoutItemBaseInput = {
    create?: XOR<CatalogItemCreateWithoutItemBaseInput, CatalogItemUncheckedCreateWithoutItemBaseInput> | CatalogItemCreateWithoutItemBaseInput[] | CatalogItemUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutItemBaseInput | CatalogItemCreateOrConnectWithoutItemBaseInput[]
    createMany?: CatalogItemCreateManyItemBaseInputEnvelope
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
  }

  export type EnumItemBaseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemBaseType
  }

  export type ItemStatUpdateOneWithoutItemBaseNestedInput = {
    create?: XOR<ItemStatCreateWithoutItemBaseInput, ItemStatUncheckedCreateWithoutItemBaseInput>
    connectOrCreate?: ItemStatCreateOrConnectWithoutItemBaseInput
    upsert?: ItemStatUpsertWithoutItemBaseInput
    disconnect?: ItemStatWhereInput | boolean
    delete?: ItemStatWhereInput | boolean
    connect?: ItemStatWhereUniqueInput
    update?: XOR<XOR<ItemStatUpdateToOneWithWhereWithoutItemBaseInput, ItemStatUpdateWithoutItemBaseInput>, ItemStatUncheckedUpdateWithoutItemBaseInput>
  }

  export type LogLootboxUpdateManyWithoutItemBaseNestedInput = {
    create?: XOR<LogLootboxCreateWithoutItemBaseInput, LogLootboxUncheckedCreateWithoutItemBaseInput> | LogLootboxCreateWithoutItemBaseInput[] | LogLootboxUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutItemBaseInput | LogLootboxCreateOrConnectWithoutItemBaseInput[]
    upsert?: LogLootboxUpsertWithWhereUniqueWithoutItemBaseInput | LogLootboxUpsertWithWhereUniqueWithoutItemBaseInput[]
    createMany?: LogLootboxCreateManyItemBaseInputEnvelope
    set?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    disconnect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    delete?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    update?: LogLootboxUpdateWithWhereUniqueWithoutItemBaseInput | LogLootboxUpdateWithWhereUniqueWithoutItemBaseInput[]
    updateMany?: LogLootboxUpdateManyWithWhereWithoutItemBaseInput | LogLootboxUpdateManyWithWhereWithoutItemBaseInput[]
    deleteMany?: LogLootboxScalarWhereInput | LogLootboxScalarWhereInput[]
  }

  export type CatalogItemUpdateManyWithoutItemBaseNestedInput = {
    create?: XOR<CatalogItemCreateWithoutItemBaseInput, CatalogItemUncheckedCreateWithoutItemBaseInput> | CatalogItemCreateWithoutItemBaseInput[] | CatalogItemUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutItemBaseInput | CatalogItemCreateOrConnectWithoutItemBaseInput[]
    upsert?: CatalogItemUpsertWithWhereUniqueWithoutItemBaseInput | CatalogItemUpsertWithWhereUniqueWithoutItemBaseInput[]
    createMany?: CatalogItemCreateManyItemBaseInputEnvelope
    set?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    disconnect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    delete?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    update?: CatalogItemUpdateWithWhereUniqueWithoutItemBaseInput | CatalogItemUpdateWithWhereUniqueWithoutItemBaseInput[]
    updateMany?: CatalogItemUpdateManyWithWhereWithoutItemBaseInput | CatalogItemUpdateManyWithWhereWithoutItemBaseInput[]
    deleteMany?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
  }

  export type ItemStatUncheckedUpdateOneWithoutItemBaseNestedInput = {
    create?: XOR<ItemStatCreateWithoutItemBaseInput, ItemStatUncheckedCreateWithoutItemBaseInput>
    connectOrCreate?: ItemStatCreateOrConnectWithoutItemBaseInput
    upsert?: ItemStatUpsertWithoutItemBaseInput
    disconnect?: ItemStatWhereInput | boolean
    delete?: ItemStatWhereInput | boolean
    connect?: ItemStatWhereUniqueInput
    update?: XOR<XOR<ItemStatUpdateToOneWithWhereWithoutItemBaseInput, ItemStatUpdateWithoutItemBaseInput>, ItemStatUncheckedUpdateWithoutItemBaseInput>
  }

  export type LogLootboxUncheckedUpdateManyWithoutItemBaseNestedInput = {
    create?: XOR<LogLootboxCreateWithoutItemBaseInput, LogLootboxUncheckedCreateWithoutItemBaseInput> | LogLootboxCreateWithoutItemBaseInput[] | LogLootboxUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutItemBaseInput | LogLootboxCreateOrConnectWithoutItemBaseInput[]
    upsert?: LogLootboxUpsertWithWhereUniqueWithoutItemBaseInput | LogLootboxUpsertWithWhereUniqueWithoutItemBaseInput[]
    createMany?: LogLootboxCreateManyItemBaseInputEnvelope
    set?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    disconnect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    delete?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    update?: LogLootboxUpdateWithWhereUniqueWithoutItemBaseInput | LogLootboxUpdateWithWhereUniqueWithoutItemBaseInput[]
    updateMany?: LogLootboxUpdateManyWithWhereWithoutItemBaseInput | LogLootboxUpdateManyWithWhereWithoutItemBaseInput[]
    deleteMany?: LogLootboxScalarWhereInput | LogLootboxScalarWhereInput[]
  }

  export type CatalogItemUncheckedUpdateManyWithoutItemBaseNestedInput = {
    create?: XOR<CatalogItemCreateWithoutItemBaseInput, CatalogItemUncheckedCreateWithoutItemBaseInput> | CatalogItemCreateWithoutItemBaseInput[] | CatalogItemUncheckedCreateWithoutItemBaseInput[]
    connectOrCreate?: CatalogItemCreateOrConnectWithoutItemBaseInput | CatalogItemCreateOrConnectWithoutItemBaseInput[]
    upsert?: CatalogItemUpsertWithWhereUniqueWithoutItemBaseInput | CatalogItemUpsertWithWhereUniqueWithoutItemBaseInput[]
    createMany?: CatalogItemCreateManyItemBaseInputEnvelope
    set?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    disconnect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    delete?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    connect?: CatalogItemWhereUniqueInput | CatalogItemWhereUniqueInput[]
    update?: CatalogItemUpdateWithWhereUniqueWithoutItemBaseInput | CatalogItemUpdateWithWhereUniqueWithoutItemBaseInput[]
    updateMany?: CatalogItemUpdateManyWithWhereWithoutItemBaseInput | CatalogItemUpdateManyWithWhereWithoutItemBaseInput[]
    deleteMany?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
  }

  export type ItemBaseCreateNestedOneWithoutItemStatInput = {
    create?: XOR<ItemBaseCreateWithoutItemStatInput, ItemBaseUncheckedCreateWithoutItemStatInput>
    connectOrCreate?: ItemBaseCreateOrConnectWithoutItemStatInput
    connect?: ItemBaseWhereUniqueInput
  }

  export type ItemBaseUpdateOneRequiredWithoutItemStatNestedInput = {
    create?: XOR<ItemBaseCreateWithoutItemStatInput, ItemBaseUncheckedCreateWithoutItemStatInput>
    connectOrCreate?: ItemBaseCreateOrConnectWithoutItemStatInput
    upsert?: ItemBaseUpsertWithoutItemStatInput
    connect?: ItemBaseWhereUniqueInput
    update?: XOR<XOR<ItemBaseUpdateToOneWithWhereWithoutItemStatInput, ItemBaseUpdateWithoutItemStatInput>, ItemBaseUncheckedUpdateWithoutItemStatInput>
  }

  export type UserCreateNestedOneWithoutLogChatInput = {
    create?: XOR<UserCreateWithoutLogChatInput, UserUncheckedCreateWithoutLogChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogChatInput
    connect?: UserWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutLogChatInput = {
    create?: XOR<RoomCreateWithoutLogChatInput, RoomUncheckedCreateWithoutLogChatInput>
    connectOrCreate?: RoomCreateOrConnectWithoutLogChatInput
    connect?: RoomWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogChatNestedInput = {
    create?: XOR<UserCreateWithoutLogChatInput, UserUncheckedCreateWithoutLogChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogChatInput
    upsert?: UserUpsertWithoutLogChatInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogChatInput, UserUpdateWithoutLogChatInput>, UserUncheckedUpdateWithoutLogChatInput>
  }

  export type RoomUpdateOneWithoutLogChatNestedInput = {
    create?: XOR<RoomCreateWithoutLogChatInput, RoomUncheckedCreateWithoutLogChatInput>
    connectOrCreate?: RoomCreateOrConnectWithoutLogChatInput
    upsert?: RoomUpsertWithoutLogChatInput
    disconnect?: RoomWhereInput | boolean
    delete?: RoomWhereInput | boolean
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutLogChatInput, RoomUpdateWithoutLogChatInput>, RoomUncheckedUpdateWithoutLogChatInput>
  }

  export type UserCreateNestedOneWithoutLogLoginInput = {
    create?: XOR<UserCreateWithoutLogLoginInput, UserUncheckedCreateWithoutLogLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogLoginNestedInput = {
    create?: XOR<UserCreateWithoutLogLoginInput, UserUncheckedCreateWithoutLogLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogLoginInput
    upsert?: UserUpsertWithoutLogLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogLoginInput, UserUpdateWithoutLogLoginInput>, UserUncheckedUpdateWithoutLogLoginInput>
  }

  export type UserCreateNestedOneWithoutLogLootboxInput = {
    create?: XOR<UserCreateWithoutLogLootboxInput, UserUncheckedCreateWithoutLogLootboxInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogLootboxInput
    connect?: UserWhereUniqueInput
  }

  export type ItemBaseCreateNestedOneWithoutLogLootboxInput = {
    create?: XOR<ItemBaseCreateWithoutLogLootboxInput, ItemBaseUncheckedCreateWithoutLogLootboxInput>
    connectOrCreate?: ItemBaseCreateOrConnectWithoutLogLootboxInput
    connect?: ItemBaseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogLootboxNestedInput = {
    create?: XOR<UserCreateWithoutLogLootboxInput, UserUncheckedCreateWithoutLogLootboxInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogLootboxInput
    upsert?: UserUpsertWithoutLogLootboxInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogLootboxInput, UserUpdateWithoutLogLootboxInput>, UserUncheckedUpdateWithoutLogLootboxInput>
  }

  export type ItemBaseUpdateOneRequiredWithoutLogLootboxNestedInput = {
    create?: XOR<ItemBaseCreateWithoutLogLootboxInput, ItemBaseUncheckedCreateWithoutLogLootboxInput>
    connectOrCreate?: ItemBaseCreateOrConnectWithoutLogLootboxInput
    upsert?: ItemBaseUpsertWithoutLogLootboxInput
    connect?: ItemBaseWhereUniqueInput
    update?: XOR<XOR<ItemBaseUpdateToOneWithWhereWithoutLogLootboxInput, ItemBaseUpdateWithoutLogLootboxInput>, ItemBaseUncheckedUpdateWithoutLogLootboxInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutLogShopInput = {
    create?: XOR<UserCreateWithoutLogShopInput, UserUncheckedCreateWithoutLogShopInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogShopInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogShopNestedInput = {
    create?: XOR<UserCreateWithoutLogShopInput, UserUncheckedCreateWithoutLogShopInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogShopInput
    upsert?: UserUpsertWithoutLogShopInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogShopInput, UserUpdateWithoutLogShopInput>, UserUncheckedUpdateWithoutLogShopInput>
  }

  export type UserCreateNestedOneWithoutLogSlotmachineInput = {
    create?: XOR<UserCreateWithoutLogSlotmachineInput, UserUncheckedCreateWithoutLogSlotmachineInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogSlotmachineInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogSlotmachineNestedInput = {
    create?: XOR<UserCreateWithoutLogSlotmachineInput, UserUncheckedCreateWithoutLogSlotmachineInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogSlotmachineInput
    upsert?: UserUpsertWithoutLogSlotmachineInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogSlotmachineInput, UserUpdateWithoutLogSlotmachineInput>, UserUncheckedUpdateWithoutLogSlotmachineInput>
  }

  export type UserCreateNestedOneWithoutUserOneTradeInput = {
    create?: XOR<UserCreateWithoutUserOneTradeInput, UserUncheckedCreateWithoutUserOneTradeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserOneTradeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserTwoTradeInput = {
    create?: XOR<UserCreateWithoutUserTwoTradeInput, UserUncheckedCreateWithoutUserTwoTradeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTwoTradeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserOneTradeNestedInput = {
    create?: XOR<UserCreateWithoutUserOneTradeInput, UserUncheckedCreateWithoutUserOneTradeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserOneTradeInput
    upsert?: UserUpsertWithoutUserOneTradeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserOneTradeInput, UserUpdateWithoutUserOneTradeInput>, UserUncheckedUpdateWithoutUserOneTradeInput>
  }

  export type UserUpdateOneRequiredWithoutUserTwoTradeNestedInput = {
    create?: XOR<UserCreateWithoutUserTwoTradeInput, UserUncheckedCreateWithoutUserTwoTradeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTwoTradeInput
    upsert?: UserUpsertWithoutUserTwoTradeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserTwoTradeInput, UserUpdateWithoutUserTwoTradeInput>, UserUncheckedUpdateWithoutUserTwoTradeInput>
  }

  export type UserCreateNestedOneWithoutLogSandboxInput = {
    create?: XOR<UserCreateWithoutLogSandboxInput, UserUncheckedCreateWithoutLogSandboxInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogSandboxInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogSandboxNestedInput = {
    create?: XOR<UserCreateWithoutLogSandboxInput, UserUncheckedCreateWithoutLogSandboxInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogSandboxInput
    upsert?: UserUpsertWithoutLogSandboxInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogSandboxInput, UserUpdateWithoutLogSandboxInput>, UserUncheckedUpdateWithoutLogSandboxInput>
  }

  export type EnumModerationPresetTypeFieldUpdateOperationsInput = {
    set?: $Enums.ModerationPresetType
  }

  export type EnumModerationResolutionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ModerationResolutionType
  }

  export type EnumModerationTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.ModerationTicketStatus
  }

  export type EnumNavigatorCategoryCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NavigatorCategoryCategory
  }

  export type EnumNavigatorCategoryViewModeFieldUpdateOperationsInput = {
    set?: $Enums.NavigatorCategoryViewMode
  }

  export type EnumNavigatorCategorySearchAllowanceFieldUpdateOperationsInput = {
    set?: $Enums.NavigatorCategorySearchAllowance
  }

  export type EnumNavigatorPublicLangueFieldUpdateOperationsInput = {
    set?: $Enums.NavigatorPublicLangue
  }

  export type EnumRoleplayEnemyTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoleplayEnemyType
  }

  export type EnumRoleplayItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoleplayItemType
  }

  export type EnumRoleplayItemCategoryFieldUpdateOperationsInput = {
    set?: $Enums.RoleplayItemCategory
  }

  export type EnumRoleplayWeaponTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoleplayWeaponType
  }

  export type EnumRoleplayWeaponInteractionFieldUpdateOperationsInput = {
    set?: $Enums.RoleplayWeaponInteraction
  }

  export type LogChatCreateNestedManyWithoutRoomInput = {
    create?: XOR<LogChatCreateWithoutRoomInput, LogChatUncheckedCreateWithoutRoomInput> | LogChatCreateWithoutRoomInput[] | LogChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutRoomInput | LogChatCreateOrConnectWithoutRoomInput[]
    createMany?: LogChatCreateManyRoomInputEnvelope
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
  }

  export type LogChatUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<LogChatCreateWithoutRoomInput, LogChatUncheckedCreateWithoutRoomInput> | LogChatCreateWithoutRoomInput[] | LogChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutRoomInput | LogChatCreateOrConnectWithoutRoomInput[]
    createMany?: LogChatCreateManyRoomInputEnvelope
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
  }

  export type EnumRoomStateFieldUpdateOperationsInput = {
    set?: $Enums.RoomState
  }

  export type LogChatUpdateManyWithoutRoomNestedInput = {
    create?: XOR<LogChatCreateWithoutRoomInput, LogChatUncheckedCreateWithoutRoomInput> | LogChatCreateWithoutRoomInput[] | LogChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutRoomInput | LogChatCreateOrConnectWithoutRoomInput[]
    upsert?: LogChatUpsertWithWhereUniqueWithoutRoomInput | LogChatUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: LogChatCreateManyRoomInputEnvelope
    set?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    disconnect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    delete?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    update?: LogChatUpdateWithWhereUniqueWithoutRoomInput | LogChatUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: LogChatUpdateManyWithWhereWithoutRoomInput | LogChatUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: LogChatScalarWhereInput | LogChatScalarWhereInput[]
  }

  export type LogChatUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<LogChatCreateWithoutRoomInput, LogChatUncheckedCreateWithoutRoomInput> | LogChatCreateWithoutRoomInput[] | LogChatUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutRoomInput | LogChatCreateOrConnectWithoutRoomInput[]
    upsert?: LogChatUpsertWithWhereUniqueWithoutRoomInput | LogChatUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: LogChatCreateManyRoomInputEnvelope
    set?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    disconnect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    delete?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    update?: LogChatUpdateWithWhereUniqueWithoutRoomInput | LogChatUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: LogChatUpdateManyWithWhereWithoutRoomInput | LogChatUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: LogChatScalarWhereInput | LogChatScalarWhereInput[]
  }

  export type LogLoginCreateNestedManyWithoutUserInput = {
    create?: XOR<LogLoginCreateWithoutUserInput, LogLoginUncheckedCreateWithoutUserInput> | LogLoginCreateWithoutUserInput[] | LogLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLoginCreateOrConnectWithoutUserInput | LogLoginCreateOrConnectWithoutUserInput[]
    createMany?: LogLoginCreateManyUserInputEnvelope
    connect?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
  }

  export type LogChatCreateNestedManyWithoutUserInput = {
    create?: XOR<LogChatCreateWithoutUserInput, LogChatUncheckedCreateWithoutUserInput> | LogChatCreateWithoutUserInput[] | LogChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutUserInput | LogChatCreateOrConnectWithoutUserInput[]
    createMany?: LogChatCreateManyUserInputEnvelope
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
  }

  export type LogSlotmachineCreateNestedManyWithoutUserInput = {
    create?: XOR<LogSlotmachineCreateWithoutUserInput, LogSlotmachineUncheckedCreateWithoutUserInput> | LogSlotmachineCreateWithoutUserInput[] | LogSlotmachineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSlotmachineCreateOrConnectWithoutUserInput | LogSlotmachineCreateOrConnectWithoutUserInput[]
    createMany?: LogSlotmachineCreateManyUserInputEnvelope
    connect?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
  }

  export type LogShopCreateNestedManyWithoutUserInput = {
    create?: XOR<LogShopCreateWithoutUserInput, LogShopUncheckedCreateWithoutUserInput> | LogShopCreateWithoutUserInput[] | LogShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogShopCreateOrConnectWithoutUserInput | LogShopCreateOrConnectWithoutUserInput[]
    createMany?: LogShopCreateManyUserInputEnvelope
    connect?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
  }

  export type LogLootboxCreateNestedManyWithoutUserInput = {
    create?: XOR<LogLootboxCreateWithoutUserInput, LogLootboxUncheckedCreateWithoutUserInput> | LogLootboxCreateWithoutUserInput[] | LogLootboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutUserInput | LogLootboxCreateOrConnectWithoutUserInput[]
    createMany?: LogLootboxCreateManyUserInputEnvelope
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
  }

  export type LogSandboxCreateNestedManyWithoutUserInput = {
    create?: XOR<LogSandboxCreateWithoutUserInput, LogSandboxUncheckedCreateWithoutUserInput> | LogSandboxCreateWithoutUserInput[] | LogSandboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSandboxCreateOrConnectWithoutUserInput | LogSandboxCreateOrConnectWithoutUserInput[]
    createMany?: LogSandboxCreateManyUserInputEnvelope
    connect?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
  }

  export type LogTradeCreateNestedManyWithoutUserOneTradeInput = {
    create?: XOR<LogTradeCreateWithoutUserOneTradeInput, LogTradeUncheckedCreateWithoutUserOneTradeInput> | LogTradeCreateWithoutUserOneTradeInput[] | LogTradeUncheckedCreateWithoutUserOneTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserOneTradeInput | LogTradeCreateOrConnectWithoutUserOneTradeInput[]
    createMany?: LogTradeCreateManyUserOneTradeInputEnvelope
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
  }

  export type LogTradeCreateNestedManyWithoutUserTwoTradeInput = {
    create?: XOR<LogTradeCreateWithoutUserTwoTradeInput, LogTradeUncheckedCreateWithoutUserTwoTradeInput> | LogTradeCreateWithoutUserTwoTradeInput[] | LogTradeUncheckedCreateWithoutUserTwoTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserTwoTradeInput | LogTradeCreateOrConnectWithoutUserTwoTradeInput[]
    createMany?: LogTradeCreateManyUserTwoTradeInputEnvelope
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
  }

  export type LogLoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogLoginCreateWithoutUserInput, LogLoginUncheckedCreateWithoutUserInput> | LogLoginCreateWithoutUserInput[] | LogLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLoginCreateOrConnectWithoutUserInput | LogLoginCreateOrConnectWithoutUserInput[]
    createMany?: LogLoginCreateManyUserInputEnvelope
    connect?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
  }

  export type LogChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogChatCreateWithoutUserInput, LogChatUncheckedCreateWithoutUserInput> | LogChatCreateWithoutUserInput[] | LogChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutUserInput | LogChatCreateOrConnectWithoutUserInput[]
    createMany?: LogChatCreateManyUserInputEnvelope
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
  }

  export type LogSlotmachineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogSlotmachineCreateWithoutUserInput, LogSlotmachineUncheckedCreateWithoutUserInput> | LogSlotmachineCreateWithoutUserInput[] | LogSlotmachineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSlotmachineCreateOrConnectWithoutUserInput | LogSlotmachineCreateOrConnectWithoutUserInput[]
    createMany?: LogSlotmachineCreateManyUserInputEnvelope
    connect?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
  }

  export type LogShopUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogShopCreateWithoutUserInput, LogShopUncheckedCreateWithoutUserInput> | LogShopCreateWithoutUserInput[] | LogShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogShopCreateOrConnectWithoutUserInput | LogShopCreateOrConnectWithoutUserInput[]
    createMany?: LogShopCreateManyUserInputEnvelope
    connect?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
  }

  export type LogLootboxUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogLootboxCreateWithoutUserInput, LogLootboxUncheckedCreateWithoutUserInput> | LogLootboxCreateWithoutUserInput[] | LogLootboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutUserInput | LogLootboxCreateOrConnectWithoutUserInput[]
    createMany?: LogLootboxCreateManyUserInputEnvelope
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
  }

  export type LogSandboxUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogSandboxCreateWithoutUserInput, LogSandboxUncheckedCreateWithoutUserInput> | LogSandboxCreateWithoutUserInput[] | LogSandboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSandboxCreateOrConnectWithoutUserInput | LogSandboxCreateOrConnectWithoutUserInput[]
    createMany?: LogSandboxCreateManyUserInputEnvelope
    connect?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
  }

  export type LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput = {
    create?: XOR<LogTradeCreateWithoutUserOneTradeInput, LogTradeUncheckedCreateWithoutUserOneTradeInput> | LogTradeCreateWithoutUserOneTradeInput[] | LogTradeUncheckedCreateWithoutUserOneTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserOneTradeInput | LogTradeCreateOrConnectWithoutUserOneTradeInput[]
    createMany?: LogTradeCreateManyUserOneTradeInputEnvelope
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
  }

  export type LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput = {
    create?: XOR<LogTradeCreateWithoutUserTwoTradeInput, LogTradeUncheckedCreateWithoutUserTwoTradeInput> | LogTradeCreateWithoutUserTwoTradeInput[] | LogTradeUncheckedCreateWithoutUserTwoTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserTwoTradeInput | LogTradeCreateOrConnectWithoutUserTwoTradeInput[]
    createMany?: LogTradeCreateManyUserTwoTradeInputEnvelope
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
  }

  export type EnumUserGenderFieldUpdateOperationsInput = {
    set?: $Enums.UserGender
  }

  export type EnumUserLangueFieldUpdateOperationsInput = {
    set?: $Enums.UserLangue
  }

  export type LogLoginUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogLoginCreateWithoutUserInput, LogLoginUncheckedCreateWithoutUserInput> | LogLoginCreateWithoutUserInput[] | LogLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLoginCreateOrConnectWithoutUserInput | LogLoginCreateOrConnectWithoutUserInput[]
    upsert?: LogLoginUpsertWithWhereUniqueWithoutUserInput | LogLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogLoginCreateManyUserInputEnvelope
    set?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    disconnect?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    delete?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    connect?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    update?: LogLoginUpdateWithWhereUniqueWithoutUserInput | LogLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogLoginUpdateManyWithWhereWithoutUserInput | LogLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogLoginScalarWhereInput | LogLoginScalarWhereInput[]
  }

  export type LogChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogChatCreateWithoutUserInput, LogChatUncheckedCreateWithoutUserInput> | LogChatCreateWithoutUserInput[] | LogChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutUserInput | LogChatCreateOrConnectWithoutUserInput[]
    upsert?: LogChatUpsertWithWhereUniqueWithoutUserInput | LogChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogChatCreateManyUserInputEnvelope
    set?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    disconnect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    delete?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    update?: LogChatUpdateWithWhereUniqueWithoutUserInput | LogChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogChatUpdateManyWithWhereWithoutUserInput | LogChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogChatScalarWhereInput | LogChatScalarWhereInput[]
  }

  export type LogSlotmachineUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogSlotmachineCreateWithoutUserInput, LogSlotmachineUncheckedCreateWithoutUserInput> | LogSlotmachineCreateWithoutUserInput[] | LogSlotmachineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSlotmachineCreateOrConnectWithoutUserInput | LogSlotmachineCreateOrConnectWithoutUserInput[]
    upsert?: LogSlotmachineUpsertWithWhereUniqueWithoutUserInput | LogSlotmachineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogSlotmachineCreateManyUserInputEnvelope
    set?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    disconnect?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    delete?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    connect?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    update?: LogSlotmachineUpdateWithWhereUniqueWithoutUserInput | LogSlotmachineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogSlotmachineUpdateManyWithWhereWithoutUserInput | LogSlotmachineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogSlotmachineScalarWhereInput | LogSlotmachineScalarWhereInput[]
  }

  export type LogShopUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogShopCreateWithoutUserInput, LogShopUncheckedCreateWithoutUserInput> | LogShopCreateWithoutUserInput[] | LogShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogShopCreateOrConnectWithoutUserInput | LogShopCreateOrConnectWithoutUserInput[]
    upsert?: LogShopUpsertWithWhereUniqueWithoutUserInput | LogShopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogShopCreateManyUserInputEnvelope
    set?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    disconnect?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    delete?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    connect?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    update?: LogShopUpdateWithWhereUniqueWithoutUserInput | LogShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogShopUpdateManyWithWhereWithoutUserInput | LogShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogShopScalarWhereInput | LogShopScalarWhereInput[]
  }

  export type LogLootboxUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogLootboxCreateWithoutUserInput, LogLootboxUncheckedCreateWithoutUserInput> | LogLootboxCreateWithoutUserInput[] | LogLootboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutUserInput | LogLootboxCreateOrConnectWithoutUserInput[]
    upsert?: LogLootboxUpsertWithWhereUniqueWithoutUserInput | LogLootboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogLootboxCreateManyUserInputEnvelope
    set?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    disconnect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    delete?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    update?: LogLootboxUpdateWithWhereUniqueWithoutUserInput | LogLootboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogLootboxUpdateManyWithWhereWithoutUserInput | LogLootboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogLootboxScalarWhereInput | LogLootboxScalarWhereInput[]
  }

  export type LogSandboxUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogSandboxCreateWithoutUserInput, LogSandboxUncheckedCreateWithoutUserInput> | LogSandboxCreateWithoutUserInput[] | LogSandboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSandboxCreateOrConnectWithoutUserInput | LogSandboxCreateOrConnectWithoutUserInput[]
    upsert?: LogSandboxUpsertWithWhereUniqueWithoutUserInput | LogSandboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogSandboxCreateManyUserInputEnvelope
    set?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    disconnect?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    delete?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    connect?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    update?: LogSandboxUpdateWithWhereUniqueWithoutUserInput | LogSandboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogSandboxUpdateManyWithWhereWithoutUserInput | LogSandboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogSandboxScalarWhereInput | LogSandboxScalarWhereInput[]
  }

  export type LogTradeUpdateManyWithoutUserOneTradeNestedInput = {
    create?: XOR<LogTradeCreateWithoutUserOneTradeInput, LogTradeUncheckedCreateWithoutUserOneTradeInput> | LogTradeCreateWithoutUserOneTradeInput[] | LogTradeUncheckedCreateWithoutUserOneTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserOneTradeInput | LogTradeCreateOrConnectWithoutUserOneTradeInput[]
    upsert?: LogTradeUpsertWithWhereUniqueWithoutUserOneTradeInput | LogTradeUpsertWithWhereUniqueWithoutUserOneTradeInput[]
    createMany?: LogTradeCreateManyUserOneTradeInputEnvelope
    set?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    disconnect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    delete?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    update?: LogTradeUpdateWithWhereUniqueWithoutUserOneTradeInput | LogTradeUpdateWithWhereUniqueWithoutUserOneTradeInput[]
    updateMany?: LogTradeUpdateManyWithWhereWithoutUserOneTradeInput | LogTradeUpdateManyWithWhereWithoutUserOneTradeInput[]
    deleteMany?: LogTradeScalarWhereInput | LogTradeScalarWhereInput[]
  }

  export type LogTradeUpdateManyWithoutUserTwoTradeNestedInput = {
    create?: XOR<LogTradeCreateWithoutUserTwoTradeInput, LogTradeUncheckedCreateWithoutUserTwoTradeInput> | LogTradeCreateWithoutUserTwoTradeInput[] | LogTradeUncheckedCreateWithoutUserTwoTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserTwoTradeInput | LogTradeCreateOrConnectWithoutUserTwoTradeInput[]
    upsert?: LogTradeUpsertWithWhereUniqueWithoutUserTwoTradeInput | LogTradeUpsertWithWhereUniqueWithoutUserTwoTradeInput[]
    createMany?: LogTradeCreateManyUserTwoTradeInputEnvelope
    set?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    disconnect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    delete?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    update?: LogTradeUpdateWithWhereUniqueWithoutUserTwoTradeInput | LogTradeUpdateWithWhereUniqueWithoutUserTwoTradeInput[]
    updateMany?: LogTradeUpdateManyWithWhereWithoutUserTwoTradeInput | LogTradeUpdateManyWithWhereWithoutUserTwoTradeInput[]
    deleteMany?: LogTradeScalarWhereInput | LogTradeScalarWhereInput[]
  }

  export type LogLoginUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogLoginCreateWithoutUserInput, LogLoginUncheckedCreateWithoutUserInput> | LogLoginCreateWithoutUserInput[] | LogLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLoginCreateOrConnectWithoutUserInput | LogLoginCreateOrConnectWithoutUserInput[]
    upsert?: LogLoginUpsertWithWhereUniqueWithoutUserInput | LogLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogLoginCreateManyUserInputEnvelope
    set?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    disconnect?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    delete?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    connect?: LogLoginWhereUniqueInput | LogLoginWhereUniqueInput[]
    update?: LogLoginUpdateWithWhereUniqueWithoutUserInput | LogLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogLoginUpdateManyWithWhereWithoutUserInput | LogLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogLoginScalarWhereInput | LogLoginScalarWhereInput[]
  }

  export type LogChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogChatCreateWithoutUserInput, LogChatUncheckedCreateWithoutUserInput> | LogChatCreateWithoutUserInput[] | LogChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogChatCreateOrConnectWithoutUserInput | LogChatCreateOrConnectWithoutUserInput[]
    upsert?: LogChatUpsertWithWhereUniqueWithoutUserInput | LogChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogChatCreateManyUserInputEnvelope
    set?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    disconnect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    delete?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    connect?: LogChatWhereUniqueInput | LogChatWhereUniqueInput[]
    update?: LogChatUpdateWithWhereUniqueWithoutUserInput | LogChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogChatUpdateManyWithWhereWithoutUserInput | LogChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogChatScalarWhereInput | LogChatScalarWhereInput[]
  }

  export type LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogSlotmachineCreateWithoutUserInput, LogSlotmachineUncheckedCreateWithoutUserInput> | LogSlotmachineCreateWithoutUserInput[] | LogSlotmachineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSlotmachineCreateOrConnectWithoutUserInput | LogSlotmachineCreateOrConnectWithoutUserInput[]
    upsert?: LogSlotmachineUpsertWithWhereUniqueWithoutUserInput | LogSlotmachineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogSlotmachineCreateManyUserInputEnvelope
    set?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    disconnect?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    delete?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    connect?: LogSlotmachineWhereUniqueInput | LogSlotmachineWhereUniqueInput[]
    update?: LogSlotmachineUpdateWithWhereUniqueWithoutUserInput | LogSlotmachineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogSlotmachineUpdateManyWithWhereWithoutUserInput | LogSlotmachineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogSlotmachineScalarWhereInput | LogSlotmachineScalarWhereInput[]
  }

  export type LogShopUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogShopCreateWithoutUserInput, LogShopUncheckedCreateWithoutUserInput> | LogShopCreateWithoutUserInput[] | LogShopUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogShopCreateOrConnectWithoutUserInput | LogShopCreateOrConnectWithoutUserInput[]
    upsert?: LogShopUpsertWithWhereUniqueWithoutUserInput | LogShopUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogShopCreateManyUserInputEnvelope
    set?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    disconnect?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    delete?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    connect?: LogShopWhereUniqueInput | LogShopWhereUniqueInput[]
    update?: LogShopUpdateWithWhereUniqueWithoutUserInput | LogShopUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogShopUpdateManyWithWhereWithoutUserInput | LogShopUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogShopScalarWhereInput | LogShopScalarWhereInput[]
  }

  export type LogLootboxUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogLootboxCreateWithoutUserInput, LogLootboxUncheckedCreateWithoutUserInput> | LogLootboxCreateWithoutUserInput[] | LogLootboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogLootboxCreateOrConnectWithoutUserInput | LogLootboxCreateOrConnectWithoutUserInput[]
    upsert?: LogLootboxUpsertWithWhereUniqueWithoutUserInput | LogLootboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogLootboxCreateManyUserInputEnvelope
    set?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    disconnect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    delete?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    connect?: LogLootboxWhereUniqueInput | LogLootboxWhereUniqueInput[]
    update?: LogLootboxUpdateWithWhereUniqueWithoutUserInput | LogLootboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogLootboxUpdateManyWithWhereWithoutUserInput | LogLootboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogLootboxScalarWhereInput | LogLootboxScalarWhereInput[]
  }

  export type LogSandboxUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogSandboxCreateWithoutUserInput, LogSandboxUncheckedCreateWithoutUserInput> | LogSandboxCreateWithoutUserInput[] | LogSandboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogSandboxCreateOrConnectWithoutUserInput | LogSandboxCreateOrConnectWithoutUserInput[]
    upsert?: LogSandboxUpsertWithWhereUniqueWithoutUserInput | LogSandboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogSandboxCreateManyUserInputEnvelope
    set?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    disconnect?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    delete?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    connect?: LogSandboxWhereUniqueInput | LogSandboxWhereUniqueInput[]
    update?: LogSandboxUpdateWithWhereUniqueWithoutUserInput | LogSandboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogSandboxUpdateManyWithWhereWithoutUserInput | LogSandboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogSandboxScalarWhereInput | LogSandboxScalarWhereInput[]
  }

  export type LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput = {
    create?: XOR<LogTradeCreateWithoutUserOneTradeInput, LogTradeUncheckedCreateWithoutUserOneTradeInput> | LogTradeCreateWithoutUserOneTradeInput[] | LogTradeUncheckedCreateWithoutUserOneTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserOneTradeInput | LogTradeCreateOrConnectWithoutUserOneTradeInput[]
    upsert?: LogTradeUpsertWithWhereUniqueWithoutUserOneTradeInput | LogTradeUpsertWithWhereUniqueWithoutUserOneTradeInput[]
    createMany?: LogTradeCreateManyUserOneTradeInputEnvelope
    set?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    disconnect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    delete?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    update?: LogTradeUpdateWithWhereUniqueWithoutUserOneTradeInput | LogTradeUpdateWithWhereUniqueWithoutUserOneTradeInput[]
    updateMany?: LogTradeUpdateManyWithWhereWithoutUserOneTradeInput | LogTradeUpdateManyWithWhereWithoutUserOneTradeInput[]
    deleteMany?: LogTradeScalarWhereInput | LogTradeScalarWhereInput[]
  }

  export type LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput = {
    create?: XOR<LogTradeCreateWithoutUserTwoTradeInput, LogTradeUncheckedCreateWithoutUserTwoTradeInput> | LogTradeCreateWithoutUserTwoTradeInput[] | LogTradeUncheckedCreateWithoutUserTwoTradeInput[]
    connectOrCreate?: LogTradeCreateOrConnectWithoutUserTwoTradeInput | LogTradeCreateOrConnectWithoutUserTwoTradeInput[]
    upsert?: LogTradeUpsertWithWhereUniqueWithoutUserTwoTradeInput | LogTradeUpsertWithWhereUniqueWithoutUserTwoTradeInput[]
    createMany?: LogTradeCreateManyUserTwoTradeInputEnvelope
    set?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    disconnect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    delete?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    connect?: LogTradeWhereUniqueInput | LogTradeWhereUniqueInput[]
    update?: LogTradeUpdateWithWhereUniqueWithoutUserTwoTradeInput | LogTradeUpdateWithWhereUniqueWithoutUserTwoTradeInput[]
    updateMany?: LogTradeUpdateManyWithWhereWithoutUserTwoTradeInput | LogTradeUpdateManyWithWhereWithoutUserTwoTradeInput[]
    deleteMany?: LogTradeScalarWhereInput | LogTradeScalarWhereInput[]
  }

  export type EnumUserWardrobeGenderFieldUpdateOperationsInput = {
    set?: $Enums.UserWardrobeGender
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumBanBantypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BanBantype | EnumBanBantypeFieldRefInput<$PrismaModel>
    in?: $Enums.BanBantype[]
    notIn?: $Enums.BanBantype[]
    not?: NestedEnumBanBantypeFilter<$PrismaModel> | $Enums.BanBantype
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBanBantypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BanBantype | EnumBanBantypeFieldRefInput<$PrismaModel>
    in?: $Enums.BanBantype[]
    notIn?: $Enums.BanBantype[]
    not?: NestedEnumBanBantypeWithAggregatesFilter<$PrismaModel> | $Enums.BanBantype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBanBantypeFilter<$PrismaModel>
    _max?: NestedEnumBanBantypeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumBotUserAiTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BotUserAiType | EnumBotUserAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BotUserAiType[]
    notIn?: $Enums.BotUserAiType[]
    not?: NestedEnumBotUserAiTypeFilter<$PrismaModel> | $Enums.BotUserAiType
  }

  export type NestedEnumBotUserAiTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BotUserAiType | EnumBotUserAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BotUserAiType[]
    notIn?: $Enums.BotUserAiType[]
    not?: NestedEnumBotUserAiTypeWithAggregatesFilter<$PrismaModel> | $Enums.BotUserAiType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBotUserAiTypeFilter<$PrismaModel>
    _max?: NestedEnumBotUserAiTypeFilter<$PrismaModel>
  }

  export type NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogBotPresetAiType | EnumCatalogBotPresetAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogBotPresetAiType[]
    notIn?: $Enums.CatalogBotPresetAiType[]
    not?: NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel> | $Enums.CatalogBotPresetAiType
  }

  export type NestedEnumCatalogBotPresetAiTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogBotPresetAiType | EnumCatalogBotPresetAiTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogBotPresetAiType[]
    notIn?: $Enums.CatalogBotPresetAiType[]
    not?: NestedEnumCatalogBotPresetAiTypeWithAggregatesFilter<$PrismaModel> | $Enums.CatalogBotPresetAiType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel>
    _max?: NestedEnumCatalogBotPresetAiTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCatalogVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogVoucherType | EnumCatalogVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogVoucherType[]
    notIn?: $Enums.CatalogVoucherType[]
    not?: NestedEnumCatalogVoucherTypeFilter<$PrismaModel> | $Enums.CatalogVoucherType
  }

  export type NestedEnumCatalogVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CatalogVoucherType | EnumCatalogVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CatalogVoucherType[]
    notIn?: $Enums.CatalogVoucherType[]
    not?: NestedEnumCatalogVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.CatalogVoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCatalogVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumCatalogVoucherTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EmulatorLootboxCategory | EnumEmulatorLootboxCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmulatorLootboxCategory[]
    notIn?: $Enums.EmulatorLootboxCategory[]
    not?: NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel> | $Enums.EmulatorLootboxCategory
  }

  export type NestedEnumEmulatorLootboxCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmulatorLootboxCategory | EnumEmulatorLootboxCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmulatorLootboxCategory[]
    notIn?: $Enums.EmulatorLootboxCategory[]
    not?: NestedEnumEmulatorLootboxCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EmulatorLootboxCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel>
    _max?: NestedEnumEmulatorLootboxCategoryFilter<$PrismaModel>
  }

  export type NestedEnumGuildItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildItemType | EnumGuildItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuildItemType[]
    notIn?: $Enums.GuildItemType[]
    not?: NestedEnumGuildItemTypeFilter<$PrismaModel> | $Enums.GuildItemType
  }

  export type NestedEnumGuildItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GuildItemType | EnumGuildItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GuildItemType[]
    notIn?: $Enums.GuildItemType[]
    not?: NestedEnumGuildItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.GuildItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGuildItemTypeFilter<$PrismaModel>
    _max?: NestedEnumGuildItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemBaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemBaseType | EnumItemBaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemBaseType[]
    notIn?: $Enums.ItemBaseType[]
    not?: NestedEnumItemBaseTypeFilter<$PrismaModel> | $Enums.ItemBaseType
  }

  export type NestedEnumItemBaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemBaseType | EnumItemBaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemBaseType[]
    notIn?: $Enums.ItemBaseType[]
    not?: NestedEnumItemBaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemBaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemBaseTypeFilter<$PrismaModel>
    _max?: NestedEnumItemBaseTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumModerationPresetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationPresetType | EnumModerationPresetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationPresetType[]
    notIn?: $Enums.ModerationPresetType[]
    not?: NestedEnumModerationPresetTypeFilter<$PrismaModel> | $Enums.ModerationPresetType
  }

  export type NestedEnumModerationPresetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationPresetType | EnumModerationPresetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationPresetType[]
    notIn?: $Enums.ModerationPresetType[]
    not?: NestedEnumModerationPresetTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModerationPresetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationPresetTypeFilter<$PrismaModel>
    _max?: NestedEnumModerationPresetTypeFilter<$PrismaModel>
  }

  export type NestedEnumModerationResolutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationResolutionType | EnumModerationResolutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationResolutionType[]
    notIn?: $Enums.ModerationResolutionType[]
    not?: NestedEnumModerationResolutionTypeFilter<$PrismaModel> | $Enums.ModerationResolutionType
  }

  export type NestedEnumModerationResolutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationResolutionType | EnumModerationResolutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationResolutionType[]
    notIn?: $Enums.ModerationResolutionType[]
    not?: NestedEnumModerationResolutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModerationResolutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationResolutionTypeFilter<$PrismaModel>
    _max?: NestedEnumModerationResolutionTypeFilter<$PrismaModel>
  }

  export type NestedEnumModerationTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationTicketStatus | EnumModerationTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationTicketStatus[]
    notIn?: $Enums.ModerationTicketStatus[]
    not?: NestedEnumModerationTicketStatusFilter<$PrismaModel> | $Enums.ModerationTicketStatus
  }

  export type NestedEnumModerationTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationTicketStatus | EnumModerationTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationTicketStatus[]
    notIn?: $Enums.ModerationTicketStatus[]
    not?: NestedEnumModerationTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModerationTicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumModerationTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryCategory | EnumNavigatorCategoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryCategory[]
    notIn?: $Enums.NavigatorCategoryCategory[]
    not?: NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel> | $Enums.NavigatorCategoryCategory
  }

  export type NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryViewMode | EnumNavigatorCategoryViewModeFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryViewMode[]
    notIn?: $Enums.NavigatorCategoryViewMode[]
    not?: NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel> | $Enums.NavigatorCategoryViewMode
  }

  export type NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategorySearchAllowance | EnumNavigatorCategorySearchAllowanceFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategorySearchAllowance[]
    notIn?: $Enums.NavigatorCategorySearchAllowance[]
    not?: NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel> | $Enums.NavigatorCategorySearchAllowance
  }

  export type NestedEnumNavigatorCategoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryCategory | EnumNavigatorCategoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryCategory[]
    notIn?: $Enums.NavigatorCategoryCategory[]
    not?: NestedEnumNavigatorCategoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorCategoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumNavigatorCategoryCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNavigatorCategoryViewModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategoryViewMode | EnumNavigatorCategoryViewModeFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategoryViewMode[]
    notIn?: $Enums.NavigatorCategoryViewMode[]
    not?: NestedEnumNavigatorCategoryViewModeWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorCategoryViewMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel>
    _max?: NestedEnumNavigatorCategoryViewModeFilter<$PrismaModel>
  }

  export type NestedEnumNavigatorCategorySearchAllowanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorCategorySearchAllowance | EnumNavigatorCategorySearchAllowanceFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorCategorySearchAllowance[]
    notIn?: $Enums.NavigatorCategorySearchAllowance[]
    not?: NestedEnumNavigatorCategorySearchAllowanceWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorCategorySearchAllowance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel>
    _max?: NestedEnumNavigatorCategorySearchAllowanceFilter<$PrismaModel>
  }

  export type NestedEnumNavigatorPublicLangueFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorPublicLangue | EnumNavigatorPublicLangueFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorPublicLangue[]
    notIn?: $Enums.NavigatorPublicLangue[]
    not?: NestedEnumNavigatorPublicLangueFilter<$PrismaModel> | $Enums.NavigatorPublicLangue
  }

  export type NestedEnumNavigatorPublicLangueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NavigatorPublicLangue | EnumNavigatorPublicLangueFieldRefInput<$PrismaModel>
    in?: $Enums.NavigatorPublicLangue[]
    notIn?: $Enums.NavigatorPublicLangue[]
    not?: NestedEnumNavigatorPublicLangueWithAggregatesFilter<$PrismaModel> | $Enums.NavigatorPublicLangue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNavigatorPublicLangueFilter<$PrismaModel>
    _max?: NestedEnumNavigatorPublicLangueFilter<$PrismaModel>
  }

  export type NestedEnumRoleplayEnemyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayEnemyType | EnumRoleplayEnemyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayEnemyType[]
    notIn?: $Enums.RoleplayEnemyType[]
    not?: NestedEnumRoleplayEnemyTypeFilter<$PrismaModel> | $Enums.RoleplayEnemyType
  }

  export type NestedEnumRoleplayEnemyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayEnemyType | EnumRoleplayEnemyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayEnemyType[]
    notIn?: $Enums.RoleplayEnemyType[]
    not?: NestedEnumRoleplayEnemyTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayEnemyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayEnemyTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleplayEnemyTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoleplayItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemType | EnumRoleplayItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemType[]
    notIn?: $Enums.RoleplayItemType[]
    not?: NestedEnumRoleplayItemTypeFilter<$PrismaModel> | $Enums.RoleplayItemType
  }

  export type NestedEnumRoleplayItemCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemCategory | EnumRoleplayItemCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemCategory[]
    notIn?: $Enums.RoleplayItemCategory[]
    not?: NestedEnumRoleplayItemCategoryFilter<$PrismaModel> | $Enums.RoleplayItemCategory
  }

  export type NestedEnumRoleplayItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemType | EnumRoleplayItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemType[]
    notIn?: $Enums.RoleplayItemType[]
    not?: NestedEnumRoleplayItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayItemTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleplayItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoleplayItemCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayItemCategory | EnumRoleplayItemCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayItemCategory[]
    notIn?: $Enums.RoleplayItemCategory[]
    not?: NestedEnumRoleplayItemCategoryWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayItemCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayItemCategoryFilter<$PrismaModel>
    _max?: NestedEnumRoleplayItemCategoryFilter<$PrismaModel>
  }

  export type NestedEnumRoleplayWeaponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponType | EnumRoleplayWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponType[]
    notIn?: $Enums.RoleplayWeaponType[]
    not?: NestedEnumRoleplayWeaponTypeFilter<$PrismaModel> | $Enums.RoleplayWeaponType
  }

  export type NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponInteraction | EnumRoleplayWeaponInteractionFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponInteraction[]
    notIn?: $Enums.RoleplayWeaponInteraction[]
    not?: NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel> | $Enums.RoleplayWeaponInteraction
  }

  export type NestedEnumRoleplayWeaponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponType | EnumRoleplayWeaponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponType[]
    notIn?: $Enums.RoleplayWeaponType[]
    not?: NestedEnumRoleplayWeaponTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayWeaponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayWeaponTypeFilter<$PrismaModel>
    _max?: NestedEnumRoleplayWeaponTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoleplayWeaponInteractionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleplayWeaponInteraction | EnumRoleplayWeaponInteractionFieldRefInput<$PrismaModel>
    in?: $Enums.RoleplayWeaponInteraction[]
    notIn?: $Enums.RoleplayWeaponInteraction[]
    not?: NestedEnumRoleplayWeaponInteractionWithAggregatesFilter<$PrismaModel> | $Enums.RoleplayWeaponInteraction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel>
    _max?: NestedEnumRoleplayWeaponInteractionFilter<$PrismaModel>
  }

  export type NestedEnumRoomStateFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomState | EnumRoomStateFieldRefInput<$PrismaModel>
    in?: $Enums.RoomState[]
    notIn?: $Enums.RoomState[]
    not?: NestedEnumRoomStateFilter<$PrismaModel> | $Enums.RoomState
  }

  export type NestedEnumRoomStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomState | EnumRoomStateFieldRefInput<$PrismaModel>
    in?: $Enums.RoomState[]
    notIn?: $Enums.RoomState[]
    not?: NestedEnumRoomStateWithAggregatesFilter<$PrismaModel> | $Enums.RoomState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStateFilter<$PrismaModel>
    _max?: NestedEnumRoomStateFilter<$PrismaModel>
  }

  export type NestedEnumUserGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserGender[]
    notIn?: $Enums.UserGender[]
    not?: NestedEnumUserGenderFilter<$PrismaModel> | $Enums.UserGender
  }

  export type NestedEnumUserLangueFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLangue | EnumUserLangueFieldRefInput<$PrismaModel>
    in?: $Enums.UserLangue[]
    notIn?: $Enums.UserLangue[]
    not?: NestedEnumUserLangueFilter<$PrismaModel> | $Enums.UserLangue
  }

  export type NestedEnumUserGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserGender | EnumUserGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserGender[]
    notIn?: $Enums.UserGender[]
    not?: NestedEnumUserGenderWithAggregatesFilter<$PrismaModel> | $Enums.UserGender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserGenderFilter<$PrismaModel>
    _max?: NestedEnumUserGenderFilter<$PrismaModel>
  }

  export type NestedEnumUserLangueWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLangue | EnumUserLangueFieldRefInput<$PrismaModel>
    in?: $Enums.UserLangue[]
    notIn?: $Enums.UserLangue[]
    not?: NestedEnumUserLangueWithAggregatesFilter<$PrismaModel> | $Enums.UserLangue
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserLangueFilter<$PrismaModel>
    _max?: NestedEnumUserLangueFilter<$PrismaModel>
  }

  export type NestedEnumUserWardrobeGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.UserWardrobeGender | EnumUserWardrobeGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserWardrobeGender[]
    notIn?: $Enums.UserWardrobeGender[]
    not?: NestedEnumUserWardrobeGenderFilter<$PrismaModel> | $Enums.UserWardrobeGender
  }

  export type NestedEnumUserWardrobeGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserWardrobeGender | EnumUserWardrobeGenderFieldRefInput<$PrismaModel>
    in?: $Enums.UserWardrobeGender[]
    notIn?: $Enums.UserWardrobeGender[]
    not?: NestedEnumUserWardrobeGenderWithAggregatesFilter<$PrismaModel> | $Enums.UserWardrobeGender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserWardrobeGenderFilter<$PrismaModel>
    _max?: NestedEnumUserWardrobeGenderFilter<$PrismaModel>
  }

  export type CatalogItemLimitedCreateWithoutCatalogItemInput = {
    limitedSells?: number
    limitedStack?: number
  }

  export type CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput = {
    limitedSells?: number
    limitedStack?: number
  }

  export type CatalogItemLimitedCreateOrConnectWithoutCatalogItemInput = {
    where: CatalogItemLimitedWhereUniqueInput
    create: XOR<CatalogItemLimitedCreateWithoutCatalogItemInput, CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput>
  }

  export type ItemBaseCreateWithoutCatalogItemInput = {
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    itemStat?: ItemStatCreateNestedOneWithoutItemBaseInput
    logLootbox?: LogLootboxCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseUncheckedCreateWithoutCatalogItemInput = {
    id?: number
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    itemStat?: ItemStatUncheckedCreateNestedOneWithoutItemBaseInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseCreateOrConnectWithoutCatalogItemInput = {
    where: ItemBaseWhereUniqueInput
    create: XOR<ItemBaseCreateWithoutCatalogItemInput, ItemBaseUncheckedCreateWithoutCatalogItemInput>
  }

  export type CatalogItemLimitedUpsertWithoutCatalogItemInput = {
    update: XOR<CatalogItemLimitedUpdateWithoutCatalogItemInput, CatalogItemLimitedUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<CatalogItemLimitedCreateWithoutCatalogItemInput, CatalogItemLimitedUncheckedCreateWithoutCatalogItemInput>
    where?: CatalogItemLimitedWhereInput
  }

  export type CatalogItemLimitedUpdateToOneWithWhereWithoutCatalogItemInput = {
    where?: CatalogItemLimitedWhereInput
    data: XOR<CatalogItemLimitedUpdateWithoutCatalogItemInput, CatalogItemLimitedUncheckedUpdateWithoutCatalogItemInput>
  }

  export type CatalogItemLimitedUpdateWithoutCatalogItemInput = {
    limitedSells?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogItemLimitedUncheckedUpdateWithoutCatalogItemInput = {
    limitedSells?: IntFieldUpdateOperationsInput | number
    limitedStack?: IntFieldUpdateOperationsInput | number
  }

  export type ItemBaseUpsertWithoutCatalogItemInput = {
    update: XOR<ItemBaseUpdateWithoutCatalogItemInput, ItemBaseUncheckedUpdateWithoutCatalogItemInput>
    create: XOR<ItemBaseCreateWithoutCatalogItemInput, ItemBaseUncheckedCreateWithoutCatalogItemInput>
    where?: ItemBaseWhereInput
  }

  export type ItemBaseUpdateToOneWithWhereWithoutCatalogItemInput = {
    where?: ItemBaseWhereInput
    data: XOR<ItemBaseUpdateWithoutCatalogItemInput, ItemBaseUncheckedUpdateWithoutCatalogItemInput>
  }

  export type ItemBaseUpdateWithoutCatalogItemInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    itemStat?: ItemStatUpdateOneWithoutItemBaseNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutItemBaseNestedInput
  }

  export type ItemBaseUncheckedUpdateWithoutCatalogItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    itemStat?: ItemStatUncheckedUpdateOneWithoutItemBaseNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutItemBaseNestedInput
  }

  export type CatalogItemCreateWithoutCatalogItemLimitedInput = {
    pageId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
    itemBase: ItemBaseCreateNestedOneWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutCatalogItemLimitedInput = {
    id?: number
    pageId: number
    itemId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
  }

  export type CatalogItemCreateOrConnectWithoutCatalogItemLimitedInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutCatalogItemLimitedInput, CatalogItemUncheckedCreateWithoutCatalogItemLimitedInput>
  }

  export type CatalogItemUpsertWithoutCatalogItemLimitedInput = {
    update: XOR<CatalogItemUpdateWithoutCatalogItemLimitedInput, CatalogItemUncheckedUpdateWithoutCatalogItemLimitedInput>
    create: XOR<CatalogItemCreateWithoutCatalogItemLimitedInput, CatalogItemUncheckedCreateWithoutCatalogItemLimitedInput>
    where?: CatalogItemWhereInput
  }

  export type CatalogItemUpdateToOneWithWhereWithoutCatalogItemLimitedInput = {
    where?: CatalogItemWhereInput
    data: XOR<CatalogItemUpdateWithoutCatalogItemLimitedInput, CatalogItemUncheckedUpdateWithoutCatalogItemLimitedInput>
  }

  export type CatalogItemUpdateWithoutCatalogItemLimitedInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
    itemBase?: ItemBaseUpdateOneRequiredWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutCatalogItemLimitedInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
  }

  export type ItemStatCreateWithoutItemBaseInput = {
    amount?: number
  }

  export type ItemStatUncheckedCreateWithoutItemBaseInput = {
    amount?: number
  }

  export type ItemStatCreateOrConnectWithoutItemBaseInput = {
    where: ItemStatWhereUniqueInput
    create: XOR<ItemStatCreateWithoutItemBaseInput, ItemStatUncheckedCreateWithoutItemBaseInput>
  }

  export type LogLootboxCreateWithoutItemBaseInput = {
    interactionType: string
    itemId: number
    timestamp: number
    user: UserCreateNestedOneWithoutLogLootboxInput
  }

  export type LogLootboxUncheckedCreateWithoutItemBaseInput = {
    id?: number
    interactionType: string
    userId: number
    itemId: number
    timestamp: number
  }

  export type LogLootboxCreateOrConnectWithoutItemBaseInput = {
    where: LogLootboxWhereUniqueInput
    create: XOR<LogLootboxCreateWithoutItemBaseInput, LogLootboxUncheckedCreateWithoutItemBaseInput>
  }

  export type LogLootboxCreateManyItemBaseInputEnvelope = {
    data: LogLootboxCreateManyItemBaseInput | LogLootboxCreateManyItemBaseInput[]
    skipDuplicates?: boolean
  }

  export type CatalogItemCreateWithoutItemBaseInput = {
    pageId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
    catalogItemLimited?: CatalogItemLimitedCreateNestedOneWithoutCatalogItemInput
  }

  export type CatalogItemUncheckedCreateWithoutItemBaseInput = {
    id?: number
    pageId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
    catalogItemLimited?: CatalogItemLimitedUncheckedCreateNestedOneWithoutCatalogItemInput
  }

  export type CatalogItemCreateOrConnectWithoutItemBaseInput = {
    where: CatalogItemWhereUniqueInput
    create: XOR<CatalogItemCreateWithoutItemBaseInput, CatalogItemUncheckedCreateWithoutItemBaseInput>
  }

  export type CatalogItemCreateManyItemBaseInputEnvelope = {
    data: CatalogItemCreateManyItemBaseInput | CatalogItemCreateManyItemBaseInput[]
    skipDuplicates?: boolean
  }

  export type ItemStatUpsertWithoutItemBaseInput = {
    update: XOR<ItemStatUpdateWithoutItemBaseInput, ItemStatUncheckedUpdateWithoutItemBaseInput>
    create: XOR<ItemStatCreateWithoutItemBaseInput, ItemStatUncheckedCreateWithoutItemBaseInput>
    where?: ItemStatWhereInput
  }

  export type ItemStatUpdateToOneWithWhereWithoutItemBaseInput = {
    where?: ItemStatWhereInput
    data: XOR<ItemStatUpdateWithoutItemBaseInput, ItemStatUncheckedUpdateWithoutItemBaseInput>
  }

  export type ItemStatUpdateWithoutItemBaseInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type ItemStatUncheckedUpdateWithoutItemBaseInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type LogLootboxUpsertWithWhereUniqueWithoutItemBaseInput = {
    where: LogLootboxWhereUniqueInput
    update: XOR<LogLootboxUpdateWithoutItemBaseInput, LogLootboxUncheckedUpdateWithoutItemBaseInput>
    create: XOR<LogLootboxCreateWithoutItemBaseInput, LogLootboxUncheckedCreateWithoutItemBaseInput>
  }

  export type LogLootboxUpdateWithWhereUniqueWithoutItemBaseInput = {
    where: LogLootboxWhereUniqueInput
    data: XOR<LogLootboxUpdateWithoutItemBaseInput, LogLootboxUncheckedUpdateWithoutItemBaseInput>
  }

  export type LogLootboxUpdateManyWithWhereWithoutItemBaseInput = {
    where: LogLootboxScalarWhereInput
    data: XOR<LogLootboxUpdateManyMutationInput, LogLootboxUncheckedUpdateManyWithoutItemBaseInput>
  }

  export type LogLootboxScalarWhereInput = {
    AND?: LogLootboxScalarWhereInput | LogLootboxScalarWhereInput[]
    OR?: LogLootboxScalarWhereInput[]
    NOT?: LogLootboxScalarWhereInput | LogLootboxScalarWhereInput[]
    id?: IntFilter<"LogLootbox"> | number
    interactionType?: StringFilter<"LogLootbox"> | string
    userId?: IntFilter<"LogLootbox"> | number
    itemId?: IntFilter<"LogLootbox"> | number
    baseId?: IntFilter<"LogLootbox"> | number
    timestamp?: IntFilter<"LogLootbox"> | number
  }

  export type CatalogItemUpsertWithWhereUniqueWithoutItemBaseInput = {
    where: CatalogItemWhereUniqueInput
    update: XOR<CatalogItemUpdateWithoutItemBaseInput, CatalogItemUncheckedUpdateWithoutItemBaseInput>
    create: XOR<CatalogItemCreateWithoutItemBaseInput, CatalogItemUncheckedCreateWithoutItemBaseInput>
  }

  export type CatalogItemUpdateWithWhereUniqueWithoutItemBaseInput = {
    where: CatalogItemWhereUniqueInput
    data: XOR<CatalogItemUpdateWithoutItemBaseInput, CatalogItemUncheckedUpdateWithoutItemBaseInput>
  }

  export type CatalogItemUpdateManyWithWhereWithoutItemBaseInput = {
    where: CatalogItemScalarWhereInput
    data: XOR<CatalogItemUpdateManyMutationInput, CatalogItemUncheckedUpdateManyWithoutItemBaseInput>
  }

  export type CatalogItemScalarWhereInput = {
    AND?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
    OR?: CatalogItemScalarWhereInput[]
    NOT?: CatalogItemScalarWhereInput | CatalogItemScalarWhereInput[]
    id?: IntFilter<"CatalogItem"> | number
    pageId?: IntFilter<"CatalogItem"> | number
    itemId?: IntFilter<"CatalogItem"> | number
    catalogName?: StringFilter<"CatalogItem"> | string
    costCredits?: IntFilter<"CatalogItem"> | number
    costPixels?: IntFilter<"CatalogItem"> | number
    costDiamonds?: IntFilter<"CatalogItem"> | number
    costLimitcoins?: IntFilter<"CatalogItem"> | number
    amount?: IntFilter<"CatalogItem"> | number
    offerActive?: BoolFilter<"CatalogItem"> | boolean
    badge?: StringFilter<"CatalogItem"> | string
  }

  export type ItemBaseCreateWithoutItemStatInput = {
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    logLootbox?: LogLootboxCreateNestedManyWithoutItemBaseInput
    catalogItem?: CatalogItemCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseUncheckedCreateWithoutItemStatInput = {
    id?: number
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutItemBaseInput
    catalogItem?: CatalogItemUncheckedCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseCreateOrConnectWithoutItemStatInput = {
    where: ItemBaseWhereUniqueInput
    create: XOR<ItemBaseCreateWithoutItemStatInput, ItemBaseUncheckedCreateWithoutItemStatInput>
  }

  export type ItemBaseUpsertWithoutItemStatInput = {
    update: XOR<ItemBaseUpdateWithoutItemStatInput, ItemBaseUncheckedUpdateWithoutItemStatInput>
    create: XOR<ItemBaseCreateWithoutItemStatInput, ItemBaseUncheckedCreateWithoutItemStatInput>
    where?: ItemBaseWhereInput
  }

  export type ItemBaseUpdateToOneWithWhereWithoutItemStatInput = {
    where?: ItemBaseWhereInput
    data: XOR<ItemBaseUpdateWithoutItemStatInput, ItemBaseUncheckedUpdateWithoutItemStatInput>
  }

  export type ItemBaseUpdateWithoutItemStatInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    logLootbox?: LogLootboxUpdateManyWithoutItemBaseNestedInput
    catalogItem?: CatalogItemUpdateManyWithoutItemBaseNestedInput
  }

  export type ItemBaseUncheckedUpdateWithoutItemStatInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutItemBaseNestedInput
    catalogItem?: CatalogItemUncheckedUpdateManyWithoutItemBaseNestedInput
  }

  export type UserCreateWithoutLogChatInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutLogChatInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutLogChatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogChatInput, UserUncheckedCreateWithoutLogChatInput>
  }

  export type RoomCreateWithoutLogChatInput = {
    caption?: string
    owner: string
    description?: string | null
    category?: number
    state?: $Enums.RoomState
    usersMax?: number
    modelName: string
    score?: number
    tags?: string | null
    password?: string | null
    wallpaper?: string
    floor?: string
    landscape?: string
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: number
    floorthick?: number
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: number
    moderationBanFuse?: boolean
    groupId?: number
    chatType?: number
    chatBalloon?: number
    chatSpeed?: number
    chatMaxDistance?: number
    chatFloodProtection?: number
    trocStatus?: number
    usersNow?: number
    allowHidewireds?: boolean
    price?: number
    wiredSecurity?: boolean
  }

  export type RoomUncheckedCreateWithoutLogChatInput = {
    id?: number
    caption?: string
    owner: string
    description?: string | null
    category?: number
    state?: $Enums.RoomState
    usersMax?: number
    modelName: string
    score?: number
    tags?: string | null
    password?: string | null
    wallpaper?: string
    floor?: string
    landscape?: string
    allowPets?: boolean
    allowPetsEat?: boolean
    allowWalkthrough?: boolean
    allowHidewall?: boolean
    wallthick?: number
    floorthick?: number
    moderationMuteFuse?: boolean
    allowRightsoverride?: boolean
    moderationKickFuse?: number
    moderationBanFuse?: boolean
    groupId?: number
    chatType?: number
    chatBalloon?: number
    chatSpeed?: number
    chatMaxDistance?: number
    chatFloodProtection?: number
    trocStatus?: number
    usersNow?: number
    allowHidewireds?: boolean
    price?: number
    wiredSecurity?: boolean
  }

  export type RoomCreateOrConnectWithoutLogChatInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutLogChatInput, RoomUncheckedCreateWithoutLogChatInput>
  }

  export type UserUpsertWithoutLogChatInput = {
    update: XOR<UserUpdateWithoutLogChatInput, UserUncheckedUpdateWithoutLogChatInput>
    create: XOR<UserCreateWithoutLogChatInput, UserUncheckedCreateWithoutLogChatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogChatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogChatInput, UserUncheckedUpdateWithoutLogChatInput>
  }

  export type UserUpdateWithoutLogChatInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutLogChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type RoomUpsertWithoutLogChatInput = {
    update: XOR<RoomUpdateWithoutLogChatInput, RoomUncheckedUpdateWithoutLogChatInput>
    create: XOR<RoomCreateWithoutLogChatInput, RoomUncheckedCreateWithoutLogChatInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutLogChatInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutLogChatInput, RoomUncheckedUpdateWithoutLogChatInput>
  }

  export type RoomUpdateWithoutLogChatInput = {
    caption?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    state?: EnumRoomStateFieldUpdateOperationsInput | $Enums.RoomState
    usersMax?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wallpaper?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    landscape?: StringFieldUpdateOperationsInput | string
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    allowPetsEat?: BoolFieldUpdateOperationsInput | boolean
    allowWalkthrough?: BoolFieldUpdateOperationsInput | boolean
    allowHidewall?: BoolFieldUpdateOperationsInput | boolean
    wallthick?: IntFieldUpdateOperationsInput | number
    floorthick?: IntFieldUpdateOperationsInput | number
    moderationMuteFuse?: BoolFieldUpdateOperationsInput | boolean
    allowRightsoverride?: BoolFieldUpdateOperationsInput | boolean
    moderationKickFuse?: IntFieldUpdateOperationsInput | number
    moderationBanFuse?: BoolFieldUpdateOperationsInput | boolean
    groupId?: IntFieldUpdateOperationsInput | number
    chatType?: IntFieldUpdateOperationsInput | number
    chatBalloon?: IntFieldUpdateOperationsInput | number
    chatSpeed?: IntFieldUpdateOperationsInput | number
    chatMaxDistance?: IntFieldUpdateOperationsInput | number
    chatFloodProtection?: IntFieldUpdateOperationsInput | number
    trocStatus?: IntFieldUpdateOperationsInput | number
    usersNow?: IntFieldUpdateOperationsInput | number
    allowHidewireds?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    wiredSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomUncheckedUpdateWithoutLogChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    caption?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: IntFieldUpdateOperationsInput | number
    state?: EnumRoomStateFieldUpdateOperationsInput | $Enums.RoomState
    usersMax?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    wallpaper?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    landscape?: StringFieldUpdateOperationsInput | string
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    allowPetsEat?: BoolFieldUpdateOperationsInput | boolean
    allowWalkthrough?: BoolFieldUpdateOperationsInput | boolean
    allowHidewall?: BoolFieldUpdateOperationsInput | boolean
    wallthick?: IntFieldUpdateOperationsInput | number
    floorthick?: IntFieldUpdateOperationsInput | number
    moderationMuteFuse?: BoolFieldUpdateOperationsInput | boolean
    allowRightsoverride?: BoolFieldUpdateOperationsInput | boolean
    moderationKickFuse?: IntFieldUpdateOperationsInput | number
    moderationBanFuse?: BoolFieldUpdateOperationsInput | boolean
    groupId?: IntFieldUpdateOperationsInput | number
    chatType?: IntFieldUpdateOperationsInput | number
    chatBalloon?: IntFieldUpdateOperationsInput | number
    chatSpeed?: IntFieldUpdateOperationsInput | number
    chatMaxDistance?: IntFieldUpdateOperationsInput | number
    chatFloodProtection?: IntFieldUpdateOperationsInput | number
    trocStatus?: IntFieldUpdateOperationsInput | number
    usersNow?: IntFieldUpdateOperationsInput | number
    allowHidewireds?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    wiredSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutLogLoginInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutLogLoginInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutLogLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogLoginInput, UserUncheckedCreateWithoutLogLoginInput>
  }

  export type UserUpsertWithoutLogLoginInput = {
    update: XOR<UserUpdateWithoutLogLoginInput, UserUncheckedUpdateWithoutLogLoginInput>
    create: XOR<UserCreateWithoutLogLoginInput, UserUncheckedCreateWithoutLogLoginInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogLoginInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogLoginInput, UserUncheckedUpdateWithoutLogLoginInput>
  }

  export type UserUpdateWithoutLogLoginInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutLogLoginInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserCreateWithoutLogLootboxInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutLogLootboxInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutLogLootboxInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogLootboxInput, UserUncheckedCreateWithoutLogLootboxInput>
  }

  export type ItemBaseCreateWithoutLogLootboxInput = {
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    itemStat?: ItemStatCreateNestedOneWithoutItemBaseInput
    catalogItem?: CatalogItemCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseUncheckedCreateWithoutLogLootboxInput = {
    id?: number
    itemName: string
    type?: $Enums.ItemBaseType
    width?: number
    length?: number
    stackHeight?: number
    canStack?: boolean
    canSit?: boolean
    isWalkable?: boolean
    spriteId: number
    allowRecycle?: boolean
    allowTrade?: boolean
    allowMarketplaceSell?: boolean
    allowGift?: boolean
    allowInventoryStack?: boolean
    interactionType?: string
    interactionModesCount?: number
    vendingIds?: string
    heightAdjustable?: string
    effectId?: number
    isRare?: boolean
    rarityLevel?: number
    itemStat?: ItemStatUncheckedCreateNestedOneWithoutItemBaseInput
    catalogItem?: CatalogItemUncheckedCreateNestedManyWithoutItemBaseInput
  }

  export type ItemBaseCreateOrConnectWithoutLogLootboxInput = {
    where: ItemBaseWhereUniqueInput
    create: XOR<ItemBaseCreateWithoutLogLootboxInput, ItemBaseUncheckedCreateWithoutLogLootboxInput>
  }

  export type UserUpsertWithoutLogLootboxInput = {
    update: XOR<UserUpdateWithoutLogLootboxInput, UserUncheckedUpdateWithoutLogLootboxInput>
    create: XOR<UserCreateWithoutLogLootboxInput, UserUncheckedCreateWithoutLogLootboxInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogLootboxInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogLootboxInput, UserUncheckedUpdateWithoutLogLootboxInput>
  }

  export type UserUpdateWithoutLogLootboxInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutLogLootboxInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type ItemBaseUpsertWithoutLogLootboxInput = {
    update: XOR<ItemBaseUpdateWithoutLogLootboxInput, ItemBaseUncheckedUpdateWithoutLogLootboxInput>
    create: XOR<ItemBaseCreateWithoutLogLootboxInput, ItemBaseUncheckedCreateWithoutLogLootboxInput>
    where?: ItemBaseWhereInput
  }

  export type ItemBaseUpdateToOneWithWhereWithoutLogLootboxInput = {
    where?: ItemBaseWhereInput
    data: XOR<ItemBaseUpdateWithoutLogLootboxInput, ItemBaseUncheckedUpdateWithoutLogLootboxInput>
  }

  export type ItemBaseUpdateWithoutLogLootboxInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    itemStat?: ItemStatUpdateOneWithoutItemBaseNestedInput
    catalogItem?: CatalogItemUpdateManyWithoutItemBaseNestedInput
  }

  export type ItemBaseUncheckedUpdateWithoutLogLootboxInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    type?: EnumItemBaseTypeFieldUpdateOperationsInput | $Enums.ItemBaseType
    width?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    stackHeight?: FloatFieldUpdateOperationsInput | number
    canStack?: BoolFieldUpdateOperationsInput | boolean
    canSit?: BoolFieldUpdateOperationsInput | boolean
    isWalkable?: BoolFieldUpdateOperationsInput | boolean
    spriteId?: IntFieldUpdateOperationsInput | number
    allowRecycle?: BoolFieldUpdateOperationsInput | boolean
    allowTrade?: BoolFieldUpdateOperationsInput | boolean
    allowMarketplaceSell?: BoolFieldUpdateOperationsInput | boolean
    allowGift?: BoolFieldUpdateOperationsInput | boolean
    allowInventoryStack?: BoolFieldUpdateOperationsInput | boolean
    interactionType?: StringFieldUpdateOperationsInput | string
    interactionModesCount?: IntFieldUpdateOperationsInput | number
    vendingIds?: StringFieldUpdateOperationsInput | string
    heightAdjustable?: StringFieldUpdateOperationsInput | string
    effectId?: IntFieldUpdateOperationsInput | number
    isRare?: BoolFieldUpdateOperationsInput | boolean
    rarityLevel?: IntFieldUpdateOperationsInput | number
    itemStat?: ItemStatUncheckedUpdateOneWithoutItemBaseNestedInput
    catalogItem?: CatalogItemUncheckedUpdateManyWithoutItemBaseNestedInput
  }

  export type UserCreateWithoutLogShopInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutLogShopInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutLogShopInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogShopInput, UserUncheckedCreateWithoutLogShopInput>
  }

  export type UserUpsertWithoutLogShopInput = {
    update: XOR<UserUpdateWithoutLogShopInput, UserUncheckedUpdateWithoutLogShopInput>
    create: XOR<UserCreateWithoutLogShopInput, UserUncheckedCreateWithoutLogShopInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogShopInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogShopInput, UserUncheckedUpdateWithoutLogShopInput>
  }

  export type UserUpdateWithoutLogShopInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutLogShopInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserCreateWithoutLogSlotmachineInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutLogSlotmachineInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutLogSlotmachineInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogSlotmachineInput, UserUncheckedCreateWithoutLogSlotmachineInput>
  }

  export type UserUpsertWithoutLogSlotmachineInput = {
    update: XOR<UserUpdateWithoutLogSlotmachineInput, UserUncheckedUpdateWithoutLogSlotmachineInput>
    create: XOR<UserCreateWithoutLogSlotmachineInput, UserUncheckedCreateWithoutLogSlotmachineInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogSlotmachineInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogSlotmachineInput, UserUncheckedUpdateWithoutLogSlotmachineInput>
  }

  export type UserUpdateWithoutLogSlotmachineInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutLogSlotmachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserCreateWithoutUserOneTradeInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutUserOneTradeInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutUserOneTradeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserOneTradeInput, UserUncheckedCreateWithoutUserOneTradeInput>
  }

  export type UserCreateWithoutUserTwoTradeInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
  }

  export type UserUncheckedCreateWithoutUserTwoTradeInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    logSandbox?: LogSandboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
  }

  export type UserCreateOrConnectWithoutUserTwoTradeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTwoTradeInput, UserUncheckedCreateWithoutUserTwoTradeInput>
  }

  export type UserUpsertWithoutUserOneTradeInput = {
    update: XOR<UserUpdateWithoutUserOneTradeInput, UserUncheckedUpdateWithoutUserOneTradeInput>
    create: XOR<UserCreateWithoutUserOneTradeInput, UserUncheckedCreateWithoutUserOneTradeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserOneTradeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserOneTradeInput, UserUncheckedUpdateWithoutUserOneTradeInput>
  }

  export type UserUpdateWithoutUserOneTradeInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutUserOneTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUpsertWithoutUserTwoTradeInput = {
    update: XOR<UserUpdateWithoutUserTwoTradeInput, UserUncheckedUpdateWithoutUserTwoTradeInput>
    create: XOR<UserCreateWithoutUserTwoTradeInput, UserUncheckedCreateWithoutUserTwoTradeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserTwoTradeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserTwoTradeInput, UserUncheckedUpdateWithoutUserTwoTradeInput>
  }

  export type UserUpdateWithoutUserTwoTradeInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutUserTwoTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    logSandbox?: LogSandboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
  }

  export type UserCreateWithoutLogSandboxInput = {
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginCreateNestedManyWithoutUserInput
    logChat?: LogChatCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineCreateNestedManyWithoutUserInput
    logShop?: LogShopCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserUncheckedCreateWithoutLogSandboxInput = {
    id?: number
    username: string
    password: string
    mail?: string | null
    authTicket?: string | null
    rank?: number
    credits?: number
    activityPoints?: number
    look?: string
    gender?: $Enums.UserGender
    motto?: string | null
    accountCreated?: number
    lastOnline?: number
    online?: boolean
    ipLast?: string | null
    machineId?: string | null
    homeRoom?: number
    blockNewfriends?: boolean
    hideOnline?: boolean
    hideInroom?: boolean
    lastOffline?: number
    moisVip?: number
    volume?: string
    vipPoints?: number
    limitCoins?: number
    acceptTrading?: boolean
    cameraFollowDisabled?: boolean
    ignoreRoomInvite?: boolean
    lastdailycredits?: string
    hideGamealert?: boolean
    ipcountry?: string | null
    gamePoints?: number
    gamePointsMonth?: number
    mazoscore?: number
    mazo?: number
    nuxEnable?: boolean
    langue?: $Enums.UserLangue
    runPoints?: number
    runPointsMonth?: number
    isBanned?: boolean
    bannerId?: number
    logLogin?: LogLoginUncheckedCreateNestedManyWithoutUserInput
    logChat?: LogChatUncheckedCreateNestedManyWithoutUserInput
    logSlotmachine?: LogSlotmachineUncheckedCreateNestedManyWithoutUserInput
    logShop?: LogShopUncheckedCreateNestedManyWithoutUserInput
    logLootbox?: LogLootboxUncheckedCreateNestedManyWithoutUserInput
    userOneTrade?: LogTradeUncheckedCreateNestedManyWithoutUserOneTradeInput
    userTwoTrade?: LogTradeUncheckedCreateNestedManyWithoutUserTwoTradeInput
  }

  export type UserCreateOrConnectWithoutLogSandboxInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogSandboxInput, UserUncheckedCreateWithoutLogSandboxInput>
  }

  export type UserUpsertWithoutLogSandboxInput = {
    update: XOR<UserUpdateWithoutLogSandboxInput, UserUncheckedUpdateWithoutLogSandboxInput>
    create: XOR<UserCreateWithoutLogSandboxInput, UserUncheckedCreateWithoutLogSandboxInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogSandboxInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogSandboxInput, UserUncheckedUpdateWithoutLogSandboxInput>
  }

  export type UserUpdateWithoutLogSandboxInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUpdateManyWithoutUserNestedInput
    logChat?: LogChatUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUpdateManyWithoutUserNestedInput
    logShop?: LogShopUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type UserUncheckedUpdateWithoutLogSandboxInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    authTicket?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    activityPoints?: IntFieldUpdateOperationsInput | number
    look?: StringFieldUpdateOperationsInput | string
    gender?: EnumUserGenderFieldUpdateOperationsInput | $Enums.UserGender
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    accountCreated?: IntFieldUpdateOperationsInput | number
    lastOnline?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    ipLast?: NullableStringFieldUpdateOperationsInput | string | null
    machineId?: NullableStringFieldUpdateOperationsInput | string | null
    homeRoom?: IntFieldUpdateOperationsInput | number
    blockNewfriends?: BoolFieldUpdateOperationsInput | boolean
    hideOnline?: BoolFieldUpdateOperationsInput | boolean
    hideInroom?: BoolFieldUpdateOperationsInput | boolean
    lastOffline?: IntFieldUpdateOperationsInput | number
    moisVip?: IntFieldUpdateOperationsInput | number
    volume?: StringFieldUpdateOperationsInput | string
    vipPoints?: IntFieldUpdateOperationsInput | number
    limitCoins?: IntFieldUpdateOperationsInput | number
    acceptTrading?: BoolFieldUpdateOperationsInput | boolean
    cameraFollowDisabled?: BoolFieldUpdateOperationsInput | boolean
    ignoreRoomInvite?: BoolFieldUpdateOperationsInput | boolean
    lastdailycredits?: StringFieldUpdateOperationsInput | string
    hideGamealert?: BoolFieldUpdateOperationsInput | boolean
    ipcountry?: NullableStringFieldUpdateOperationsInput | string | null
    gamePoints?: IntFieldUpdateOperationsInput | number
    gamePointsMonth?: IntFieldUpdateOperationsInput | number
    mazoscore?: IntFieldUpdateOperationsInput | number
    mazo?: IntFieldUpdateOperationsInput | number
    nuxEnable?: BoolFieldUpdateOperationsInput | boolean
    langue?: EnumUserLangueFieldUpdateOperationsInput | $Enums.UserLangue
    runPoints?: IntFieldUpdateOperationsInput | number
    runPointsMonth?: IntFieldUpdateOperationsInput | number
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannerId?: IntFieldUpdateOperationsInput | number
    logLogin?: LogLoginUncheckedUpdateManyWithoutUserNestedInput
    logChat?: LogChatUncheckedUpdateManyWithoutUserNestedInput
    logSlotmachine?: LogSlotmachineUncheckedUpdateManyWithoutUserNestedInput
    logShop?: LogShopUncheckedUpdateManyWithoutUserNestedInput
    logLootbox?: LogLootboxUncheckedUpdateManyWithoutUserNestedInput
    userOneTrade?: LogTradeUncheckedUpdateManyWithoutUserOneTradeNestedInput
    userTwoTrade?: LogTradeUncheckedUpdateManyWithoutUserTwoTradeNestedInput
  }

  export type LogChatCreateWithoutRoomInput = {
    userName: string
    timestamp?: number
    message: string
    type: string
    user: UserCreateNestedOneWithoutLogChatInput
  }

  export type LogChatUncheckedCreateWithoutRoomInput = {
    id?: number
    userId: number
    userName: string
    timestamp?: number
    message: string
    type: string
  }

  export type LogChatCreateOrConnectWithoutRoomInput = {
    where: LogChatWhereUniqueInput
    create: XOR<LogChatCreateWithoutRoomInput, LogChatUncheckedCreateWithoutRoomInput>
  }

  export type LogChatCreateManyRoomInputEnvelope = {
    data: LogChatCreateManyRoomInput | LogChatCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type LogChatUpsertWithWhereUniqueWithoutRoomInput = {
    where: LogChatWhereUniqueInput
    update: XOR<LogChatUpdateWithoutRoomInput, LogChatUncheckedUpdateWithoutRoomInput>
    create: XOR<LogChatCreateWithoutRoomInput, LogChatUncheckedCreateWithoutRoomInput>
  }

  export type LogChatUpdateWithWhereUniqueWithoutRoomInput = {
    where: LogChatWhereUniqueInput
    data: XOR<LogChatUpdateWithoutRoomInput, LogChatUncheckedUpdateWithoutRoomInput>
  }

  export type LogChatUpdateManyWithWhereWithoutRoomInput = {
    where: LogChatScalarWhereInput
    data: XOR<LogChatUpdateManyMutationInput, LogChatUncheckedUpdateManyWithoutRoomInput>
  }

  export type LogChatScalarWhereInput = {
    AND?: LogChatScalarWhereInput | LogChatScalarWhereInput[]
    OR?: LogChatScalarWhereInput[]
    NOT?: LogChatScalarWhereInput | LogChatScalarWhereInput[]
    id?: IntFilter<"LogChat"> | number
    userId?: IntFilter<"LogChat"> | number
    roomId?: IntNullableFilter<"LogChat"> | number | null
    userName?: StringFilter<"LogChat"> | string
    timestamp?: IntFilter<"LogChat"> | number
    message?: StringFilter<"LogChat"> | string
    type?: StringFilter<"LogChat"> | string
  }

  export type LogLoginCreateWithoutUserInput = {
    date?: number
    ip: string
    userAgent: string
  }

  export type LogLoginUncheckedCreateWithoutUserInput = {
    id?: number
    date?: number
    ip: string
    userAgent: string
  }

  export type LogLoginCreateOrConnectWithoutUserInput = {
    where: LogLoginWhereUniqueInput
    create: XOR<LogLoginCreateWithoutUserInput, LogLoginUncheckedCreateWithoutUserInput>
  }

  export type LogLoginCreateManyUserInputEnvelope = {
    data: LogLoginCreateManyUserInput | LogLoginCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogChatCreateWithoutUserInput = {
    userName: string
    timestamp?: number
    message: string
    type: string
    room?: RoomCreateNestedOneWithoutLogChatInput
  }

  export type LogChatUncheckedCreateWithoutUserInput = {
    id?: number
    roomId?: number | null
    userName: string
    timestamp?: number
    message: string
    type: string
  }

  export type LogChatCreateOrConnectWithoutUserInput = {
    where: LogChatWhereUniqueInput
    create: XOR<LogChatCreateWithoutUserInput, LogChatUncheckedCreateWithoutUserInput>
  }

  export type LogChatCreateManyUserInputEnvelope = {
    data: LogChatCreateManyUserInput | LogChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogSlotmachineCreateWithoutUserInput = {
    amount: number
    isWin: boolean
    date: number
  }

  export type LogSlotmachineUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    isWin: boolean
    date: number
  }

  export type LogSlotmachineCreateOrConnectWithoutUserInput = {
    where: LogSlotmachineWhereUniqueInput
    create: XOR<LogSlotmachineCreateWithoutUserInput, LogSlotmachineUncheckedCreateWithoutUserInput>
  }

  export type LogSlotmachineCreateManyUserInputEnvelope = {
    data: LogSlotmachineCreateManyUserInput | LogSlotmachineCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogShopCreateWithoutUserInput = {
    date: number
    price: number
    content: string
    type: number
    catalogItemId?: number
  }

  export type LogShopUncheckedCreateWithoutUserInput = {
    id?: number
    date: number
    price: number
    content: string
    type: number
    catalogItemId?: number
  }

  export type LogShopCreateOrConnectWithoutUserInput = {
    where: LogShopWhereUniqueInput
    create: XOR<LogShopCreateWithoutUserInput, LogShopUncheckedCreateWithoutUserInput>
  }

  export type LogShopCreateManyUserInputEnvelope = {
    data: LogShopCreateManyUserInput | LogShopCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogLootboxCreateWithoutUserInput = {
    interactionType: string
    itemId: number
    timestamp: number
    itemBase: ItemBaseCreateNestedOneWithoutLogLootboxInput
  }

  export type LogLootboxUncheckedCreateWithoutUserInput = {
    id?: number
    interactionType: string
    itemId: number
    baseId: number
    timestamp: number
  }

  export type LogLootboxCreateOrConnectWithoutUserInput = {
    where: LogLootboxWhereUniqueInput
    create: XOR<LogLootboxCreateWithoutUserInput, LogLootboxUncheckedCreateWithoutUserInput>
  }

  export type LogLootboxCreateManyUserInputEnvelope = {
    data: LogLootboxCreateManyUserInput | LogLootboxCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogSandboxCreateWithoutUserInput = {
    method: string
    editName: string
    editKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogSandboxUncheckedCreateWithoutUserInput = {
    id?: number
    method: string
    editName: string
    editKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogSandboxCreateOrConnectWithoutUserInput = {
    where: LogSandboxWhereUniqueInput
    create: XOR<LogSandboxCreateWithoutUserInput, LogSandboxUncheckedCreateWithoutUserInput>
  }

  export type LogSandboxCreateManyUserInputEnvelope = {
    data: LogSandboxCreateManyUserInput | LogSandboxCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogTradeCreateWithoutUserOneTradeInput = {
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
    userTwoTrade: UserCreateNestedOneWithoutUserTwoTradeInput
  }

  export type LogTradeUncheckedCreateWithoutUserOneTradeInput = {
    id?: number
    userTwoId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
  }

  export type LogTradeCreateOrConnectWithoutUserOneTradeInput = {
    where: LogTradeWhereUniqueInput
    create: XOR<LogTradeCreateWithoutUserOneTradeInput, LogTradeUncheckedCreateWithoutUserOneTradeInput>
  }

  export type LogTradeCreateManyUserOneTradeInputEnvelope = {
    data: LogTradeCreateManyUserOneTradeInput | LogTradeCreateManyUserOneTradeInput[]
    skipDuplicates?: boolean
  }

  export type LogTradeCreateWithoutUserTwoTradeInput = {
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
    userOneTrade: UserCreateNestedOneWithoutUserOneTradeInput
  }

  export type LogTradeUncheckedCreateWithoutUserTwoTradeInput = {
    id?: number
    userOneId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
  }

  export type LogTradeCreateOrConnectWithoutUserTwoTradeInput = {
    where: LogTradeWhereUniqueInput
    create: XOR<LogTradeCreateWithoutUserTwoTradeInput, LogTradeUncheckedCreateWithoutUserTwoTradeInput>
  }

  export type LogTradeCreateManyUserTwoTradeInputEnvelope = {
    data: LogTradeCreateManyUserTwoTradeInput | LogTradeCreateManyUserTwoTradeInput[]
    skipDuplicates?: boolean
  }

  export type LogLoginUpsertWithWhereUniqueWithoutUserInput = {
    where: LogLoginWhereUniqueInput
    update: XOR<LogLoginUpdateWithoutUserInput, LogLoginUncheckedUpdateWithoutUserInput>
    create: XOR<LogLoginCreateWithoutUserInput, LogLoginUncheckedCreateWithoutUserInput>
  }

  export type LogLoginUpdateWithWhereUniqueWithoutUserInput = {
    where: LogLoginWhereUniqueInput
    data: XOR<LogLoginUpdateWithoutUserInput, LogLoginUncheckedUpdateWithoutUserInput>
  }

  export type LogLoginUpdateManyWithWhereWithoutUserInput = {
    where: LogLoginScalarWhereInput
    data: XOR<LogLoginUpdateManyMutationInput, LogLoginUncheckedUpdateManyWithoutUserInput>
  }

  export type LogLoginScalarWhereInput = {
    AND?: LogLoginScalarWhereInput | LogLoginScalarWhereInput[]
    OR?: LogLoginScalarWhereInput[]
    NOT?: LogLoginScalarWhereInput | LogLoginScalarWhereInput[]
    id?: IntFilter<"LogLogin"> | number
    userId?: IntFilter<"LogLogin"> | number
    date?: IntFilter<"LogLogin"> | number
    ip?: StringFilter<"LogLogin"> | string
    userAgent?: StringFilter<"LogLogin"> | string
  }

  export type LogChatUpsertWithWhereUniqueWithoutUserInput = {
    where: LogChatWhereUniqueInput
    update: XOR<LogChatUpdateWithoutUserInput, LogChatUncheckedUpdateWithoutUserInput>
    create: XOR<LogChatCreateWithoutUserInput, LogChatUncheckedCreateWithoutUserInput>
  }

  export type LogChatUpdateWithWhereUniqueWithoutUserInput = {
    where: LogChatWhereUniqueInput
    data: XOR<LogChatUpdateWithoutUserInput, LogChatUncheckedUpdateWithoutUserInput>
  }

  export type LogChatUpdateManyWithWhereWithoutUserInput = {
    where: LogChatScalarWhereInput
    data: XOR<LogChatUpdateManyMutationInput, LogChatUncheckedUpdateManyWithoutUserInput>
  }

  export type LogSlotmachineUpsertWithWhereUniqueWithoutUserInput = {
    where: LogSlotmachineWhereUniqueInput
    update: XOR<LogSlotmachineUpdateWithoutUserInput, LogSlotmachineUncheckedUpdateWithoutUserInput>
    create: XOR<LogSlotmachineCreateWithoutUserInput, LogSlotmachineUncheckedCreateWithoutUserInput>
  }

  export type LogSlotmachineUpdateWithWhereUniqueWithoutUserInput = {
    where: LogSlotmachineWhereUniqueInput
    data: XOR<LogSlotmachineUpdateWithoutUserInput, LogSlotmachineUncheckedUpdateWithoutUserInput>
  }

  export type LogSlotmachineUpdateManyWithWhereWithoutUserInput = {
    where: LogSlotmachineScalarWhereInput
    data: XOR<LogSlotmachineUpdateManyMutationInput, LogSlotmachineUncheckedUpdateManyWithoutUserInput>
  }

  export type LogSlotmachineScalarWhereInput = {
    AND?: LogSlotmachineScalarWhereInput | LogSlotmachineScalarWhereInput[]
    OR?: LogSlotmachineScalarWhereInput[]
    NOT?: LogSlotmachineScalarWhereInput | LogSlotmachineScalarWhereInput[]
    id?: IntFilter<"LogSlotmachine"> | number
    userId?: IntFilter<"LogSlotmachine"> | number
    amount?: IntFilter<"LogSlotmachine"> | number
    isWin?: BoolFilter<"LogSlotmachine"> | boolean
    date?: IntFilter<"LogSlotmachine"> | number
  }

  export type LogShopUpsertWithWhereUniqueWithoutUserInput = {
    where: LogShopWhereUniqueInput
    update: XOR<LogShopUpdateWithoutUserInput, LogShopUncheckedUpdateWithoutUserInput>
    create: XOR<LogShopCreateWithoutUserInput, LogShopUncheckedCreateWithoutUserInput>
  }

  export type LogShopUpdateWithWhereUniqueWithoutUserInput = {
    where: LogShopWhereUniqueInput
    data: XOR<LogShopUpdateWithoutUserInput, LogShopUncheckedUpdateWithoutUserInput>
  }

  export type LogShopUpdateManyWithWhereWithoutUserInput = {
    where: LogShopScalarWhereInput
    data: XOR<LogShopUpdateManyMutationInput, LogShopUncheckedUpdateManyWithoutUserInput>
  }

  export type LogShopScalarWhereInput = {
    AND?: LogShopScalarWhereInput | LogShopScalarWhereInput[]
    OR?: LogShopScalarWhereInput[]
    NOT?: LogShopScalarWhereInput | LogShopScalarWhereInput[]
    id?: IntFilter<"LogShop"> | number
    userId?: IntFilter<"LogShop"> | number
    date?: IntFilter<"LogShop"> | number
    price?: IntFilter<"LogShop"> | number
    content?: StringFilter<"LogShop"> | string
    type?: IntFilter<"LogShop"> | number
    catalogItemId?: IntFilter<"LogShop"> | number
  }

  export type LogLootboxUpsertWithWhereUniqueWithoutUserInput = {
    where: LogLootboxWhereUniqueInput
    update: XOR<LogLootboxUpdateWithoutUserInput, LogLootboxUncheckedUpdateWithoutUserInput>
    create: XOR<LogLootboxCreateWithoutUserInput, LogLootboxUncheckedCreateWithoutUserInput>
  }

  export type LogLootboxUpdateWithWhereUniqueWithoutUserInput = {
    where: LogLootboxWhereUniqueInput
    data: XOR<LogLootboxUpdateWithoutUserInput, LogLootboxUncheckedUpdateWithoutUserInput>
  }

  export type LogLootboxUpdateManyWithWhereWithoutUserInput = {
    where: LogLootboxScalarWhereInput
    data: XOR<LogLootboxUpdateManyMutationInput, LogLootboxUncheckedUpdateManyWithoutUserInput>
  }

  export type LogSandboxUpsertWithWhereUniqueWithoutUserInput = {
    where: LogSandboxWhereUniqueInput
    update: XOR<LogSandboxUpdateWithoutUserInput, LogSandboxUncheckedUpdateWithoutUserInput>
    create: XOR<LogSandboxCreateWithoutUserInput, LogSandboxUncheckedCreateWithoutUserInput>
  }

  export type LogSandboxUpdateWithWhereUniqueWithoutUserInput = {
    where: LogSandboxWhereUniqueInput
    data: XOR<LogSandboxUpdateWithoutUserInput, LogSandboxUncheckedUpdateWithoutUserInput>
  }

  export type LogSandboxUpdateManyWithWhereWithoutUserInput = {
    where: LogSandboxScalarWhereInput
    data: XOR<LogSandboxUpdateManyMutationInput, LogSandboxUncheckedUpdateManyWithoutUserInput>
  }

  export type LogSandboxScalarWhereInput = {
    AND?: LogSandboxScalarWhereInput | LogSandboxScalarWhereInput[]
    OR?: LogSandboxScalarWhereInput[]
    NOT?: LogSandboxScalarWhereInput | LogSandboxScalarWhereInput[]
    id?: IntFilter<"LogSandbox"> | number
    userId?: IntFilter<"LogSandbox"> | number
    method?: StringFilter<"LogSandbox"> | string
    editName?: StringFilter<"LogSandbox"> | string
    editKey?: StringFilter<"LogSandbox"> | string
    createdAt?: DateTimeFilter<"LogSandbox"> | Date | string
    updatedAt?: DateTimeFilter<"LogSandbox"> | Date | string
  }

  export type LogTradeUpsertWithWhereUniqueWithoutUserOneTradeInput = {
    where: LogTradeWhereUniqueInput
    update: XOR<LogTradeUpdateWithoutUserOneTradeInput, LogTradeUncheckedUpdateWithoutUserOneTradeInput>
    create: XOR<LogTradeCreateWithoutUserOneTradeInput, LogTradeUncheckedCreateWithoutUserOneTradeInput>
  }

  export type LogTradeUpdateWithWhereUniqueWithoutUserOneTradeInput = {
    where: LogTradeWhereUniqueInput
    data: XOR<LogTradeUpdateWithoutUserOneTradeInput, LogTradeUncheckedUpdateWithoutUserOneTradeInput>
  }

  export type LogTradeUpdateManyWithWhereWithoutUserOneTradeInput = {
    where: LogTradeScalarWhereInput
    data: XOR<LogTradeUpdateManyMutationInput, LogTradeUncheckedUpdateManyWithoutUserOneTradeInput>
  }

  export type LogTradeScalarWhereInput = {
    AND?: LogTradeScalarWhereInput | LogTradeScalarWhereInput[]
    OR?: LogTradeScalarWhereInput[]
    NOT?: LogTradeScalarWhereInput | LogTradeScalarWhereInput[]
    id?: IntFilter<"LogTrade"> | number
    userOneId?: IntFilter<"LogTrade"> | number
    userTwoId?: IntFilter<"LogTrade"> | number
    userOneItems?: StringFilter<"LogTrade"> | string
    userTwoItems?: StringFilter<"LogTrade"> | string
    roomId?: IntFilter<"LogTrade"> | number
    time?: IntFilter<"LogTrade"> | number
  }

  export type LogTradeUpsertWithWhereUniqueWithoutUserTwoTradeInput = {
    where: LogTradeWhereUniqueInput
    update: XOR<LogTradeUpdateWithoutUserTwoTradeInput, LogTradeUncheckedUpdateWithoutUserTwoTradeInput>
    create: XOR<LogTradeCreateWithoutUserTwoTradeInput, LogTradeUncheckedCreateWithoutUserTwoTradeInput>
  }

  export type LogTradeUpdateWithWhereUniqueWithoutUserTwoTradeInput = {
    where: LogTradeWhereUniqueInput
    data: XOR<LogTradeUpdateWithoutUserTwoTradeInput, LogTradeUncheckedUpdateWithoutUserTwoTradeInput>
  }

  export type LogTradeUpdateManyWithWhereWithoutUserTwoTradeInput = {
    where: LogTradeScalarWhereInput
    data: XOR<LogTradeUpdateManyMutationInput, LogTradeUncheckedUpdateManyWithoutUserTwoTradeInput>
  }

  export type LogLootboxCreateManyItemBaseInput = {
    id?: number
    interactionType: string
    userId: number
    itemId: number
    timestamp: number
  }

  export type CatalogItemCreateManyItemBaseInput = {
    id?: number
    pageId: number
    catalogName: string
    costCredits?: number
    costPixels?: number
    costDiamonds?: number
    costLimitcoins?: number
    amount?: number
    offerActive?: boolean
    badge?: string
  }

  export type LogLootboxUpdateWithoutItemBaseInput = {
    interactionType?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLogLootboxNestedInput
  }

  export type LogLootboxUncheckedUpdateWithoutItemBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogLootboxUncheckedUpdateManyWithoutItemBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type CatalogItemUpdateWithoutItemBaseInput = {
    pageId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
    catalogItemLimited?: CatalogItemLimitedUpdateOneWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateWithoutItemBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
    catalogItemLimited?: CatalogItemLimitedUncheckedUpdateOneWithoutCatalogItemNestedInput
  }

  export type CatalogItemUncheckedUpdateManyWithoutItemBaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    catalogName?: StringFieldUpdateOperationsInput | string
    costCredits?: IntFieldUpdateOperationsInput | number
    costPixels?: IntFieldUpdateOperationsInput | number
    costDiamonds?: IntFieldUpdateOperationsInput | number
    costLimitcoins?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    offerActive?: BoolFieldUpdateOperationsInput | boolean
    badge?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatCreateManyRoomInput = {
    id?: number
    userId: number
    userName: string
    timestamp?: number
    message: string
    type: string
  }

  export type LogChatUpdateWithoutRoomInput = {
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLogChatNestedInput
  }

  export type LogChatUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogLoginCreateManyUserInput = {
    id?: number
    date?: number
    ip: string
    userAgent: string
  }

  export type LogChatCreateManyUserInput = {
    id?: number
    roomId?: number | null
    userName: string
    timestamp?: number
    message: string
    type: string
  }

  export type LogSlotmachineCreateManyUserInput = {
    id?: number
    amount: number
    isWin: boolean
    date: number
  }

  export type LogShopCreateManyUserInput = {
    id?: number
    date: number
    price: number
    content: string
    type: number
    catalogItemId?: number
  }

  export type LogLootboxCreateManyUserInput = {
    id?: number
    interactionType: string
    itemId: number
    baseId: number
    timestamp: number
  }

  export type LogSandboxCreateManyUserInput = {
    id?: number
    method: string
    editName: string
    editKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogTradeCreateManyUserOneTradeInput = {
    id?: number
    userTwoId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
  }

  export type LogTradeCreateManyUserTwoTradeInput = {
    id?: number
    userOneId: number
    userOneItems: string
    userTwoItems: string
    roomId: number
    time: number
  }

  export type LogLoginUpdateWithoutUserInput = {
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
  }

  export type LogLoginUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
  }

  export type LogLoginUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatUpdateWithoutUserInput = {
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneWithoutLogChatNestedInput
  }

  export type LogChatUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogChatUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type LogSlotmachineUpdateWithoutUserInput = {
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogSlotmachineUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogSlotmachineUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    isWin?: BoolFieldUpdateOperationsInput | boolean
    date?: IntFieldUpdateOperationsInput | number
  }

  export type LogShopUpdateWithoutUserInput = {
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
  }

  export type LogShopUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
  }

  export type LogShopUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    catalogItemId?: IntFieldUpdateOperationsInput | number
  }

  export type LogLootboxUpdateWithoutUserInput = {
    interactionType?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    itemBase?: ItemBaseUpdateOneRequiredWithoutLogLootboxNestedInput
  }

  export type LogLootboxUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogLootboxUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    interactionType?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    baseId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
  }

  export type LogSandboxUpdateWithoutUserInput = {
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSandboxUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSandboxUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    editName?: StringFieldUpdateOperationsInput | string
    editKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogTradeUpdateWithoutUserOneTradeInput = {
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    userTwoTrade?: UserUpdateOneRequiredWithoutUserTwoTradeNestedInput
  }

  export type LogTradeUncheckedUpdateWithoutUserOneTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogTradeUncheckedUpdateManyWithoutUserOneTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userTwoId?: IntFieldUpdateOperationsInput | number
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogTradeUpdateWithoutUserTwoTradeInput = {
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    userOneTrade?: UserUpdateOneRequiredWithoutUserOneTradeNestedInput
  }

  export type LogTradeUncheckedUpdateWithoutUserTwoTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOneId?: IntFieldUpdateOperationsInput | number
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type LogTradeUncheckedUpdateManyWithoutUserTwoTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOneId?: IntFieldUpdateOperationsInput | number
    userOneItems?: StringFieldUpdateOperationsInput | string
    userTwoItems?: StringFieldUpdateOperationsInput | string
    roomId?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ItemBaseCountOutputTypeDefaultArgs instead
     */
    export type ItemBaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemBaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanDefaultArgs instead
     */
    export type BanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BotPetDefaultArgs instead
     */
    export type BotPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BotPetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BotUserDefaultArgs instead
     */
    export type BotUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BotUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogBotPresetDefaultArgs instead
     */
    export type CatalogBotPresetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogBotPresetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogItemDefaultArgs instead
     */
    export type CatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogItemLimitedDefaultArgs instead
     */
    export type CatalogItemLimitedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogItemLimitedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogMarketplaceDataDefaultArgs instead
     */
    export type CatalogMarketplaceDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogMarketplaceDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogMarketplaceOfferDefaultArgs instead
     */
    export type CatalogMarketplaceOfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogMarketplaceOfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogPageDefaultArgs instead
     */
    export type CatalogPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogPageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogPageLangueDefaultArgs instead
     */
    export type CatalogPageLangueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogPageLangueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogPetRaceDefaultArgs instead
     */
    export type CatalogPetRaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogPetRaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogPromotionDefaultArgs instead
     */
    export type CatalogPromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogPromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogVoucherDefaultArgs instead
     */
    export type CatalogVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogVoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsForumPostDefaultArgs instead
     */
    export type CmsForumPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsForumPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsForumThreadDefaultArgs instead
     */
    export type CmsForumThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsForumThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsFourmCategoryDefaultArgs instead
     */
    export type CmsFourmCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsFourmCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsMailConfirmDefaultArgs instead
     */
    export type CmsMailConfirmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsMailConfirmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsMailForgotDefaultArgs instead
     */
    export type CmsMailForgotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsMailForgotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsNewsDefaultArgs instead
     */
    export type CmsNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsNewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsStaffDefaultArgs instead
     */
    export type CmsStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsStaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CmsStaffProtectDefaultArgs instead
     */
    export type CmsStaffProtectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CmsStaffProtectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorAchievementDefaultArgs instead
     */
    export type EmulatorAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorBannerDefaultArgs instead
     */
    export type EmulatorBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorBannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorChatStyleDefaultArgs instead
     */
    export type EmulatorChatStyleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorChatStyleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorCommandDefaultArgs instead
     */
    export type EmulatorCommandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorCommandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorCommandPetDefaultArgs instead
     */
    export type EmulatorCommandPetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorCommandPetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorEffectDefaultArgs instead
     */
    export type EmulatorEffectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorEffectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorLandingviewDefaultArgs instead
     */
    export type EmulatorLandingviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorLandingviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorLootboxDefaultArgs instead
     */
    export type EmulatorLootboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorLootboxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorPermissionDefaultArgs instead
     */
    export type EmulatorPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorPermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorQuestDefaultArgs instead
     */
    export type EmulatorQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorQuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorSettingDefaultArgs instead
     */
    export type EmulatorSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorStatsDefaultArgs instead
     */
    export type EmulatorStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorStatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorStatusDefaultArgs instead
     */
    export type EmulatorStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmulatorTextDefaultArgs instead
     */
    export type EmulatorTextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmulatorTextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildDefaultArgs instead
     */
    export type GuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildItemDefaultArgs instead
     */
    export type GuildItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildMembershipDefaultArgs instead
     */
    export type GuildMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildRequestDefaultArgs instead
     */
    export type GuildRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemBaseDefaultArgs instead
     */
    export type ItemBaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemBaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemLimitedDefaultArgs instead
     */
    export type ItemLimitedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemLimitedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemMoodlightDefaultArgs instead
     */
    export type ItemMoodlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemMoodlightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemPresentDefaultArgs instead
     */
    export type ItemPresentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemPresentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemStatDefaultArgs instead
     */
    export type ItemStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemStatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTeleportDefaultArgs instead
     */
    export type ItemTeleportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTeleportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemWiredDefaultArgs instead
     */
    export type ItemWiredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemWiredDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogChatDefaultArgs instead
     */
    export type LogChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogChatPubDefaultArgs instead
     */
    export type LogChatPubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogChatPubDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogCommandDefaultArgs instead
     */
    export type LogCommandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogCommandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogFlagmeDefaultArgs instead
     */
    export type LogFlagmeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogFlagmeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogLoginDefaultArgs instead
     */
    export type LogLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogLoginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogLootboxDefaultArgs instead
     */
    export type LogLootboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogLootboxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogPaymentDefaultArgs instead
     */
    export type LogPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogShopDefaultArgs instead
     */
    export type LogShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogShopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogSlotmachineDefaultArgs instead
     */
    export type LogSlotmachineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogSlotmachineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogStaffDefaultArgs instead
     */
    export type LogStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogStaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogTradeDefaultArgs instead
     */
    export type LogTradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogTradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogVpnDefaultArgs instead
     */
    export type LogVpnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogVpnDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogSandboxDefaultArgs instead
     */
    export type LogSandboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogSandboxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessengerFriendshipDefaultArgs instead
     */
    export type MessengerFriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessengerFriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessengerOfflineMessageDefaultArgs instead
     */
    export type MessengerOfflineMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessengerOfflineMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessengerRequestDefaultArgs instead
     */
    export type MessengerRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessengerRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationPresetDefaultArgs instead
     */
    export type ModerationPresetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationPresetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationResolutionDefaultArgs instead
     */
    export type ModerationResolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationResolutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationTicketDefaultArgs instead
     */
    export type ModerationTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationTopicDefaultArgs instead
     */
    export type ModerationTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationTopicActionDefaultArgs instead
     */
    export type ModerationTopicActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationTopicActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NavigatorCategoryDefaultArgs instead
     */
    export type NavigatorCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NavigatorCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NavigatorPublicDefaultArgs instead
     */
    export type NavigatorPublicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NavigatorPublicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleplayDefaultArgs instead
     */
    export type RoleplayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleplayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleplayEnemyDefaultArgs instead
     */
    export type RoleplayEnemyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleplayEnemyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleplayItemDefaultArgs instead
     */
    export type RoleplayItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleplayItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleplayWeaponDefaultArgs instead
     */
    export type RoleplayWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleplayWeaponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomModelDefaultArgs instead
     */
    export type RoomModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomModelCustomDefaultArgs instead
     */
    export type RoomModelCustomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomModelCustomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomRightDefaultArgs instead
     */
    export type RoomRightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomRightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomSwearwordFilterDefaultArgs instead
     */
    export type RoomSwearwordFilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomSwearwordFilterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBannerDefaultArgs instead
     */
    export type UserBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPhotoDefaultArgs instead
     */
    export type UserPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPremiumDefaultArgs instead
     */
    export type UserPremiumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPremiumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQuestDefaultArgs instead
     */
    export type UserQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleplayDefaultArgs instead
     */
    export type UserRoleplayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleplayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleplayItemDefaultArgs instead
     */
    export type UserRoleplayItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleplayItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserStatsDefaultArgs instead
     */
    export type UserStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserStatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserWardrobeDefaultArgs instead
     */
    export type UserWardrobeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserWardrobeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WordFilterRetroDefaultArgs instead
     */
    export type WordFilterRetroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WordFilterRetroDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}